// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { END_CALL_PAGES } from '../adapter/CallAdapter';
import { _isInCall, _isPreviewOn, _isInLobbyOrConnecting } from "../../../../../calling-component-bindings/src";
import { isPhoneNumberIdentifier } from '@azure/communication-common';
const ACCESS_DENIED_TEAMS_MEETING_SUB_CODE = 5854;
const REMOTE_PSTN_USER_HUNG_UP = 560000;
const REMOVED_FROM_CALL_SUB_CODES = [5000, 5300, REMOTE_PSTN_USER_HUNG_UP];
/**
 * @private
 */
export const isCameraOn = (state) => {
    if (state.call) {
        const stream = state.call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
        return !!stream;
    }
    else {
        if (state.devices.selectedCamera) {
            const previewOn = _isPreviewOn(state.devices);
            return previewOn;
        }
    }
    return false;
};
/**
 * Reduce the set of call controls visible on mobile.
 * For example do not show screenshare button.
 *
 * @private
 */
export const reduceCallControlsForMobile = (callControlOptions) => {
    if (callControlOptions === false) {
        return false;
    }
    // Ensure call controls a valid object.
    const reduceCallControlOptions = callControlOptions === true ? {} : callControlOptions || {};
    // Set to compressed mode when composite is optimized for mobile
    reduceCallControlOptions.displayType = 'compact';
    // Do not show screen share button when composite is optimized for mobile unless the developer
    // has explicitly opted in.
    if (reduceCallControlOptions.screenShareButton !== true) {
        reduceCallControlOptions.screenShareButton = false;
    }
    return reduceCallControlOptions;
};
var CallEndReasons;
(function (CallEndReasons) {
    CallEndReasons[CallEndReasons["LEFT_CALL"] = 0] = "LEFT_CALL";
    CallEndReasons[CallEndReasons["ACCESS_DENIED"] = 1] = "ACCESS_DENIED";
    CallEndReasons[CallEndReasons["REMOVED_FROM_CALL"] = 2] = "REMOVED_FROM_CALL";
    CallEndReasons[CallEndReasons["ROOM_NOT_FOUND"] = 3] = "ROOM_NOT_FOUND";
    CallEndReasons[CallEndReasons["DENIED_PERMISSION_TO_ROOM"] = 4] = "DENIED_PERMISSION_TO_ROOM";
})(CallEndReasons || (CallEndReasons = {}));
const getCallEndReason = (call) => {
    var _a, _b, _c;
    const remoteParticipantsEndedArray = Array.from(Object.values(call.remoteParticipantsEnded));
    /**
     * Handle the special case in a PSTN call where removing the last user kicks the caller out of the call.
     * The code and subcode is the same as when a user is removed from a teams interop call.
     * Hence, we look at the last remote participant removed to determine if the last participant removed was a phone number.
     * If yes, the caller was kicked out of the call, but we need to show them that they left the call.
     * Note: This check will only work for 1:1 PSTN Calls. The subcode is different for 1:N PSTN calls, and we do not need to handle that case.
     */
    if (remoteParticipantsEndedArray.length === 1 && isPhoneNumberIdentifier(remoteParticipantsEndedArray[0].identifier) && ((_a = call.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) !== REMOTE_PSTN_USER_HUNG_UP) {
        return CallEndReasons.LEFT_CALL;
    }
    if (((_b = call.callEndReason) === null || _b === void 0 ? void 0 : _b.subCode) && call.callEndReason.subCode === ACCESS_DENIED_TEAMS_MEETING_SUB_CODE) {
        return CallEndReasons.ACCESS_DENIED;
    }
    if (((_c = call.callEndReason) === null || _c === void 0 ? void 0 : _c.subCode) && REMOVED_FROM_CALL_SUB_CODES.includes(call.callEndReason.subCode)) {
        return CallEndReasons.REMOVED_FROM_CALL;
    }
    if (call.callEndReason) {
        // No error codes match, assume the user simply left the call regularly
        return CallEndReasons.LEFT_CALL;
    }
    throw new Error('No matching call end reason');
};
/**
 * Get the current call composite page based on the current call composite state
 *
 * @param Call - The current call state
 * @param previousCall - The state of the most recent previous call that has ended.
 *
 * @remarks - The previousCall state is needed to determine if the call has ended.
 * When the call ends a new call object is created, and so we must lookback at the
 * previous call state to understand how the call has ended. If there is no previous
 * call we know that this is a fresh call and can display the configuration page.
 *
 * @private
 */
export const getCallCompositePage = (call, previousCall, unsupportedBrowserInfo, transferCall) => {
    if (call) {
        // Must check for ongoing call *before* looking at any previous calls.
        // If the composite completes one call and joins another, the previous calls
        // will be populated, but not relevant for determining the page.
        // `_isInLobbyOrConnecting` needs to be checked first because `_isInCall` also returns true when call is in lobby.
        if (_isInLobbyOrConnecting(call === null || call === void 0 ? void 0 : call.state)) {
            return 'lobby';
            // `LocalHold` needs to be checked before `isInCall` since it is also a state that's considered in call.
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'LocalHold') {
            return 'call';
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'Disconnecting') {
            return 'leaving';
        }
        else if (_isInCall(call === null || call === void 0 ? void 0 : call.state)) {
            return 'call';
        }
        else {
            // When the call object has been constructed after clicking , but before 'connecting' has been
            // set on the call object, we continue to show the configuration screen.
            // The call object does not correctly reflect local device state until `call.state` moves to `connecting`.
            // Moving to the 'lobby' page too soon leads to components that depend on the `call` object to show incorrect
            // transitional state.
            return 'configuration';
        }
    }
    if (previousCall) {
        const reason = getCallEndReason(previousCall);
        switch (reason) {
            case CallEndReasons.ACCESS_DENIED:
                return 'accessDeniedTeamsMeeting';
            case CallEndReasons.REMOVED_FROM_CALL:
                return 'removedFromCall';
            case CallEndReasons.LEFT_CALL:
                if (previousCall.diagnostics.network.latest.noNetwork) {
                    return 'joinCallFailedDueToNoNetwork';
                }
                return 'leftCall';
        }
    }
    // No call state - show starting page (configuration)
    return 'configuration';
};
/** @private */
export const IsCallEndedPage = (page) => END_CALL_PAGES.includes(page);
/**
 * Creates a new call control options object and sets the correct values for disabling
 * the buttons provided in the `disabledControls` array.
 * Returns a new object without changing the original object.
 * @param callControlOptions options for the call control component that need to be modified.
 * @param disabledControls An array of controls to disable.
 * @returns a copy of callControlOptions with disabledControls disabled
 * @private
 */
export const disableCallControls = (callControlOptions, disabledControls) => {
    var _a;
    if (callControlOptions === false) {
        return false;
    }
    // Ensure we clone the prop if it is an object to ensure we do not mutate the original prop.
    let newOptions = (_a = (callControlOptions instanceof Object ? Object.assign({}, callControlOptions) : callControlOptions)) !== null && _a !== void 0 ? _a : {};
    if (newOptions === true || newOptions === undefined) {
        newOptions = disabledControls.reduce((acc, key) => {
            acc[key] = {
                disabled: true
            };
            return acc;
        }, {});
    }
    else {
        disabledControls.forEach(key => {
            if (newOptions[key] !== false) {
                newOptions[key] = {
                    disabled: true
                };
            }
        });
    }
    return newOptions;
};
/**
 * Check if a disabled object is provided for a button and returns if the button is disabled.
 * A button is only disabled if is explicitly set to disabled.
 *
 * @param option
 * @returns whether a button is disabled
 * @private
 */
export const isDisabled = (option) => {
    if (option === undefined || typeof option === 'boolean') {
        return false;
    }
    return option.disabled;
};
/**
 * Check if we are using safari browser
 * @private
 */
export const _isSafari = (environmentInfo) => {
    return /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);
};
/**
 * @private
 * This is the util function to create a participant modifier for remote participantList
 * It memoize previous original participant items and only update the changed participant
 * It takes in one modifier function to generate one single participant object, it returns undefined if the object keeps unmodified
 */
export const createParticipantModifier = (createModifiedParticipant) => {
    let previousParticipantState = undefined;
    let modifiedParticipants = {};
    const memoizedParticipants = {};
    return (state) => {
        var _a, _b, _c, _d;
        // if root state is the same, we don't need to update the participants
        if (((_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants) !== previousParticipantState) {
            modifiedParticipants = {};
            const originalParticipants = (_b = state.call) === null || _b === void 0 ? void 0 : _b.remoteParticipants;
            for (const key in originalParticipants) {
                const modifiedParticipant = createModifiedParticipant(key, originalParticipants[key]);
                if (modifiedParticipant === undefined) {
                    modifiedParticipants[key] = originalParticipants[key];
                    continue;
                }
                // Generate the new item if original cached item has been changed
                if (((_c = memoizedParticipants[key]) === null || _c === void 0 ? void 0 : _c.originalRef) !== originalParticipants[key]) {
                    memoizedParticipants[key] = {
                        newParticipant: modifiedParticipant,
                        originalRef: originalParticipants[key]
                    };
                }
                // the modified participant is always coming from the memoized cache, whether is was refreshed
                // from the previous closure or not
                modifiedParticipants[key] = memoizedParticipants[key].newParticipant;
            }
            previousParticipantState = (_d = state.call) === null || _d === void 0 ? void 0 : _d.remoteParticipants;
        }
        return Object.assign(Object.assign({}, state), { call: state.call ? Object.assign(Object.assign({}, state.call), { remoteParticipants: modifiedParticipants }) : undefined });
    };
};
/**
 * @private
 */
export const dismissVideoEffectsError = (toDismiss) => {
    var _a;
    const now = new Date(Date.now());
    const toDismissTimestamp = (_a = toDismiss.timestamp) !== null && _a !== void 0 ? _a : now;
    // Record that this error was dismissed for the first time right now.
    return {
        dismissedAt: now > toDismissTimestamp ? now : toDismissTimestamp,
        activeSince: toDismiss.timestamp
    };
};
//# sourceMappingURL=Utils.js.map