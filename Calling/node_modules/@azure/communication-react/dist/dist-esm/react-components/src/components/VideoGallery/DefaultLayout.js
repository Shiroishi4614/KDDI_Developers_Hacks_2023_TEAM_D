// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { Stack } from '@fluentui/react';
import React, { useMemo, useState, useRef } from 'react';
import { GridLayout } from '../GridLayout';
import { isNarrowWidth } from '../utils/responsive';
import { rootLayoutStyle } from './styles/DefaultLayout.styles';
import { videoGalleryLayoutGap } from './styles/Layout.styles';
import { useOrganizedParticipants } from './utils/videoGalleryLayoutUtils';
import { OverflowGallery } from './OverflowGallery';
/**
 * DefaultLayout displays remote participants, local video component, and screen sharing component in
 * a grid an overflow gallery.
 *
 * @private
 */
export const DefaultLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, parentWidth, pinnedParticipantUserIds = [] } = props;
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = useState([...Array(maxRemoteVideoStreams - activeVideoStreams).keys()]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    if (localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    const overflowGallery = useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React.createElement(OverflowGallery, { isNarrow: isNarrow, shouldFloatLocalVideo: false, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, onFetchTilesToRender: setIndexesToRender, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            } });
    }, [isNarrow, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, setIndexesToRender]);
    return React.createElement(Stack, { styles: rootLayoutStyle, tokens: videoGalleryLayoutGap },
        screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
        overflowGallery);
};
//# sourceMappingURL=DefaultLayout.js.map