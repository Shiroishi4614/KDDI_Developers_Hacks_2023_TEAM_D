// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { LayerHost, mergeStyles, Stack } from '@fluentui/react';
import { useId } from '@fluentui/react-hooks';
import React, { useMemo, useRef, useState } from 'react';
import { useTheme } from '../../theming';
import { GridLayout } from '../GridLayout';
import { isNarrowWidth } from '../utils/responsive';
import { FloatingLocalVideo } from './FloatingLocalVideo';
import { LARGE_FLOATING_MODAL_SIZE_REM, localVideoTileContainerStyle, localVideoTileWithControlsContainerStyle, LOCAL_VIDEO_TILE_ZINDEX, SMALL_FLOATING_MODAL_SIZE_REM } from './styles/FloatingLocalVideo.styles';
import { innerLayoutStyle, layerHostStyle, rootLayoutStyle } from './styles/FloatingLocalVideoLayout.styles';
import { videoGalleryLayoutGap } from './styles/Layout.styles';
import { useOrganizedParticipants } from './utils/videoGalleryLayoutUtils';
import { OverflowGallery } from './OverflowGallery';
/**
 * FloatingLocalVideoLayout displays remote participants and a screen sharing component in
 * a grid and overflow gallery while floating the local video
 *
 * @private
 */
export const FloatingLocalVideoLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, showCameraSwitcherInLocalPreview, parentWidth, parentHeight, pinnedParticipantUserIds = [] } = props;
    const theme = useTheme();
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const shouldFloatLocalVideo = remoteParticipants.length > 0;
    if (!shouldFloatLocalVideo && localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = useState([...Array(maxRemoteVideoStreams - activeVideoStreams).keys()]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const layerHostId = useId('layerhost');
    const localVideoSizeRem = useMemo(() => {
        if (isNarrow) {
            return SMALL_FLOATING_MODAL_SIZE_REM;
        }
        return LARGE_FLOATING_MODAL_SIZE_REM;
    }, [overflowGalleryTiles.length, isNarrow]);
    const wrappedLocalVideoComponent = localVideoComponent && shouldFloatLocalVideo ?
        // When we use showCameraSwitcherInLocalPreview it disables dragging to allow keyboard navigation.
        showCameraSwitcherInLocalPreview ? React.createElement(Stack, { className: mergeStyles(localVideoTileWithControlsContainerStyle(theme, localVideoSizeRem), {
                boxShadow: theme.effects.elevation8,
                zIndex: LOCAL_VIDEO_TILE_ZINDEX
            }) }, localVideoComponent) : overflowGalleryTiles.length > 0 ? React.createElement(Stack, { className: mergeStyles(localVideoTileContainerStyle(theme, localVideoSizeRem)) }, localVideoComponent) : React.createElement(FloatingLocalVideo, { localVideoComponent: localVideoComponent, layerHostId: layerHostId, localVideoSizeRem: localVideoSizeRem, parentWidth: parentWidth, parentHeight: parentHeight }) : undefined;
    const overflowGallery = useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React.createElement(OverflowGallery, { onFetchTilesToRender: setIndexesToRender, isNarrow: isNarrow, shouldFloatLocalVideo: true, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            } });
    }, [isNarrow, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, setIndexesToRender]);
    return React.createElement(Stack, { styles: rootLayoutStyle },
        wrappedLocalVideoComponent,
        React.createElement(LayerHost, { id: layerHostId, className: mergeStyles(layerHostStyle) }),
        React.createElement(Stack, { styles: innerLayoutStyle, tokens: videoGalleryLayoutGap },
            screenShareComponent ? screenShareComponent : React.createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            overflowGallery));
};
//# sourceMappingURL=FloatingLocalVideoLayout.js.map