{"version":3,"file":"StreamUtils.js","sourceRoot":"","sources":["../../../../preprocess-dist/calling-stateful-client/src/StreamUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CreateViewOptions, LocalVideoStream, RemoteVideoStream, VideoStreamRenderer, VideoStreamRendererView } from '@azure/communication-calling';\nimport { CommunicationIdentifierKind } from '@azure/communication-common';\nimport { LocalVideoStreamState, RemoteVideoStreamState } from './CallClientState';\nimport { CallContext } from './CallContext';\nimport { convertSdkLocalStreamToDeclarativeLocalStream, convertSdkRemoteStreamToDeclarativeRemoteStream, convertFromSDKToDeclarativeVideoStreamRendererView } from './Converter';\nimport { InternalCallContext } from './InternalCallContext';\nimport { toFlatCommunicationIdentifier, _logEvent } from '@internal/acs-ui-common';\nimport { EventNames } from './Logger';\nimport { _logStreamEvent } from './StreamUtilsLogging';\n\n/**\n * Return result from {@link StatefulCallClient.createView}.\n *\n * @public\n */\nexport type CreateViewResult = {\n  renderer: VideoStreamRenderer;\n  view: VideoStreamRendererView;\n};\nasync function createViewVideo(context: CallContext, internalContext: InternalCallContext, callId: string, stream?: RemoteVideoStreamState | LocalVideoStreamState, participantId?: CommunicationIdentifierKind | string, options?: CreateViewOptions): Promise<CreateViewResult | undefined> {\n  // we can only have 3 types of createView\n  let streamEventType: 'createViewLocal' | 'createViewRemote' | 'createViewUnparented';\n\n  // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.\n\n  if (participantId) {\n    streamEventType = 'createViewRemote';\n  } else if (callId) {\n    streamEventType = 'createViewLocal';\n  } else {\n    // TODO update for when unparented view.\n    throw new Error('unparented createView not implemented yet here');\n    streamEventType = 'createViewUnparented';\n  }\n  const streamType = stream?.mediaStreamType;\n  const streamId = (stream as RemoteVideoStream).id;\n\n  // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.\n  const participantKey = streamEventType === 'createViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;\n  const streamLogInfo = {\n    callId,\n    participantKey,\n    streamId,\n    streamType,\n    streamEventType\n  };\n\n  // make different logging announcement based on whether or not we are starting a local or remote\n  _logStreamEvent(EventNames.CREATING_VIEW, streamLogInfo);\n\n  // if we have a participant Id and a stream get the remote info, else get the local render info from state.\n  const renderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);\n  if (!renderInfo) {\n    _logStreamEvent(EventNames.STREAM_NOT_FOUND, streamLogInfo);\n    return;\n  }\n  if (renderInfo.status === 'Rendered') {\n    _logStreamEvent(EventNames.STREAM_ALREADY_RENDERED, streamLogInfo);\n    return;\n  }\n  if (renderInfo.status === 'Rendering') {\n    // Do not log to console here as this is a very common situation due to UI rerenders while\n    // the video rendering is in progress.\n    _logStreamEvent(EventNames.STREAM_RENDERING, streamLogInfo);\n    return;\n  }\n\n  // \"Stopping\" only happens if the stream was in \"rendering\" but `disposeView` was called.\n  // Now that `createView` has been re-called, we can flip the state back to \"rendering\".\n  if (renderInfo.status === 'Stopping') {\n    if (streamEventType === 'createViewRemote' && participantKey) {\n      _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);\n      internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (renderInfo.stream as RemoteVideoStream), 'Rendering', renderInfo.renderer);\n    } else if (streamEventType === 'createViewLocal') {\n      _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);\n      internalContext.setLocalRenderInfo(callId, (renderInfo.stream as LocalVideoStream), 'Rendering', renderInfo.renderer);\n    }\n    return;\n  }\n  const renderer = new VideoStreamRenderer(renderInfo.stream);\n  streamEventType === 'createViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (renderInfo.stream as RemoteVideoStream), 'Rendering', undefined) : internalContext.setLocalRenderInfo(callId, (renderInfo.stream as LocalVideoStream), 'Rendering', renderer);\n  let view;\n  try {\n    view = await renderer.createView(options);\n  } catch (e) {\n    if (streamEventType === 'createViewRemote' && participantKey) {\n      _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo);\n      internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (renderInfo.stream as RemoteVideoStream), 'NotRendered', undefined);\n    } else if (streamEventType === 'createViewLocal') {\n      _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo, e);\n      internalContext.setLocalRenderInfo(callId, (renderInfo.stream as LocalVideoStream), 'NotRendered', undefined);\n    }\n    throw e;\n  }\n\n  // Since render could take some time, we need to check if the stream is still valid and if we received a signal to\n  // stop rendering.\n  const refreshedRenderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);\n  if (!refreshedRenderInfo) {\n    // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer\n    // and clean up the state.\n    _logStreamEvent(EventNames.RENDER_INFO_NOT_FOUND, streamLogInfo);\n    renderer.dispose();\n    streamEventType === 'createViewRemote' && participantKey ? context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined) : context.setLocalVideoStreamRendererView(callId, undefined);\n    return;\n  }\n  if (refreshedRenderInfo.status === 'Stopping') {\n    // Stop render was called on this stream after we had started rendering. We will dispose this view and do not\n    // put the view into the state.\n    streamEventType === 'createViewRemote';\n    _logStreamEvent(EventNames.CREATED_STREAM_STOPPING, streamLogInfo);\n    renderer.dispose();\n    if (streamEventType === 'createViewRemote' && participantKey) {\n      internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (refreshedRenderInfo.stream as RemoteVideoStream), 'NotRendered', undefined);\n      context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);\n    } else if (streamEventType === 'createViewLocal') {\n      internalContext.setLocalRenderInfo(callId, (refreshedRenderInfo.stream as LocalVideoStream), 'NotRendered', undefined);\n      context.setLocalVideoStreamRendererView(callId, undefined);\n    }\n    return;\n  }\n\n  // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by\n  // updating the state.\n  if (streamEventType === 'createViewRemote' && participantKey) {\n    internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (refreshedRenderInfo.stream as RemoteVideoStream), 'Rendered', renderer);\n    context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, convertFromSDKToDeclarativeVideoStreamRendererView(view));\n    _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);\n  } else if (streamEventType === 'createViewLocal') {\n    internalContext.setLocalRenderInfo(callId, (refreshedRenderInfo.stream as LocalVideoStream), 'Rendered', renderer);\n    context.setLocalVideoStreamRendererView(callId, convertFromSDKToDeclarativeVideoStreamRendererView(view));\n    _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);\n  }\n  return {\n    renderer,\n    view\n  };\n}\nasync function createViewUnparentedVideo(context: CallContext, internalContext: InternalCallContext, stream: LocalVideoStreamState, options?: CreateViewOptions): Promise<CreateViewResult | undefined> {\n  const renderInfo = internalContext.getUnparentedRenderInfo(stream);\n  if (renderInfo && renderInfo.status === 'Rendered') {\n    console.warn('Unparented LocalVideoStream is already rendered');\n    return;\n  }\n  if (renderInfo && renderInfo.status === 'Rendering') {\n    // Do not log to console here as this is a very common situation due to UI rerenders while\n    // the video rendering is in progress.\n    return;\n  }\n  if (renderInfo && renderInfo.status === 'Stopping') {\n    console.warn('Unparented LocalVideoStream is in the middle of stopping');\n    return;\n  }\n  const localVideoStream = new LocalVideoStream(stream.source);\n  const renderer = new VideoStreamRenderer(localVideoStream);\n  internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendering', undefined);\n  let view: VideoStreamRendererView;\n  try {\n    view = await renderer.createView(options);\n  } catch (e) {\n    // Special case for unparented views. Since they are not tied to anything and created by us based on the calls to\n    // this function we'll delete it to clean up the data since keeping it around doesn't help us and if developer wants\n    // to create a new view they can check that the view is not rendered and call this function again.\n    internalContext.deleteUnparentedRenderInfo(stream);\n    throw e;\n  }\n\n  // Since render could take some time, we need to check if the stream is still valid and if we received a signal to\n  // stop rendering.\n  const refreshedRenderInfo = internalContext.getUnparentedRenderInfo(stream);\n  if (!refreshedRenderInfo) {\n    // Unparented stream's RenderInfo was deleted. Currently this shouldn't happen but if it does we'll just dispose the\n    // renderer and clean up state. If developer wanted the stream they could call this function again and that should\n    // generate new working state via this function.\n    renderer.dispose();\n    context.deleteDeviceManagerUnparentedView(stream);\n    return;\n  }\n  if (refreshedRenderInfo.status === 'Stopping') {\n    // Stop render was called on this stream after we had started rendering. We will dispose this view and do not\n    // put the view into the state. Special case for unparented views, delete them from state when stopped to free up\n    // the memory since we were the ones generating this and not tied to any Call state.\n    internalContext.deleteUnparentedRenderInfo(stream);\n    context.deleteDeviceManagerUnparentedView(stream);\n    return;\n  }\n  // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by\n  // updating the state.\n  internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendered', renderer);\n  internalContext.subscribeToUnparentedViewVideoEffects(localVideoStream, context);\n  context.setDeviceManagerUnparentedView(stream, convertFromSDKToDeclarativeVideoStreamRendererView(view));\n  return {\n    renderer,\n    view\n  };\n}\nfunction disposeViewVideo(context: CallContext, internalContext: InternalCallContext, callId: string, stream: RemoteVideoStreamState | LocalVideoStreamState, participantId?: CommunicationIdentifierKind | string): void {\n  // we can only have 3 types of createView\n  let streamEventType: 'disposeViewLocal' | 'disposeViewRemote' | 'disposeViewUnparented';\n\n  // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.\n\n  if (participantId) {\n    streamEventType = 'disposeViewRemote';\n  } else if (callId) {\n    streamEventType = 'disposeViewLocal';\n  } else {\n    // TODO update for when unparented view.\n    streamEventType = 'disposeViewUnparented';\n  }\n  const streamType = stream.mediaStreamType;\n  const streamId = (stream as RemoteVideoStream).id;\n\n  // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.\n  const participantKey = streamEventType === 'disposeViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;\n  const streamLogInfo = {\n    callId,\n    participantKey,\n    streamId,\n    streamType\n  };\n  _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);\n  if (streamEventType === 'disposeViewRemote' && participantKey) {\n    context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);\n  }\n  const renderInfo = streamEventType === 'disposeViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);\n  if (!renderInfo) {\n    _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);\n    return;\n  }\n\n  // Nothing to dispose of or clean up -- we can safely exit early here.\n  if (renderInfo.status === 'NotRendered') {\n    _logStreamEvent(EventNames.STREAM_ALREADY_DISPOSED, streamLogInfo);\n    return;\n  }\n\n  // Status is already marked as \"stopping\" so we can exit early here. This is because stopping only occurs\n  // when the stream is being created in createView but hasn't been completed being created yet. The createView\n  // method will see the \"stopping\" status and perform the cleanup\n  if (renderInfo.status === 'Stopping') {\n    _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);\n    return;\n  }\n\n  // If the stream is in the middle of being rendered (i.e. has state \"Rendering\"), we need the status as\n  // \"stopping\" without performing any cleanup. This will tell the `createView` method that it should stop\n  // rendering and clean up the state once the view has finished being created.\n  if (renderInfo.status === 'Rendering') {\n    _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);\n    streamEventType === 'disposeViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (renderInfo.stream as RemoteVideoStream), 'Stopping', undefined) : internalContext.setLocalRenderInfo(callId, (renderInfo.stream as LocalVideoStream), 'Stopping', renderInfo.renderer);\n    return;\n  }\n  if (renderInfo.renderer) {\n    _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);\n    renderInfo.renderer.dispose();\n    // Else the state must be in the \"Rendered\" state, so we can dispose the renderer and clean up the state.\n    if (streamEventType === 'disposeViewRemote' && participantKey) {\n      internalContext.setRemoteRenderInfo(callId, participantKey, streamId, (renderInfo.stream as RemoteVideoStream), 'NotRendered', undefined);\n    } else if (streamEventType === 'disposeViewLocal') {\n      internalContext.setLocalRenderInfo(callId, (renderInfo.stream as LocalVideoStream), 'NotRendered', undefined);\n      context.setLocalVideoStreamRendererView(callId, undefined);\n    }\n  } else {\n    _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);\n  }\n}\nfunction disposeViewUnparentedVideo(context: CallContext, internalContext: InternalCallContext, stream: LocalVideoStreamState): void {\n  const streamType = stream.mediaStreamType;\n  const streamLogInfo = {\n    streamType,\n    streamEventType: 'disposeViewUnparented'\n  };\n  _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);\n  context.deleteDeviceManagerUnparentedView(stream);\n  const renderInfo = internalContext.getUnparentedRenderInfo(stream);\n  if (!renderInfo) {\n    _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);\n    return;\n  }\n  if (renderInfo.status === 'Rendering') {\n    _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);\n    internalContext.setUnparentedRenderInfo(stream, renderInfo.stream, 'Stopping', undefined);\n  } else {\n    internalContext.deleteUnparentedRenderInfo(stream);\n  }\n  if (renderInfo.renderer) {\n    _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);\n    renderInfo.renderer.dispose();\n  } else {\n    _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);\n  }\n}\n\n/**\n * @private\n */\nexport function createView(context: CallContext, internalContext: InternalCallContext, callId: string | undefined, participantId: CommunicationIdentifierKind | string | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState, options?: CreateViewOptions): Promise<CreateViewResult | undefined> {\n  const streamType = stream.mediaStreamType;\n  if (callId) {\n    return createViewVideo(context, internalContext, callId, stream, participantId, options);\n  } else if (!('id' in stream) && !callId) {\n    // Render LocalVideoStream that is not part of a Call\n    // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).\n    // We do not have a startLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.\n    return context.withAsyncErrorTeedToState(async () => await createViewUnparentedVideo(context, internalContext, stream, options), 'Call.startVideo')();\n  } else {\n    _logStreamEvent(EventNames.CREATE_STREAM_INVALID_PARAMS, {\n      streamType\n    });\n    return Promise.resolve(undefined);\n  }\n}\n\n/**\n * @private\n */\nexport function disposeView(context: CallContext, internalContext: InternalCallContext, callId: string | undefined, participantId: CommunicationIdentifierKind | string | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState): void {\n  const streamType = stream.mediaStreamType;\n  if (callId) {\n    disposeViewVideo(context, internalContext, callId, stream, participantId);\n  } else if (!('id' in stream) && !callId) {\n    // Stop rendering LocalVideoStream that is not part of a Call\n    // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).\n    // We do not have a stopLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.\n    context.withErrorTeedToState(() => disposeViewUnparentedVideo(context, internalContext, stream), 'Call.stopVideo')();\n  } else {\n    _logStreamEvent(EventNames.DISPOSE_STREAM_INVALID_PARAMS, {\n      streamType\n    });\n    return;\n  }\n}\n\n/**\n * @private\n * Only stops videos that are tied to a Call.\n */\nexport function disposeAllViewsFromCall(context: CallContext, internalContext: InternalCallContext, callId: string): void {\n  const callStreams = internalContext.getRemoteRenderInfoForCall(callId);\n  if (callStreams) {\n    for (const [participantKey, participantStreams] of callStreams.entries()) {\n      for (const [_, remoteStreamAndRenderer] of participantStreams.entries()) {\n        // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to\n        // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.\n        disposeView(context, internalContext, callId, participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(remoteStreamAndRenderer.stream));\n      }\n    }\n  }\n  const localStreamAndRenderer = internalContext.getLocalRenderInfo(callId);\n  if (localStreamAndRenderer && localStreamAndRenderer.renderer) {\n    // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to\n    // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.\n    disposeView(context, internalContext, callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localStreamAndRenderer.stream));\n  }\n}\n\n/**\n * @private\n */\nexport function disposeAllViews(context: CallContext, internalContext: InternalCallContext): void {\n  const callIds = internalContext.getCallIds();\n  for (const callId of callIds) {\n    disposeAllViewsFromCall(context, internalContext, callId);\n  }\n}\"../../acs-ui-common/src\""]}