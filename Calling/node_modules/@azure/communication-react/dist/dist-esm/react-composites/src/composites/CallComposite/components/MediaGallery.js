// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { VideoGallery, Announcer } from "../../../../../react-components/src";
import { usePropsFor } from '../hooks/usePropsFor';
import { AvatarPersona } from '../../common/AvatarPersona';
import { mergeStyles, Stack } from '@fluentui/react';
import { getIsPreviewCameraOn } from '../selectors/baseSelectors';
import { useHandlers } from '../hooks/useHandlers';
import { useSelector } from '../hooks/useSelector';
import { localVideoCameraCycleButtonSelector } from '../selectors/LocalVideoTileSelector';
import { LocalVideoCameraCycleButton } from "../../../../../react-components/src";
import { useParticipantChangedAnnouncement } from '../utils/MediaGalleryUtils';
const VideoGalleryStyles = {
    root: {
        height: '100%',
        minHeight: '10rem',
        // space affordance to ensure media gallery is never collapsed
        minWidth: '6rem'
    }
};
const localVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions = {
    scalingMode: 'Crop'
};
/**
 * @private
 */
export const MediaGallery = (props) => {
    const videoGalleryProps = usePropsFor(VideoGallery);
    const cameraSwitcherCameras = useSelector(localVideoCameraCycleButtonSelector);
    const cameraSwitcherCallback = useHandlers(LocalVideoCameraCycleButton);
    const announcerString = useParticipantChangedAnnouncement();
    const layoutBasedOnTilePosition = localVideoTileLayoutTrampoline();
    const cameraSwitcherProps = useMemo(() => {
        return Object.assign(Object.assign({}, cameraSwitcherCallback), cameraSwitcherCameras);
    }, [cameraSwitcherCallback, cameraSwitcherCameras]);
    const onRenderAvatar = useCallback((userId, options) => {
        return React.createElement(Stack, { className: mergeStyles({
                position: 'absolute',
                height: '100%',
                width: '100%'
            }) },
            React.createElement(Stack, { styles: {
                    root: {
                        margin: 'auto',
                        maxHeight: '100%'
                    }
                } }, (options === null || options === void 0 ? void 0 : options.coinSize) && React.createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData }))));
    }, [props.onFetchAvatarPersonaData]);
    useLocalVideoStartTrigger(!!props.isVideoStreamOn);
    const VideoGalleryMemoized = useMemo(() => {
        var _a;
        return React.createElement(VideoGallery, Object.assign({}, videoGalleryProps, { localVideoViewOptions: localVideoViewOptions, remoteVideoViewOptions: remoteVideoViewOptions, styles: VideoGalleryStyles, layout: layoutBasedOnTilePosition, showCameraSwitcherInLocalPreview: props.isMobile, localVideoCameraCycleButtonProps: cameraSwitcherProps, onRenderAvatar: (_a = props.onRenderAvatar) !== null && _a !== void 0 ? _a : onRenderAvatar }));
    }, [videoGalleryProps, props.isMobile, props.onRenderAvatar, onRenderAvatar, cameraSwitcherProps, layoutBasedOnTilePosition]);
    return React.createElement("div", { style: mediaGalleryContainerStyles },
        React.createElement(Announcer, { announcementString: announcerString, ariaLive: 'polite' }),
        VideoGalleryMemoized);
};
/**
 * @private
 *
 * `shouldTransition` is an extra predicate that controls whether this hooks actually transitions the call.
 * The rule of hooks disallows calling the hook conditionally, so this predicate can be used to make the decision.
 */
export const useLocalVideoStartTrigger = (isLocalVideoAvailable, shouldTransition) => {
    // Once a call is joined, we need to transition the local preview camera setting into the call.
    // This logic is needed on any screen that we might join a call from:
    // - The Media gallery
    // - The lobby page
    // - The networkReconnect interstitial that may show at the start of a call.
    //
    // @TODO: Can we simply have the callHandlers handle this transition logic.
    const [isButtonStatusSynced, setIsButtonStatusSynced] = useState(false);
    const isPreviewCameraOn = useSelector(getIsPreviewCameraOn);
    const mediaGalleryHandlers = useHandlers(MediaGallery);
    useEffect(() => {
        if (shouldTransition !== false) {
            if (isPreviewCameraOn && !isLocalVideoAvailable && !isButtonStatusSynced) {
                mediaGalleryHandlers.onStartLocalVideo();
            }
            setIsButtonStatusSynced(true);
        }
    }, [shouldTransition, isButtonStatusSynced, isPreviewCameraOn, isLocalVideoAvailable, mediaGalleryHandlers]);
};
const mediaGalleryContainerStyles = {
    width: '100%',
    height: '100%'
};
const localVideoTileLayoutTrampoline = (localTileOptions) => {
    return 'floatingLocalVideo';
};
//# sourceMappingURL=MediaGallery.js.map