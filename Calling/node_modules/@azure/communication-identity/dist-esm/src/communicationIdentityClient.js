// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { createCommunicationAuthPolicy, isKeyCredential, parseClientArguments, } from "@azure/communication-common";
import { isTokenCredential } from "@azure/core-auth";
import { IdentityRestClient } from "./generated/src/identityRestClient";
import { SpanStatusCode } from "@azure/core-tracing";
import { createSpan } from "./common/tracing";
import { logger } from "./common/logger";
const isCommunicationIdentityClientOptions = (options) => options && !isTokenCredential(options) && !isKeyCredential(options);
/**
 * Client class for interacting with Azure Communication Services User Token Management.
 */
export class CommunicationIdentityClient {
    constructor(connectionStringOrEndpoint, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = parseClientArguments(connectionStringOrEndpoint, credentialOrOptions);
        const options = isCommunicationIdentityClientOptions(credentialOrOptions)
            ? credentialOrOptions
            : maybeOptions;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        this.client = new IdentityRestClient(url, Object.assign({ endpoint: url }, internalPipelineOptions));
        const authPolicy = createCommunicationAuthPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
    }
    /**
     * Creates a scoped user token.
     *
     * @param user - The user whose tokens are being issued.
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    async getToken(user, scopes, options = {}) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-issueToken", options);
        try {
            return await this.client.communicationIdentityOperations.issueAccessToken(user.communicationUserId, scopes, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Revokes all data and tokens created for a user.
     *
     * @param user - The user whose tokens are being revoked.
     * @param options - Additional options for the request.
     */
    async revokeTokens(user, options = {}) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-revokeTokens", options);
        try {
            await this.client.communicationIdentityOperations.revokeAccessTokens(user.communicationUserId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a single user.
     *
     * @param options - Additional options for the request.
     */
    async createUser(options = {}) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-createUser", options);
        try {
            const result = await this.client.communicationIdentityOperations.create(updatedOptions);
            return {
                communicationUserId: result.identity.id,
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a single user and a token simultaneously.
     *
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    async createUserAndToken(scopes, options = {}) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-createUserAndToken", options);
        try {
            const { identity, accessToken } = await this.client.communicationIdentityOperations.create(Object.assign({ createTokenWithScopes: scopes }, updatedOptions));
            return Object.assign(Object.assign({}, accessToken), { user: { communicationUserId: identity.id } });
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Triggers revocation event for user and deletes all its data.
     *
     * @param user - The user being deleted.
     * @param options - Additional options for the request.
     */
    async deleteUser(user, options = {}) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-deleteUser", options);
        try {
            await this.client.communicationIdentityOperations.delete(user.communicationUserId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Exchanges an Azure AD access token of a Teams user for a new Communication Identity access token with a matching expiration time.
     *
     * @param options - Options used to exchange an Azure AD access token of a Teams user for a new Communication Identity access token.
     */
    async getTokenForTeamsUser(options) {
        const { span, updatedOptions } = createSpan("CommunicationIdentity-getTokenForTeamsUser", options);
        const { teamsUserAadToken, clientId, userObjectId } = options;
        try {
            return await this.client.communicationIdentityOperations.exchangeTeamsUserAccessToken(teamsUserAadToken, clientId, userObjectId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}
//# sourceMappingURL=communicationIdentityClient.js.map