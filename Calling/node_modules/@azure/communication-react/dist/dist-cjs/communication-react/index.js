'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var communicationCommon = require('@azure/communication-common');
var reselect = require('reselect');
var memoizeOne = require('memoize-one');
var communicationCalling = require('@azure/communication-calling');
var logger = require('@azure/logger');
var EventEmitter = require('events');
var produce = require('immer');
var React = require('react');
var react = require('@fluentui/react');
var r = require('react-dom');
var reactIcons = require('@fluentui/react-icons');
var uuid = require('uuid');
var reactFileTypeIcons = require('@fluentui/react-file-type-icons');
var htmlToReact = require('html-to-react');
var Linkify = require('react-linkify');
var DOMPurify = require('dompurify');
var reactHooks = require('@fluentui/react-hooks');
var reactWindowProvider = require('@fluentui/react-window-provider');
var copy = require('copy-to-clipboard');
var communicationChat = require('@azure/communication-chat');
var nanoid = require('nanoid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var reselect__namespace = /*#__PURE__*/_interopNamespace(reselect);
var memoizeOne__default = /*#__PURE__*/_interopDefaultLegacy(memoizeOne);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);
var produce__default = /*#__PURE__*/_interopDefaultLegacy(produce);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var r__namespace = /*#__PURE__*/_interopNamespace(r);
var Linkify__default = /*#__PURE__*/_interopDefaultLegacy(Linkify);
var DOMPurify__default = /*#__PURE__*/_interopDefaultLegacy(DOMPurify);
var copy__default = /*#__PURE__*/_interopDefaultLegacy(copy);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const argsCmp = (args1, args2, objCmp) => {
    return args1.length === args2.length && args1.every((arg1, index) => objCmp(args2[index], arg1));
};
/**
 * The function memoize a series of function calls in a single pass,
 * it memoizes all the args and return in a single run of the callback function, and read it in the next round of execution
 * note: this is a memory opimized function which will only memoize one round of bulk calls
 * @param  fnToMemoize - the function needs to be bulk memorized and a key key paramter needs to be provided as cache id
 * @param  shouldCacheUpdate - the validate function for comparing 2 argument, return true when 2 args are equal
 * @returns callback function includes a series calls of memoizedFn, and each call will get cache result if args are the same(according to shouldCacheUpdate fn)
 * @example
 * ```ts
 * const items = [{id:1, value:3}];
 * const heavyFn = (_key, value) => { // key is not used in the function, but it is a cache id
 *   // assume this is a heavy caculation
 *   return value+1;
 * }
 *
 * const memoizeHeavyFnAll = memoizeFnAll(heavyFn);
 * const generateValueArray = (memoizedHeavyFn) => (
 *   items.map(item => {
 *     memoizedHeavyFn(item.id, item.value);
 *   })
 * );
 *
 * const result = memoizeHeavyFnAll(generateValueArray); // Cache: {}, nextCache: {1: 4 *new}, heavyFn call times: 1
 *
 * // Argument changed
 * items[0].value = 2
 * const result0 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 4}, nextCache: {1: 3 *new}, heavyFn call times: 1
 *
 * // Cache added
 * items.push({id:3, value:4});
 * const result1 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3 *hit}, nextCache: {1: 3, 3: 5 *new}, heavyFn call times: 1
 *
 * // Cache removed
 * delete items[0];
 * const result2 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3, 3: 5 *hit}, nextCache: {3: 5}, heavyFn call times: 0
 * ```
 *
 * @public
 */
const memoizeFnAll = (fnToMemoize, shouldCacheUpdate = Object.is) => {
    let cache = new Map();
    let nextCache = new Map();
    return (callback) => {
        const memoizedFn = (key, ...args) => {
            const value = cache.get(key);
            if (value) {
                const [preArgs, ret] = value;
                if (argsCmp(preArgs, args, shouldCacheUpdate)) {
                    nextCache.set(key, [args, ret]);
                    return ret;
                }
            }
            const ret = fnToMemoize(key, ...args);
            nextCache.set(key, [args, ret]);
            return ret;
        };
        const retValue = callback(memoizedFn);
        cache = nextCache;
        nextCache = new Map();
        return retValue;
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * A string representation of a {@link @azure/communication-common#CommunicationIdentifier}.
 *
 * This string representation of CommunicationIdentifier is guaranteed to be stable for
 * a unique Communication user. Thus,
 * - it can be used to persist a user's identity in external databases.
 * - it can be used as keys into a Map to store data for the user.
 *
 * @public
 */
const toFlatCommunicationIdentifier = (identifier) => {
    return communicationCommon.getIdentifierRawId(identifier);
};
/**
 * Reverse operation of {@link toFlatCommunicationIdentifier}.
 *
 * @public
 */
const fromFlatCommunicationIdentifier = (id) => {
    // if the id passed is a phone number we need to build the rawId to pass in
    const rawId = id.indexOf('+') === 0 ? '4:' + id : id;
    return communicationCommon.createIdentifierFromRawId(rawId);
};
/**
 * Returns a CommunicationIdentifier.
 * @internal
 */
const _toCommunicationIdentifier = (id) => {
    if (typeof id === 'string') {
        return fromFlatCommunicationIdentifier(id);
    }
    return id;
};
/**
 * Check if an object is identifier.
 *
 * @internal
 */
const _isValidIdentifier = (identifier) => {
    return communicationCommon.isCommunicationUserIdentifier(identifier) || communicationCommon.isPhoneNumberIdentifier(identifier) || communicationCommon.isMicrosoftTeamsUserIdentifier(identifier) || communicationCommon.isUnknownIdentifier(identifier);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// GENERATED FILE. DO NOT EDIT MANUALLY.
var telemetryVersion = '1.6.0';

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// Removes long suffixes that don't fit the constraints for telemetry application ID.
// e.g., the build suffix is dropped for alpha package versions.
const sanitize = (version) => {
    const alphaIndex = version.search(/alpha/);
    if (alphaIndex >= 0) {
        return version.substring(0, alphaIndex + 5);
    }
    return version;
};
/**
 * Application ID to be included in telemetry data from the UI library.
 * Template: acXYYY/<version>
 * Where:
 * - X describes a platform, [r: web, i: iOS, a: Android]
 * - YYY describes what's running on this platform (optional, currently unused by this library):
 *    Y[0] is high-level artifact,
 *      [0: undefined, 1: AzureCommunicationLibrary, 2: ACS SampleApp]
 *    Y[1] is specific implementation,
 *      [0: undefined, 1: Call Composite, 2: Chat Composite, 3: CallWithChatComposite, 4: UI Components]
 *    Y[2] is reserved for implementation details,
 *      [0: undefined]
 *
 * @internal
 */
const _getApplicationId = () => {
    const version = telemetryVersion;
    return sanitize(`acr/${version}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 *
 * Replace the pattern "\{\}" in str with the values passed in as vars
 *
 * @example
 * ```ts
 *   _formatString("hello {name}. '{name}' is a rare name.", {name: "Foo"});
 *   // returns "hello Foo. 'Foo' is a rare name."
 * ```
 * @param str - The string to be formatted
 * @param variables - Variables to use to format the string
 * @returns a formatted string
 */
const _formatString = (str, vars) => {
    if (!str) {
        return '';
    }
    if (!vars) {
        return str;
    }
    // regex to search for the pattern "\{\}"
    const placeholdersRegex = /{(\w+)}/g;
    return str.replace(placeholdersRegex, (_, k) => vars[k] || `{${k}}`);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Wrap JSON.stringify in a try-catch as JSON.stringify throws an exception if it fails.
 *
 * Use this only in areas where the JSON.stringify is non-critical and OK for the JSON.stringify to fail, such as logging.
 *
 * @internal
 */
const _safeJSONStringify = (value, replacer = createSafeReplacer(), space) => {
    try {
        return JSON.stringify(value, replacer, space);
    }
    catch (e) {
        console.error(e);
        return undefined;
    }
};
// Log all visited refs to avoid circular ref
const createSafeReplacer = () => {
    const visited = new Set();
    return function replacer(key, value) {
        if (typeof value !== 'object') {
            return value;
        }
        if (visited.has(value)) {
            return 'Visited-Ref';
        }
        else {
            visited.add(value);
            return value;
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Converts units of rem to units of pixels
 * @param rem - units of rem
 * @returns units of pixels
 */
const _convertRemToPx = (rem) => {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
};
/**
 * @internal
 * Disable dismiss on resize to work around a couple Fluent UI bugs
 * - The Callout is dismissed whenever *any child of window (inclusive)* is resized. In practice, this
 * happens when we change the VideoGallery layout, or even when the video stream element is internally resized
 * by the headless SDK.
 * - We also want to prevent dismiss when chat pane is scrolling especially a new message is added.
 * A side effect of this workaround is that the context menu stays open when window is resized, and may
 * get detached from original target visually. That bug is preferable to the bug when this value is not set -
 * The Callout (frequently) gets dismissed automatically.
 */
const _preventDismissOnEvent = (ev) => {
    return ev.type === 'resize' || ev.type === 'scroll';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Converts px value to rem value.
 * For example, an input of `16` will return `1rem`.
 */
const _pxToRem = (px) => `${px / 16}rem`;

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * This is a log function to log structural data for easier parse in telemetry
 */
const _logEvent = (logger, event) => {
    logger[event.level](_safeJSONStringify(event));
};

/**
 * @private
 */
const getDeviceManager$1 = (state) => state.deviceManager;
/**
 * @private
 */
const getCallExists = (state, props) => !!state.calls[props.callId];
/**
 * @private
 */
const getDominantSpeakers = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants$1 = (state, props) => {
    var _a;
    return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.remoteParticipants;
};
/**
 * @private
 */
const getIsScreenSharingOn = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn; };
/**
 * @private
 */
const getIsMuted = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.isMuted; };
/**
 * @private
 */
const getLocalVideoStreams$1 = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getScreenShareRemoteParticipant = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant; };
/**
 * @private
 */
const getDisplayName$2 = (state) => { var _a; return (_a = state.callAgent) === null || _a === void 0 ? void 0 : _a.displayName; };
/**
 * @private
 */
const getIdentifier = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getLatestErrors$1 = (state) => state.latestErrors;
/**
 * @private
 */
const getDiagnostics = (state, props) => { var _a; return (_a = state.calls[props.callId]) === null || _a === void 0 ? void 0 : _a.diagnostics; };
/**
 * @private
 */
const getEnvironmentInfo = (state) => {
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$z = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Check if the call state represents being in the call
 *
 * @internal
 */
const _isInCall = (callStatus) => !!callStatus && !['None', 'Disconnected', 'Connecting', 'Ringing', 'EarlyMedia', 'Disconnecting'].includes(callStatus);
/**
 * Check if the call state represents being in the lobby or waiting to be admitted.
 *
 * @internal
 */
const _isInLobbyOrConnecting = (callStatus) => !!callStatus && ['Connecting', 'Ringing', 'InLobby', 'EarlyMedia'].includes(callStatus);
/**
 * Check if the device manager local video is on when not part of a call
 * i.e. do unparented views exist.
 *
 * @internal
 */
const _isPreviewOn = (deviceManager) => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    return deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view !== undefined;
};
/**
 * Dispose of all preview views
 * We assume all unparented views are local preview views.
 *
 * @private
 */
const disposeAllLocalPreviewViews = (callClient) => __awaiter$z(void 0, void 0, void 0, function* () {
    const unparentedViews = callClient.getState().deviceManager.unparentedViews;
    for (const view of unparentedViews) {
        yield callClient.disposeView(undefined, undefined, view);
    }
});
/**
 * @private
 * A type guard to ensure all participants are acceptable type for ACS call
 */
const isACSCallParticipants = (participants) => {
    return participants.every(p => !communicationCommon.isMicrosoftTeamsUserIdentifier(p));
};
/**
 * @private
 * Checks whether the user is a 'Ringing' PSTN user.
 */
const _isRingingPSTNParticipant = (participant) => {
    return participant.identifier.kind === 'phoneNumber' && participant.state === 'Connecting' ? 'Ringing' : participant.state;
};

// Copyright (c) Microsoft Corporation.
/**
 * Selector for {@link MicrophoneButton} component.
 *
 * @public
 */
const microphoneButtonSelector = reselect__namespace.createSelector([getCallExists, getIsMuted, getDeviceManager$1], (callExists, isMuted, deviceManager) => {
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : true;
    return {
        disabled: !callExists || !permission,
        checked: callExists ? !isMuted : false,
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});
/**
 * Selector for {@link CameraButton} component.
 *
 * @public
 */
const cameraButtonSelector = reselect__namespace.createSelector([getLocalVideoStreams$1, getDeviceManager$1], (localVideoStreams, deviceManager) => {
    const previewOn = _isPreviewOn(deviceManager);
    const localVideoFromCall = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
    const permission = deviceManager.deviceAccess ? deviceManager.deviceAccess.video : true;
    return {
        disabled: !deviceManager.selectedCamera || !permission || !deviceManager.cameras.length,
        checked: localVideoStreams !== undefined && localVideoStreams.length > 0 ? !!localVideoFromCall : previewOn,
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});
/**
 * Selector for {@link ScreenShareButton} component.
 *
 * @public
 */
const screenShareButtonSelector = reselect__namespace.createSelector([getIsScreenSharingOn], (isScreenSharingOn) => {
    return {
        checked: isScreenSharingOn
    };
});
/**
 * Selector for {@link DevicesButton} component.
 *
 * @public
 */
const devicesButtonSelector = reselect__namespace.createSelector([getDeviceManager$1], deviceManager => {
    return {
        microphones: removeBlankNameDevices(deviceManager.microphones),
        speakers: removeBlankNameDevices(deviceManager.speakers),
        cameras: removeBlankNameDevices(deviceManager.cameras),
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker,
        selectedCamera: deviceManager.selectedCamera
    };
});
function removeBlankNameDevices(devices) {
    return devices.filter(device => device.name !== '');
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$y = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const areStreamsEqual = (prevStream, newStream) => {
    return !!prevStream && !!newStream && prevStream.source.id === newStream.source.id;
};
/**
 * Create the common implementation of {@link CallingHandlers} for all types of Call
 *
 * @private
 */
const createDefaultCommonCallingHandlers = memoizeOne__default['default']((callClient, deviceManager, call) => {
    const onStartLocalVideo = () => __awaiter$y(void 0, void 0, void 0, function* () {
        // Before the call object creates a stream, dispose of any local preview streams.
        // @TODO: is there any way to parent the unparented view to the call object instead
        // of disposing and creating a new stream?
        yield disposeAllLocalPreviewViews(callClient);
        const callId = call === null || call === void 0 ? void 0 : call.id;
        let videoDeviceInfo = callClient.getState().deviceManager.selectedCamera;
        if (!videoDeviceInfo) {
            const cameras = yield (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.getCameras());
            videoDeviceInfo = cameras && cameras.length > 0 ? cameras[0] : undefined;
            videoDeviceInfo && (deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.selectCamera(videoDeviceInfo));
        }
        if (!callId || !videoDeviceInfo) {
            return;
        }
        const stream = new communicationCalling.LocalVideoStream(videoDeviceInfo);
        if (call && !call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.startVideo(stream);
        }
    });
    const onStopLocalVideo = (stream) => __awaiter$y(void 0, void 0, void 0, function* () {
        const callId = call === null || call === void 0 ? void 0 : call.id;
        if (!callId) {
            return;
        }
        if (call && call.localVideoStreams.find(s => areStreamsEqual(s, stream))) {
            yield call.stopVideo(stream);
        }
    });
    const onToggleCamera = (options) => __awaiter$y(void 0, void 0, void 0, function* () {
        const previewOn = _isPreviewOn(callClient.getState().deviceManager);
        if (previewOn && call && call.state === 'Connecting') {
            // This is to workaround: https://skype.visualstudio.com/SPOOL/_workitems/edit/3030558.
            // The root cause of the issue is caused by never transitioning the unparented view to the
            // call object when going from configuration page (disconnected call state) to connecting.
            //
            // Currently the only time the local video stream is moved from unparented view to the call
            // object is when we transition from connecting -> call state. If the camera was on,
            // inside the MediaGallery we trigger toggleCamera. This triggers onStartLocalVideo which
            // destroys the unparentedView and creates a new stream in the call - so all looks well.
            //
            // However, if someone turns off their camera during the lobbyOrConnecting screen, the
            // call.localVideoStreams will be empty (as the stream is currently stored in the unparented
            // views and was never transitioned to the call object) and thus we incorrectly try to create
            // a new video stream for the call object, instead of only stopping the unparented view.
            //
            // The correct fix for this is to ensure that callAgent.onStartCall is called with the
            // localvideostream as a videoOption. That will mean call.onLocalVideoStreamsUpdated will
            // be triggered when the call is in connecting state, which we can then transition the
            // local video stream to the stateful call client and get into a clean state.
            yield onDisposeLocalStreamView();
            return;
        }
        if (call && (_isInCall(call.state) || _isInLobbyOrConnecting(call.state))) {
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            if (stream) {
                yield onStopLocalVideo(stream);
            }
            else {
                yield onStartLocalVideo();
            }
        }
        else {
            const selectedCamera = callClient.getState().deviceManager.selectedCamera;
            if (selectedCamera) {
                if (previewOn) {
                    yield onDisposeLocalStreamView();
                }
                else {
                    yield callClient.createView(undefined, undefined, {
                        source: selectedCamera,
                        mediaStreamType: 'Video'
                    }, options);
                }
            }
        }
    });
    const onSelectMicrophone = (device) => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectMicrophone(device);
    });
    const onSelectSpeaker = (device) => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        return deviceManager.selectSpeaker(device);
    });
    const onSelectCamera = (device, options) => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!deviceManager) {
            return;
        }
        if (call && _isInCall(call.state)) {
            deviceManager.selectCamera(device);
            const stream = call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
            return stream === null || stream === void 0 ? void 0 : stream.switchSource(device);
        }
        else {
            const previewOn = _isPreviewOn(callClient.getState().deviceManager);
            if (!previewOn) {
                deviceManager.selectCamera(device);
                return;
            }
            yield onDisposeLocalStreamView();
            deviceManager.selectCamera(device);
            yield callClient.createView(undefined, undefined, {
                source: device,
                mediaStreamType: 'Video'
            }, options);
        }
    });
    const onToggleMicrophone = () => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!call || !_isInCall(call.state)) {
            throw new Error(`Please invoke onToggleMicrophone after call is started`);
        }
        return call.isMuted ? yield call.unmute() : yield call.mute();
    });
    const onStartScreenShare = () => __awaiter$y(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.startScreenSharing()); });
    const onStopScreenShare = () => __awaiter$y(void 0, void 0, void 0, function* () { return yield (call === null || call === void 0 ? void 0 : call.stopScreenSharing()); });
    const onToggleScreenShare = () => __awaiter$y(void 0, void 0, void 0, function* () { return (call === null || call === void 0 ? void 0 : call.isScreenSharingOn) ? yield onStopScreenShare() : yield onStartScreenShare(); });
    const onHangUp = (forEveryone) => __awaiter$y(void 0, void 0, void 0, function* () {
        return yield (call === null || call === void 0 ? void 0 : call.hangUp({
            forEveryone: forEveryone === true ? true : false
        }));
    });
    const onCreateLocalStreamView = (options = {
        scalingMode: 'Crop',
        isMirrored: true
    }) => __awaiter$y(void 0, void 0, void 0, function* () {
        var _a;
        if (!call || call.localVideoStreams.length === 0) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            return;
        }
        const localStream = callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (!localStream) {
            return;
        }
        const { view } = (_a = (yield callClient.createView(call.id, undefined, localStream, options))) !== null && _a !== void 0 ? _a : {};
        return view ? {
            view
        } : undefined;
    });
    const onCreateRemoteStreamView = (userId, options = {
        scalingMode: 'Crop'
    }) => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        // Find the first available stream, if there is none, then get the first stream
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video' && i.isAvailable) || Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing' && i.isAvailable) || Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        let createViewResult = undefined;
        if (remoteVideoStream && remoteVideoStream.isAvailable && !remoteVideoStream.view) {
            createViewResult = yield callClient.createView(call.id, participant.identifier, remoteVideoStream, options);
        }
        if (screenShareStream && screenShareStream.isAvailable && !screenShareStream.view) {
            // Hardcoded `scalingMode` since it is highly unlikely that CONTOSO would ever want to use a different scaling mode for screenshare.
            // Using `Crop` would crop the contents of screenshare and `Stretch` would warp it.
            // `Fit` is the only mode that maintains the integrity of the screen being shared.
            createViewResult = yield callClient.createView(call.id, participant.identifier, screenShareStream, {
                scalingMode: 'Fit'
            });
        }
        return (createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view) ? {
            view: createViewResult === null || createViewResult === void 0 ? void 0 : createViewResult.view
        } : undefined;
    });
    const onDisposeRemoteStreamView = (userId) => __awaiter$y(void 0, void 0, void 0, function* () {
        if (!call) {
            return;
        }
        const callState = callClient.getState().calls[call.id];
        if (!callState) {
            throw new Error(`Call Not Found: ${call.id}`);
        }
        const participant = Object.values(callState.remoteParticipants).find(participant => toFlatCommunicationIdentifier(participant.identifier) === userId);
        if (!participant || !participant.videoStreams) {
            return;
        }
        const remoteVideoStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'Video');
        const screenShareStream = Object.values(participant.videoStreams).find(i => i.mediaStreamType === 'ScreenSharing');
        if (remoteVideoStream && remoteVideoStream.view) {
            callClient.disposeView(call.id, participant.identifier, remoteVideoStream);
        }
        if (screenShareStream && screenShareStream.view) {
            callClient.disposeView(call.id, participant.identifier, screenShareStream);
        }
    });
    const onDisposeLocalStreamView = () => __awaiter$y(void 0, void 0, void 0, function* () {
        // If the user is currently in a call, dispose of the local stream view attached to that call.
        const callState = call && callClient.getState().calls[call.id];
        const localStream = callState === null || callState === void 0 ? void 0 : callState.localVideoStreams.find(item => item.mediaStreamType === 'Video');
        if (call && callState && localStream) {
            callClient.disposeView(call.id, undefined, localStream);
        }
        // If the user is not in a call we currently assume any unparented view is a LocalPreview and stop all
        // since those are only used for LocalPreview currently.
        // TODO: we need to remember which LocalVideoStream was used for LocalPreview and dispose that one.
        yield disposeAllLocalPreviewViews(callClient);
    });
    const notImplemented = () => {
        throw new Error('Not implemented, cannot call a method from an abstract object');
    };
    return {
        onHangUp,
        onSelectCamera,
        onSelectMicrophone,
        onSelectSpeaker,
        onStartScreenShare,
        onStopScreenShare,
        onToggleCamera,
        onToggleMicrophone,
        onToggleScreenShare,
        onCreateLocalStreamView,
        onCreateRemoteStreamView,
        onStartLocalVideo,
        onDisposeRemoteStreamView,
        onDisposeLocalStreamView,
        onRemoveParticipant: notImplemented,
        onStartCall: notImplemented
    };
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$x = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link CallingHandlers} for teams call.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const createDefaultCallingHandlers = memoizeOne__default['default']((callClient, callAgent, deviceManager, call) => {
    return Object.assign(Object.assign({}, createDefaultCommonCallingHandlers(callClient, deviceManager, call)), { 
        // FIXME: onStartCall API should use string, not the underlying SDK types.
        onStartCall: (participants, options) => {
            if (!isACSCallParticipants(participants)) {
                throw new Error('TeamsUserIdentifier in Teams call is not supported!');
            }
            return callAgent === null || callAgent === void 0 ? void 0 : callAgent.startCall(participants, options);
        }, onRemoveParticipant: (userId) => __awaiter$x(void 0, void 0, void 0, function* () {
            const participant = _toCommunicationIdentifier(userId);
            yield (call === null || call === void 0 ? void 0 : call.removeParticipant(participant));
        }) });
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$w = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyDeviceManager proxies DeviceManager and subscribes to all events that affect device manager state. State updates
 * are set on the provided context. Also any queries for state are proxied and stored in state as well. Only one device
 * manager should exist for a given CallClient so if CallClient.getDeviceManager is called multiple times, either a
 * cached ProxyDeviceManager should be returned or the existing ProxyDeviceManager should be destructed via destructor()
 * and a new ProxyDeviceManager created.
 */
class ProxyDeviceManager {
    constructor(deviceManager, context) {
        this.setDeviceManager = () => {
            // isSpeakerSelectionAvailable, selectedMicrophone, and selectedSpeaker are properties on DeviceManager. Since they
            // are not functions we can't proxy them so we'll update whenever we think they may need updating such as at
            // construction time or when certain events happen.
            this._context.setDeviceManagerIsSpeakerSelectionAvailable(this._deviceManager.isSpeakerSelectionAvailable);
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this.subscribe = () => {
            this._deviceManager.on('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.on('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.on('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.on('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * This is used to unsubscribe DeclarativeDeviceManager from the DeviceManager events.
         */
        this.unsubscribe = () => {
            this._deviceManager.off('videoDevicesUpdated', this.videoDevicesUpdated);
            this._deviceManager.off('audioDevicesUpdated', this.audioDevicesUpdated);
            this._deviceManager.off('selectedMicrophoneChanged', this.selectedMicrophoneChanged);
            this._deviceManager.off('selectedSpeakerChanged', this.selectedSpeakerChanged);
        };
        /**
         * Used to set a camera inside the proxy device manager.
         *
         * @param videoDeviceInfo VideoDeviceInfo
         */
        this.selectCamera = (videoDeviceInfo) => {
            this._context.setDeviceManagerSelectedCamera(videoDeviceInfo);
        };
        this.videoDevicesUpdated = () => __awaiter$w(this, void 0, void 0, function* () {
            // Device Manager always has a camera with '' name if there are no real camera devices available.
            // We don't want to show that in the UI.
            const realCameras = (yield this._deviceManager.getCameras()).filter(c => !!c.name);
            this._context.setDeviceManagerCameras(dedupeById(realCameras));
        });
        this.audioDevicesUpdated = () => __awaiter$w(this, void 0, void 0, function* () {
            this._context.setDeviceManagerMicrophones(dedupeById(yield this._deviceManager.getMicrophones()));
            this._context.setDeviceManagerSpeakers(dedupeById(yield this._deviceManager.getSpeakers()));
        });
        this.selectedMicrophoneChanged = () => {
            this._context.setDeviceManagerSelectedMicrophone(this._deviceManager.selectedMicrophone);
        };
        this.selectedSpeakerChanged = () => {
            this._context.setDeviceManagerSelectedSpeaker(this._deviceManager.selectedSpeaker);
        };
        this._deviceManager = deviceManager;
        this._context = context;
        this.setDeviceManager();
        this.subscribe();
    }
    get(target, prop) {
        switch (prop) {
            case 'getCameras':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getCameras().then((cameras) => {
                            // Device Manager always has a camera with '' name if there are no real camera devices available.
                            // We don't want to show that in the UI.
                            const realCameras = cameras.filter(c => !!c.name);
                            this._context.setDeviceManagerCameras(dedupeById(realCameras));
                            return realCameras;
                        });
                    }, 'DeviceManager.getCameras');
                }
            case 'getMicrophones':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getMicrophones().then((microphones) => {
                            this._context.setDeviceManagerMicrophones(dedupeById(microphones));
                            return microphones;
                        });
                    }, 'DeviceManager.getMicrophones');
                }
            case 'getSpeakers':
                {
                    return this._context.withAsyncErrorTeedToState(() => {
                        return target.getSpeakers().then((speakers) => {
                            this._context.setDeviceManagerSpeakers(dedupeById(speakers));
                            return speakers;
                        });
                    }, 'DeviceManager.getSpeakers');
                }
            case 'selectMicrophone':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectMicrophone(...args).then(() => {
                            this._context.setDeviceManagerSelectedMicrophone(target.selectedMicrophone);
                        });
                    }, 'DeviceManager.selectMicrophone');
                }
            case 'selectSpeaker':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.selectSpeaker(...args).then(() => {
                            this._context.setDeviceManagerSelectedSpeaker(target.selectedSpeaker);
                        });
                    }, 'DeviceManager.selectSpeaker');
                }
            case 'askDevicePermission':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => {
                        return target.askDevicePermission(...args).then((deviceAccess) => {
                            this._context.setDeviceManagerDeviceAccess(deviceAccess);
                            this.setDeviceManager();
                            return deviceAccess;
                        });
                    }, 'DeviceManager.askDevicePermission');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
// TODO: Remove this when SDK no longer returns duplicate audio and video devices
/** Helper function to dedupe duplicate audio and video devices obtained from SDK */
const dedupeById = (devices) => {
    const ids = new Set();
    const uniqueDevices = [];
    devices.forEach((device) => {
        if (!ids.has(device.id)) {
            uniqueDevices.push(device);
            ids.add(device.id);
        }
    });
    return uniqueDevices;
};
/**
 * Creates a declarative DeviceManager by proxying DeviceManager with ProxyDeviceManager. The declarative DeviceManager
 * will put state updates in the given context.
 *
 * @param deviceManager - DeviceManager from SDK
 * @param context - CallContext from StatefulCallClient
 *
 * @private
 */
const deviceManagerDeclaratify = (deviceManager, context, internalContext) => {
    const proxyDeviceManager = new ProxyDeviceManager(deviceManager, context);
    Object.defineProperty(deviceManager, 'unsubscribe', {
        configurable: false,
        value: () => proxyDeviceManager.unsubscribe()
    });
    Object.defineProperty(deviceManager, 'selectCamera', {
        configurable: false,
        value: (videoDeviceInfo) => proxyDeviceManager.selectCamera(videoDeviceInfo)
    });
    return new Proxy(deviceManager, proxyDeviceManager);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error thrown from failed stateful API methods.
 *
 * @public
 */
class CallError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'CallError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const callingStatefulLogger = logger.createClientLogger('communication-react:calling-stateful');
/**
 * @private
 */
var EventNames;
(function (EventNames) {
    // Info
    EventNames["VIEW_RENDER_SUCCEED"] = "VIEW_RENDER_SUCCEED";
    EventNames["START_DISPOSE_STREAM"] = "START_DISPOSE_STREAM";
    EventNames["START_STREAM_RENDERING"] = "START_STREAM_RENDERING";
    EventNames["DISPOSING_RENDERER"] = "DISPOSING_RENDERER";
    EventNames["CREATING_VIEW"] = "CREATING_VIEW";
    // Warning
    EventNames["CREATE_STREAM_INVALID_PARAMS"] = "CREATE_STREAM_INVALID_PARAMS";
    EventNames["DISPOSE_STREAM_INVALID_PARAMS"] = "DISPOSE_STREAM_INVALID_PARAMS";
    EventNames["STREAM_ALREADY_RENDERED"] = "STREAM_ALREADY_RENDERED";
    EventNames["STREAM_ALREADY_DISPOSED"] = "STREAM_ALREADY_DISPOSED";
    EventNames["STREAM_STOPPING"] = "STREAM_STOPPING";
    EventNames["CREATED_STREAM_STOPPING"] = "CREATED_STREAM_STOPPING";
    EventNames["STREAM_RENDERING"] = "STREAM_RENDERING";
    // Error
    EventNames["STREAM_NOT_FOUND"] = "STREAM_NOT_FOUND";
    EventNames["RENDER_INFO_NOT_FOUND"] = "RENDER_INFO_NOT_FOUND";
    EventNames["DISPOSE_INFO_NOT_FOUND"] = "DISPOSE_INFO_NOT_FOUND";
    EventNames["RENDERER_NOT_FOUND"] = "RENDERER_NOT_FOUND";
    EventNames["CREATE_STREAM_FAIL"] = "CREATE_STREAM_FAIL";
})(EventNames || (EventNames = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 * Call Id will change during the call for at least 1 time
 * This is to avoid async bug that call id has been changed during an async-await function
 * but the function still uses stale call id to access state
 */
class CallIdHistory {
    constructor() {
        this._callIdHistory = new Map();
    }
    updateCallIdHistory(newCallId, oldCallId) {
        // callId for a call can fluctuate between some set of values.
        // But if a newCallId already exists, and maps to different call, we're in trouble.
        // This can only happen if a callId is reused across two distinct calls.
        const existing = this._callIdHistory.get(newCallId);
        if (existing !== undefined && this.latestCallId(newCallId) !== oldCallId) {
            console.trace(`${newCallId} alredy exists and maps to ${existing}, which is not the same as ${oldCallId}`);
        }
        // The latest callId never maps to another callId.
        this._callIdHistory.delete(newCallId);
        this._callIdHistory.set(oldCallId, newCallId);
    }
    latestCallId(callId) {
        let latest = callId;
        /* eslint no-constant-condition: ["error", { "checkLoops": false }] */
        while (true) {
            const newer = this._callIdHistory.get(latest);
            if (newer === undefined) {
                break;
            }
            latest = newer;
        }
        return latest;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$v = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet();
// Needed to generate state diff for verbose logging.
produce.enablePatches();
// TODO: How can we make this configurable?
/**
 * @private
 */
const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
class CallContext$2 {
    constructor(userId, maxListeners = 50) {
        this._callIdHistory = new CallIdHistory();
        /**
         * Tees direct errors to state.
         * @remarks
         * This is typically used for errors that are caught and intended to be shown to the user.
         *
         * @param error The raw error to report.
         * @param target The error target to tee error to.
         *
         * @private
         */
        this.teeErrorToState = (error, target) => {
            const callError = toCallError(target, error);
            this.setLatestError(target, callError);
        };
        this._logger = logger.createClientLogger('communication-react:calling-context');
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter__default['default']();
        this._emitter.setMaxListeners(maxListeners);
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce.produce(this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
    // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.modifyState((draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        });
    }
    setCallAgent(callAgent) {
        this.modifyState((draft) => {
            draft.callAgent = callAgent;
        });
    }
    setCall(call) {
        this.modifyState((draft) => {
            const latestCallId = this._callIdHistory.latestCallId(call.id);
            const existingCall = draft.calls[latestCallId];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive; // We don't update the startTime and endTime if we are updating an existing active call
            }
            else {
                draft.calls[latestCallId] = call;
            }
        });
    }
    removeCall(callId) {
        this.modifyState((draft) => {
            delete draft.calls[this._callIdHistory.latestCallId(callId)];
        });
    }
    setCallEnded(callId, callEndReason) {
        const latestCallId = this._callIdHistory.latestCallId(callId);
        this.modifyState((draft) => {
            const call = draft.calls[latestCallId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[latestCallId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[latestCallId] = call;
            }
        });
    }
    setCallState(callId, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.state = state;
            }
        });
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        this.modifyState((draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                call.id = newCallId;
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        });
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        });
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallLocalVideoStream(callId, streams) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.localVideoStreams = streams;
            }
        });
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        });
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        });
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        });
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        });
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        });
    }
    setLocalVideoStreamRendererView(callId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                if (call.localVideoStreams.length > 0) {
                    call.localVideoStreams[0].view = view;
                }
            }
        });
    }
    setParticipantState(callId, participantKey, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        });
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        });
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        });
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        });
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        });
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        });
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamViewScalingMode(callId, participantKey, streamId, scalingMode) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream && stream.view) {
                        stream.view.scalingMode = scalingMode;
                    }
                }
            }
        });
    }
    setIncomingCall(call) {
        this.modifyState((draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        });
    }
    removeIncomingCall(callId) {
        this.modifyState((draft) => {
            delete draft.incomingCalls[callId];
        });
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.modifyState((draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        });
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.modifyState((draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        });
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        });
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        });
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        });
    }
    setDeviceManagerCameras(cameras) {
        this.modifyState((draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some(camera => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        });
    }
    setDeviceManagerMicrophones(microphones) {
        this.modifyState((draft) => {
            draft.deviceManager.microphones = microphones;
        });
    }
    setDeviceManagerSpeakers(speakers) {
        this.modifyState((draft) => {
            draft.deviceManager.speakers = speakers;
        });
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.modifyState((draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        });
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.modifyState((draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        });
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.source.id === localVideoStream.source.id && stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        });
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter$v(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                callingStatefulLogger.info(`Calling stateful client target function called: ${target}`);
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
}
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
function convertSdkLocalStreamToDeclarativeLocalStream(stream) {
    return {
        source: stream.source,
        mediaStreamType: stream.mediaStreamType,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkRemoteStreamToDeclarativeRemoteStream(stream) {
    return {
        id: stream.id,
        mediaStreamType: stream.mediaStreamType,
        isAvailable: stream.isAvailable,
        view: undefined
    };
}
/**
 * @private
 */
function convertSdkParticipantToDeclarativeParticipant(participant) {
    const declarativeVideoStreams = {};
    for (const videoStream of participant.videoStreams) {
        declarativeVideoStreams[videoStream.id] = convertSdkRemoteStreamToDeclarativeRemoteStream(videoStream);
    }
    return {
        identifier: participant.identifier,
        displayName: participant.displayName,
        state: participant.state,
        callEndReason: participant.callEndReason,
        videoStreams: declarativeVideoStreams,
        isMuted: participant.isMuted,
        isSpeaking: participant.isSpeaking
    };
}
/**
 * @private
 *
 * Note at the time of writing only one LocalVideoStream is supported by the SDK.
 */
function convertSdkCallToDeclarativeCall(call) {
    const declarativeRemoteParticipants = {};
    call.remoteParticipants.forEach((participant) => {
        declarativeRemoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = convertSdkParticipantToDeclarativeParticipant(participant);
    });
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        state: call.state,
        callEndReason: call.callEndReason,
        diagnostics: {
            network: {
                latest: {}
            },
            media: {
                latest: {}
            }
        },
        direction: call.direction,
        isMuted: call.isMuted,
        isScreenSharingOn: call.isScreenSharingOn,
        localVideoStreams: call.localVideoStreams.map(convertSdkLocalStreamToDeclarativeLocalStream),
        remoteParticipants: declarativeRemoteParticipants,
        remoteParticipantsEnded: {},
        recording: {
            isRecordingActive: false
        },
        transcription: {
            isTranscriptionActive: false
        },
        screenShareRemoteParticipant: undefined,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertSdkIncomingCallToDeclarativeIncomingCall(call) {
    return {
        id: call.id,
        callerInfo: call.callerInfo,
        startTime: new Date(),
        endTime: undefined
    };
}
/**
 * @private
 */
function convertFromSDKToDeclarativeVideoStreamRendererView(view) {
    return {
        scalingMode: view.scalingMode,
        isMirrored: view.isMirrored,
        target: view.target
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class RemoteVideoStreamSubscriber {
    constructor(callIdRef, participantKey, remoteVideoStream, context) {
        this.subscribe = () => {
            this._remoteVideoStream.on('isAvailableChanged', this.isAvailableChanged);
            this.checkAndUpdateScreenShareState();
        };
        this.unsubscribe = () => {
            this._remoteVideoStream.off('isAvailableChanged', this.isAvailableChanged);
        };
        this.includesActiveScreenShareStream = (streams) => {
            for (const stream of Object.values(streams)) {
                if (stream.mediaStreamType === 'ScreenSharing' && stream.isAvailable) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Update the state with the active screen share stream. If there is an existing stream will overwrite it if this one
         * is active (newer stream takes priority). If there is an existing stream and this one is set to unavailable, and the
         * existing stream is different participant, then don't set the active screen share stream to undefined, else set it
         * to undefined.
         */
        this.checkAndUpdateScreenShareState = () => {
            var _a, _b, _c;
            if (this._remoteVideoStream.mediaStreamType !== 'ScreenSharing') {
                return;
            }
            if (this._remoteVideoStream.isAvailable) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, this._participantKey);
                return;
            }
            const existingScreenShare = (_a = this._context.getState().calls[this._callIdRef.callId]) === null || _a === void 0 ? void 0 : _a.screenShareRemoteParticipant;
            // If somehow we end up with an event where a RemoteParticipant's ScreenShare stream is set to
            // unavailable but there exists already another different participant actively sharing, and they are still
            // sharing then this event shouldn't set the screenShareRemoteParticipant to undefined.
            if (!existingScreenShare || existingScreenShare === this._participantKey) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            const streams = (_c = (_b = this._context.getState().calls[this._callIdRef.callId]) === null || _b === void 0 ? void 0 : _b.remoteParticipants[existingScreenShare]) === null || _c === void 0 ? void 0 : _c.videoStreams;
            if (!streams) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
            // If the existing ScreenShare that is not owned by the current RemoteParticipant is still active, don't
            // overwrite it with undefined. So only overwrite if it is not active.
            if (!this.includesActiveScreenShareStream(streams)) {
                this._context.setCallScreenShareParticipant(this._callIdRef.callId, undefined);
                return;
            }
        };
        this.isAvailableChanged = () => {
            this._context.setRemoteVideoStreamIsAvailable(this._callIdRef.callId, this._participantKey, this._remoteVideoStream.id, this._remoteVideoStream.isAvailable);
            this.checkAndUpdateScreenShareState();
        };
        this._callIdRef = callIdRef;
        this._participantKey = participantKey;
        this._remoteVideoStream = remoteVideoStream;
        this._context = context;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * helper function to manage logging for stream disposals
 *
 * @param eventName Name of event that occured when managing streams
 * @param streamLogInfo Data about the stream in the event
 * @returns
 */
function _logDisposeStreamEvent(eventName, streamLogInfo) {
    switch (eventName) {
        case EventNames.DISPOSE_STREAM_INVALID_PARAMS:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSE_STREAM_INVALID_PARAMS,
                level: 'warning',
                message: 'Dispose View invalid combination of parameters.',
                data: {
                    streamType: streamLogInfo.streamType
                }
            });
            return;
        case EventNames.START_DISPOSE_STREAM:
            _logEvent(callingStatefulLogger, {
                name: EventNames.START_DISPOSE_STREAM,
                level: 'info',
                message: 'Start disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.DISPOSE_INFO_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSE_INFO_NOT_FOUND,
                level: 'error',
                message: 'Cannot find render info when disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_STOPPING,
                level: 'info',
                message: 'Stream is currently marked as stopping, will continue if is local preview',
                data: streamLogInfo
            });
            return;
        case EventNames.DISPOSING_RENDERER:
            _logEvent(callingStatefulLogger, {
                name: EventNames.DISPOSING_RENDERER,
                level: 'info',
                message: 'Disposing view renderer.',
                data: streamLogInfo
            });
            return;
        case EventNames.RENDERER_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.RENDERER_NOT_FOUND,
                level: 'error',
                message: 'Cannot find renderer when disposing stream.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_ALREADY_DISPOSED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_ALREADY_DISPOSED,
                level: 'info',
                message: 'Stream is already disposed.',
                data: streamLogInfo
            });
            return;
        default:
            return;
    }
}
/**
 * helper function to manage logging for local stream creations
 *
 * @param eventName Name of the event to occured when creating a local stream
 * @param streamLogInfo Data about the stream in the event
 * @param error that is thrown by caller
 * @returns
 */
function _logCreateStreamEvent(eventName, streamLogInfo, error) {
    switch (eventName) {
        case EventNames.CREATE_STREAM_INVALID_PARAMS:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_STREAM_INVALID_PARAMS,
                level: 'warning',
                message: 'Create View invalid combination of parameters.',
                data: {
                    streamType: streamLogInfo.streamType
                }
            });
            return;
        case EventNames.START_STREAM_RENDERING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.START_STREAM_RENDERING,
                level: 'info',
                message: 'Start creating view for local video.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_NOT_FOUND,
                level: 'error',
                message: 'Stream not found in state.',
                data: {
                    callId: streamLogInfo.callId
                }
            });
            return;
        case EventNames.STREAM_ALREADY_RENDERED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_ALREADY_RENDERED,
                level: 'warning',
                message: 'Stream is already rendered.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_RENDERING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_RENDERING,
                level: 'warning',
                message: 'Stream is rendering.',
                data: streamLogInfo
            });
            return;
        case EventNames.STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.STREAM_STOPPING,
                level: 'warning',
                message: 'Stream was marked as stopping by dispose view. Resetting state to "Rendering".',
                data: streamLogInfo
            });
            return;
        case EventNames.CREATE_STREAM_FAIL:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATE_STREAM_FAIL,
                level: 'error',
                message: 'Failed to create view.',
                data: {
                    error: error,
                    streamType: streamLogInfo.streamType,
                    callId: streamLogInfo.callId
                }
            });
            return;
        case EventNames.RENDER_INFO_NOT_FOUND:
            _logEvent(callingStatefulLogger, {
                name: EventNames.RENDER_INFO_NOT_FOUND,
                level: 'error',
                message: 'Cannot find render info after create the view. ',
                data: streamLogInfo
            });
            return;
        case EventNames.CREATED_STREAM_STOPPING:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATED_STREAM_STOPPING,
                level: 'warning',
                message: 'Render info status is stopping, dispose renderer.',
                data: streamLogInfo
            });
            return;
        case EventNames.VIEW_RENDER_SUCCEED:
            _logEvent(callingStatefulLogger, {
                name: EventNames.VIEW_RENDER_SUCCEED,
                level: 'info',
                message: `Successfully render the view.`,
                data: streamLogInfo
            });
            return;
        case EventNames.CREATING_VIEW:
            _logEvent(callingStatefulLogger, {
                name: EventNames.CREATING_VIEW,
                level: 'info',
                message: 'Start creating view for remote video.',
                data: streamLogInfo
            });
            return;
        default:
            return;
    }
}
/**
 * helper function to fire streamUtils logging events
 *
 * @param eventName Name of event from streamUtils
 * @param streamLogInfo informaiton about the event and who called it
 * @param error if any errors present will be added to message in logging
 */
function _logStreamEvent(eventName, streamLogInfo, error) {
    if (streamLogInfo.streamEventType === 'disposeViewLocal' || streamLogInfo.streamEventType === 'disposeViewRemote' || streamLogInfo.streamEventType === 'disposeViewUnparented') {
        _logDisposeStreamEvent(eventName, streamLogInfo);
    }
    else if (streamLogInfo.streamEventType === 'createViewLocal' || streamLogInfo.streamEventType === 'createViewRemote') {
        _logCreateStreamEvent(eventName, streamLogInfo, error);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$u = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createViewVideo(context, internalContext, callId, stream, participantId, options) {
    return __awaiter$u(this, void 0, void 0, function* () {
        // we can only have 3 types of createView
        let streamEventType;
        // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.
        if (participantId) {
            streamEventType = 'createViewRemote';
        }
        else if (callId) {
            streamEventType = 'createViewLocal';
        }
        else {
            // TODO update for when unparented view.
            throw new Error('unparented createView not implemented yet here');
        }
        const streamType = stream === null || stream === void 0 ? void 0 : stream.mediaStreamType;
        const streamId = stream.id;
        // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.
        const participantKey = streamEventType === 'createViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;
        const streamLogInfo = {
            callId,
            participantKey,
            streamId,
            streamType,
            streamEventType
        };
        // make different logging announcement based on whether or not we are starting a local or remote
        _logStreamEvent(EventNames.CREATING_VIEW, streamLogInfo);
        // if we have a participant Id and a stream get the remote info, else get the local render info from state.
        const renderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);
        if (!renderInfo) {
            _logStreamEvent(EventNames.STREAM_NOT_FOUND, streamLogInfo);
            return;
        }
        if (renderInfo.status === 'Rendered') {
            _logStreamEvent(EventNames.STREAM_ALREADY_RENDERED, streamLogInfo);
            return;
        }
        if (renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            _logStreamEvent(EventNames.STREAM_RENDERING, streamLogInfo);
            return;
        }
        // "Stopping" only happens if the stream was in "rendering" but `disposeView` was called.
        // Now that `createView` has been re-called, we can flip the state back to "rendering".
        if (renderInfo.status === 'Stopping') {
            if (streamEventType === 'createViewRemote' && participantKey) {
                _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
                internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Rendering', renderInfo.renderer);
            }
            else if (streamEventType === 'createViewLocal') {
                _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
                internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Rendering', renderInfo.renderer);
            }
            return;
        }
        const renderer = new communicationCalling.VideoStreamRenderer(renderInfo.stream);
        streamEventType === 'createViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Rendering', undefined) : internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Rendering', renderer);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            if (streamEventType === 'createViewRemote' && participantKey) {
                _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo);
                internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
            }
            else if (streamEventType === 'createViewLocal') {
                _logStreamEvent(EventNames.CREATE_STREAM_FAIL, streamLogInfo, e);
                internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
            }
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = streamEventType === 'createViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);
        if (!refreshedRenderInfo) {
            // RenderInfo was removed. This should not happen unless stream was removed from the call so dispose the renderer
            // and clean up the state.
            _logStreamEvent(EventNames.RENDER_INFO_NOT_FOUND, streamLogInfo);
            renderer.dispose();
            streamEventType === 'createViewRemote' && participantKey ? context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined) : context.setLocalVideoStreamRendererView(callId, undefined);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            _logStreamEvent(EventNames.CREATED_STREAM_STOPPING, streamLogInfo);
            renderer.dispose();
            if (streamEventType === 'createViewRemote' && participantKey) {
                internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'NotRendered', undefined);
                context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
            }
            else if (streamEventType === 'createViewLocal') {
                internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'NotRendered', undefined);
                context.setLocalVideoStreamRendererView(callId, undefined);
            }
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        if (streamEventType === 'createViewRemote' && participantKey) {
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, refreshedRenderInfo.stream, 'Rendered', renderer);
            context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
            _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);
        }
        else if (streamEventType === 'createViewLocal') {
            internalContext.setLocalRenderInfo(callId, refreshedRenderInfo.stream, 'Rendered', renderer);
            context.setLocalVideoStreamRendererView(callId, convertFromSDKToDeclarativeVideoStreamRendererView(view));
            _logStreamEvent(EventNames.VIEW_RENDER_SUCCEED, streamLogInfo);
        }
        return {
            renderer,
            view
        };
    });
}
function createViewUnparentedVideo(context, internalContext, stream, options) {
    return __awaiter$u(this, void 0, void 0, function* () {
        const renderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (renderInfo && renderInfo.status === 'Rendered') {
            console.warn('Unparented LocalVideoStream is already rendered');
            return;
        }
        if (renderInfo && renderInfo.status === 'Rendering') {
            // Do not log to console here as this is a very common situation due to UI rerenders while
            // the video rendering is in progress.
            return;
        }
        if (renderInfo && renderInfo.status === 'Stopping') {
            console.warn('Unparented LocalVideoStream is in the middle of stopping');
            return;
        }
        const localVideoStream = new communicationCalling.LocalVideoStream(stream.source);
        const renderer = new communicationCalling.VideoStreamRenderer(localVideoStream);
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendering', undefined);
        let view;
        try {
            view = yield renderer.createView(options);
        }
        catch (e) {
            // Special case for unparented views. Since they are not tied to anything and created by us based on the calls to
            // this function we'll delete it to clean up the data since keeping it around doesn't help us and if developer wants
            // to create a new view they can check that the view is not rendered and call this function again.
            internalContext.deleteUnparentedRenderInfo(stream);
            throw e;
        }
        // Since render could take some time, we need to check if the stream is still valid and if we received a signal to
        // stop rendering.
        const refreshedRenderInfo = internalContext.getUnparentedRenderInfo(stream);
        if (!refreshedRenderInfo) {
            // Unparented stream's RenderInfo was deleted. Currently this shouldn't happen but if it does we'll just dispose the
            // renderer and clean up state. If developer wanted the stream they could call this function again and that should
            // generate new working state via this function.
            renderer.dispose();
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        if (refreshedRenderInfo.status === 'Stopping') {
            // Stop render was called on this stream after we had started rendering. We will dispose this view and do not
            // put the view into the state. Special case for unparented views, delete them from state when stopped to free up
            // the memory since we were the ones generating this and not tied to any Call state.
            internalContext.deleteUnparentedRenderInfo(stream);
            context.deleteDeviceManagerUnparentedView(stream);
            return;
        }
        // Else the stream still exists and status is not telling us to stop rendering. Complete the render process by
        // updating the state.
        internalContext.setUnparentedRenderInfo(stream, localVideoStream, 'Rendered', renderer);
        internalContext.subscribeToUnparentedViewVideoEffects(localVideoStream, context);
        context.setDeviceManagerUnparentedView(stream, convertFromSDKToDeclarativeVideoStreamRendererView(view));
        return {
            renderer,
            view
        };
    });
}
function disposeViewVideo(context, internalContext, callId, stream, participantId) {
    // we can only have 3 types of createView
    let streamEventType;
    // we will reuse these for local as well but we need to make sure the remote stream is passed in like before.
    if (participantId) {
        streamEventType = 'disposeViewRemote';
    }
    else if (callId) {
        streamEventType = 'disposeViewLocal';
    }
    else {
        // TODO update for when unparented view.
        streamEventType = 'disposeViewUnparented';
    }
    const streamType = stream.mediaStreamType;
    const streamId = stream.id;
    // we want to check to see if there is a participantId this will tell us whether its a local stream or a remote one.
    const participantKey = streamEventType === 'disposeViewRemote' && participantId ? typeof participantId === 'string' ? participantId : toFlatCommunicationIdentifier(participantId) : undefined;
    const streamLogInfo = {
        callId,
        participantKey,
        streamId,
        streamType
    };
    _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);
    if (streamEventType === 'disposeViewRemote' && participantKey) {
        context.setRemoteVideoStreamRendererView(callId, participantKey, streamId, undefined);
    }
    const renderInfo = streamEventType === 'disposeViewRemote' && participantKey ? internalContext.getRemoteRenderInfoForParticipant(callId, participantKey, streamId) : internalContext.getLocalRenderInfo(callId);
    if (!renderInfo) {
        _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);
        return;
    }
    // Nothing to dispose of or clean up -- we can safely exit early here.
    if (renderInfo.status === 'NotRendered') {
        _logStreamEvent(EventNames.STREAM_ALREADY_DISPOSED, streamLogInfo);
        return;
    }
    // Status is already marked as "stopping" so we can exit early here. This is because stopping only occurs
    // when the stream is being created in createView but hasn't been completed being created yet. The createView
    // method will see the "stopping" status and perform the cleanup
    if (renderInfo.status === 'Stopping') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        return;
    }
    // If the stream is in the middle of being rendered (i.e. has state "Rendering"), we need the status as
    // "stopping" without performing any cleanup. This will tell the `createView` method that it should stop
    // rendering and clean up the state once the view has finished being created.
    if (renderInfo.status === 'Rendering') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        streamEventType === 'disposeViewRemote' && participantKey ? internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'Stopping', undefined) : internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'Stopping', renderInfo.renderer);
        return;
    }
    if (renderInfo.renderer) {
        _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);
        renderInfo.renderer.dispose();
        // Else the state must be in the "Rendered" state, so we can dispose the renderer and clean up the state.
        if (streamEventType === 'disposeViewRemote' && participantKey) {
            internalContext.setRemoteRenderInfo(callId, participantKey, streamId, renderInfo.stream, 'NotRendered', undefined);
        }
        else if (streamEventType === 'disposeViewLocal') {
            internalContext.setLocalRenderInfo(callId, renderInfo.stream, 'NotRendered', undefined);
            context.setLocalVideoStreamRendererView(callId, undefined);
        }
    }
    else {
        _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);
    }
}
function disposeViewUnparentedVideo(context, internalContext, stream) {
    const streamType = stream.mediaStreamType;
    const streamLogInfo = {
        streamType,
        streamEventType: 'disposeViewUnparented'
    };
    _logStreamEvent(EventNames.START_DISPOSE_STREAM, streamLogInfo);
    context.deleteDeviceManagerUnparentedView(stream);
    const renderInfo = internalContext.getUnparentedRenderInfo(stream);
    if (!renderInfo) {
        _logStreamEvent(EventNames.DISPOSE_INFO_NOT_FOUND, streamLogInfo);
        return;
    }
    if (renderInfo.status === 'Rendering') {
        _logStreamEvent(EventNames.STREAM_STOPPING, streamLogInfo);
        internalContext.setUnparentedRenderInfo(stream, renderInfo.stream, 'Stopping', undefined);
    }
    else {
        internalContext.deleteUnparentedRenderInfo(stream);
    }
    if (renderInfo.renderer) {
        _logStreamEvent(EventNames.DISPOSING_RENDERER, streamLogInfo);
        renderInfo.renderer.dispose();
    }
    else {
        _logStreamEvent(EventNames.RENDERER_NOT_FOUND, streamLogInfo);
    }
}
/**
 * @private
 */
function createView(context, internalContext, callId, participantId, stream, options) {
    const streamType = stream.mediaStreamType;
    if (callId) {
        return createViewVideo(context, internalContext, callId, stream, participantId, options);
    }
    else if (!('id' in stream) && !callId) {
        // Render LocalVideoStream that is not part of a Call
        // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).
        // We do not have a startLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.
        return context.withAsyncErrorTeedToState(() => __awaiter$u(this, void 0, void 0, function* () { return yield createViewUnparentedVideo(context, internalContext, stream, options); }), 'Call.startVideo')();
    }
    else {
        _logStreamEvent(EventNames.CREATE_STREAM_INVALID_PARAMS, {
            streamType
        });
        return Promise.resolve(undefined);
    }
}
/**
 * @private
 */
function disposeView(context, internalContext, callId, participantId, stream) {
    const streamType = stream.mediaStreamType;
    if (callId) {
        disposeViewVideo(context, internalContext, callId, stream, participantId);
    }
    else if (!('id' in stream) && !callId) {
        // Stop rendering LocalVideoStream that is not part of a Call
        // Because it is not part of the call we don't tee errors to state naturally (e.g. via a Call Client function such as startVideo).
        // We do not have a stopLocalPreviewVideo function, so as a workaround we ensure any errors are propagated here.
        context.withErrorTeedToState(() => disposeViewUnparentedVideo(context, internalContext, stream), 'Call.stopVideo')();
    }
    else {
        _logStreamEvent(EventNames.DISPOSE_STREAM_INVALID_PARAMS, {
            streamType
        });
        return;
    }
}
/**
 * @private
 * Only stops videos that are tied to a Call.
 */
function disposeAllViewsFromCall(context, internalContext, callId) {
    const callStreams = internalContext.getRemoteRenderInfoForCall(callId);
    if (callStreams) {
        for (const [participantKey, participantStreams] of callStreams.entries()) {
            for (const [_, remoteStreamAndRenderer] of participantStreams.entries()) {
                // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
                // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
                disposeView(context, internalContext, callId, participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(remoteStreamAndRenderer.stream));
            }
        }
    }
    const localStreamAndRenderer = internalContext.getLocalRenderInfo(callId);
    if (localStreamAndRenderer && localStreamAndRenderer.renderer) {
        // We don't want to accept SDK stream as parameter but we also don't cache the declarative stream so we have to
        // convert the SDK stream to declarative stream which is not pretty so this could use some further refactoring.
        disposeView(context, internalContext, callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(localStreamAndRenderer.stream));
    }
}
/**
 * @private
 */
function disposeAllViews(context, internalContext) {
    const callIds = internalContext.getCallIds();
    for (const callId of callIds) {
        disposeAllViewsFromCall(context, internalContext, callId);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Keeps track of the listeners assigned to a particular participant because when we get an event from SDK, it doesn't
 * tell us which participant it is for. If we keep track of this then we know which participant in the state that needs
 * an update and also which property of that participant. Also we can use this when unregistering to a participant.
 */
class ParticipantSubscriber$1 {
    constructor(callIdRef, participant, context, internalContext) {
        this.subscribe = () => {
            this._participant.on('stateChanged', this.stateChanged);
            this._participant.on('isMutedChanged', this.isMutedChanged);
            this._participant.on('displayNameChanged', this.displayNameChanged);
            this._participant.on('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.on('videoStreamsUpdated', this.videoStreamsUpdated);
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                    this.addRemoteVideoStreamSubscriber(stream);
                }
                this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, this._participant.videoStreams.map(convertSdkRemoteStreamToDeclarativeRemoteStream), []);
            }
        };
        this.unsubscribe = () => {
            this._participant.off('stateChanged', this.stateChanged);
            this._participant.off('isMutedChanged', this.isMutedChanged);
            this._participant.off('displayNameChanged', this.displayNameChanged);
            this._participant.off('isSpeakingChanged', this.isSpeakingChanged);
            this._participant.off('videoStreamsUpdated', this.videoStreamsUpdated);
            // If unsubscribing it means the participant left the call. If they have any rendering streams we should stop them
            // as it doesn't make sense to render for an ended participant.
            if (this._participant.videoStreams.length > 0) {
                for (const stream of this._participant.videoStreams) {
                    disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                    this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
                }
            }
        };
        this.addRemoteVideoStreamSubscriber = (remoteVideoStream) => {
            var _a;
            (_a = this._remoteVideoStreamSubscribers.get(remoteVideoStream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._remoteVideoStreamSubscribers.set(remoteVideoStream.id, new RemoteVideoStreamSubscriber(this._callIdRef, this._participantKey, remoteVideoStream, this._context));
        };
        this.stateChanged = () => {
            this._context.setParticipantState(this._callIdRef.callId, this._participantKey, this._participant.state);
        };
        this.isMutedChanged = () => {
            this._context.setParticipantIsMuted(this._callIdRef.callId, this._participantKey, this._participant.isMuted);
        };
        this.displayNameChanged = () => {
            this._context.setParticipantDisplayName(this._callIdRef.callId, this._participantKey, this._participant.displayName || '');
        };
        this.isSpeakingChanged = () => {
            this._context.setParticipantIsSpeaking(this._callIdRef.callId, this._participantKey, this._participant.isSpeaking);
        };
        this.videoStreamsUpdated = (event) => {
            var _a;
            for (const stream of event.removed) {
                (_a = this._remoteVideoStreamSubscribers.get(stream.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                disposeView(this._context, this._internalContext, this._callIdRef.callId, this._participantKey, convertSdkRemoteStreamToDeclarativeRemoteStream(stream));
                this._internalContext.deleteRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id);
            }
            for (const stream of event.added) {
                this._internalContext.setRemoteRenderInfo(this._callIdRef.callId, this._participantKey, stream.id, stream, 'NotRendered', undefined);
                this.addRemoteVideoStreamSubscriber(stream);
            }
            this._context.setRemoteVideoStreams(this._callIdRef.callId, this._participantKey, event.added.map(convertSdkRemoteStreamToDeclarativeRemoteStream), event.removed.map((stream) => stream.id));
        };
        this._callIdRef = callIdRef;
        this._participant = participant;
        this._context = context;
        this._internalContext = internalContext;
        this._participantKey = toFlatCommunicationIdentifier(this._participant.identifier);
        this._remoteVideoStreamSubscribers = new Map();
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class RecordingSubscriber {
    constructor(callIdRef, context, recording) {
        this.subscribe = () => {
            this._recording.on('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.unsubscribe = () => {
            this._recording.off('isRecordingActiveChanged', this.isAvailableChanged);
        };
        this.isAvailableChanged = () => {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._recording = recording;
        // If recording as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._recording.isRecordingActive) {
            this._context.setCallRecordingActive(this._callIdRef.callId, this._recording.isRecordingActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class TranscriptionSubscriber {
    constructor(callIdRef, context, transcription) {
        this.subscribe = () => {
            this._transcription.on('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.unsubscribe = () => {
            this._transcription.off('isTranscriptionActiveChanged', this.isTranscriptionActiveChanged);
        };
        this.isTranscriptionActiveChanged = () => {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._transcription = transcription;
        // If transcription as already started when we joined the call, make sure it is reflected in state as there may not
        // be an event for it.
        if (this._transcription.isTranscriptionActive) {
            this._context.setCallTranscriptionActive(this._callIdRef.callId, this._transcription.isTranscriptionActive);
        }
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
class UserFacingDiagnosticsSubscriber {
    constructor(callIdRef, context, diagnostics) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._callIdRef = callIdRef;
        this._context = context;
        this._diagnostics = diagnostics;
        this.setInitialDiagnostics();
        this.subscribe();
    }
    setInitialDiagnostics() {
        const network = this._diagnostics.network.getLatest();
        const media = this._diagnostics.media.getLatest();
        if (Object.entries(network).length === 0 && Object.entries(media).length === 0) {
            return;
        }
        this._context.modifyState(state => {
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            call.diagnostics = {
                network: {
                    latest: network
                },
                media: {
                    latest: media
                }
            };
        });
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const network = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.network.latest;
            if (network) {
                network[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
    mediaDiagnosticsChanged(args) {
        this._context.modifyState(state => {
            var _a;
            const call = state.calls[this._callIdRef.callId];
            if (call === undefined) {
                return;
            }
            const media = (_a = call.diagnostics) === null || _a === void 0 ? void 0 : _a.media.latest;
            if (media) {
                media[args.diagnostic] = latestFromEvent(args);
            }
        });
    }
}
const latestFromEvent = (args) => ({
    value: args.value,
    valueType: args.valueType
});

// Copyright (c) Microsoft Corporation.
/**
 * Keeps track of the listeners assigned to a particular call because when we get an event from SDK, it doesn't tell us
 * which call it is for. If we keep track of this then we know which call in the state that needs an update and also
 * which property of that call. Also we can use this when unregistering to a call.
 */
class CallSubscriber {
    constructor(call, context, internalContext) {
        this.subscribe = () => {
            this._call.on('stateChanged', this.stateChanged);
            this._call.on('idChanged', this.idChanged);
            this._call.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.on('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.on('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.on('isMutedChanged', this.isMuteChanged);
            this._call.feature(communicationCalling.Features.DominantSpeakers).on('dominantSpeakersChanged', this.dominantSpeakersChanged);
            // At time of writing only one LocalVideoStream is supported by SDK.
            if (this._call.localVideoStreams.length > 0) {
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
            }
            if (this._call.remoteParticipants.length > 0) {
                this._call.remoteParticipants.forEach((participant) => {
                    this.addParticipantListener(participant);
                });
                this._context.setCallRemoteParticipants(this._callIdRef.callId, this._call.remoteParticipants.map(convertSdkParticipantToDeclarativeParticipant), []);
            }
        };
        this.unsubscribe = () => {
            this._call.off('stateChanged', this.stateChanged);
            this._call.off('idChanged', this.idChanged);
            this._call.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged);
            this._call.off('remoteParticipantsUpdated', this.remoteParticipantsUpdated);
            this._call.off('localVideoStreamsUpdated', this.localVideoStreamsUpdated);
            this._call.off('isMutedChanged', this.isMuteChanged);
            this._participantSubscribers.forEach((participantSubscriber) => {
                participantSubscriber.unsubscribe();
            });
            this._participantSubscribers.clear();
            // If we are unsubscribing that means we no longer want to display any video for this call (callEnded or callAgent
            // disposed) and we should not be updating it any more. So if video is rendering we stop rendering.
            if (this._call.localVideoStreams && this._call.localVideoStreams[0]) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0]));
            }
            this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
            this._diagnosticsSubscriber.unsubscribe();
            this._recordingSubscriber.unsubscribe();
            this._transcriptionSubscriber.unsubscribe();
        };
        this.stateChanged = () => {
            this._context.setCallState(this._callIdRef.callId, this._call.state);
        };
        this.idChanged = () => {
            this._internalContext.setCallId(this._call.id, this._callIdRef.callId);
            this._context.setCallId(this._call.id, this._callIdRef.callId);
            this._callIdRef.callId = this._call.id;
        };
        this.isScreenSharingOnChanged = () => {
            this._context.setCallIsScreenSharingOn(this._callIdRef.callId, this._call.isScreenSharingOn);
        };
        this.isMuteChanged = () => {
            this._context.setCallIsMicrophoneMuted(this._callIdRef.callId, this._call.isMuted);
        };
        this.remoteParticipantsUpdated = (event) => {
            event.added.forEach((participant) => {
                this.addParticipantListener(participant);
            });
            event.removed.forEach((participant) => {
                this.removeParticipantListener(participant);
            });
            // Remove any added participants from remoteParticipantsEnded if they are there and add any removed participants to
            // remoteParticipantsEnded.
            this._context.setCallRemoteParticipantsEnded(this._callIdRef.callId, event.removed.map(convertSdkParticipantToDeclarativeParticipant), event.added.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
            // Add added participants to remoteParticipants and remove removed participants from remoteParticipants.
            this._context.setCallRemoteParticipants(this._callIdRef.callId, event.added.map(convertSdkParticipantToDeclarativeParticipant), event.removed.map((participant) => {
                return toFlatCommunicationIdentifier(participant.identifier);
            }));
        };
        this.localVideoStreamsUpdated = (event) => {
            // At time of writing only one LocalVideoStream is supported by SDK.
            if (event.added.length > 0) {
                const localVideoStreams = [convertSdkLocalStreamToDeclarativeLocalStream(this._call.localVideoStreams[0])];
                // IMPORTANT: The internalContext should be set before context. This is done to ensure that the internal context
                // has the required data when component re-renders due to external state changes.
                this._internalContext.setLocalRenderInfo(this._callIdRef.callId, this._call.localVideoStreams[0], 'NotRendered', undefined);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, [...localVideoStreams]);
            }
            if (event.removed.length > 0) {
                disposeView(this._context, this._internalContext, this._callIdRef.callId, undefined, convertSdkLocalStreamToDeclarativeLocalStream(event.removed[0]));
                this._internalContext.deleteLocalRenderInfo(this._callIdRef.callId);
                this._context.setCallLocalVideoStream(this._callIdRef.callId, []);
            }
        };
        this.dominantSpeakersChanged = () => {
            const dominantSpeakers = this._call.feature(communicationCalling.Features.DominantSpeakers).dominantSpeakers;
            this._context.setCallDominantSpeakers(this._callIdRef.callId, dominantSpeakers);
        };
        this._call = call;
        this._callIdRef = {
            callId: call.id
        };
        this._context = context;
        this._internalContext = internalContext;
        this._diagnosticsSubscriber = new UserFacingDiagnosticsSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.UserFacingDiagnostics));
        this._participantSubscribers = new Map();
        this._recordingSubscriber = new RecordingSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Recording));
        this._transcriptionSubscriber = new TranscriptionSubscriber(this._callIdRef, this._context, this._call.feature(communicationCalling.Features.Transcription));
        this.subscribe();
    }
    addParticipantListener(participant) {
        var _a;
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        (_a = this._participantSubscribers.get(participantKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._participantSubscribers.set(participantKey, new ParticipantSubscriber$1(this._callIdRef, participant, this._context, this._internalContext));
    }
    removeParticipantListener(participant) {
        const participantKey = toFlatCommunicationIdentifier(participant.identifier);
        const participantSubscriber = this._participantSubscribers.get(participantKey);
        if (participantSubscriber) {
            participantSubscriber.unsubscribe();
            this._participantSubscribers.delete(participantKey);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$t = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyIncomingCall {
    constructor(context) {
        this._context = context;
    }
    get(target, prop) {
        switch (prop) {
            case 'accept':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$t(this, void 0, void 0, function* () {
                            return yield target.accept(...args);
                        });
                    }, 'IncomingCall.accept');
                }
            case 'reject':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$t(this, void 0, void 0, function* () {
                            return yield target.reject(...args);
                        });
                    }, 'IncomingCall.reject');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Incoming Call by proxying IncomingCall using ProxyIncomingCall.
 * @param incomingCall - IncomingCall from SDK
 * @returns proxied IncomingCall
 */
const incomingCallDeclaratify = (incomingCall, context) => {
    const proxyIncomingCall = new ProxyIncomingCall(context);
    return new Proxy(incomingCall, proxyIncomingCall);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Keeps track of the listeners assigned to a particular incoming call because when we get an event from SDK, it doesn't
 * tell us which incoming call it is for. If we keep track of this then we know which incoming call in the state that
 * needs an update and also which property of that incoming call. Also we can use this when unregistering to a incoming
 * call.
 */
class IncomingCallSubscriber {
    constructor(incomingCall, 
    // setIncomingCallEnded callback is used so parent can clean up IncomingCallSubscriber.
    setIncomingCallEnded) {
        this.subscribe = () => {
            this._incomingCall.on('callEnded', this.callEnded);
        };
        this.unsubscribe = () => {
            this._incomingCall.off('callEnded', this.callEnded);
        };
        this.callEnded = (event) => {
            this._setIncomingCallEnded(this._incomingCall.id, event.callEndReason);
        };
        this._incomingCall = incomingCall;
        this._setIncomingCallEnded = setIncomingCallEnded;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$s = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgentCommon {
    constructor(context, internalContext) {
        // Unsubscribe is called when CallAgent is disposed. This should mean no more updating of existing call but we don't
        // remove any existing state.
        this.unregisterSubscriber = () => {
            for (const [_, callSubscriber] of this._callSubscribers.entries()) {
                callSubscriber.unsubscribe();
            }
            this._callSubscribers.clear();
            for (const [_, incomingCallSubscriber] of this._incomingCallSubscribers.entries()) {
                incomingCallSubscriber.unsubscribe();
            }
            this._incomingCallSubscribers.clear();
            this._declarativeIncomingCalls.clear();
            for (const [_, declarativeCall] of this._declarativeCalls.entries()) {
                declarativeCall.unsubscribe();
            }
            this._declarativeCalls.clear();
        };
        this.callsUpdated = (event) => {
            const addedStatefulCall = [];
            for (const call of event.added) {
                const statefulCall = this.addCall(call);
                addedStatefulCall.push(statefulCall);
            }
            const removedStatefulCall = [];
            for (const call of event.removed) {
                disposeAllViewsFromCall(this._context, this._internalContext, call.id);
                const callSubscriber = this._callSubscribers.get(call);
                if (callSubscriber) {
                    callSubscriber.unsubscribe();
                    this._callSubscribers.delete(call);
                }
                this._context.setCallEnded(call.id, call.callEndReason);
                const declarativeCall = this._declarativeCalls.get(call);
                if (declarativeCall) {
                    declarativeCall.unsubscribe();
                    removedStatefulCall.push(declarativeCall);
                    this._declarativeCalls.delete(call);
                }
                else {
                    removedStatefulCall.push(this.callDeclaratify(call, this._context));
                }
            }
            for (const externalCallsUpdatedListener of this._externalCallsUpdatedListeners) {
                externalCallsUpdatedListener({
                    added: addedStatefulCall,
                    removed: removedStatefulCall
                });
            }
        };
        this.setIncomingCallEnded = (incomingCallId, callEndReason) => {
            const incomingCallSubscriber = this._incomingCallSubscribers.get(incomingCallId);
            if (incomingCallSubscriber) {
                incomingCallSubscriber.unsubscribe();
                this._incomingCallSubscribers.delete(incomingCallId);
            }
            this._declarativeIncomingCalls.delete(incomingCallId);
            this._context.setIncomingCallEnded(incomingCallId, callEndReason);
        };
        this.incomingCall = ({ incomingCall }) => {
            // Make sure to not subscribe to the incoming call if we are already subscribed to it.
            if (!this._incomingCallSubscribers.has(incomingCall.id)) {
                this._incomingCallSubscribers.set(incomingCall.id, new IncomingCallSubscriber(incomingCall, this.setIncomingCallEnded));
            }
            this._declarativeIncomingCalls.set(incomingCall.id, incomingCallDeclaratify(incomingCall, this._context));
            this._context.setIncomingCall(convertSdkIncomingCallToDeclarativeIncomingCall(incomingCall));
        };
        this.addCall = (call) => {
            var _a;
            (_a = this._callSubscribers.get(call)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            // For API extentions we need to have the call in the state when we are subscribing as we may want to update the
            // state during the subscription process in the subscriber so we add the call to state before subscribing.
            this._context.setCall(convertSdkCallToDeclarativeCall(call));
            this._callSubscribers.set(call, new CallSubscriber(call, this._context, this._internalContext));
            return this.getOrCreateDeclarativeCall(call);
        };
        this.getOrCreateDeclarativeCall = (call) => {
            const declarativeCall = this._declarativeCalls.get(call);
            if (declarativeCall) {
                return declarativeCall;
            }
            const newDeclarativeCall = this.callDeclaratify(call, this._context);
            this._declarativeCalls.set(call, newDeclarativeCall);
            return newDeclarativeCall;
        };
        this._context = context;
        this._internalContext = internalContext;
        this._callSubscribers = new Map();
        this._incomingCallSubscribers = new Map();
        this._declarativeIncomingCalls = new Map();
        this._declarativeCalls = new Map();
        this._externalCallsUpdatedListeners = new Set();
    }
    // We can't directly override get function because it is proxied,
    // Add a getCommon function and call it in child class
    getCommon(target, prop) {
        switch (prop) {
            case 'startCall':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = this.startCall(target, args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.startCall');
                }
            case 'join':
                {
                    return this._context.withErrorTeedToState((...args) => {
                        const call = this.joinCall(target, args);
                        this.addCall(call);
                        return this.getOrCreateDeclarativeCall(call);
                    }, 'CallAgent.join');
                }
            case 'calls':
                {
                    return Array.from(this._declarativeCalls.values());
                }
            case 'on':
                {
                    return (...args) => {
                        const isCallsUpdated = args[0] === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.add(listener);
                        }
                        else {
                            this.agentSubscribe(target, args);
                        }
                    };
                }
            case 'off':
                {
                    return (...args) => {
                        const isCallsUpdated = args[0] === 'callsUpdated';
                        if (isCallsUpdated) {
                            const listener = args[1];
                            this._externalCallsUpdatedListeners.delete(listener);
                        }
                        else {
                            this.agentUnsubscribe(target, args);
                        }
                    };
                }
            case 'dispose':
                {
                    // Wrapping CallAgent.dispose in a callback type (): Promise<void> to accomodate the change of CallAgent.dispose
                    // in calling beta version 1.8.0-beta.1 from callback type (): Promise<void> to (): void
                    const callAgentDisposeAsyncCallbackWrapper = () => __awaiter$s(this, void 0, void 0, function* () {
                        yield target.dispose();
                        return Promise.resolve();
                    });
                    return () => {
                        return callAgentDisposeAsyncCallbackWrapper().then(() => {
                            this.unsubscribe();
                        });
                    };
                }
            /**
             * This attribute is a special case and doesn't exist on the CallAgent interface.
             * We need this to be able to return a declarative incoming call object using the call agent.
             * In a standard headless SDK usage, the right way to get an incoming call is to use the `incomingCall` event.
             * However, using the declarative layer, the ideal usage would be to:
             * 1. subscribe to the `onStateChange` event
             * 2. Get the incoming call from the new state and it's ID
             * 3. Use `callAgent.incomingCalls` and filter an incoming call ID to get a declarative incoming call object
             */
            case 'incomingCalls':
                {
                    return Array.from(this._declarativeIncomingCalls.values());
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * @private
 */
const clearCallRelatedState = (context, internalContext) => {
    // Make sure there are no existing call data if creating a new CallAgentDeclarative (if creating a new
    // CallAgentDeclarative after disposing of the hold one will mean context have old call state). TODO: should we stop
    // rendering when the previous callAgent is disposed?
    disposeAllViews(context, internalContext);
    context.clearCallRelatedState();
    internalContext.clearCallRelatedState();
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$r = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyCallCommon {
    constructor(context) {
        this._context = context;
    }
    unsubscribe() {
        /** No subscriptions yet. But there will be one for transfer feature soon. */
    }
    getContext() {
        return this._context;
    }
    get(target, prop) {
        switch (prop) {
            case 'mute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.mute(...args);
                        });
                    }, 'Call.mute');
                }
            case 'unmute':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.unmute(...args);
                        });
                    }, 'Call.unmute');
                }
            case 'startVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.startVideo(...args);
                        });
                    }, 'Call.startVideo');
                }
            case 'stopVideo':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.stopVideo(...args);
                        });
                    }, 'Call.stopVideo');
                }
            case 'startScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.startScreenSharing(...args);
                        });
                    }, 'Call.startScreenSharing');
                }
            case 'stopScreenSharing':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.stopScreenSharing(...args);
                        });
                    }, 'Call.stopScreenSharing');
                }
            case 'hold':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.hold(...args);
                        });
                    }, 'Call.hold');
                }
            case 'resume':
                {
                    return this._context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$r(this, void 0, void 0, function* () {
                            return yield target.resume(...args);
                        });
                    }, 'Call.resume');
                }
            case 'feature':
                {
                    // these are mini version of Proxy object - if it grows too big, a real Proxy object should be used.
                    return this._context.withErrorTeedToState((...args) => {
                        return target.feature(...args);
                    }, 'Call.feature');
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$q = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyCall extends ProxyCallCommon {
    get(target, prop) {
        switch (prop) {
            case 'addParticipant':
                {
                    return this.getContext().withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$q(this, void 0, void 0, function* () {
                            return yield target.addParticipant(...args);
                        });
                    }, 'Call.addParticipant');
                }
            default:
                return super.get(target, prop);
        }
    }
}
/**
 * Creates a declarative Call by proxying Call with ProxyCall.
 * This should only be used with CallAgentDeclarative as CallAgentDeclarative will add that
 * call to the context properly (need to have the Call in context to update it - CallAgentDeclarative will add Call to
 * context)
 *
 * @param call - Call from SDK
 * @param context - CallContext from StatefulCallClient
 */
const callDeclaratify = (call, context) => {
    const proxyCall = new ProxyCall(context);
    Object.defineProperty(call, 'unsubscribe', {
        configurable: false,
        value: () => proxyCall.unsubscribe()
    });
    return new Proxy(call, proxyCall);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const _isACSCall = (call) => {
    return true;
};
/**
 * @internal
 */
const _isACSCallAgent = (callAgent) => {
    return true;
};
/**
 * @internal
 */
const _isTeamsCall = (call) => {
    return false;
};
/**
 * @internal
 */
const _isTeamsCallAgent = (callAgent) => {
    return false;
};

// Copyright (c) Microsoft Corporation.
/**
 * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state
 * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will
 * unsubscribe from all state updates.
 */
class ProxyCallAgent extends ProxyCallAgentCommon {
    constructor(callAgent, context, internalContext) {
        super(context, internalContext);
        this.subscribe = () => {
            this._callAgent.on('callsUpdated', this.callsUpdated);
            this._callAgent.on('incomingCall', this.incomingCall);
            // There could be scenario that when ProxyCallAgent is created that the given CallAgent already has Calls. In this
            // case we need to make sure to subscribe to those already existing Calls.
            for (const call of this._callAgent.calls) {
                this.addCall(call);
            }
        };
        this.unsubscribe = () => {
            this._callAgent.off('callsUpdated', this.callsUpdated);
            this._callAgent.off('incomingCall', this.incomingCall);
            this.unregisterSubscriber();
        };
        this._callAgent = callAgent;
        this.subscribe();
    }
    callDeclaratify(call, context) {
        {
            return callDeclaratify(call, context);
        }
    }
    startCall(agent, args) {
        {
            return agent.startCall(...args);
        }
    }
    joinCall(agent, args) {
        {
            return agent.join(...args);
        }
    }
    agentSubscribe(agent, args) {
        {
            return agent.on(...args);
        }
    }
    agentUnsubscribe(agent, args) {
        {
            return agent.off(...args);
        }
    }
    get(target, prop) {
        return super.getCommon(target, prop);
    }
}
/**
 * Creates a declarative CallAgent by proxying CallAgent with ProxyCallAgent which will track state updates by updating
 * the given context.
 *
 * @param callAgent - CallAgent from SDK
 * @param context - CallContext from StatefulCallClient
 * @param internalContext- InternalCallContext from StatefulCallClient
 */
const callAgentDeclaratify = (callAgent, context, internalContext) => {
    clearCallRelatedState(context, internalContext);
    return new Proxy(callAgent, new ProxyCallAgent(callAgent, context, internalContext));
};

// Copyright (c) Microsoft Corporation.
/**
 * Contains internal data used between different Declarative components to share data.
 */
class InternalCallContext {
    constructor() {
        // <CallId, <ParticipantKey, <StreamId, RemoteRenderInfo>>
        this._remoteRenderInfos = new Map();
        // <CallId, LocalRenderInfo>.
        this._localRenderInfos = new Map();
        // Used for keeping track of rendered LocalVideoStreams that are not part of a Call.
        // The key is the stream ID. We assume each stream ID to only have one owning render info
        this._unparentedRenderInfos = new Map();
        this._callIdHistory = new CallIdHistory();
    }
    // Used for keeping track of video effects subscribers that are not part of a Call.
    // The key is the stream ID. We assume each stream ID
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        const remoteRenderInfos = this._remoteRenderInfos.get(oldCallId);
        if (remoteRenderInfos) {
            this._remoteRenderInfos.delete(oldCallId);
            this._remoteRenderInfos.set(newCallId, remoteRenderInfos);
        }
        const localRenderInfos = this._localRenderInfos.get(oldCallId);
        if (localRenderInfos) {
            this._localRenderInfos.delete(oldCallId);
            this._localRenderInfos.set(newCallId, localRenderInfos);
        }
    }
    getCallIds() {
        return this._remoteRenderInfos.keys();
    }
    getRemoteRenderInfoForCall(callId) {
        return this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    getRemoteRenderInfoForParticipant(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return undefined;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return undefined;
        }
        return participantRenderInfos.get(streamId);
    }
    setRemoteRenderInfo(callId, participantKey, streamId, stream, status, renderer) {
        let callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            callRenderInfos = new Map();
            this._remoteRenderInfos.set(this._callIdHistory.latestCallId(callId), callRenderInfos);
        }
        let participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            participantRenderInfos = new Map();
            callRenderInfos.set(participantKey, participantRenderInfos);
        }
        participantRenderInfos.set(streamId, {
            stream,
            status,
            renderer
        });
    }
    deleteRemoteRenderInfo(callId, participantKey, streamId) {
        const callRenderInfos = this._remoteRenderInfos.get(this._callIdHistory.latestCallId(callId));
        if (!callRenderInfos) {
            return;
        }
        const participantRenderInfos = callRenderInfos.get(participantKey);
        if (!participantRenderInfos) {
            return;
        }
        participantRenderInfos.delete(streamId);
    }
    setLocalRenderInfo(callId, stream, status, renderer) {
        this._localRenderInfos.set(this._callIdHistory.latestCallId(callId), {
            stream,
            status,
            renderer
        });
    }
    getLocalRenderInfo(callId) {
        return this._localRenderInfos.get(this._callIdHistory.latestCallId(callId));
    }
    deleteLocalRenderInfo(callId) {
        this._localRenderInfos.delete(this._callIdHistory.latestCallId(callId));
    }
    getUnparentedRenderInfo(localVideoStream) {
        return this._unparentedRenderInfos.get(localVideoStream.source.id);
    }
    getUnparentedRenderInfos() {
        return [...this._unparentedRenderInfos].map(([, renderInfo]) => renderInfo.stream);
    }
    setUnparentedRenderInfo(statefulStream, stream, status, renderer) {
        this._unparentedRenderInfos.set(statefulStream.source.id, {
            stream,
            status,
            renderer
        });
    }
    deleteUnparentedRenderInfo(localVideoStream) {
        this._unparentedRenderInfos.delete(localVideoStream.source.id);
    }
    subscribeToUnparentedViewVideoEffects(localVideoStream, callContext) { }
    // UnparentedRenderInfos are not cleared as they are not part of the Call state.
    clearCallRelatedState() {
        this._remoteRenderInfos.clear();
        this._localRenderInfos.clear();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$p = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
class ProxyVideoStreamRendererView {
    constructor(context, callId, participantId, _streamId) {
        this._context = context;
        this._callId = callId;
        this._participantId = participantId;
        this._streamId = _streamId;
    }
    get(target, prop) {
        switch (prop) {
            case 'updateScalingMode':
                {
                    return (...args) => __awaiter$p(this, void 0, void 0, function* () {
                        yield target.updateScalingMode(...args);
                        this._context.setRemoteVideoStreamViewScalingMode(this._callId, this._participantId, this._streamId, args[0]);
                    });
                }
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a declarative VideoStreamRendererView that is backed by a VideoStreamRendererView from the SDK.
 * Calling methods on this declarative object triggers state updates in the stateful client.
 */
const videoStreamRendererViewDeclaratify = (view, context, callId, participantId, streamId) => {
    const proxyVideoStreamRendererView = new ProxyVideoStreamRendererView(context, callId, participantId, streamId);
    return new Proxy(view, proxyVideoStreamRendererView);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$o = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * ProxyCallClient proxies CallClient {@link @azure/communication-calling#CallClient} and subscribes to all events that
 * affect state. ProxyCallClient keeps its own copy of the call state and when state is updated, ProxyCallClient emits
 * the event 'stateChanged'.
 */
class ProxyCallClient {
    constructor(context, internalContext) {
        this._context = context;
        this._internalContext = internalContext;
    }
    get(target, prop) {
        switch (prop) {
            case 'createCallAgent':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$o(this, void 0, void 0, function* () {
                        // createCallAgent will throw an exception if the previous callAgent was not disposed. If the previous
                        // callAgent was disposed then it would have unsubscribed to events so we can just create a new declarative
                        // callAgent if the createCallAgent succeeds.
                        const callAgent = yield target.createCallAgent(...args);
                        this._callAgent = callAgentDeclaratify(callAgent, this._context, this._internalContext);
                        this._context.setCallAgent({
                            displayName: this._callAgent.displayName
                        });
                        return this._callAgent;
                    }), 'CallClient.createCallAgent');
                }
            case 'createTeamsCallAgent':
                {
                    return Reflect.get(target, prop);
                }
            case 'getDeviceManager':
                {
                    return this._context.withAsyncErrorTeedToState(() => __awaiter$o(this, void 0, void 0, function* () {
                        // As of writing, the SDK always returns the same instance of DeviceManager so we keep a reference of
                        // DeviceManager and if it does not change we return the cached DeclarativeDeviceManager. If it does not we'll
                        // throw an error that indicate we need to fix this issue as our implementation has diverged from the SDK.
                        const deviceManager = yield target.getDeviceManager();
                        if (this._sdkDeviceManager) {
                            if (this._sdkDeviceManager === deviceManager) {
                                return this._deviceManager;
                            }
                            else {
                                throw new Error('Multiple DeviceManager not supported. This means a incompatible version of communication-calling is ' + 'used OR calling declarative was not properly updated to communication-calling version.');
                            }
                        }
                        else {
                            this._sdkDeviceManager = deviceManager;
                        }
                        this._deviceManager = deviceManagerDeclaratify(deviceManager, this._context, this._internalContext);
                        return this._deviceManager;
                    }), 'CallClient.getDeviceManager');
                }
            case 'feature':
            default:
                return Reflect.get(target, prop);
        }
    }
}
/**
 * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient
 * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access
 * to state in a declarative way.
 *
 * It is important to use the {@link @azure/communication-calling#DeviceManager} and
 * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are
 * obtained from the StatefulCallClient in order for their state changes to be proxied properly.
 *
 * @param args - {@link StatefulCallClientArgs}
 * @param options - {@link StatefulCallClientOptions}
 *
 * @public
 */
const createStatefulCallClient = (args, options) => {
    callingStatefulLogger.info(`Creating calling stateful client using library version: ${_getApplicationId()}`);
    return createStatefulCallClientWithDeps(new communicationCalling.CallClient(withTelemetryTag(options === null || options === void 0 ? void 0 : options.callClientOptions)), new CallContext$2(communicationCommon.getIdentifierKind(args.userId), options === null || options === void 0 ? void 0 : options.maxStateChangeListeners), new InternalCallContext());
};
/**
 * Package-internal version of createStatefulCallClient that allows dependency injection.
 *
 * This function should not be exported from the package.
 */
const createStatefulCallClientWithDeps = (callClient, context, internalContext) => {
    Object.defineProperty(callClient, 'getState', {
        configurable: false,
        value: () => context.getState()
    });
    Object.defineProperty(callClient, 'onStateChange', {
        configurable: false,
        value: (handler) => context.onStateChange(handler)
    });
    Object.defineProperty(callClient, 'offStateChange', {
        configurable: false,
        value: (handler) => context.offStateChange(handler)
    });
    Object.defineProperty(callClient, 'createView', {
        configurable: false,
        value: (callId, participantId, stream, options) => __awaiter$o(void 0, void 0, void 0, function* () {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            const result = yield createView(context, internalContext, callId, participantIdKind, stream, options);
            // We only need to declaratify the VideoStreamRendererView object for remote participants. Because the updateScalingMode only needs to be called on remote participant stream views.
            if ('id' in stream && callId && participantId && result) {
                const participantKey = toFlatCommunicationIdentifier(participantId);
                result.view = videoStreamRendererViewDeclaratify(result.view, context, callId, participantKey, stream.id);
            }
            return result;
        })
    });
    Object.defineProperty(callClient, 'disposeView', {
        configurable: false,
        value: (callId, participantId, stream) => {
            const participantIdKind = participantId ? communicationCommon.getIdentifierKind(participantId) : undefined;
            disposeView(context, internalContext, callId, participantIdKind, stream);
        }
    });
    return new Proxy(callClient, new ProxyCallClient(context, internalContext));
};
const withTelemetryTag = (options) => {
    var _a, _b;
    const tags = (_b = (_a = options === null || options === void 0 ? void 0 : options.diagnostics) === null || _a === void 0 ? void 0 : _a.tags) !== null && _b !== void 0 ? _b : [];
    tags.push(_getApplicationId());
    return Object.assign(Object.assign({}, options), { diagnostics: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.diagnostics), { tags }) });
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallAgentContext = React.createContext(undefined);
const CallAgentProviderBase = (props) => {
    const { callAgent } = props;
    const initialState = {
        callAgent
    };
    return React__default['default'].createElement(CallAgentContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#CallAgent}.
 *
 * Calling components from this package must be wrapped with a {@link CallAgentProvider}.
 *
 * @public
 */
const CallAgentProvider = (props) => React__default['default'].createElement(CallAgentProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#CallAgent} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallAgent = () => {
    var _a;
    const callAgent = (_a = React.useContext(CallAgentContext)) === null || _a === void 0 ? void 0 : _a.callAgent;
    if (callAgent && !_isACSCallAgent()) {
        throw new Error('TeamsCallAgent object was provided, try useTeamsCall() instead');
    }
    return callAgent;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallClientContext = React.createContext(undefined);
/**
 * @private
 */
const CallClientProviderBase = (props) => {
    const { callClient } = props;
    const [deviceManager, setDeviceManager] = React.useState(undefined);
    /**
     * Initialize the DeviceManager inside CallClientState
     */
    React.useEffect(() => {
        callClient.getDeviceManager().then(manager => {
            manager.getCameras();
            manager.getMicrophones();
            manager.getSpeakers();
            setDeviceManager(manager);
        }).catch(error => {
            throw new Error(error);
        });
    }, [callClient]);
    const initialState = {
        callClient,
        deviceManager
    };
    return React__default['default'].createElement(CallClientContext.Provider, { value: initialState }, props.children);
};
/**
 * A {@link React.Context} that stores a {@link StatefulCallClient}.
 *
 * Calling components from this package must be wrapped with a {@link CallClientProvider}.
 *
 * @public
 */
const CallClientProvider = (props) => React__default['default'].createElement(CallClientProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link StatefulCallClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useCallClient = () => {
    const context = React.useContext(CallClientContext);
    if (context === undefined) {
        throw new Error('CallClient Context is undefined');
    }
    return context.callClient;
};
/**
 * Hook to obtain {@link StatefulDeviceManager} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useDeviceManager = () => {
    var _a;
    return (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.deviceManager;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallContext$1 = React.createContext(undefined);
/**
 * @private
 */
const CallProviderBase = (props) => {
    const { children, call } = props;
    const initialState = {
        call
    };
    return React__default['default'].createElement(CallContext$1.Provider, { value: initialState }, children);
};
/**
 * A {@link React.Context} that stores a {@link @azure/communication-calling#Call}.
 *
 * Calling components from this package must be wrapped with a {@link CallProvider}.
 *
 * @public
 */
const CallProvider = (props) => React__default['default'].createElement(CallProviderBase, Object.assign({}, props));
/**
 * Hook to obtain {@link @azure/communication-calling#Call} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * you must have previously used the CallProvider with a Call object to use this hook
 *
 * @public
 */
const useCall = () => {
    var _a;
    const call = (_a = React.useContext(CallContext$1)) === null || _a === void 0 ? void 0 : _a.call;
    if (call && !_isACSCall()) {
        throw new Error('Incorrect call type: Must provide a Regular Call object.');
    }
    return call;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const typingIndicatorContainerStyle = react.mergeStyles({
    minHeight: '2.125rem',
    // flexFlow set to column-reverse to align the text to the bottom of the container
    flexFlow: 'column-reverse'
});
/**
 * @private
 */
const typingIndicatorStringStyle = react.mergeStyles({
    fontWeight: 400,
    width: '100%',
    alignSelf: 'center',
    wordBreak: 'break-word'
});

var participantItem$j={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed participant",participantStateRinging:"Calling...",participantStateHold:"On hold"};var typingIndicator$j={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$j={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var mentionPopover$j={mentionPopoverHeader:"Suggestions"};var messageStatusIndicator$j={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$j={label:"Leave",tooltipContent:"Leave call"};var cameraButton$j={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off",onSplitButtonPrimaryActionCamera:"Turn off camera",offSplitButtonPrimaryActionCamera:"Turn on camera",cameraPrimaryActionSplitButtonTitle:"Use camera",videoEffectsMenuItemTitle:"Effects"};var microphoneButton$j={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off",offSplitButtonMicrophonePrimaryAction:"Unmute microphone",onSplitButtonMicrophonePrimaryAction:"Mute microphone",microphonePrimaryActionSplitButtonTitle:"Use microphone"};var devicesButton$j={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$j={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied"};var screenShareButton$j={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var messageThread$j={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file",blockedWarningText:"This message was deleted due to organizational policy.",blockedWarningLinkText:"Details",fileCardGroupMessage:"The message has {fileCount} attachment"};var errorBar$j={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"There was an issue starting screen share.",stopScreenShareGeneric:"Failed to stop screen sharing",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneAccessDeniedSafari:"Unable to access microphone. Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAccessDeniedSafari:"Unable to access camera. Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link.",cameraFrozenForRemoteParticipants:"Users in the call are having issues seeing your video. Please check your devices and network.",unableToStartVideoEffect:"Unable to apply video effect."};var videoGallery$j={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed participant",fitRemoteParticipantToFrame:"Fit to frame",fillRemoteParticipantFrame:"Fill frame",pinParticipantForMe:"Pin for me",pinParticipantForMeLimitReached:"Pin (limit reached)",unpinParticipantForMe:"Unpin",pinParticipantMenuItemAriaLabel:"Pin {participantName}",unpinParticipantMenuItemAriaLabel:"Unpin {participantName}",pinnedParticipantAnnouncementAriaLabel:"Pinned {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Unpinned {participantName}"};var dialpad$j={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$j={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$j={participantStateRinging:"Calling...",participantStateHold:"On hold"};var CameraAndMicrophoneSitePermissionsRequest$j={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Allow camera and microphone access"};var CameraSitePermissionsRequest$j={primaryText:"Allow {appName} to use your camera",secondaryText:"This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Allow camera access"};var MicrophoneSitePermissionsRequest$j={primaryText:"Allow {appName} to use your microphone",secondaryText:"This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Allow microphone access"};var CameraAndMicrophoneSitePermissionsCheck$j={primaryText:"Checking for camera and microphone access",secondaryText:"Allow access if prompted. This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Checking for camera and microphone access. Allow access if prompted."};var CameraSitePermissionsCheck$j={primaryText:"Checking for camera access",secondaryText:"Allow access if prompted. This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Checking for camera access. Allow access if prompted."};var MicrophoneSitePermissionsCheck$j={primaryText:"Checking for microphone access",secondaryText:"Allow access if prompted. This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Checking for microphone access. Allow access if prompted."};var CameraAndMicrophoneSitePermissionsDenied$j={primaryText:"Unable to access camera and microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraAndMicrophoneSitePermissionsDeniedSafari$j={primaryText:"Unable to access camera and microphone",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDenied$j={primaryText:"Unable to access camera",secondaryText:"Click the lock icon in the address bar to grant camera permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDenied$j={primaryText:"Unable to access microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDeniedSafari$j={primaryText:"Unable to access camera",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDeniedSafari$j={primaryText:"Unable to access microphone",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var UnsupportedBrowser$j={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLinkText:"See compatibility requirements"};var UnsupportedBrowserVersion$j={primaryText:"Browser update needed",secondaryText:"To ensure the best call possible, please update your browser and then try joining the call again.",moreHelpLinkText:"See compatibility requirements",continueAnywayButtonText:"Start call without updating"};var UnsupportedOperatingSystem$j={primaryText:"Operating system not supported",secondaryText:"Please join this call using a device with a compatible operating system.",moreHelpLinkText:"See compatibility requirements"};var BrowserPermissionDenied$j={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$j={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$j={leftNavButtonAriaLabel:"previous page",rightNavButtonAriaLabel:"next page"};var en_US$1 = {participantItem:participantItem$j,typingIndicator:typingIndicator$j,sendBox:sendBox$j,mentionPopover:mentionPopover$j,messageStatusIndicator:messageStatusIndicator$j,endCallButton:endCallButton$j,cameraButton:cameraButton$j,microphoneButton:microphoneButton$j,devicesButton:devicesButton$j,participantsButton:participantsButton$j,screenShareButton:screenShareButton$j,messageThread:messageThread$j,errorBar:errorBar$j,videoGallery:videoGallery$j,dialpad:dialpad$j,holdButton:holdButton$j,videoTile:videoTile$j,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$j,CameraSitePermissionsRequest:CameraSitePermissionsRequest$j,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$j,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$j,CameraSitePermissionsCheck:CameraSitePermissionsCheck$j,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$j,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$j,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$j,CameraSitePermissionsDenied:CameraSitePermissionsDenied$j,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$j,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$j,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$j,UnsupportedBrowser:UnsupportedBrowser$j,UnsupportedBrowserVersion:UnsupportedBrowserVersion$j,UnsupportedOperatingSystem:UnsupportedOperatingSystem$j,BrowserPermissionDenied:BrowserPermissionDenied$j,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$j,VerticalGallery:VerticalGallery$j};

var participantItem$i={isMeText:"(you)",menuTitle:"More Options",removeButtonLabel:"Remove",sharingIconLabel:"Sharing",mutedIconLabel:"Muted",displayNamePlaceholder:"Unnamed participant",participantStateRinging:"Calling...",participantStateHold:"On hold"};var typingIndicator$i={singleUser:"{user} is typing ...",multipleUsers:"{users} are typing ...",multipleUsersAbbreviateOne:"{users} and 1 other are typing ...",multipleUsersAbbreviateMany:"{users} and {numOthers} others are typing ...",delimiter:", "};var sendBox$i={placeholderText:"Enter a message",textTooLong:"Your message length is over the maximum limit.",sendButtonAriaLabel:"Send message",fileUploadsPendingError:"Uploading... Please wait.",removeFile:"Remove file",uploading:"Uploading",uploadCompleted:"Upload completed"};var mentionPopover$i={mentionPopoverHeader:"Suggestions"};var messageStatusIndicator$i={deliveredAriaLabel:"Message sent",deliveredTooltipText:"Sent",seenAriaLabel:"Message seen by others",seenTooltipText:"Seen",readByTooltipText:"Read by {messageThreadReadCount} of {remoteParticipantsCount}",sendingAriaLabel:"Message sending",sendingTooltipText:"Sending",failedToSendAriaLabel:"Message failed to send",failedToSendTooltipText:"Failed to send"};var endCallButton$i={label:"Leave",tooltipContent:"Leave call"};var cameraButton$i={onLabel:"Turn off",offLabel:"Turn on",tooltipDisabledContent:"Camera is disabled",tooltipOnContent:"Turn off camera",tooltipOffContent:"Turn on camera",tooltipVideoLoadingContent:"Video is loading",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",cameraButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Turn off camera and camera options",offSplitButtonAriaLabel:"Turn on camera and camera options",cameraActionTurnedOnAnnouncement:"Your camera has been turned on",cameraActionTurnedOffAnnouncement:"Your camera has been turned off",onSplitButtonPrimaryActionCamera:"Turn off camera",offSplitButtonPrimaryActionCamera:"Turn on camera",cameraPrimaryActionSplitButtonTitle:"Use camera",videoEffectsMenuItemTitle:"Effects"};var microphoneButton$i={onLabel:"Mute",offLabel:"Unmute",tooltipDisabledContent:"Microphone is disabled",tooltipOnContent:"Mute microphone",tooltipOffContent:"Unmute microphone",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker",microphoneButtonSplitRoleDescription:"Split button",onSplitButtonAriaLabel:"Mute microphone and audio options",offSplitButtonAriaLabel:"Unmute microphone and audio options",microphoneActionTurnedOnAnnouncement:"Your microphone has been turned on",microphoneActionTurnedOffAnnouncement:"Your microphone has been turned off",offSplitButtonMicrophonePrimaryAction:"Unmute microphone",onSplitButtonMicrophonePrimaryAction:"Mute microphone",microphonePrimaryActionSplitButtonTitle:"Use microphone"};var devicesButton$i={label:"Devices",tooltipContent:"Manage devices",cameraMenuTitle:"Camera",cameraMenuTooltip:"Choose camera",audioDeviceMenuTitle:"Audio Device",audioDeviceMenuTooltip:"Choose audio device",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choose microphone",speakerMenuTitle:"Speaker",speakerMenuTooltip:"Choose speaker"};var participantsButton$i={label:"People",tooltipContent:"Show participants",menuHeader:"In this call",participantsListButtonLabel:"{numParticipants} people",muteAllButtonLabel:"Mute all",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied"};var screenShareButton$i={onLabel:"Stop presenting",offLabel:"Present",tooltipDisabledContent:"Presenting is disabled",tooltipOnContent:"Presenting your screen",tooltipOffContent:"Present your screen"};var messageThread$i={yesterday:"Yesterday",sunday:"Sunday",monday:"Monday",tuesday:"Tuesday",wednesday:"Wednesday",thursday:"Thursday",friday:"Friday",saturday:"Saturday",participantJoined:"joined the chat.",participantLeft:"left the chat.",editMessage:"Edit",removeMessage:"Delete",resendMessage:"Try sending again",failToSendTag:"Failed to send",editedTag:"Edited",liveAuthorIntro:"{author} says",messageContentAriaText:"{author} said {message}",messageContentMineAriaText:"You said {message}",editBoxTextLimit:"Your message is over the limit of {limitNumber} characters",editBoxPlaceholderText:"Edit your message",newMessagesIndicator:"New messages",noDisplayNameSub:"No name",editBoxCancelButton:"Cancel",editBoxSubmitButton:"Submit",messageReadCount:"Read by {messageReadByCount} of {remoteParticipantsCount}",actionMenuMoreOptions:"More Options",downloadFile:"Download file",blockedWarningText:"This message was deleted due to organisational policy.",blockedWarningLinkText:"Details",fileCardGroupMessage:"The message has {fileCount} attachment"};var errorBar$i={unableToReachChatService:"You are offline",accessDenied:"Unable to access chat services - please check the user credentials provided",userNotInChatThread:"You are no longer in this chat thread",sendMessageNotInChatThread:"Failed to send message because you are no longer in this chat thread",sendMessageGeneric:"Failed to send message",callingNetworkFailure:"Troubling connecting call - you seem to be offline",startVideoGeneric:"Failed to start video",stopVideoGeneric:"Failed to stop video",muteGeneric:"Failed to mute microphone",unmuteGeneric:"Failed to unmute microphone",speakingWhileMuted:"Your microphone is muted",startScreenShareGeneric:"Failed to start screen sharing",stopScreenShareGeneric:"There was an issue starting screen share.",callNetworkQualityLow:"Network quality is low.",callNoSpeakerFound:"No speakers or headphones found. Connect an audio device to hear the call.",callNoMicrophoneFound:"No microphones found. Connect an audio input device.",callMicrophoneAccessDenied:"Unable to access microphone. Click the lock in the address bar to grant permission to this webpage.",callMicrophoneAccessDeniedSafari:"Unable to access microphone. Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",callMicrophoneMutedBySystem:"You are muted by your system.",callMicrophoneUnmutedBySystem:"Your microphone recovered and you were unmuted by your system.",callMacOsMicrophoneAccessDenied:"Unable to access microphone. Grant microphone permission in your macOS privacy settings.",callLocalVideoFreeze:"Network bandwidth is poor. Your video may appear paused for others on the call.",callCameraAccessDenied:"Unable to access camera. Click the lock in the address bar to grant permission to this webpage.",callCameraAccessDeniedSafari:"Unable to access camera. Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",callCameraAlreadyInUse:"Unable to access camera. It may already be in use by another application.",callVideoStoppedBySystem:"Your video has been stopped by your system.",callVideoRecoveredBySystem:"Your video has resumed.",callMacOsCameraAccessDenied:"MacOS is blocking access to your camera. Update your privacy settings to allow this browser to access your camera.",callMacOsScreenShareAccessDenied:"MacOS is blocking screen sharing. Update your privacy settings to allow this browser to record your screen.",dismissButtonAriaLabel:"Close",failedToJoinCallGeneric:"Failed to join call.",failedToJoinCallInvalidMeetingLink:"Unable to join Meeting. Invalid Link.",cameraFrozenForRemoteParticipants:"Users in the call are having issues seeing your video. Please check your devices and network.",unableToStartVideoEffect:"Unable to apply video effect."};var videoGallery$i={screenIsBeingSharedMessage:"You are sharing your screen",screenShareLoadingMessage:"Loading {participant}'s screen",localVideoLabel:"You",localVideoCameraSwitcherLabel:"Switch camera",localVideoMovementLabel:"Movable Local Video Tile",localVideoSelectedDescription:"{cameraName} selected",displayNamePlaceholder:"Unnamed participant",fitRemoteParticipantToFrame:"Fit to frame",fillRemoteParticipantFrame:"Fill frame",pinParticipantForMe:"Pin for me",pinParticipantForMeLimitReached:"Pin (limit reached)",unpinParticipantForMe:"Unpin",pinParticipantMenuItemAriaLabel:"Pin {participantName}",unpinParticipantMenuItemAriaLabel:"Unpin {participantName}",pinnedParticipantAnnouncementAriaLabel:"Pinned {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Unpinned {participantName}"};var dialpad$i={placeholderText:"Enter phone number",deleteButtonAriaLabel:"Delete"};var holdButton$i={onLabel:"Resume",offLabel:"Hold",tooltipOnContent:"Resume call",tooltipOffContent:"Hold call"};var videoTile$i={participantStateRinging:"Calling...",participantStateHold:"On hold"};var CameraAndMicrophoneSitePermissionsRequest$i={primaryText:"Allow {appName} to use your camera and microphone",secondaryText:"This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Allow camera and microphone access"};var CameraSitePermissionsRequest$i={primaryText:"Allow {appName} to use your camera",secondaryText:"This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Allow camera access"};var MicrophoneSitePermissionsRequest$i={primaryText:"Allow {appName} to use your microphone",secondaryText:"This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Allow microphone access"};var CameraAndMicrophoneSitePermissionsCheck$i={primaryText:"Checking for camera and microphone access",secondaryText:"Allow access if prompted. This is so participants can see and hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera and microphone",ariaLabel:"Checking for camera and microphone access. Allow access if prompted."};var CameraSitePermissionsCheck$i={primaryText:"Checking for camera access",secondaryText:"Allow access if prompted. This is so participants can see you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without camera",ariaLabel:"Checking for camera access. Allow access if prompted."};var MicrophoneSitePermissionsCheck$i={primaryText:"Checking for microphone access",secondaryText:"Allow access if prompted. This is so participants can hear you.",linkText:"Need help? Get troubleshooting help",primaryButtonText:"Continue without microphone",ariaLabel:"Checking for microphone access. Allow access if prompted."};var CameraAndMicrophoneSitePermissionsDenied$i={primaryText:"Unable to access camera and microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraAndMicrophoneSitePermissionsDeniedSafari$i={primaryText:"Unable to access camera and microphone",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera and microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDenied$i={primaryText:"Unable to access camera",secondaryText:"Click the lock icon in the address bar to grant camera permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDenied$i={primaryText:"Unable to access microphone",secondaryText:"Click the lock icon in the address bar to grant microphone permissions to this webpage. A page refresh may be required.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var CameraSitePermissionsDeniedSafari$i={primaryText:"Unable to access camera",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without camera",linkText:"Need help? Get troubleshooting help"};var MicrophoneSitePermissionsDeniedSafari$i={primaryText:"Unable to access microphone",secondaryText:"Refresh the page to allow permissions, or check this browser’s settings and verify permissions are enabled for this website.",primaryButtonText:"Continue without microphone",linkText:"Need help? Get troubleshooting help"};var UnsupportedBrowser$i={primaryText:"Browser not supported",secondaryText:"Please join this call using a compatible browser.",moreHelpLinkText:"See compatibility requirements"};var UnsupportedBrowserVersion$i={primaryText:"Browser update needed",secondaryText:"To ensure the best call possible, please update your browser and then try joining the call again.",moreHelpLinkText:"See compatibility requirements",continueAnywayButtonText:"Start call without updating"};var UnsupportedOperatingSystem$i={primaryText:"Operating system not supported",secondaryText:"Please join this call using a device with a compatible operating system.",moreHelpLinkText:"See compatibility requirements"};var BrowserPermissionDenied$i={primaryText:"Can't use your camera or microphone",secondaryText:"Your browser might not have access to your camera or microphone. To fix this, open System Preferences.",primaryButtonText:"Try again",linkText:"Need help? Get troubleshooting help"};var BrowserPermissionDeniedIOS$i={primaryText:"Allow microphone access to continue",secondaryText:"So other participants can hear you.",primaryButtonText:"Try again",imageAltText:"Microphone and camera device permission location for iOS",linkText:"Need help? Get troubleshooting help",step1Text:"Go to the Settings app",step2Text:"Scroll down to settings for this browser",step3Text:"Turn on Microphone (Camera optional)",step4Text:"Try joining the call again",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$i={leftNavButtonAriaLabel:"previous page",rightNavButtonAriaLabel:"next page"};var en_GB$1 = {participantItem:participantItem$i,typingIndicator:typingIndicator$i,sendBox:sendBox$i,mentionPopover:mentionPopover$i,messageStatusIndicator:messageStatusIndicator$i,endCallButton:endCallButton$i,cameraButton:cameraButton$i,microphoneButton:microphoneButton$i,devicesButton:devicesButton$i,participantsButton:participantsButton$i,screenShareButton:screenShareButton$i,messageThread:messageThread$i,errorBar:errorBar$i,videoGallery:videoGallery$i,dialpad:dialpad$i,holdButton:holdButton$i,videoTile:videoTile$i,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$i,CameraSitePermissionsRequest:CameraSitePermissionsRequest$i,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$i,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$i,CameraSitePermissionsCheck:CameraSitePermissionsCheck$i,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$i,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$i,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$i,CameraSitePermissionsDenied:CameraSitePermissionsDenied$i,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$i,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$i,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$i,UnsupportedBrowser:UnsupportedBrowser$i,UnsupportedBrowserVersion:UnsupportedBrowserVersion$i,UnsupportedOperatingSystem:UnsupportedOperatingSystem$i,BrowserPermissionDenied:BrowserPermissionDenied$i,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$i,VerticalGallery:VerticalGallery$i};

var participantItem$h={isMeText:"(أنت)",menuTitle:"المزيد من الخيارات",removeButtonLabel:"إزالة",sharingIconLabel:"جارٍ المشاركة",mutedIconLabel:"تم كتم الصوت",displayNamePlaceholder:"مشارك غير مسمى",participantStateRinging:"يتم الآن الاتصال...",participantStateHold:"قيد الانتظار"};var typingIndicator$h={singleUser:"{user} يكتب",multipleUsers:"يكتب {users} الآن...",multipleUsersAbbreviateOne:"جارٍ الكتابة بواسطة {users} وشخص آخر",multipleUsersAbbreviateMany:"{users} وآخرون {numOthers} يكتبون ...",delimiter:"و "};var sendBox$h={placeholderText:"أدخل رسالة",textTooLong:"تجاوز طول الرسالة الحد الأقصى.",sendButtonAriaLabel:"إرسال رسالة",fileUploadsPendingError:"جارِ التحميل... يرجى الانتظار.",removeFile:"إزالة الملف",uploading:"جارٍ التحميل",uploadCompleted:"اكتمل التحميل"};var mentionPopover$h={mentionPopoverHeader:"الاقتراحات"};var messageStatusIndicator$h={deliveredAriaLabel:"تم إرسال الرسالة",deliveredTooltipText:"تم الإرسال",seenAriaLabel:"تمت مشاهدة الرسالة من قِبل الآخرين.",seenTooltipText:"تمت المشاهدة",readByTooltipText:"تمت القراءة بواسطة {messageThreadReadCount} من {remoteParticipantsCount}",sendingAriaLabel:"إرسال الرسالة",sendingTooltipText:"جاري الإرسال",failedToSendAriaLabel:"فشل إرسال الرسالة",failedToSendTooltipText:"فشل الإرسال"};var endCallButton$h={label:"مغادرة",tooltipContent:"مغادرة المكالمة"};var cameraButton$h={onLabel:"إيقاف تشغيل",offLabel:"تمكين",tooltipDisabledContent:"الكاميرا مُعطلة",tooltipOnContent:"إيقاف تشغيل الكاميرا",tooltipOffContent:"تشغيل الكاميرا",tooltipVideoLoadingContent:"جار تحميل الفيديو",cameraMenuTitle:"الكاميرا",cameraMenuTooltip:"اختيار الكاميرا",cameraButtonSplitRoleDescription:"زر الانقسام",onSplitButtonAriaLabel:"خيارات إيقاف تشغيل الكاميرا",offSplitButtonAriaLabel:"خيارات تشغيل الكاميرا",cameraActionTurnedOnAnnouncement:"تم تشغيل كاميراتك",cameraActionTurnedOffAnnouncement:"تم إيقاف تشغيل كاميراتك",onSplitButtonPrimaryActionCamera:"إيقاف تشغيل الكاميرا",offSplitButtonPrimaryActionCamera:"تشغيل الكاميرا",cameraPrimaryActionSplitButtonTitle:"استخدام الكاميرا",videoEffectsMenuItemTitle:"التأثيرات"};var microphoneButton$h={onLabel:"كتم الصوت",offLabel:"إلغاء كتم الصوت",tooltipDisabledContent:"تم تعطيل الميكروفون",tooltipOnContent:"كتم صوت الميكروفون",tooltipOffContent:"إلغاء كتم صوت الميكروفون",microphoneMenuTitle:"الميكروفون",microphoneMenuTooltip:"اختيار الميكروفون",speakerMenuTitle:"مكبر الصوت",speakerMenuTooltip:"اختيار مكبر صوت",microphoneButtonSplitRoleDescription:"زر الانقسام",onSplitButtonAriaLabel:"كتم صوت الميكروفون وخيارات الصوت",offSplitButtonAriaLabel:"إلغاء كتم صوت الميكروفون وخيارات الصوت",microphoneActionTurnedOnAnnouncement:"تم تشغيل الميكروفون",microphoneActionTurnedOffAnnouncement:"تم إيقاف الميكروفون",offSplitButtonMicrophonePrimaryAction:"إلغاء كتم صوت الميكروفون",onSplitButtonMicrophonePrimaryAction:"كتم صوت الميكروفون",microphonePrimaryActionSplitButtonTitle:"استخدام الميكروفون"};var devicesButton$h={label:"الأجهزة",tooltipContent:"إدارة الأجهزة",cameraMenuTitle:"الكاميرا",cameraMenuTooltip:"اختيار الكاميرا",audioDeviceMenuTitle:"جهاز صوت",audioDeviceMenuTooltip:"إلغاء كتم صوت الجهاز",microphoneMenuTitle:"الميكروفون",microphoneMenuTooltip:"اختيار الميكروفون",speakerMenuTitle:"مكبر الصوت",speakerMenuTooltip:"اختيار مكبر صوت"};var participantsButton$h={label:"الأشخاص",tooltipContent:"إظهار المشاركين",menuHeader:"في هذه المكالمة",participantsListButtonLabel:"{numParticipants} من الأشخاص",muteAllButtonLabel:"كتم صوت الجميع",copyInviteLinkButtonLabel:"نسخ ارتباط دعوة",copyInviteLinkActionedAriaLabel:"تم نسخ ارتباط الدعوة"};var screenShareButton$h={onLabel:"إيقاف التقديم",offLabel:"تقديم",tooltipDisabledContent:"تم تعطيل التقديم",tooltipOnContent:"تقديم العرض على شاشتك.",tooltipOffContent:"عرض الشاشة"};var messageThread$h={yesterday:"أمس",sunday:"الأحد",monday:"الاثنين",tuesday:"الثلاثاء",wednesday:"الأربعاء",thursday:"الخميس",friday:"الجمعة",saturday:"السبت",participantJoined:"انضم إلى المحادثة.",participantLeft:"قام بمغادرة الدردشة.",editMessage:"تحرير",removeMessage:"حذف",resendMessage:"محاولة الإرسال مرة أخرى",failToSendTag:"فشل الإرسال",editedTag:"تم التحرير",liveAuthorIntro:"قال {author}",messageContentAriaText:"{author} قال {message}",messageContentMineAriaText:"لقد قلت {message}",editBoxTextLimit:"تجاوزت رسالتك الحد الأقصى لعدد الأحرف {limitNumber}",editBoxPlaceholderText:"تحرير رسالتك",newMessagesIndicator:"رسائل جديدة",noDisplayNameSub:"لا يوجد اسم",editBoxCancelButton:"إلغاء الأمر",editBoxSubmitButton:"إرسال",messageReadCount:"تمت القراءة بواسطة {messageReadByCount} من {remoteParticipantsCount}",actionMenuMoreOptions:"المزيد من الخيارات",downloadFile:"تنزيل ملف",blockedWarningText:"تم حذف هذه الرسالة بسبب نهج تنظيمي.",blockedWarningLinkText:"تفاصيل",fileCardGroupMessage:"تحتوي الرسالة على مرفق {fileCount}"};var errorBar$h={unableToReachChatService:"أنت غير متصل",accessDenied:"يتعذر الوصول إلى خدمات الدردشة - الرجاء التحقق من بيانات اعتماد المستخدم المقدمة",userNotInChatThread:"لم تعد مضمناً في هذا ترابط الدردشة هذا",sendMessageNotInChatThread:"فشل إرسال الرسالة لأنك لم تعد في مؤشر ترابط الدردشة هذا",sendMessageGeneric:"فشل إرسال الرسالة",callingNetworkFailure:"مكالمة مزعجة - يبدو أنك غير متصل",startVideoGeneric:"فشل بدء الفيديو",stopVideoGeneric:"فشل إيقاف الفيديو",muteGeneric:"فشل كتم صوت الميكروفون",unmuteGeneric:"فشل إلغاء كتم صوت الميكروفون",speakingWhileMuted:"تم كتم صوت الميكروفون",startScreenShareGeneric:"حدثت مشكلة أثناء بدء مشاركة الشاشة.",stopScreenShareGeneric:"فشل إيقاف مشاركة الشاشة",callNetworkQualityLow:"جودة الشبكة مقبولة.",callNoSpeakerFound:"لم يتم العثور على سماعات أو سماعات رأس. قم بتوصيل جهاز صوت لسماع المكالمة.",callNoMicrophoneFound:"لم يتم العثور على ميكروفونات. قم بتوصيل جهاز إدخال صوت.",callMicrophoneAccessDenied:"يتعذر الوصول إلى الميكروفون. انقر فوق التأمين في شريط العناوين لمنح الإذن لصفحة ويب هذه.",callMicrophoneAccessDeniedSafari:"يتعذر الوصول إلى الميكروفون. قم بتحديث الصفحة للسماح بالأذونات، أو تحقق من إعدادات هذا المستعرض وتحقق من تمكين الأذونات لموقع الويب هذا.",callMicrophoneMutedBySystem:"تم كتم صوتك بواسطة النظام.",callMicrophoneUnmutedBySystem:"تم استرداد الميكروفون وتم إلغاء كتم صوتك من قبل النظام.",callMacOsMicrophoneAccessDenied:"يتعذر الوصول إلى الميكروفون. امنح الميكروفون إذنا في إعدادات خصوصية macOS.",callLocalVideoFreeze:"النطاق الترددي للشبكة ضعيف. قد يظهر الفيديو متوقفا مؤقتا للآخرين في المكالمة.",callCameraAccessDenied:"يتعذر الوصول إلى الكاميرا. انقر فوق التأمين في شريط العناوين لمنح الإذن لصفحة ويب هذه.",callCameraAccessDeniedSafari:"يتعذر الوصول إلى الكاميرا. قم بتحديث الصفحة للسماح بالأذونات، أو تحقق من إعدادات هذا المستعرض وتحقق من تمكين الأذونات لموقع الويب هذا.",callCameraAlreadyInUse:"يتعذر الوصول إلى الكاميرا. قد يكون قيد الاستخدام بالفعل بواسطة تطبيق آخر.",callVideoStoppedBySystem:"تم إيقاف الفيديو الخاص بك من قبل النظام.",callVideoRecoveredBySystem:"تم استئناف الفيديو الخاص بك.",callMacOsCameraAccessDenied:"يقوم MacOS بحظر الوصول إلى الكاميرا الخاصة بك. قم بتحديث إعدادات الخصوصية للسماح لهذا المستعرض بالوصول إلى الكاميرا.",callMacOsScreenShareAccessDenied:"يقوم MacOS بحظر مشاركة الشاشة. قم بتحديث إعدادات الخصوصية للسماح لهذا المستعرض بتسجيل الشاشة.",dismissButtonAriaLabel:"إغلاق",failedToJoinCallGeneric:"فشل في الانضمام إلى المكالمة.",failedToJoinCallInvalidMeetingLink:"تعذر الانضمام إلى الاجتماع. ارتباط غير صالح.",cameraFrozenForRemoteParticipants:"يواجه المستخدمون في المكالمة مشكلات في رؤية الفيديو الخاص بك. الرجاء التحقق من أجهزتك وشبكتك.",unableToStartVideoEffect:"يتعذر تطبيق تأثير الفيديو."};var videoGallery$h={screenIsBeingSharedMessage:"أنت تشارك شاشتك",screenShareLoadingMessage:"يتم الآن تحميل شاشة {participant}",localVideoLabel:"أنت",localVideoCameraSwitcherLabel:"تبديل الكاميرا",localVideoMovementLabel:"لوحة فيديو محلية قابلة للنقل",localVideoSelectedDescription:"تم تحديد {cameraName}",displayNamePlaceholder:"مشارك غير مسمى",fitRemoteParticipantToFrame:"الملاءمة داخل إطار",fillRemoteParticipantFrame:"تعبئة الإطار",pinParticipantForMe:"تثبيت نيابة عني",pinParticipantForMeLimitReached:"تثبيت (تم بلوغ الحد الأقصى)",unpinParticipantForMe:"إلغاء التثبيت",pinParticipantMenuItemAriaLabel:"تثبيت {participantName}",unpinParticipantMenuItemAriaLabel:"إزالة تثبيت {participantName}",pinnedParticipantAnnouncementAriaLabel:"تم تثبيت {participantName}",unpinnedParticipantAnnouncementAriaLabel:"تم إلغاء تثبيت {participantName}"};var dialpad$h={placeholderText:"أدخل رقم الهاتف",deleteButtonAriaLabel:"حذف"};var holdButton$h={onLabel:"استئناف",offLabel:"انتظار",tooltipOnContent:"استئناف المكالمة",tooltipOffContent:"تعليق المكالمة"};var videoTile$h={participantStateRinging:"يتم الآن الاتصال...",participantStateHold:"قيد الانتظار"};var CameraAndMicrophoneSitePermissionsRequest$h={primaryText:"السماح {appName} باستخدام الكاميرا والميكروفون لديك",secondaryText:"هذا حتى يتمكن المشاركون من مشاهدتك والاستماع إليك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة بدون الكاميرا والميكروفون",ariaLabel:"السماح بالوصول إلى الكاميرا والميكروفون"};var CameraSitePermissionsRequest$h={primaryText:"السماح {appName} باستخدام الكاميرا",secondaryText:"هذا حتى يتمكن المشاركون من مشاهدتك والاستماع إليك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة دون كاميرا",ariaLabel:"السماح بالوصول إلى الكاميرا"};var MicrophoneSitePermissionsRequest$h={primaryText:"السماح {appName} باستخدام الميكروفون",secondaryText:"هذا حتى يتمكن المشاركون من الاستماع إليك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة دون ميكروفون",ariaLabel:"السماح بالوصول إلى الميكروفون"};var CameraAndMicrophoneSitePermissionsCheck$h={primaryText:"التحقق من الوصول إلى الكاميرا والميكروفون",secondaryText:"السماح بالوصول إذا طُلب منك ذلك. هذا حتى يتمكن المشاركون من رؤيتك والاستماع إليك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة بدون الكاميرا والميكروفون",ariaLabel:"التحقق من الوصول إلى الكاميرا والميكروفون. السماح بالوصول إذا طُلب منك ذلك."};var CameraSitePermissionsCheck$h={primaryText:"التحقق من الوصول إلى الكاميرا",secondaryText:"السماح بالوصول إذا طُلب منك ذلك. هذا حتى يتمكن المشاركون من رؤيتك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة بدون كاميرا",ariaLabel:"التحقق من الوصول إلى الكاميرا. السماح بالوصول إذا طُلب منك ذلك."};var MicrophoneSitePermissionsCheck$h={primaryText:"التحقق من الوصول إلى الميكروفون",secondaryText:"السماح بالوصول إذا طُلب منك ذلك. هذا حتى يتمكن المشاركون من الاستماع إليك.",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",primaryButtonText:"المتابعة بدون ميكروفون",ariaLabel:"التحقق من الوصول إلى الميكروفون. السماح بالوصول إذا طُلب منك ذلك."};var CameraAndMicrophoneSitePermissionsDenied$h={primaryText:"يتعذر الوصول إلى الكاميرا والميكروفون",secondaryText:"انقر فوق أيقونة التأمين في شريط العناوين لمنح أذونات الميكروفون لصفحة الويب هذه. قد يكون تحديث الصفحة مطلوبا.",primaryButtonText:"المتابعة دون الكاميرا والميكروفون",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var CameraAndMicrophoneSitePermissionsDeniedSafari$h={primaryText:"يتعذر الوصول إلى الكاميرا والميكروفون",secondaryText:"قم بتحديث الصفحة للسماح بالأذونات، أو تحقق من إعدادات هذا المستعرض وتحقق من تمكين الأذونات لموقع الويب هذا.",primaryButtonText:"المتابعة دون الكاميرا والميكروفون",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var CameraSitePermissionsDenied$h={primaryText:"تعذر الوصول إلى الكاميرا",secondaryText:"انقر فوق أيقونة التأمين في شريط العناوين لمنح أذونات الكاميرا لصفحة ويب هذه. قد يكون تحديث الصفحة مطلوبا.",primaryButtonText:"المتابعة دون كاميرا",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var MicrophoneSitePermissionsDenied$h={primaryText:"يتعذر الوصول إلى الميكروفون",secondaryText:"انقر فوق أيقونة التأمين في شريط العناوين لمنح أذونات الميكروفون لصفحة الويب هذه. قد يكون تحديث الصفحة مطلوبا.",primaryButtonText:"المتابعة بدون ميكروفون",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var CameraSitePermissionsDeniedSafari$h={primaryText:"تعذر الوصول إلى الكاميرا",secondaryText:"قم بتحديث الصفحة للسماح بالأذونات، أو تحقق من إعدادات هذا المستعرض وتحقق من تمكين الأذونات لموقع الويب هذا.",primaryButtonText:"المتابعة دون كاميرا",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var MicrophoneSitePermissionsDeniedSafari$h={primaryText:"يتعذر الوصول إلى الميكروفون",secondaryText:"قم بتحديث الصفحة للسماح بالأذونات، أو تحقق من إعدادات هذا المستعرض وتحقق من تمكين الأذونات لموقع الويب هذا.",primaryButtonText:"المتابعة دون ميكروفون",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var UnsupportedBrowser$h={primaryText:"المتصفح غير مدعوم",secondaryText:"الرجاء الانضمام إلى هذه المكالمة باستخدام مستعرض متوافق.",moreHelpLinkText:"الاطلاع على متطلبات التوافق"};var UnsupportedBrowserVersion$h={primaryText:"يلزم تحديث المستعرض",secondaryText:"لضمان أفضل مكالمة ممكنة، الرجاء تحديث المستعرض الخاص بك ثم محاولة الانضمام إلى المكالمة مرة أخرى.",moreHelpLinkText:"الاطلاع على متطلبات التوافق",continueAnywayButtonText:"بدء المكالمة دون تحديث"};var UnsupportedOperatingSystem$h={primaryText:"نظام التشغيل غير معتمد",secondaryText:"الرجاء الانضمام إلى هذه المكالمة باستخدام جهاز بنظام تشغيل متوافق.",moreHelpLinkText:"الاطلاع على متطلبات التوافق"};var BrowserPermissionDenied$h={primaryText:"يتعذر استخدام الكاميرا أو الميكروفون",secondaryText:"قد لا يكون لدى المستعرض إمكانية الوصول إلى الكاميرا أو الميكروفون لديك. لحل هذه المشكلة، افتح \"تفضيلات النظام\".",primaryButtonText:"حاول مرة أخرى",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها"};var BrowserPermissionDeniedIOS$h={primaryText:"السماح بالوصول إلى الميكروفون للمتابعة",secondaryText:"حتى يتمكن المشاركون الآخرون من سماعك.",primaryButtonText:"حاول مرة أخرى",imageAltText:"موقع إذن جهاز الكاميرا والميكروفون لـ iOS",linkText:"هل تحتاج إلى مساعدة؟ الحصول على تعليمات استكشاف الأخطاء وإصلاحها",step1Text:"انتقل إلى تطبيق الإعدادات",step2Text:"التمرير لأسفل للوصول إلى إعدادات هذا المستعرض",step3Text:"تشغيل الميكروفون (الكاميرا اختيارية)",step4Text:"حاول الانضمام إلى المكالمة مرة أخرى",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$h={leftNavButtonAriaLabel:"الصفحة السابقة",rightNavButtonAriaLabel:"الصفحة التالية"};var ar_SA$1 = {participantItem:participantItem$h,typingIndicator:typingIndicator$h,sendBox:sendBox$h,mentionPopover:mentionPopover$h,messageStatusIndicator:messageStatusIndicator$h,endCallButton:endCallButton$h,cameraButton:cameraButton$h,microphoneButton:microphoneButton$h,devicesButton:devicesButton$h,participantsButton:participantsButton$h,screenShareButton:screenShareButton$h,messageThread:messageThread$h,errorBar:errorBar$h,videoGallery:videoGallery$h,dialpad:dialpad$h,holdButton:holdButton$h,videoTile:videoTile$h,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$h,CameraSitePermissionsRequest:CameraSitePermissionsRequest$h,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$h,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$h,CameraSitePermissionsCheck:CameraSitePermissionsCheck$h,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$h,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$h,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$h,CameraSitePermissionsDenied:CameraSitePermissionsDenied$h,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$h,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$h,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$h,UnsupportedBrowser:UnsupportedBrowser$h,UnsupportedBrowserVersion:UnsupportedBrowserVersion$h,UnsupportedOperatingSystem:UnsupportedOperatingSystem$h,BrowserPermissionDenied:BrowserPermissionDenied$h,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$h,VerticalGallery:VerticalGallery$h};

var participantItem$g={isMeText:"(Sie)",menuTitle:"Weitere Optionen",removeButtonLabel:"Entfernen",sharingIconLabel:"Teilen",mutedIconLabel:"Stumm geschaltet",displayNamePlaceholder:"Teilnehmer ohne Namen",participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife"};var typingIndicator$g={singleUser:"{user} schreibt ...",multipleUsers:"{users} schreiben ...",multipleUsersAbbreviateOne:"{users} und 1 andere Person schreiben ...",multipleUsersAbbreviateMany:"{users} und {numOthers} andere schreiben ...",delimiter:", "};var sendBox$g={placeholderText:"Nachricht eingeben",textTooLong:"Ihre Nachrichtenlänge überschreitet den maximalen Grenzwert.",sendButtonAriaLabel:"Nachricht senden",fileUploadsPendingError:"Wird hochgeladen... Bitte warten.",removeFile:"Datei entfernen",uploading:"Hochladen",uploadCompleted:"Upload abgeschlossen"};var mentionPopover$g={mentionPopoverHeader:"Vorschläge"};var messageStatusIndicator$g={deliveredAriaLabel:"Nachricht gesendet",deliveredTooltipText:"Gesendet",seenAriaLabel:"Nachricht von anderen gesehen",seenTooltipText:"Gesehen",readByTooltipText:"Gelesen von {messageThreadReadCount} von {remoteParticipantsCount}",sendingAriaLabel:"Nachricht wird gesendet",sendingTooltipText:"Wird gesendet",failedToSendAriaLabel:"Nachricht konnte nicht gesendet werden",failedToSendTooltipText:"Fehler beim Senden"};var endCallButton$g={label:"Verlassen",tooltipContent:"Anruf verlassen"};var cameraButton$g={onLabel:"Deaktivieren",offLabel:"Aktivieren",tooltipDisabledContent:"Kamera ist deaktiviert",tooltipOnContent:"Kamera ausschalten",tooltipOffContent:"Kamera einschalten",tooltipVideoLoadingContent:"Video wird geladen",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswählen",cameraButtonSplitRoleDescription:"Unterteilte Schaltfläche",onSplitButtonAriaLabel:"Kamera und Kameraoptionen deaktivieren",offSplitButtonAriaLabel:"Kamera und Kameraoptionen aktivieren",cameraActionTurnedOnAnnouncement:"Ihre Kamera wurde eingeschaltet.",cameraActionTurnedOffAnnouncement:"Ihre Kamera wurde ausgeschaltet.",onSplitButtonPrimaryActionCamera:"Kamera ausschalten",offSplitButtonPrimaryActionCamera:"Kamera einschalten",cameraPrimaryActionSplitButtonTitle:"Kamera verwenden",videoEffectsMenuItemTitle:"Effekte"};var microphoneButton$g={onLabel:"Stumm schalten",offLabel:"Stummschaltung aufheben",tooltipDisabledContent:"Mikrofon ist deaktiviert",tooltipOnContent:"Mikrofon stummschalten",tooltipOffContent:"Mikrofonstummschaltung aufheben",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswählen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswählen",microphoneButtonSplitRoleDescription:"Unterteilte Schaltfläche",onSplitButtonAriaLabel:"Mikrofon- und Audiooptionen stummschalten",offSplitButtonAriaLabel:"Stummschaltung von Mikrofon- und Audiooptionen aufheben",microphoneActionTurnedOnAnnouncement:"Ihr Mikrofon wurde eingeschaltet.",microphoneActionTurnedOffAnnouncement:"Ihr Mikrofon wurde ausgeschaltet.",offSplitButtonMicrophonePrimaryAction:"Mikrofonstummschaltung aufheben",onSplitButtonMicrophonePrimaryAction:"Mikrofon stummschalten",microphonePrimaryActionSplitButtonTitle:"Mikrofon verwenden"};var devicesButton$g={label:"Geräte",tooltipContent:"Geräte verwalten",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera auswählen",audioDeviceMenuTitle:"Audiogerät",audioDeviceMenuTooltip:"Audiogerät auswählen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon auswählen",speakerMenuTitle:"Lautsprecher",speakerMenuTooltip:"Lautsprecher auswählen"};var participantsButton$g={label:"Personen",tooltipContent:"Teilnehmende anzeigen",menuHeader:"In diesem Anruf",participantsListButtonLabel:"{numParticipants} Personen",muteAllButtonLabel:"Alle stumm schalten",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Einladungslink kopiert"};var screenShareButton$g={onLabel:"Präsentation beenden",offLabel:"Präsentieren",tooltipDisabledContent:"Präsentieren ist deaktiviert",tooltipOnContent:"Ihr Bildschirm wird präsentiert",tooltipOffContent:"Präsentieren Sie Ihren Bildschirm"};var messageThread$g={yesterday:"Gestern",sunday:"Sonntag",monday:"Montag",tuesday:"Dienstag",wednesday:"Mittwoch",thursday:"Donnerstag",friday:"Freitag",saturday:"Samstag",participantJoined:"ist dem Chat beigetreten.",participantLeft:"hat den Chat verlassen.",editMessage:"Bearbeiten",removeMessage:"Löschen",resendMessage:"Erneut senden",failToSendTag:"Fehler beim Senden",editedTag:"Bearbeitet",liveAuthorIntro:"{author} sagt",messageContentAriaText:"{author} hat {message} gesagt",messageContentMineAriaText:"Sie sagten {message}",editBoxTextLimit:"Ihre Nachricht überschreitet das Limit von {limitNumber} Zeichen.",editBoxPlaceholderText:"Bearbeiten Sie Ihre Nachricht",newMessagesIndicator:"Neue Nachrichten",noDisplayNameSub:"Kein Name",editBoxCancelButton:"Abbrechen",editBoxSubmitButton:"Übermitteln",messageReadCount:"Gelesen von {messageReadByCount} von {remoteParticipantsCount}",actionMenuMoreOptions:"Weitere Optionen",downloadFile:"Datei herunterladen",blockedWarningText:"Diese Nachricht wurde aufgrund einer Organisationsrichtlinie gelöscht.",blockedWarningLinkText:"Details",fileCardGroupMessage:"Die Nachricht weist eine {fileCount}-Anlage auf"};var errorBar$g={unableToReachChatService:"Sie sind offline.",accessDenied:"Auf die Chatdienste kann nicht zugegriffen werden. Überprüfen Sie die angegebenen Benutzeranmeldeinformationen.",userNotInChatThread:"Sie sind nicht mehr in diesem Chatthread vertreten.",sendMessageNotInChatThread:"Fehler beim Senden der Nachricht, weil Sie sich nicht mehr in diesem Chatthread befinden.",sendMessageGeneric:"Fehler beim Senden der Nachricht",callingNetworkFailure:"Problematische Anrufverbindung – Sie scheinen offline zu sein",startVideoGeneric:"Video konnte nicht gestartet werden",stopVideoGeneric:"Video konnte nicht beendet werden",muteGeneric:"Mikrofon konnte nicht stummgeschaltet werden",unmuteGeneric:"Stummschaltung des Mikrofons konnte nicht beendet werden",speakingWhileMuted:"Ihr Mikrofon ist stummgeschaltet",startScreenShareGeneric:"Beim Starten der Bildschirmfreigabe ist ein Problem aufgetreten.",stopScreenShareGeneric:"Bildschirmfreigabe konnte nicht beendet werden",callNetworkQualityLow:"Die Netzwerkqualität ist niedrig.",callNoSpeakerFound:"Keine Lautsprecher oder Kopfhörer gefunden. Schließen Sie ein Audiogerät an, um den Anruf zu hören.",callNoMicrophoneFound:"Es wurden keine Mikrofone gefunden. Schließen Sie ein Audioeingabegerät an.",callMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callMicrophoneAccessDeniedSafari:"Auf das Mikrofon kann nicht zugegriffen werden. Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder überprüfen Sie die Einstellungen dieses Browsers, und stellen Sie sicher, dass die Berechtigungen für diese Website aktiviert sind.",callMicrophoneMutedBySystem:"Sie werden von Ihrem System stummgeschaltet.",callMicrophoneUnmutedBySystem:"Ihr Mikrofon wurde wiederhergestellt, und Ihr System hat die Stummschaltung aufgehoben.",callMacOsMicrophoneAccessDenied:"Auf das Mikrofon kann nicht zugegriffen werden. Erteilen Sie die Mikrofonberechtigung in Ihren macOS-Datenschutzeinstellungen.",callLocalVideoFreeze:"Die Netzwerkbandbreite ist schlecht. Ihr Video wird möglicherweise für andere Personen während des Anrufs angehalten angezeigt.",callCameraAccessDenied:"Auf die Kamera kann nicht zugegriffen werden. Klicken Sie auf die Sperre in der Adressleiste, um dieser Webseite Berechtigungen zu erteilen.",callCameraAccessDeniedSafari:"Auf die Kamera kann nicht zugegriffen werden. Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder überprüfen Sie die Einstellungen dieses Browsers, und stellen Sie sicher, dass die Berechtigungen für diese Website aktiviert sind.",callCameraAlreadyInUse:"Auf die Kamera kann nicht zugegriffen werden. Sie wird möglicherweise bereits von einer anderen Anwendung verwendet.",callVideoStoppedBySystem:"Ihr Video wurde von Ihrem System beendet.",callVideoRecoveredBySystem:"Ihr Video wurde fortgesetzt.",callMacOsCameraAccessDenied:"MacOS blockiert den Zugriff auf Ihre Kamera. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser auf Ihre Kamera zugreifen kann.",callMacOsScreenShareAccessDenied:"MacOS blockiert die Bildschirmfreigabe. Aktualisieren Sie Ihre Datenschutzeinstellungen, damit dieser Browser Ihren Bildschirm aufzeichnen kann.",dismissButtonAriaLabel:"Schließen",failedToJoinCallGeneric:"Fehler bei der Teilnahme am Anruf.",failedToJoinCallInvalidMeetingLink:"Teilnahme an Besprechung nicht möglich. Ungültiger Link.",cameraFrozenForRemoteParticipants:"Benutzer im Anruf haben Probleme, Ihr Video zu sehen. Überprüfen Sie Ihre Geräte und Ihr Netzwerk.",unableToStartVideoEffect:"Videoeffekt kann nicht angewendet werden."};var videoGallery$g={screenIsBeingSharedMessage:"Sie teilen Ihren Bildschirm",screenShareLoadingMessage:"Der Bildschirm von {participant} wird geladen",localVideoLabel:"Sie",localVideoCameraSwitcherLabel:"Kamera wechseln",localVideoMovementLabel:"Verschiebbare lokale Videokachel",localVideoSelectedDescription:"{cameraName} ausgewählt",displayNamePlaceholder:"Teilnehmer ohne Namen",fitRemoteParticipantToFrame:"An Rahmen anpassen",fillRemoteParticipantFrame:"Rahmen ausfüllen",pinParticipantForMe:"Für mich anheften",pinParticipantForMeLimitReached:"Anheften (Limit erreicht)",unpinParticipantForMe:"Lösen",pinParticipantMenuItemAriaLabel:"{participantName} anheften",unpinParticipantMenuItemAriaLabel:"{participantName} lösen",pinnedParticipantAnnouncementAriaLabel:"{participantName} angeheftet",unpinnedParticipantAnnouncementAriaLabel:"{participantName} gelöst"};var dialpad$g={placeholderText:"Telefonnummer eingeben",deleteButtonAriaLabel:"Löschen"};var holdButton$g={onLabel:"Fortsetzen",offLabel:"Halten",tooltipOnContent:"Anruf fortsetzen",tooltipOffContent:"Anruf halten"};var videoTile$g={participantStateRinging:"Anrufen...",participantStateHold:"In der Warteschleife"};var CameraAndMicrophoneSitePermissionsRequest$g={primaryText:"Zulassen, dass {appName} Ihre Kamera und Ihr Mikrofon verwendet",secondaryText:"So können die Teilnehmer Sie sehen und hören.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",ariaLabel:"Zugriff auf Kamera und Mikrofon zulassen"};var CameraSitePermissionsRequest$g={primaryText:"{appName} die Verwendung Ihrer Kamera erlauben",secondaryText:"So können die Teilnehmer Sie sehen.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera fortfahren",ariaLabel:"Kamerazugriff zulassen"};var MicrophoneSitePermissionsRequest$g={primaryText:"{appName} die Verwendung Ihres Mikrofons erlauben",secondaryText:"So können die Teilnehmer Sie hören.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Mikrofon fortfahren",ariaLabel:"Mikrofonzugriff zulassen"};var CameraAndMicrophoneSitePermissionsCheck$g={primaryText:"Überprüfen des Kamera- und Mikrofonzugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie sehen und hören können.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",ariaLabel:"Überprüfen des Kamera- und Mikrofonzugriffs. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var CameraSitePermissionsCheck$g={primaryText:"Überprüfung des Kamerazugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie sehen können.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Kamera fortfahren",ariaLabel:"Überprüfen des Kamerazugriffs. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var MicrophoneSitePermissionsCheck$g={primaryText:"Überprüfen des Mikrofonzugriffs",secondaryText:"Zugriff bei Aufforderung zulassen. Dies ist so, dass Teilnehmer Sie hören können.",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",primaryButtonText:"Ohne Mikrofon fortfahren",ariaLabel:"Der Mikrofonzugriff wird überprüft. Erlauben Sie den Zugriff, wenn Sie aufgefordert werden."};var CameraAndMicrophoneSitePermissionsDenied$g={primaryText:"Auf Kamera und Mikrofon kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Mikrofonberechtigungen zu erteilen. Möglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraAndMicrophoneSitePermissionsDeniedSafari$g={primaryText:"Auf Kamera und Mikrofon kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder überprüfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen für diese Website aktiviert sind.",primaryButtonText:"Ohne Kamera und Mikrofon fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraSitePermissionsDenied$g={primaryText:"Auf die Kamera kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Kameraberechtigungen zu erteilen. Möglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Kamera fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var MicrophoneSitePermissionsDenied$g={primaryText:"Auf das Mikrofon kann nicht zugegriffen werden",secondaryText:"Klicken Sie auf das Schlosssymbol in der Adressleiste, um dieser Webseite Mikrofonberechtigungen zu erteilen. Möglicherweise ist eine Seitenaktualisierung erforderlich.",primaryButtonText:"Ohne Mikrofon fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var CameraSitePermissionsDeniedSafari$g={primaryText:"Auf die Kamera kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder überprüfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen für diese Website aktiviert sind.",primaryButtonText:"Ohne Kamera fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var MicrophoneSitePermissionsDeniedSafari$g={primaryText:"Auf das Mikrofon kann nicht zugegriffen werden",secondaryText:"Aktualisieren Sie die Seite, um Berechtigungen zuzulassen, oder überprüfen Sie die Einstellungen dieses Browsers und stellen Sie sicher, dass die Berechtigungen für diese Website aktiviert sind.",primaryButtonText:"Ohne Mikrofon fortfahren",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var UnsupportedBrowser$g={primaryText:"Der Browser wird nicht unterstützt.",secondaryText:"Bitte nehmen Sie über einen kompatiblen Browser an diesem Anruf teil.",moreHelpLinkText:"Kompatibilitätsanforderungen anzeigen"};var UnsupportedBrowserVersion$g={primaryText:"Browserupdate erforderlich",secondaryText:"Um einen optimalen Anruf zu gewährleisten, aktualisieren Sie Ihren Browser, und versuchen Sie dann erneut, an dem Anruf teilzunehmen.",moreHelpLinkText:"Kompatibilitätsanforderungen anzeigen",continueAnywayButtonText:"Anruf ohne Aktualisierung starten"};var UnsupportedOperatingSystem$g={primaryText:"Das Betriebssystem wird nicht unterstützt.",secondaryText:"Nehmen Sie an diesem Anruf teil, indem Sie ein Gerät mit einem kompatiblen Betriebssystem verwenden.",moreHelpLinkText:"Kompatibilitätsanforderungen anzeigen"};var BrowserPermissionDenied$g={primaryText:"Kamera oder Mikrofon kann nicht verwendet werden",secondaryText:"Ihr Browser hat möglicherweise keinen Zugriff auf Ihre Kamera oder Ihr Mikrofon. Öffnen Sie die Systemeinstellungen, um dieses Problem zu beheben.",primaryButtonText:"Erneut versuchen",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung"};var BrowserPermissionDeniedIOS$g={primaryText:"Mikrofonzugriff zulassen, um fortzufahren",secondaryText:"Damit andere Teilnehmer Sie hören können.",primaryButtonText:"Erneut versuchen",imageAltText:"Berechtigungsspeicherort für Mikrofon- und Kamerageräte für iOS",linkText:"Benötigen Sie Hilfe? Hilfe zur Problembehandlung",step1Text:"Zur Einstellungs-App wechseln",step2Text:"Scrollen Sie nach unten zu den Einstellungen dieses Browsers",step3Text:"Mikrofon einschalten (Kamera optional)",step4Text:"Versuchen Sie erneut, dem Anruf beizutreten",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$g={leftNavButtonAriaLabel:"Vorherige Seite",rightNavButtonAriaLabel:"Nächste Seite"};var de_DE$1 = {participantItem:participantItem$g,typingIndicator:typingIndicator$g,sendBox:sendBox$g,mentionPopover:mentionPopover$g,messageStatusIndicator:messageStatusIndicator$g,endCallButton:endCallButton$g,cameraButton:cameraButton$g,microphoneButton:microphoneButton$g,devicesButton:devicesButton$g,participantsButton:participantsButton$g,screenShareButton:screenShareButton$g,messageThread:messageThread$g,errorBar:errorBar$g,videoGallery:videoGallery$g,dialpad:dialpad$g,holdButton:holdButton$g,videoTile:videoTile$g,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$g,CameraSitePermissionsRequest:CameraSitePermissionsRequest$g,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$g,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$g,CameraSitePermissionsCheck:CameraSitePermissionsCheck$g,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$g,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$g,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$g,CameraSitePermissionsDenied:CameraSitePermissionsDenied$g,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$g,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$g,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$g,UnsupportedBrowser:UnsupportedBrowser$g,UnsupportedBrowserVersion:UnsupportedBrowserVersion$g,UnsupportedOperatingSystem:UnsupportedOperatingSystem$g,BrowserPermissionDenied:BrowserPermissionDenied$g,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$g,VerticalGallery:VerticalGallery$g};

var participantItem$f={isMeText:"(tú)",menuTitle:"Más opciones",removeButtonLabel:"Quitar",sharingIconLabel:"Compartiendo",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante sin nombre",participantStateRinging:"Llamando...",participantStateHold:"En espera"};var typingIndicator$f={singleUser:"{user} está escribiendo...",multipleUsers:"{users} están escribiendo...",multipleUsersAbbreviateOne:"{users} y 1 usuario más están escribiendo...",multipleUsersAbbreviateMany:"{users} y {numOthers} usuarios más están escribiendo...",delimiter:", "};var sendBox$f={placeholderText:"Escribir un mensaje",textTooLong:"La longitud del mensaje supera el límite máximo.",sendButtonAriaLabel:"Enviar mensaje",fileUploadsPendingError:"Cargando... Espere.",removeFile:"Quitar archivo",uploading:"Cargando",uploadCompleted:"Carga completada"};var mentionPopover$f={mentionPopoverHeader:"Sugerencias"};var messageStatusIndicator$f={deliveredAriaLabel:"Mensaje enviado",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensaje visto por otros usuarios",seenTooltipText:"Visto",readByTooltipText:"Leído por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envío de mensajes",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Error al enviar el mensaje",failedToSendTooltipText:"Error al enviar"};var endCallButton$f={label:"Baja",tooltipContent:"Abandonar llamada"};var cameraButton$f={onLabel:"Desactivar",offLabel:"Activar",tooltipDisabledContent:"La cámara está deshabilitada",tooltipOnContent:"Desconectar la cámara",tooltipOffContent:"Activar la cámara",tooltipVideoLoadingContent:"El vídeo se está cargando",cameraMenuTitle:"Cámara",cameraMenuTooltip:"Elegir cámara",cameraButtonSplitRoleDescription:"Botón de expansión",onSplitButtonAriaLabel:"Desactivar la cámara y las opciones de cámara",offSplitButtonAriaLabel:"Activar la cámara y las opciones de cámara",cameraActionTurnedOnAnnouncement:"La cámara se ha activado",cameraActionTurnedOffAnnouncement:"La cámara se ha desactivado",onSplitButtonPrimaryActionCamera:"Desconectar la cámara",offSplitButtonPrimaryActionCamera:"Activar la cámara",cameraPrimaryActionSplitButtonTitle:"Usar cámara",videoEffectsMenuItemTitle:"Efectos"};var microphoneButton$f={onLabel:"Silenciar",offLabel:"Reactivar audio",tooltipDisabledContent:"Micrófono deshabilitado",tooltipOnContent:"Silenciar micrófono",tooltipOffContent:"Reactivar micrófono",microphoneMenuTitle:"Micrófono",microphoneMenuTooltip:"Elegir micrófono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz",microphoneButtonSplitRoleDescription:"Botón de expansión",onSplitButtonAriaLabel:"Silenciar opciones de micrófono y audio",offSplitButtonAriaLabel:"Reactivar el micrófono y las opciones de audio",microphoneActionTurnedOnAnnouncement:"El micrófono se ha activado",microphoneActionTurnedOffAnnouncement:"El micrófono se ha desactivado",offSplitButtonMicrophonePrimaryAction:"Reactivar micrófono",onSplitButtonMicrophonePrimaryAction:"Silenciar micrófono",microphonePrimaryActionSplitButtonTitle:"Usar micrófono"};var devicesButton$f={label:"Dispositivos",tooltipContent:"Administrar dispositivos",cameraMenuTitle:"Cámara",cameraMenuTooltip:"Elegir cámara",audioDeviceMenuTitle:"Dispositivo de audio",audioDeviceMenuTooltip:"Elegir dispositivo de audio",microphoneMenuTitle:"Micrófono",microphoneMenuTooltip:"Elegir micrófono",speakerMenuTitle:"Altavoz",speakerMenuTooltip:"Elegir altavoz"};var participantsButton$f={label:"Contactos",tooltipContent:"Mostrar participantes",menuHeader:"En esta llamada",participantsListButtonLabel:"{numParticipants} personas",muteAllButtonLabel:"Silenciar a todos",copyInviteLinkButtonLabel:"Copiar vínculo de invitación",copyInviteLinkActionedAriaLabel:"Vínculo de invitación copiado"};var screenShareButton$f={onLabel:"Dejar de presentar",offLabel:"Presentar",tooltipDisabledContent:"La presentación está deshabilitada",tooltipOnContent:"Presentando su pantalla",tooltipOffContent:"Presentar la pantalla"};var messageThread$f={yesterday:"Ayer",sunday:"Domingo",monday:"Lunes",tuesday:"Martes",wednesday:"Miércoles",thursday:"Jueves",friday:"Viernes",saturday:"Sábado",participantJoined:"se unió al chat.",participantLeft:"abandonó el chat.",editMessage:"Editar",removeMessage:"Eliminar",resendMessage:"Intente enviar de nuevo",failToSendTag:"Error al enviar",editedTag:"Editado",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} dijo {message}",messageContentMineAriaText:"Has dicho {message}",editBoxTextLimit:"El mensaje supera el límite de {limitNumber} caracteres",editBoxPlaceholderText:"Editar el mensaje",newMessagesIndicator:"Mensajes nuevos",noDisplayNameSub:"Sin nombre",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar",messageReadCount:"Leído por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Más opciones",downloadFile:"Descargar archivo",blockedWarningText:"Este mensaje se eliminó debido a la directiva de la organización.",blockedWarningLinkText:"Detalles",fileCardGroupMessage:"El mensaje tiene {fileCount} datos adjuntos"};var errorBar$f={unableToReachChatService:"Sin conexión",accessDenied:"No se puede acceder a los servicios de chat. Compruebe las credenciales de usuario proporcionadas.",userNotInChatThread:"Ya no está en este hilo de chat",sendMessageNotInChatThread:"No se pudo enviar el mensaje porque ya no está en este hilo de chat",sendMessageGeneric:"Error al enviar el mensaje",callingNetworkFailure:"Problema al conectar la llamada; parece que no hay conexión",startVideoGeneric:"No se pudo iniciar el vídeo",stopVideoGeneric:"No se pudo detener el vídeo",muteGeneric:"No se pudo silenciar el micrófono",unmuteGeneric:"No se pudo reactivar el micrófono",speakingWhileMuted:"El micrófono está desactivado",startScreenShareGeneric:"Hubo un problema al iniciar la pantalla compartida.",stopScreenShareGeneric:"No se pudo detener la pantalla compartida",callNetworkQualityLow:"La calidad de la red es baja.",callNoSpeakerFound:"No se encontraron altavoces ni auriculares. Conecta un dispositivo de audio para escuchar la llamada.",callNoMicrophoneFound:"No se encontraron micrófonos. Conecta un dispositivo de entrada de audio.",callMicrophoneAccessDenied:"No se puede acceder al micrófono. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta página web.",callMicrophoneAccessDeniedSafari:"No se puede acceder al micrófono. Actualice la página para permitir permisos o compruebe la configuración de este explorador y compruebe que los permisos estén habilitados para este sitio web.",callMicrophoneMutedBySystem:"Su sistema ha silenciado su audio.",callMicrophoneUnmutedBySystem:"Su micrófono se ha recuperado y el sistema ha activado el audio.",callMacOsMicrophoneAccessDenied:"No se puede acceder al micrófono. Conceda permiso al micrófono en la configuración de privacidad de macOS.",callLocalVideoFreeze:"El ancho de banda de red es deficiente. Es posible que el vídeo aparezca pausado para otros usuarios en la llamada.",callCameraAccessDenied:"No se puede acceder a la cámara. Haga clic en el bloqueo de la barra de direcciones para conceder permiso a esta página web.",callCameraAccessDeniedSafari:"No se puede acceder a la cámara. Actualice la página para permitir permisos o compruebe la configuración de este explorador y compruebe que los permisos estén habilitados para este sitio web.",callCameraAlreadyInUse:"No se puede acceder a la cámara. Puede que ya la esté usando otra aplicación.",callVideoStoppedBySystem:"El sistema ha detenido el vídeo.",callVideoRecoveredBySystem:"El vídeo se ha reanudado.",callMacOsCameraAccessDenied:"MacOS está bloqueando el acceso a la cámara. Actualiza la configuración de privacidad para permitir que este explorador acceda a la cámara.",callMacOsScreenShareAccessDenied:"MacOS está bloqueando el uso compartido de la pantalla. Actualice la configuración de privacidad para permitir que este explorador grabe la pantalla.",dismissButtonAriaLabel:"Cerrar",failedToJoinCallGeneric:"No se pudo unir a la llamada.",failedToJoinCallInvalidMeetingLink:"No se puede unir a la reunión. Vínculo no válido.",cameraFrozenForRemoteParticipants:"Los usuarios de la llamada tienen problemas para ver el vídeo. Compruebe los dispositivos y la red.",unableToStartVideoEffect:"No se puede aplicar el efecto de vídeo."};var videoGallery$f={screenIsBeingSharedMessage:"Está compartiendo su pantalla",screenShareLoadingMessage:"Cargando la pantalla de {participant}",localVideoLabel:"Tú",localVideoCameraSwitcherLabel:"Cambiar de cámara",localVideoMovementLabel:"Mosaico de vídeo local movible",localVideoSelectedDescription:"{cameraName} seleccionada",displayNamePlaceholder:"Participante sin nombre",fitRemoteParticipantToFrame:"Ajustar al marco",fillRemoteParticipantFrame:"Marco de relleno",pinParticipantForMe:"Anclar para mí",pinParticipantForMeLimitReached:"Pin (límite alcanzado)",unpinParticipantForMe:"Desanclar",pinParticipantMenuItemAriaLabel:"Anclar {participantName}",unpinParticipantMenuItemAriaLabel:"Desanclar {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} anclado",unpinnedParticipantAnnouncementAriaLabel:"{participantName} desanclado"};var dialpad$f={placeholderText:"Introduzca el número de teléfono",deleteButtonAriaLabel:"Eliminar"};var holdButton$f={onLabel:"Reanudar",offLabel:"En espera",tooltipOnContent:"Reanudar llamada",tooltipOffContent:"Poner llamada en espera"};var videoTile$f={participantStateRinging:"Llamando...",participantStateHold:"En espera"};var CameraAndMicrophoneSitePermissionsRequest$f={primaryText:"Permitir que {appName} usen la cámara y el micrófono",secondaryText:"Esto es para que los participantes puedan verle y oírle.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin cámara ni micrófono",ariaLabel:"Permitir el acceso a la cámara y al micrófono"};var CameraSitePermissionsRequest$f={primaryText:"Permitir que {appName} use la cámara",secondaryText:"Esto sirve para que los participantes puedan verle.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin cámara",ariaLabel:"Permitir el acceso a la cámara"};var MicrophoneSitePermissionsRequest$f={primaryText:"Permitir que {appName} use el micrófono",secondaryText:"Esto sirve para que los participantes puedan oírle.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin micrófono",ariaLabel:"Permitir el acceso al micrófono"};var CameraAndMicrophoneSitePermissionsCheck$f={primaryText:"Comprobando el acceso a la cámara y al micrófono",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan verle y oírle.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin cámara ni micrófono",ariaLabel:"Comprobando el acceso a la cámara y al micrófono. Permitir el acceso si se le solicita."};var CameraSitePermissionsCheck$f={primaryText:"Comprobando el acceso a la cámara",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan verlo.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin cámara",ariaLabel:"Comprobando el acceso a la cámara. Permitir el acceso si se le solicita."};var MicrophoneSitePermissionsCheck$f={primaryText:"Comprobando el acceso al micrófono",secondaryText:"Permitir el acceso si se le solicita. Esto es para que los participantes puedan oírle.",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",primaryButtonText:"Continuar sin micrófono",ariaLabel:"Comprobando el acceso al micrófono. Permitir el acceso si se le solicita."};var CameraAndMicrophoneSitePermissionsDenied$f={primaryText:"No se puede permitir el acceso a la cámara ni al micrófono.",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de micrófono a esta página web. Es posible que sea necesario actualizar la página.",primaryButtonText:"Continuar sin cámara ni micrófono",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var CameraAndMicrophoneSitePermissionsDeniedSafari$f={primaryText:"No se puede permitir el acceso a la cámara ni al micrófono.",secondaryText:"Actualice la página para permitir permisos o compruebe la configuración de este explorador y compruebe que los permisos estén habilitados para este sitio web.",primaryButtonText:"Continuar sin cámara ni micrófono",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var CameraSitePermissionsDenied$f={primaryText:"No se puede acceder a la cámara",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de cámara a esta página web. Es posible que sea necesario actualizar la página.",primaryButtonText:"Continuar sin cámara",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var MicrophoneSitePermissionsDenied$f={primaryText:"No se puede acceder al micrófono.",secondaryText:"Haga clic en el icono de bloqueo de la barra de direcciones para conceder permisos de micrófono a esta página web. Es posible que sea necesario actualizar la página.",primaryButtonText:"Continuar sin micrófono",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var CameraSitePermissionsDeniedSafari$f={primaryText:"No se puede acceder a la cámara.",secondaryText:"Actualice la página para permitir permisos o compruebe la configuración de este explorador y compruebe que los permisos estén habilitados para este sitio web.",primaryButtonText:"Continuar sin cámara",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var MicrophoneSitePermissionsDeniedSafari$f={primaryText:"No se puede acceder al micrófono",secondaryText:"Actualice la página para permitir permisos o compruebe la configuración de este explorador y compruebe que los permisos estén habilitados para este sitio web.",primaryButtonText:"Continuar sin micrófono",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var UnsupportedBrowser$f={primaryText:"Explorador no compatible",secondaryText:"Únase a esta llamada con un explorador compatible.",moreHelpLinkText:"Ver los requisitos de compatibilidad"};var UnsupportedBrowserVersion$f={primaryText:"Es necesario actualizar el explorador",secondaryText:"Para garantizar la mejor llamada posible, actualice el explorador e intente unirse de nuevo a la llamada.",moreHelpLinkText:"Ver los requisitos de compatibilidad",continueAnywayButtonText:"Iniciar llamada sin actualizar"};var UnsupportedOperatingSystem$f={primaryText:"Sistema operativo no compatible",secondaryText:"Únase a esta llamada con un dispositivo con un sistema operativo compatible.",moreHelpLinkText:"Ver los requisitos de compatibilidad"};var BrowserPermissionDenied$f={primaryText:"No se puede usar la cámara o el micrófono",secondaryText:"Es posible que el explorador no tenga acceso a la cámara o al micrófono. Para solucionar este problema, abra Preferencias del sistema.",primaryButtonText:"Intentar de nuevo",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas"};var BrowserPermissionDeniedIOS$f={primaryText:"Permite el acceso al micrófono para continuar",secondaryText:"Para que otros participantes puedan oírte.",primaryButtonText:"Intentar de nuevo",imageAltText:"Ubicación de permisos del dispositivo de micrófono y cámara para iOS",linkText:"¿Necesitas ayuda? Obtén ayuda para la solución de problemas",step1Text:"Ve a la aplicación de Configuración",step2Text:"Desplázate hacia abajo hasta la configuración de este explorador",step3Text:"Activar micrófono (cámara opcional)",step4Text:"Intenta unirte de nuevo a la llamada",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$f={leftNavButtonAriaLabel:"página anterior",rightNavButtonAriaLabel:"página siguiente"};var es_ES$1 = {participantItem:participantItem$f,typingIndicator:typingIndicator$f,sendBox:sendBox$f,mentionPopover:mentionPopover$f,messageStatusIndicator:messageStatusIndicator$f,endCallButton:endCallButton$f,cameraButton:cameraButton$f,microphoneButton:microphoneButton$f,devicesButton:devicesButton$f,participantsButton:participantsButton$f,screenShareButton:screenShareButton$f,messageThread:messageThread$f,errorBar:errorBar$f,videoGallery:videoGallery$f,dialpad:dialpad$f,holdButton:holdButton$f,videoTile:videoTile$f,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$f,CameraSitePermissionsRequest:CameraSitePermissionsRequest$f,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$f,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$f,CameraSitePermissionsCheck:CameraSitePermissionsCheck$f,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$f,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$f,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$f,CameraSitePermissionsDenied:CameraSitePermissionsDenied$f,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$f,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$f,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$f,UnsupportedBrowser:UnsupportedBrowser$f,UnsupportedBrowserVersion:UnsupportedBrowserVersion$f,UnsupportedOperatingSystem:UnsupportedOperatingSystem$f,BrowserPermissionDenied:BrowserPermissionDenied$f,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$f,VerticalGallery:VerticalGallery$f};

var participantItem$e={isMeText:"(sinä)",menuTitle:"Lisää vaihtoehtoja",removeButtonLabel:"Poista",sharingIconLabel:"Jakaminen",mutedIconLabel:"Mykistetty",displayNamePlaceholder:"Nimetön osallistuja",participantStateRinging:"Soitetaan...",participantStateHold:"Pidossa"};var typingIndicator$e={singleUser:"{user} käyttäjä kirjoittaa parhaillaan...",multipleUsers:"{users} käyttäjää kirjoittaa parhaillaan...",multipleUsersAbbreviateOne:"{users} ja yksi muu käyttäjä kirjoittaa parhaillaan...",multipleUsersAbbreviateMany:"{users} ja {numOthers} muuta käyttäjää kirjoittaa parhaillaan...",delimiter:", "};var sendBox$e={placeholderText:"Kirjoita viesti",textTooLong:"Viestin pituus ylittää enimmäispituuden.",sendButtonAriaLabel:"Lähetä viesti",fileUploadsPendingError:"Ladataan palvelimeen... Odota hetki.",removeFile:"Poista tiedosto",uploading:"Ladataan palvelimeen",uploadCompleted:"Ladattu palvelimeen"};var mentionPopover$e={mentionPopoverHeader:"Ehdotuksia"};var messageStatusIndicator$e={deliveredAriaLabel:"Viesti on lähetetty",deliveredTooltipText:"Lähetetty",seenAriaLabel:"Muut ovat nähneet viestin",seenTooltipText:"Nähty",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} osallistujaa on lukenut viestin",sendingAriaLabel:"Viestiä lähetetään",sendingTooltipText:"Lähetetään",failedToSendAriaLabel:"Viestin lähettäminen epäonnistui",failedToSendTooltipText:"Lähettäminen epäonnistui"};var endCallButton$e={label:"Poistu",tooltipContent:"Poistu puhelusta"};var cameraButton$e={onLabel:"Poista käytöstä",offLabel:"Ota käyttöön",tooltipDisabledContent:"Kamera on poissa käytöstä",tooltipOnContent:"Poista kamera käytöstä",tooltipOffContent:"Käynnistä kamera",tooltipVideoLoadingContent:"Videota ladataan",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Valitse kamera",cameraButtonSplitRoleDescription:"Jaettu painike",onSplitButtonAriaLabel:"Kameran ja sen käytöstä poistamisen asetukset",offSplitButtonAriaLabel:"Kameran ja sen käyttöön ottamisen asetukset",cameraActionTurnedOnAnnouncement:"Kamerasi on otettu käyttöön",cameraActionTurnedOffAnnouncement:"Kamerasi on poistettu käytöstä",onSplitButtonPrimaryActionCamera:"Poista kamera käytöstä",offSplitButtonPrimaryActionCamera:"Käynnistä kamera",cameraPrimaryActionSplitButtonTitle:"Käytä kameraa",videoEffectsMenuItemTitle:"Tehosteet"};var microphoneButton$e={onLabel:"Mykistä",offLabel:"Poista mykistys",tooltipDisabledContent:"Mikrofoni on poissa käytöstä",tooltipOnContent:"Mykistä mikrofoni",tooltipOffContent:"Poista mikrofonin mykistys",microphoneMenuTitle:"Mikrofoni",microphoneMenuTooltip:"Valitse mikrofoni",speakerMenuTitle:"Kaiutin",speakerMenuTooltip:"Valitse kaiutin",microphoneButtonSplitRoleDescription:"Jaettu painike",onSplitButtonAriaLabel:"Äänen ja mikrofonin mykistyksen asetukset",offSplitButtonAriaLabel:"Äänen ja mikrofonin mykistyksen poistamisen asetukset",microphoneActionTurnedOnAnnouncement:"Mikrofonisi on otettu käyttöön",microphoneActionTurnedOffAnnouncement:"Mikrofonisi on poistettu käytöstä",offSplitButtonMicrophonePrimaryAction:"Poista mikrofonin mykistys",onSplitButtonMicrophonePrimaryAction:"Mykistä mikrofoni",microphonePrimaryActionSplitButtonTitle:"Käytä mikrofonia"};var devicesButton$e={label:"Laitteet",tooltipContent:"Hallitse laitteita",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Valitse kamera",audioDeviceMenuTitle:"Äänilaite",audioDeviceMenuTooltip:"Valitse äänilaite",microphoneMenuTitle:"Mikrofoni",microphoneMenuTooltip:"Valitse mikrofoni",speakerMenuTitle:"Kaiutin",speakerMenuTooltip:"Valitse kaiutin"};var participantsButton$e={label:"Ihmiset",tooltipContent:"Näytä osallistujat",menuHeader:"Tässä puhelussa",participantsListButtonLabel:"{numParticipants} henkilöä",muteAllButtonLabel:"Mykistä kaikki",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu"};var screenShareButton$e={onLabel:"Lopeta esitys",offLabel:"Esitä",tooltipDisabledContent:"Näytön jakaminen on poissa käytöstä",tooltipOnContent:"Näyttösi näytetään muille osallistujille",tooltipOffContent:"Näytä oma näyttösi"};var messageThread$e={yesterday:"eilen",sunday:"sunnuntaina",monday:"maanantaina",tuesday:"tiistaina",wednesday:"keskiviikkona",thursday:"torstaina",friday:"perjantaina",saturday:"lauantaina",participantJoined:"liittyi keskusteluun.",participantLeft:"poistui keskustelusta.",editMessage:"Muokkaa",removeMessage:"Poista",resendMessage:"Yritä lähettää viesti uudelleen",failToSendTag:"Lähettäminen epäonnistui",editedTag:"Muokattu",liveAuthorIntro:"{author} sanoo",messageContentAriaText:"{author} sanoi {message}",messageContentMineAriaText:"Sanoit {message}",editBoxTextLimit:"Viesti ylittää {limitNumber} merkin rajan",editBoxPlaceholderText:"Muokkaa viestiäsi",newMessagesIndicator:"Uudet viestit",noDisplayNameSub:"Ei nimeä",editBoxCancelButton:"Peruuta",editBoxSubmitButton:"Lähetä",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} osallistujaa on lukenut viestin",actionMenuMoreOptions:"Lisää vaihtoehtoja",downloadFile:"Lataa tiedosto",blockedWarningText:"Tämä viesti poistettiin organisaation käytännön vuoksi.",blockedWarningLinkText:"Lisätiedot",fileCardGroupMessage:"Viestissä on {fileCount} liite"};var errorBar$e={unableToReachChatService:"Olet offline-tilassa",accessDenied:"Keskustelupalveluihin ei saada yhteyttä – tarkista annetut käyttäjän tunnistetiedot",userNotInChatThread:"Et ole enää mukana tässä keskusteluketjussa",sendMessageNotInChatThread:"Viestin lähettäminen epäonnistui, koska et ole enää tässä keskusteluketjussa",sendMessageGeneric:"Viestin lähettäminen epäonnistui",callingNetworkFailure:"Puhelun yhdistämisessä on ongelma. Vaikutat olevan offline-tilassa",startVideoGeneric:"Videon käynnistäminen epäonnistui",stopVideoGeneric:"Videon pysäyttäminen epäonnistui",muteGeneric:"Mikrofonin mykistäminen epäonnistui",unmuteGeneric:"Mikrofonin mykistyksen poistaminen epäonnistui",speakingWhileMuted:"Mikrofonisi on mykistetty",startScreenShareGeneric:"Näytön jakamisen aloittamisessa ilmeni ongelma.",stopScreenShareGeneric:"Näytön jakamisen lopettaminen epäonnistui",callNetworkQualityLow:"Verkkoyhteyden laatu on huono.",callNoSpeakerFound:"Kaiuttimia tai kuulokkeita ei löytynyt. Yhdistä äänilaite voidaksesi kuulla puhelun.",callNoMicrophoneFound:"Mikrofoneja ei löytynyt. Yhdistä äänitulolaite.",callMicrophoneAccessDenied:"Mikrofonia ei voi käyttää. Myönnä käyttöoikeus tälle verkkosivulle napsauttamalla osoiterivin lukitusta.",callMicrophoneAccessDeniedSafari:"Mikrofonia ei voi käyttää. Salli käyttöoikeudet päivittämällä sivu tai tarkista tämän selaimen asetukset ja varmista, että käyttöoikeudet on otettu käyttöön tässä sivustossa.",callMicrophoneMutedBySystem:"Järjestelmäasetuksen perusteella sinut on mykistetty.",callMicrophoneUnmutedBySystem:"Mikrofonisi palautui käyttöön ja järjestelmä on poistanut sen mykistyksen.",callMacOsMicrophoneAccessDenied:"Mikrofonia ei voi käyttää. Salli mikrofonin käyttö macOS:in tietosuoja-asetuksissa.",callLocalVideoFreeze:"Verkon kaistanleveys on heikko. Videokuvasi saattaa näkyä keskeytettynä puhelun muille osallistujille.",callCameraAccessDenied:"Kameraa ei voi käyttää. Myönnä käyttöoikeus tälle verkkosivulle napsauttamalla osoiterivin lukitusta.",callCameraAccessDeniedSafari:"Kameraa ei voi käyttää. Salli käyttöoikeudet päivittämällä sivu tai tarkista tämän selaimen asetukset ja varmista, että käyttöoikeudet on otettu käyttöön tässä sivustossa.",callCameraAlreadyInUse:"Kameraa ei voi käyttää. Toinen sovellus saattaa jo käyttää sitä.",callVideoStoppedBySystem:"Järjestelmä on pysäyttänyt videosi.",callVideoRecoveredBySystem:"Videosi näytetään jälleen.",callMacOsCameraAccessDenied:"MacOS estää kameran käytön. Päivitä tietosuoja-asetukset, jotta selain voi käyttää kameraasi.",callMacOsScreenShareAccessDenied:"MacOS estää näytön jakamisen. Päivitä tietosuoja-asetukset, jotta selain voi tallentaa, mitä näytölläsi tapahtuu.",dismissButtonAriaLabel:"Sulje",failedToJoinCallGeneric:"Puheluun liittyminen epäonnistui.",failedToJoinCallInvalidMeetingLink:"Kokoukseen liittyminen ei onnistu. Linkki on virheellinen.",cameraFrozenForRemoteParticipants:"Puhelun käyttäjillä on videokuvan näkymiseen liittyviä ongelmia. Tarkista laitteesi ja verkkosi.",unableToStartVideoEffect:"Videotehosteen käyttäminen ei onnistu."};var videoGallery$e={screenIsBeingSharedMessage:"Näyttösi jaetaan parhaillaan",screenShareLoadingMessage:"Ladataan käyttäjän {participant} näyttöä",localVideoLabel:"Sinä",localVideoCameraSwitcherLabel:"Vaihda kameraa",localVideoMovementLabel:"Siirrettävä paikallisen videon ruutu",localVideoSelectedDescription:"{cameraName} on valittu",displayNamePlaceholder:"Nimetön osallistuja",fitRemoteParticipantToFrame:"Sovita kehykseen",fillRemoteParticipantFrame:"Täytä kehys",pinParticipantForMe:"Kiinnitä minulle",pinParticipantForMeLimitReached:"Kiinnitys (enimmäisraja saavutettu)",unpinParticipantForMe:"Poista kiinnitys",pinParticipantMenuItemAriaLabel:"Kiinnitä {participantName}",unpinParticipantMenuItemAriaLabel:"Poista henkilön {participantName} kiinnitys",pinnedParticipantAnnouncementAriaLabel:"Kiinnitetty {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Poistettu henkilön {participantName} kiinnitys"};var dialpad$e={placeholderText:"Anna puhelinnumero",deleteButtonAriaLabel:"Poista"};var holdButton$e={onLabel:"Jatka",offLabel:"Pito",tooltipOnContent:"Jatka puhelua",tooltipOffContent:"Aseta puhelu pitoon"};var videoTile$e={participantStateRinging:"Soitetaan...",participantStateHold:"Pidossa"};var CameraAndMicrophoneSitePermissionsRequest$e={primaryText:"Salli {appName} käyttää kameraa ja mikrofonia",secondaryText:"Näin osallistujat voivat nähdä ja kuulla sinua.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",ariaLabel:"Salli kameran ja mikrofonin käyttö"};var CameraSitePermissionsRequest$e={primaryText:"Salli sovelluksen {appName} käyttää kameraasi",secondaryText:"Tätä tarvitaan, jotta muut osallistujat näkevät sinut.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman kameraa",ariaLabel:"Salli kameran käyttö"};var MicrophoneSitePermissionsRequest$e={primaryText:"Salli sovelluksen {appName} käyttää mikrofoniasi",secondaryText:"Tätä tarvitaan, jotta muut osallistujat kuulevat sinut.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman mikrofonia",ariaLabel:"Salli mikrofonin käyttö"};var CameraAndMicrophoneSitePermissionsCheck$e={primaryText:"Tarkistetaan kameran ja mikrofonin käyttöoikeutta",secondaryText:"Salli käyttö, jos niin kehotetaan tekemään. Näin osallistujat voivat nähdä ja kuulla sinua.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",ariaLabel:"Tarkistetaan kameran ja mikrofonin käyttöoikeutta. Salli käyttö pyydettäessä."};var CameraSitePermissionsCheck$e={primaryText:"Tarkistetaan kameran käyttöoikeutta",secondaryText:"Salli käyttö, jos niin kehotetaan tekemään. Osallistujat näkevät sinut tässä.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman kameraa",ariaLabel:"Tarkistetaan kameran käyttöoikeutta. Salli käyttö pyydettäessä."};var MicrophoneSitePermissionsCheck$e={primaryText:"Tarkistetaan mikrofonin käyttöoikeutta",secondaryText:"Salli käyttö pyydettäessä. Tätä tarvitaan, jotta muut osallistujat kuulevat sinut.",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",primaryButtonText:"Jatka ilman mikrofonia",ariaLabel:"Tarkistetaan mikrofonin käyttöoikeutta. Salli käyttö pyydettäessä."};var CameraAndMicrophoneSitePermissionsDenied$e={primaryText:"Kameraa ja mikrofonia ei voi käyttää",secondaryText:"Myönnä mikrofonin käyttöoikeudet tälle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun päivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var CameraAndMicrophoneSitePermissionsDeniedSafari$e={primaryText:"Kameraa ja mikrofonia ei voi käyttää",secondaryText:"Salli käyttöoikeudet päivittämällä sivu tai tarkista tämän selaimen asetukset ja varmista, että käyttöoikeudet on otettu käyttöön tässä sivustossa.",primaryButtonText:"Jatka ilman kameraa ja mikrofonia",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var CameraSitePermissionsDenied$e={primaryText:"Kameraa ei voi käyttää",secondaryText:"Myönnä kameran käyttöoikeudet tälle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun päivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman kameraa",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var MicrophoneSitePermissionsDenied$e={primaryText:"Mikrofonia ei voi käyttää",secondaryText:"Myönnä mikrofonin käyttöoikeudet tälle verkkosivulle napsauttamalla osoiterivin lukkokuvaketta. Sivun päivitys saattaa olla pakollinen.",primaryButtonText:"Jatka ilman mikrofonia",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var CameraSitePermissionsDeniedSafari$e={primaryText:"Kameraa ei voi käyttää",secondaryText:"Salli käyttöoikeudet päivittämällä sivu tai tarkista tämän selaimen asetukset ja varmista, että käyttöoikeudet on otettu käyttöön tässä sivustossa.",primaryButtonText:"Jatka ilman kameraa",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var MicrophoneSitePermissionsDeniedSafari$e={primaryText:"Mikrofonia ei voi käyttää",secondaryText:"Salli käyttöoikeudet päivittämällä sivu tai tarkista tämän selaimen asetukset ja varmista, että käyttöoikeudet on otettu käyttöön tässä sivustossa.",primaryButtonText:"Jatka ilman mikrofonia",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var UnsupportedBrowser$e={primaryText:"Selainta ei tueta",secondaryText:"Liity tähän puheluun käyttämällä yhteensopivaa selainta.",moreHelpLinkText:"Näytä yhteensopivuusvaatimukset"};var UnsupportedBrowserVersion$e={primaryText:"Selain on päivitettävä",secondaryText:"Jotta puhelu olisi paras mahdollinen, päivitä selain ja yritä liittyä puheluun uudelleen.",moreHelpLinkText:"Näytä yhteensopivuusvaatimukset",continueAnywayButtonText:"Aloita puhelu päivittämättä"};var UnsupportedOperatingSystem$e={primaryText:"Käyttöjärjestelmää ei tueta",secondaryText:"Liity tähän puheluun käyttämällä laitetta, jossa on yhteensopiva käyttöjärjestelmä.",moreHelpLinkText:"Näytä yhteensopivuusvaatimukset"};var BrowserPermissionDenied$e={primaryText:"Kamerasi tai mikrofonisi käyttäminen ei onnistu",secondaryText:"Selaimesi ei ehkä voi käyttää kameraasi tai mikrofoniasi. Voit korjata tämän avaamalla Järjestelmäasetukset.",primaryButtonText:"Yritä uudelleen",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita"};var BrowserPermissionDeniedIOS$e={primaryText:"Jatka sallimalla mikrofonin käyttö",secondaryText:"Tarvitaan, jotta muut osallistujat kuulevat sinut.",primaryButtonText:"Yritä uudelleen",imageAltText:"Kohta, josta mikrofonin ja kameran käyttöoikeus löytyy iOS:issa",linkText:"Tarvitsetko apua? Hae vianmääritysohjeita",step1Text:"Siirry asetussovellukseen.",step2Text:"Vieritä alaspäin tämän selaimen asetuksiin",step3Text:"Ota mikrofoni käyttöön (kameran käyttö on valinnaista)",step4Text:"Yritä liittyä puheluun uudelleen",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$e={leftNavButtonAriaLabel:"edellinen sivu",rightNavButtonAriaLabel:"seuraava sivu"};var fi_FI$1 = {participantItem:participantItem$e,typingIndicator:typingIndicator$e,sendBox:sendBox$e,mentionPopover:mentionPopover$e,messageStatusIndicator:messageStatusIndicator$e,endCallButton:endCallButton$e,cameraButton:cameraButton$e,microphoneButton:microphoneButton$e,devicesButton:devicesButton$e,participantsButton:participantsButton$e,screenShareButton:screenShareButton$e,messageThread:messageThread$e,errorBar:errorBar$e,videoGallery:videoGallery$e,dialpad:dialpad$e,holdButton:holdButton$e,videoTile:videoTile$e,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$e,CameraSitePermissionsRequest:CameraSitePermissionsRequest$e,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$e,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$e,CameraSitePermissionsCheck:CameraSitePermissionsCheck$e,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$e,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$e,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$e,CameraSitePermissionsDenied:CameraSitePermissionsDenied$e,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$e,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$e,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$e,UnsupportedBrowser:UnsupportedBrowser$e,UnsupportedBrowserVersion:UnsupportedBrowserVersion$e,UnsupportedOperatingSystem:UnsupportedOperatingSystem$e,BrowserPermissionDenied:BrowserPermissionDenied$e,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$e,VerticalGallery:VerticalGallery$e};

var participantItem$d={isMeText:"(vous)",menuTitle:"Plus d’options",removeButtonLabel:"Supprimer",sharingIconLabel:"Partage",mutedIconLabel:"Muet activé",displayNamePlaceholder:"Participant sans nom",participantStateRinging:"Appel en cours...",participantStateHold:"En attente"};var typingIndicator$d={singleUser:"{user} en train d’écrire...",multipleUsers:"{users} sont en train d'écrire...",multipleUsersAbbreviateOne:"{users} et 1 autre en train d'écrire...",multipleUsersAbbreviateMany:"{users} et {numOthers} autres en train d’écrire...",delimiter:", "};var sendBox$d={placeholderText:"Saisir un message",textTooLong:"La longueur de votre message dépasse la limite maximale.",sendButtonAriaLabel:"Envoyer un message",fileUploadsPendingError:"Chargement en cours... Veuillez patienter.",removeFile:"Supprimer un fichier",uploading:"Chargement",uploadCompleted:"Téléchargement terminé"};var mentionPopover$d={mentionPopoverHeader:"Suggestions"};var messageStatusIndicator$d={deliveredAriaLabel:"Message envoyé",deliveredTooltipText:"Envoyé",seenAriaLabel:"Message vu par d’autres personnes",seenTooltipText:"Vu",readByTooltipText:"Lu par {messageThreadReadCount} participants sur {remoteParticipantsCount}",sendingAriaLabel:"Envoi du message",sendingTooltipText:"Envoi",failedToSendAriaLabel:"Échec d'envoi du message",failedToSendTooltipText:"Échec de l'envoi"};var endCallButton$d={label:"Quitter",tooltipContent:"Quitter l'appel"};var cameraButton$d={onLabel:"Désactiver",offLabel:"Activer",tooltipDisabledContent:"La caméra est désactivée.",tooltipOnContent:"Désactiver la caméra",tooltipOffContent:"Activer la caméra",tooltipVideoLoadingContent:"Chargement de la vidéo",cameraMenuTitle:"Caméra",cameraMenuTooltip:"Choisissez l'appareil photo",cameraButtonSplitRoleDescription:"Bouton partagé",onSplitButtonAriaLabel:"Désactiver les options d’appareil photo et d’appareil photo",offSplitButtonAriaLabel:"Activer les options d’appareil photo et d’appareil photo",cameraActionTurnedOnAnnouncement:"Votre caméra a été activée",cameraActionTurnedOffAnnouncement:"Votre caméra a été désactivée",onSplitButtonPrimaryActionCamera:"Désactiver l’appareil photo",offSplitButtonPrimaryActionCamera:"Activer la caméra",cameraPrimaryActionSplitButtonTitle:"Utiliser l’appareil photo",videoEffectsMenuItemTitle:"Effets"};var microphoneButton$d={onLabel:"Désactiver le son",offLabel:"Réactiver le son",tooltipDisabledContent:"Le microphone est désactivé.",tooltipOnContent:"Désactiver le micro",tooltipOffContent:"Activer le micro",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur",microphoneButtonSplitRoleDescription:"Bouton partagé",onSplitButtonAriaLabel:"Désactiver le micro et les options audio",offSplitButtonAriaLabel:"Activer le son du microphone et des options audio",microphoneActionTurnedOnAnnouncement:"Votre micro a été activé",microphoneActionTurnedOffAnnouncement:"Votre micro a été désactivé",offSplitButtonMicrophonePrimaryAction:"Activer le son du microphone",onSplitButtonMicrophonePrimaryAction:"Désactiver le microphone",microphonePrimaryActionSplitButtonTitle:"Utiliser le microphone"};var devicesButton$d={label:"Appareils",tooltipContent:"Gérer les appareils",cameraMenuTitle:"Appareil photo",cameraMenuTooltip:"Choisissez l'appareil photo",audioDeviceMenuTitle:"Périphérique audio",audioDeviceMenuTooltip:"Choisissez un périphérique audio",microphoneMenuTitle:"Microphone",microphoneMenuTooltip:"Choisissez le micro",speakerMenuTitle:"Haut-parleur",speakerMenuTooltip:"Choisissez le haut-parleur"};var participantsButton$d={label:"Personnes",tooltipContent:"Afficher les participants",menuHeader:"Pendant cet appel",participantsListButtonLabel:"{numParticipants} contacts",muteAllButtonLabel:"Désactiver tous les micros",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien d’invitation a été copié."};var screenShareButton$d={onLabel:"Arrêter la présentation",offLabel:"Présenter",tooltipDisabledContent:"La présentation est désactivée.",tooltipOnContent:"Présentation de votre écran",tooltipOffContent:"Présenter votre écran"};var messageThread$d={yesterday:"Hier",sunday:"Dimanche",monday:"Lundi",tuesday:"Mardi",wednesday:"Mercredi",thursday:"Jeudi",friday:"Vendredi",saturday:"Samedi",participantJoined:"a rejoint la conversation.",participantLeft:"a quitté le conversation.",editMessage:"Modifier",removeMessage:"Supprimer",resendMessage:"Réessayer l'envoi",failToSendTag:"Échec de l'envoi",editedTag:"Modifié",liveAuthorIntro:"{author} dit",messageContentAriaText:"{author} a dit {message}",messageContentMineAriaText:"Vous avez dit {message}",editBoxTextLimit:"Votre message dépasse la limite de {limitNumber} caractères",editBoxPlaceholderText:"Modifier votre message",newMessagesIndicator:"Nouveaux messages",noDisplayNameSub:"Sans nom",editBoxCancelButton:"Annuler",editBoxSubmitButton:"Envoyer",messageReadCount:"Lu par {messageReadByCount} participants sur {remoteParticipantsCount}",actionMenuMoreOptions:"Plus d’options",downloadFile:"Télécharger un fichier",blockedWarningText:"Ce message a été supprimé en raison d’une stratégie de l’organisation.",blockedWarningLinkText:"Détails",fileCardGroupMessage:"Le message a {fileCount} pièce jointe"};var errorBar$d={unableToReachChatService:"Vous êtes hors connexion",accessDenied:"Impossible d’accéder aux services de conversation. Vérifiez les informations d’identification de l’utilisateur fournies",userNotInChatThread:"Vous n’est plus dans ce thread de conversation",sendMessageNotInChatThread:"Échec de l’envoi du message car vous n’êtes plus dans ce thread de conversation",sendMessageGeneric:"Échec de l’envoi du message",callingNetworkFailure:"Perturbation de l’appel de connexion : vous semblez être hors connexion",startVideoGeneric:"Échec du démarrage de la vidéo",stopVideoGeneric:"Échec de l’arrêt de la vidéo",muteGeneric:"Échec de la désactivation du son du microphone",unmuteGeneric:"Échec de l’activation du son du microphone",speakingWhileMuted:"Votre micro est désactivé",startScreenShareGeneric:"Un problème est survenu durant le démarrage du partage d’écran.",stopScreenShareGeneric:"Échec de l’arrêt du partage d’écran",callNetworkQualityLow:"La qualité de réseau est faible.",callNoSpeakerFound:"Aucun haut-parleur ou casque n’a été trouvé. Connectez un périphérique audio pour entendre l’appel.",callNoMicrophoneFound:"Aucun micro n’a été trouvé. Connectez un périphérique d’entrée audio.",callMicrophoneAccessDenied:"Impossible d’accéder au microphone. Cliquez sur le verrou dans la barre d’adresses pour accorder l’autorisation à cette page Web.",callMicrophoneAccessDeniedSafari:"Impossible d’accéder au microphone. Actualisez la page pour autoriser les autorisations, ou vérifiez les paramètres de ce navigateur et vérifiez que les autorisations sont activées pour ce site web.",callMicrophoneMutedBySystem:"Votre micro est désactivé par votre système.",callMicrophoneUnmutedBySystem:"Votre micro a été récupéré et la son a été activé par votre système.",callMacOsMicrophoneAccessDenied:"Impossible d’accéder au microphone. Accordez l’autorisation de microphone dans vos paramètres de confidentialité macOS.",callLocalVideoFreeze:"La bande passante réseau est médiocre. Votre vidéo peut apparaître suspendue pour les autres participants à l’appel.",callCameraAccessDenied:"Impossible d’accéder à la caméra. Cliquez sur le verrou dans la barre d’adresses pour accorder l’autorisation à cette page Web.",callCameraAccessDeniedSafari:"Impossible d’accéder à la caméra. Actualisez la page pour autoriser les autorisations, ou vérifiez les paramètres de ce navigateur et vérifiez que les autorisations sont activées pour ce site web.",callCameraAlreadyInUse:"Impossible d’accéder à la caméra. Il est peut-être déjà utilisé par une autre application.",callVideoStoppedBySystem:"Votre vidéo a été arrêtée par votre système.",callVideoRecoveredBySystem:"Votre vidéo a repris.",callMacOsCameraAccessDenied:"MacOS bloque l’accès à votre caméra. Mettez à jour vos paramètres de confidentialité pour autoriser ce navigateur à accéder à votre caméra.",callMacOsScreenShareAccessDenied:"MacOS bloque le partage d’écran. Mettez à jour vos paramètres de confidentialité pour permettre à ce navigateur d’enregistrer votre écran.",dismissButtonAriaLabel:"Fermer",failedToJoinCallGeneric:"Nous n’avons pas pu rejoindre l’appel.",failedToJoinCallInvalidMeetingLink:"Impossible de rejoindre la réunion. Lien non valide.",cameraFrozenForRemoteParticipants:"Les utilisateurs de l’appel rencontrent des problèmes pour voir votre vidéo. Vérifiez vos appareils et votre réseau.",unableToStartVideoEffect:"Impossible d’appliquer l’effet vidéo."};var videoGallery$d={screenIsBeingSharedMessage:"Vous partagez votre écran.",screenShareLoadingMessage:"Chargement de l’écran de {participant}",localVideoLabel:"Vous",localVideoCameraSwitcherLabel:"Changer de caméra",localVideoMovementLabel:"Vignette de vidéo locale déplaçable",localVideoSelectedDescription:"{cameraName} sélectionnée",displayNamePlaceholder:"Participant sans nom",fitRemoteParticipantToFrame:"Ajuster à l'image",fillRemoteParticipantFrame:"Remplir l'image",pinParticipantForMe:"Épingler pour moi",pinParticipantForMeLimitReached:"Épingler (limite atteinte)",unpinParticipantForMe:"Détacher",pinParticipantMenuItemAriaLabel:"Épingler {participantName}",unpinParticipantMenuItemAriaLabel:"Détacher {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} a été épinglé",unpinnedParticipantAnnouncementAriaLabel:"{participantName} a été détaché"};var dialpad$d={placeholderText:"Entrer un numéro de téléphone",deleteButtonAriaLabel:"Supprimer"};var holdButton$d={onLabel:"Reprendre",offLabel:"Mettre en attente",tooltipOnContent:"Reprendre l’appel",tooltipOffContent:"Mettre l’appel en attente"};var videoTile$d={participantStateRinging:"Appel en cours...",participantStateHold:"En attente"};var CameraAndMicrophoneSitePermissionsRequest$d={primaryText:"Autoriser {appName} à utiliser votre caméra et votre microphone",secondaryText:"Cela permet aux participants de vous voir et de vous entendre.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans caméra ni micro",ariaLabel:"Autoriser l'accès à la caméra et au microphone"};var CameraSitePermissionsRequest$d={primaryText:"Autoriser {appName} à utiliser votre caméra",secondaryText:"Cela permet aux participants de vous voir.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans caméra",ariaLabel:"Autoriser l’accès à la caméra"};var MicrophoneSitePermissionsRequest$d={primaryText:"Autoriser {appName} à utiliser votre micro",secondaryText:"Cela permet aux participants de vous écouter.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans microphone",ariaLabel:"Autoriser l’accès au micro"};var CameraAndMicrophoneSitePermissionsCheck$d={primaryText:"Vérification de l’accès à la caméra et au microphone",secondaryText:"Autorisez l’accès si vous y êtes invité. Cela permet aux participants de vous voir et de vous entendre.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans caméra ni micro",ariaLabel:"Vérification de l’accès à la caméra et au microphone. Autorisez l’accès si vous y êtes invité."};var CameraSitePermissionsCheck$d={primaryText:"Vérification de l’accès à la caméra",secondaryText:"Autorisez l’accès si vous y êtes invité. Cela permet aux participants de vous voir.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans appareil photo",ariaLabel:"Vérification de l’accès à la caméra. Autorisez l’accès si vous y êtes invité."};var MicrophoneSitePermissionsCheck$d={primaryText:"Vérification de l’accès au microphone",secondaryText:"Autorisez l’accès si vous y êtes invité. Cela permet aux participants de vous entendre.",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",primaryButtonText:"Continuer sans microphone",ariaLabel:"Vérification de l’accès au microphone. Autorisez l’accès si vous y êtes invité."};var CameraAndMicrophoneSitePermissionsDenied$d={primaryText:"Nous n’avons pas pu accéder au micro et à la caméra.",secondaryText:"Cliquez sur l’icône de verrouillage dans la barre d’adresses pour accorder des autorisations de microphone à cette page Web. Une actualisation de page peut être nécessaire.",primaryButtonText:"Continuer sans caméra ni microphone",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var CameraAndMicrophoneSitePermissionsDeniedSafari$d={primaryText:"Nous n’avons pas pu accéder au micro et à la caméra.",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vérifiez les paramètres de ce navigateur et vérifiez que les autorisations sont activées pour ce site web.",primaryButtonText:"Continuer sans caméra ni microphone",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var CameraSitePermissionsDenied$d={primaryText:"Impossible d’accéder à la caméra",secondaryText:"Cliquez sur l’icône de verrouillage dans la barre d’adresses pour accorder des autorisations d’appareil photo à cette page Web. Une actualisation de page peut être nécessaire.",primaryButtonText:"Continuer sans caméra",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var MicrophoneSitePermissionsDenied$d={primaryText:"Nous n’avons pas pu accéder au micro.",secondaryText:"Cliquez sur l’icône de verrouillage dans la barre d’adresses pour accorder des autorisations de microphone à cette page Web. Une actualisation de page peut être nécessaire.",primaryButtonText:"Continuer sans microphone",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var CameraSitePermissionsDeniedSafari$d={primaryText:"Nous n’avons pas pu accéder à la caméra.",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vérifiez les paramètres de ce navigateur et vérifiez que les autorisations sont activées pour ce site web.",primaryButtonText:"Continuer sans appareil photo",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var MicrophoneSitePermissionsDeniedSafari$d={primaryText:"Impossible d’accéder au microphone",secondaryText:"Actualisez la page pour autoriser les autorisations, ou vérifiez les paramètres de ce navigateur et vérifiez que les autorisations sont activées pour ce site web.",primaryButtonText:"Continuer sans microphone",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var UnsupportedBrowser$d={primaryText:"Navigateur non pris en charge",secondaryText:"Rejoignez cet appel à l’aide d’un navigateur compatible.",moreHelpLinkText:"Voir les exigences de compatibilité"};var UnsupportedBrowserVersion$d={primaryText:"Mise à jour du navigateur nécessaire",secondaryText:"Pour garantir le meilleur appel possible, mettez à jour votre navigateur, puis réessayez de rejoindre l’appel.",moreHelpLinkText:"Voir les exigences de compatibilité",continueAnywayButtonText:"Démarrer l’appel sans mettre à jour"};var UnsupportedOperatingSystem$d={primaryText:"Système d'exploitation non pris en charge",secondaryText:"Rejoignez cet appel à l’aide d’un appareil avec un système d’exploitation compatible.",moreHelpLinkText:"Voir les exigences de compatibilité"};var BrowserPermissionDenied$d={primaryText:"Impossible d’utiliser votre caméra ou votre micro",secondaryText:"Votre navigateur n’a peut-être pas accès à votre caméra ou à votre micro. Pour résoudre ce problème, ouvrez Préférences système.",primaryButtonText:"Réessayer",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes"};var BrowserPermissionDeniedIOS$d={primaryText:"Autoriser l’accès au microphone pour continuer",secondaryText:"Ainsi, les autres participants peuvent vous entendre.",primaryButtonText:"Réessayer",imageAltText:"Emplacement des autorisations pour le microphone et la caméra pour iOS",linkText:"Besoin d’aide ? Obtenir de l’aide sur la résolution des problèmes",step1Text:"Accéder à l’application Paramètres",step2Text:"Faites défiler vers le bas pour accéder aux paramètres de ce navigateur",step3Text:"Activer le microphone (caméra facultative)",step4Text:"Réessayez de rejoindre l’appel",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$d={leftNavButtonAriaLabel:"page précédente",rightNavButtonAriaLabel:"page suivante"};var fr_FR$1 = {participantItem:participantItem$d,typingIndicator:typingIndicator$d,sendBox:sendBox$d,mentionPopover:mentionPopover$d,messageStatusIndicator:messageStatusIndicator$d,endCallButton:endCallButton$d,cameraButton:cameraButton$d,microphoneButton:microphoneButton$d,devicesButton:devicesButton$d,participantsButton:participantsButton$d,screenShareButton:screenShareButton$d,messageThread:messageThread$d,errorBar:errorBar$d,videoGallery:videoGallery$d,dialpad:dialpad$d,holdButton:holdButton$d,videoTile:videoTile$d,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$d,CameraSitePermissionsRequest:CameraSitePermissionsRequest$d,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$d,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$d,CameraSitePermissionsCheck:CameraSitePermissionsCheck$d,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$d,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$d,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$d,CameraSitePermissionsDenied:CameraSitePermissionsDenied$d,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$d,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$d,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$d,UnsupportedBrowser:UnsupportedBrowser$d,UnsupportedBrowserVersion:UnsupportedBrowserVersion$d,UnsupportedOperatingSystem:UnsupportedOperatingSystem$d,BrowserPermissionDenied:BrowserPermissionDenied$d,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$d,VerticalGallery:VerticalGallery$d};

var participantItem$c={isMeText:"(אתה)",menuTitle:"אפשרויות נוספות",removeButtonLabel:"הסר",sharingIconLabel:"משתף",mutedIconLabel:"מושתק",displayNamePlaceholder:"משתתף ללא שם",participantStateRinging:"מתקשר...",participantStateHold:"בהמתנה"};var typingIndicator$c={singleUser:"{user} מקליד...",multipleUsers:"{users} מקלידים...",multipleUsersAbbreviateOne:"{users} ומשתמש אחד נוסף מקלידים...",multipleUsersAbbreviateMany:"{users} ו{numOthers} אחרים מקלידים...",delimiter:", "};var sendBox$c={placeholderText:"הזן הודעה",textTooLong:"אורך ההודעה שלך חורג מהמגבלה המרבית.",sendButtonAriaLabel:"שלח הודעה",fileUploadsPendingError:"מעלה... אנא המתן.",removeFile:"הסר קובץ",uploading:"מעלה",uploadCompleted:"ההעלאה הושלמה"};var mentionPopover$c={mentionPopoverHeader:"הצעות"};var messageStatusIndicator$c={deliveredAriaLabel:"ההודעה נשלחה",deliveredTooltipText:"‏‏נשלח",seenAriaLabel:"הודעה שנראתה על-ידי אחרים",seenTooltipText:"נראה",readByTooltipText:"נקרא על-ידי {messageThreadReadCount} מתוך {remoteParticipantsCount}",sendingAriaLabel:"שליחת הודעה",sendingTooltipText:"שולח",failedToSendAriaLabel:"שליחת ההודעה נכשלה",failedToSendTooltipText:"השליחה נכשלה"};var endCallButton$c={label:"עזוב",tooltipContent:"עזוב את השיחה"};var cameraButton$c={onLabel:"כבה",offLabel:"הפעל",tooltipDisabledContent:"המצלמה אינה זמינה",tooltipOnContent:"כבה מצלמה",tooltipOffContent:"הפעל מצלמה",tooltipVideoLoadingContent:"הווידאו נטען",cameraMenuTitle:"מצלמה",cameraMenuTooltip:"בחר מצלמה",cameraButtonSplitRoleDescription:"לחצן פיצול",onSplitButtonAriaLabel:"כבה את אפשרויות המצלמה והמצלמה",offSplitButtonAriaLabel:"הפעל אפשרויות מצלמה ומצלמה",cameraActionTurnedOnAnnouncement:"המצלמה שלך הופעלה",cameraActionTurnedOffAnnouncement:"המצלמה שלך כבויה",onSplitButtonPrimaryActionCamera:"כבה מצלמה",offSplitButtonPrimaryActionCamera:"הפעל את המצלמה",cameraPrimaryActionSplitButtonTitle:"השתמש במצלמה",videoEffectsMenuItemTitle:"אפקטים"};var microphoneButton$c={onLabel:"השתק",offLabel:"בטל השתקה",tooltipDisabledContent:"המיקרופון אינו זמין",tooltipOnContent:"השתק מיקרופון",tooltipOffContent:"בטל השתקה של מיקרופון",microphoneMenuTitle:"מיקרופון",microphoneMenuTooltip:"בחר מיקרופון",speakerMenuTitle:"רמקול",speakerMenuTooltip:"בחר רמקול",microphoneButtonSplitRoleDescription:"לחצן פיצול",onSplitButtonAriaLabel:"השתק אפשרויות מיקרופון ושמע",offSplitButtonAriaLabel:"בטל השתקה של אפשרויות מיקרופון ושמע",microphoneActionTurnedOnAnnouncement:"המיקרופון שלך הופעל",microphoneActionTurnedOffAnnouncement:"המיקרופון שלך כובה",offSplitButtonMicrophonePrimaryAction:"בטל את ההשתקה של המיקרופון",onSplitButtonMicrophonePrimaryAction:"השתק את המיקרופון",microphonePrimaryActionSplitButtonTitle:"השתמש במיקרופון"};var devicesButton$c={label:"מכשירים",tooltipContent:"נהל מכשירים",cameraMenuTitle:"מצלמה",cameraMenuTooltip:"בחר מצלמה",audioDeviceMenuTitle:"התקן שמע",audioDeviceMenuTooltip:"בחר התקן שמע",microphoneMenuTitle:"מיקרופון",microphoneMenuTooltip:"בחר מיקרופון",speakerMenuTitle:"רמקול",speakerMenuTooltip:"בחר רמקול"};var participantsButton$c={label:"אנשים",tooltipContent:"הצג משתתפים",menuHeader:"בשיחה זו",participantsListButtonLabel:"{numParticipants} אנשים",muteAllButtonLabel:"השתק הכל",copyInviteLinkButtonLabel:"העתק קישור הזמנה",copyInviteLinkActionedAriaLabel:"קישור ההזמנה הועתק"};var screenShareButton$c={onLabel:"הפסק להציג",offLabel:"נוכח",tooltipDisabledContent:"הצגה אינה זמינה",tooltipOnContent:"מציג את המסך שלך",tooltipOffContent:"הצג את המסך שלך"};var messageThread$c={yesterday:"אתמול",sunday:"יום ראשון",monday:"יום שני",tuesday:"שלישי",wednesday:"יום רביעי",thursday:"יום חמישי",friday:"יום שישי",saturday:"יום שבת",participantJoined:"הצטרף לצ'אט.",participantLeft:"עזב את הצ'אט.",editMessage:"ערוך",removeMessage:"מחק",resendMessage:"נסה לשלוח שוב",failToSendTag:"השליחה נכשלה",editedTag:"נערך",liveAuthorIntro:"{author} אומר",messageContentAriaText:"{author} אמר {message}",messageContentMineAriaText:"אמרת {message}",editBoxTextLimit:"ההודעה שלך נמצאת מעבר למגבלה של {limitNumber} תווים",editBoxPlaceholderText:"ערוך את ההודעה שלך",newMessagesIndicator:"הודעות חדשות",noDisplayNameSub:"ללא שם",editBoxCancelButton:"בטל",editBoxSubmitButton:"שלח",messageReadCount:"נקרא על-ידי {messageReadByCount} מתוך {remoteParticipantsCount}",actionMenuMoreOptions:"אפשרויות נוספות",downloadFile:"הורד קובץ",blockedWarningText:"הודעה זו נמחקה עקב מדיניות ארגונית.",blockedWarningLinkText:"פרטים",fileCardGroupMessage:"ההודעה כוללת קובץ מצורף {fileCount}"};var errorBar$c={unableToReachChatService:"אתה נמצא במצב לא מקוון",accessDenied:"לא ניתן לגשת אל שירותי צ'אט - בדוק את אישורי המשתמש שסופקו",userNotInChatThread:"אינך נמצא עוד בהליך משנה זה של צ'אט",sendMessageNotInChatThread:"שליחת ההודעה נכשלה מכיוון שאתה כבר לא נמצא בהליך משנה זה של צ'אט",sendMessageGeneric:"שליחת ההודעה נכשלה",callingNetworkFailure:"ממתקשה בחיבור השיחה - נראה שאתה לא מקוון",startVideoGeneric:"הפעלת סרטון הווידאו נכשלה",stopVideoGeneric:"הפסקת הווידאו נכשלה",muteGeneric:"השתקת המיקרופון נכשלה",unmuteGeneric:"ביטול השתקת המיקרופון נכשל",speakingWhileMuted:"המיקרופון שלך מושתק",startScreenShareGeneric:"הייתה בעיה בהפעלת שיתוף מסך.",stopScreenShareGeneric:"הפסקת שיתוף המסכים נכשלה",callNetworkQualityLow:"איכות הרשת נמוכה.",callNoSpeakerFound:"לא נמצאו רמקולים או אוזניות. חבר התקן שמע כדי לשמוע את השיחה.",callNoMicrophoneFound:"לא נמצאו מיקרופונים. חבר התקן קלט שמע.",callMicrophoneAccessDenied:"לא ניתן לגשת למיקרופון. לחץ על הנעילה בשורת הכתובת כדי להעניק הרשאה לדף אינטרנט זה.",callMicrophoneAccessDeniedSafari:"לא ניתן לגשת למיקרופון. רענן את הדף כדי לאפשר הרשאות, או בדוק את ההגדרות של דפדפן זה וודא שהרשאות זמינות עבור אתר אינטרנט זה.",callMicrophoneMutedBySystem:"אתה מושתק על-ידי המערכת שלך.",callMicrophoneUnmutedBySystem:"המיקרופון שלך התאושש והמערכת שלך ביטלה את ההשתקה.",callMacOsMicrophoneAccessDenied:"לא ניתן לגשת למיקרופון. הענק הרשאת מיקרופון בהגדרות הפרטיות של macOS.",callLocalVideoFreeze:"רוחב הפס של הרשת גרוע. ייתכן שהווידאו שלך יופיע מושהה עבור אחרים בשיחה.",callCameraAccessDenied:"לא ניתן לגשת למצלמה. לחץ על הנעילה בשורת הכתובת כדי להעניק הרשאה לדף אינטרנט זה.",callCameraAccessDeniedSafari:"לא ניתן לגשת למצלמה. רענן את הדף כדי לאפשר הרשאות, או בדוק את ההגדרות של דפדפן זה וודא שהרשאות זמינות עבור אתר אינטרנט זה.",callCameraAlreadyInUse:"לא ניתן לגשת למצלמה. ייתכן שהוא כבר נמצא בשימוש על-ידי יישום אחר.",callVideoStoppedBySystem:"הווידאו שלך הופסק על-ידי המערכת.",callVideoRecoveredBySystem:"הווידאו שלך התחדש.",callMacOsCameraAccessDenied:"MacOS חוסם את הגישה למצלמה שלך. עדכן את הגדרות הפרטיות שלך כדי לאפשר לדפדפן זה לגשת למצלמה שלך.",callMacOsScreenShareAccessDenied:"MacOS חוסם שיתוף מסכים. עדכן את הגדרות הפרטיות שלך כדי לאפשר לדפדפן זה להקליט את המסך שלך.",dismissButtonAriaLabel:"סגור",failedToJoinCallGeneric:"הצטרפות לשיחה נכשלה.",failedToJoinCallInvalidMeetingLink:"לא ניתן להצטרף לפגישה. קישור לא חוקי.",cameraFrozenForRemoteParticipants:"משתמשים בשיחה נתקלים בבעיות בהצגת הווידאו שלך. בדוק את המכשירים ואת הרשת שלך.",unableToStartVideoEffect:"לא ניתן להחיל אפקט וידאו."};var videoGallery$c={screenIsBeingSharedMessage:"אתה משתף את המסך שלך",screenShareLoadingMessage:"טוען את המסך של {participant}",localVideoLabel:"אתה",localVideoCameraSwitcherLabel:"החלף מצלמה",localVideoMovementLabel:"אריח וידאו מקומי נשלף",localVideoSelectedDescription:"{cameraName} נבחר",displayNamePlaceholder:"משתתף ללא שם",fitRemoteParticipantToFrame:"התאם למסגרת",fillRemoteParticipantFrame:"מלא את המסגרת",pinParticipantForMe:"הצמד עבורי",pinParticipantForMeLimitReached:"הצמדה (הגעת למגבלה)",unpinParticipantForMe:"בטל הצמדה",pinParticipantMenuItemAriaLabel:"הצמד את {participantName}",unpinParticipantMenuItemAriaLabel:"בטל את הצמדת {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} הוצמד",unpinnedParticipantAnnouncementAriaLabel:"הצמדת {participantName} בוטלה"};var dialpad$c={placeholderText:"הזן מספר טלפון",deleteButtonAriaLabel:"מחק"};var holdButton$c={onLabel:"המשך",offLabel:"החזק",tooltipOnContent:"חדש שיחה",tooltipOffContent:"השהה שיחה"};var videoTile$c={participantStateRinging:"מתקשר...",participantStateHold:"בהמתנה"};var CameraAndMicrophoneSitePermissionsRequest$c={primaryText:"אפשר {appName} להשתמש במצלמה ובמיקרופון שלך",secondaryText:"זה כדי שהמשתתפים יוכלו לראות ולשמוע אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מצלמה ומיקרופון",ariaLabel:"אפשר גישה למצלמה ולמיקרופון"};var CameraSitePermissionsRequest$c={primaryText:"אפשר {appName} להשתמש במצלמה שלך",secondaryText:"זה כדי שהמשתתפים יוכלו לראות אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מצלמה",ariaLabel:"אפשר גישה למצלמה"};var MicrophoneSitePermissionsRequest$c={primaryText:"אפשר {appName} להשתמש במיקרופון שלך",secondaryText:"זה כדי שהמשתתפים יוכלו לשמוע אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מיקרופון",ariaLabel:"אפשר גישה למיקרופון"};var CameraAndMicrophoneSitePermissionsCheck$c={primaryText:"בודק אם קיימת גישה למצלמה ולמיקרופון",secondaryText:"אפשר גישה אם תתבקש לעשות זאת. זה כדי שהמשתתפים יוכלו לראות ולשמוע אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מצלמה ומיקרופון",ariaLabel:"בודק אם קיימת גישה למצלמה ולמיקרופון. אפשר גישה אם תתבקש לעשות זאת."};var CameraSitePermissionsCheck$c={primaryText:"בודק אם קיימת גישה למצלמה",secondaryText:"אפשר גישה אם תתבקש לעשות זאת. זה כדי שהמשתתפים יוכלו לראות אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מצלמה",ariaLabel:"בודק אם קיימת גישה למצלמה. אפשר גישה אם תתבקש לעשות זאת."};var MicrophoneSitePermissionsCheck$c={primaryText:"בודק אם קיימת גישה למיקרופון",secondaryText:"אפשר גישה אם תתבקש לעשות זאת. זה כדי שהמשתתפים יוכלו לשמוע אותך.",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",primaryButtonText:"המשך ללא מיקרופון",ariaLabel:"בודק אם קיימת גישה למיקרופון. אפשר גישה אם תתבקש לעשות זאת."};var CameraAndMicrophoneSitePermissionsDenied$c={primaryText:"לא ניתן לגשת למצלמה ולמיקרופון",secondaryText:"לחץ על סמל המנעול בשורת הכתובת כדי להעניק הרשאות מיקרופון לדף אינטרנט זה. ייתכן שיידרש רענון דף.",primaryButtonText:"המשך ללא מצלמה ומיקרופון",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var CameraAndMicrophoneSitePermissionsDeniedSafari$c={primaryText:"לא ניתן לגשת למצלמה ולמיקרופון",secondaryText:"רענן את הדף כדי לאפשר הרשאות, או בדוק את ההגדרות של דפדפן זה וודא שהרשאות זמינות עבור אתר אינטרנט זה.",primaryButtonText:"המשך ללא מצלמה ומיקרופון",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var CameraSitePermissionsDenied$c={primaryText:"לא ניתן לגשת למצלמה",secondaryText:"לחץ על סמל המנעול בשורת הכתובת כדי להעניק הרשאות מצלמה לדף אינטרנט זה. ייתכן שיידרש רענון דף.",primaryButtonText:"המשך ללא מצלמה",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var MicrophoneSitePermissionsDenied$c={primaryText:"לא ניתן לגשת למיקרופון",secondaryText:"לחץ על סמל המנעול בשורת הכתובת כדי להעניק הרשאות מיקרופון לדף אינטרנט זה. ייתכן שיידרש רענון דף.",primaryButtonText:"המשך ללא מיקרופון",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var CameraSitePermissionsDeniedSafari$c={primaryText:"לא ניתן לגשת למצלמה",secondaryText:"רענן את הדף כדי לאפשר הרשאות, או בדוק את ההגדרות של דפדפן זה וודא שהרשאות זמינות עבור אתר אינטרנט זה.",primaryButtonText:"המשך ללא מצלמה",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var MicrophoneSitePermissionsDeniedSafari$c={primaryText:"לא ניתן לגשת למיקרופון",secondaryText:"רענן את הדף כדי לאפשר הרשאות, או בדוק את ההגדרות של דפדפן זה וודא שהרשאות זמינות עבור אתר אינטרנט זה.",primaryButtonText:"המשך ללא מיקרופון",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var UnsupportedBrowser$c={primaryText:"הדפדפן אינו נתמך",secondaryText:"הצטרף לשיחה זו באמצעות דפדפן תואם.",moreHelpLinkText:"ראה דרישות תאימות"};var UnsupportedBrowserVersion$c={primaryText:"‏‏נדרש עדכון דפדפן",secondaryText:"כדי להבטיח את השיחה הטובה ביותר האפשרית, עדכן את הדפדפן ולאחר מכן נסה להצטרף שוב לשיחה.",moreHelpLinkText:"ראה דרישות תאימות",continueAnywayButtonText:"התחל שיחה מבלי לעדכן"};var UnsupportedOperatingSystem$c={primaryText:"מערכת ההפעלה אינה נתמכת",secondaryText:"הצטרף לשיחה זו באמצעות התקן עם מערכת הפעלה תואמת.",moreHelpLinkText:"ראה דרישות תאימות"};var BrowserPermissionDenied$c={primaryText:"לא ניתן להשתמש במצלמה או במיקרופון שלך",secondaryText:"ייתכן שלדפדפן שלך אין גישה למצלמה או למיקרופון שלך. כדי לפתור בעיה זו, פתח את 'העדפות מערכת'.",primaryButtonText:"נסה שוב",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות"};var BrowserPermissionDeniedIOS$c={primaryText:"אפשר גישה למיקרופון כדי להמשיך",secondaryText:"כך שמשתתפים אחרים יוכלו לשמוע אותך.",primaryButtonText:"נסה שוב",imageAltText:"מיקום הרשאה של מיקרופון והתקן מצלמה עבור iOS",linkText:"זקוק לעזרה? קבל עזרה עבור פתרון בעיות",step1Text:"עבור אל האפליקציה 'הגדרות'",step2Text:"גלול למטה להגדרות עבור דפדפן זה",step3Text:"הפעל מיקרופון (מצלמה אופציונלית)",step4Text:"נסה להצטרף שוב לשיחה",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$c={leftNavButtonAriaLabel:"הדף הקודם",rightNavButtonAriaLabel:"הדף הבא"};var he_IL$1 = {participantItem:participantItem$c,typingIndicator:typingIndicator$c,sendBox:sendBox$c,mentionPopover:mentionPopover$c,messageStatusIndicator:messageStatusIndicator$c,endCallButton:endCallButton$c,cameraButton:cameraButton$c,microphoneButton:microphoneButton$c,devicesButton:devicesButton$c,participantsButton:participantsButton$c,screenShareButton:screenShareButton$c,messageThread:messageThread$c,errorBar:errorBar$c,videoGallery:videoGallery$c,dialpad:dialpad$c,holdButton:holdButton$c,videoTile:videoTile$c,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$c,CameraSitePermissionsRequest:CameraSitePermissionsRequest$c,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$c,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$c,CameraSitePermissionsCheck:CameraSitePermissionsCheck$c,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$c,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$c,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$c,CameraSitePermissionsDenied:CameraSitePermissionsDenied$c,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$c,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$c,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$c,UnsupportedBrowser:UnsupportedBrowser$c,UnsupportedBrowserVersion:UnsupportedBrowserVersion$c,UnsupportedOperatingSystem:UnsupportedOperatingSystem$c,BrowserPermissionDenied:BrowserPermissionDenied$c,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$c,VerticalGallery:VerticalGallery$c};

var participantItem$b={isMeText:"(tu)",menuTitle:"Altre opzioni",removeButtonLabel:"Rimuovi",sharingIconLabel:"Condivisione",mutedIconLabel:"Disattivato",displayNamePlaceholder:"Partecipante senza nome",participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa"};var typingIndicator$b={singleUser:"{user} sta scrivendo ...",multipleUsers:"{users} stanno scrivendo ...",multipleUsersAbbreviateOne:"{users} e 1 altro stanno scrivendo ...",multipleUsersAbbreviateMany:"{users} e {numOthers} altri stanno scrivendo ...",delimiter:", "};var sendBox$b={placeholderText:"Immetti un messaggio",textTooLong:"La lunghezza del messaggio supera il limite massimo.",sendButtonAriaLabel:"Invio messaggio",fileUploadsPendingError:"Caricamento in corso... Attendere.",removeFile:"Rimuovi file",uploading:"Caricamento in corso",uploadCompleted:"Caricamento completato"};var mentionPopover$b={mentionPopoverHeader:"Suggerimenti"};var messageStatusIndicator$b={deliveredAriaLabel:"Il messaggio è stato inviato",deliveredTooltipText:"Inviato",seenAriaLabel:"Messaggio visualizzato da altri utenti",seenTooltipText:"Visualizzato",readByTooltipText:"Letto da {messageThreadReadCount} di {remoteParticipantsCount}",sendingAriaLabel:"Invio del messaggio",sendingTooltipText:"Invio in corso",failedToSendAriaLabel:"Invio messaggio non riuscito",failedToSendTooltipText:"Invio non riuscito"};var endCallButton$b={label:"Permesso",tooltipContent:"Abbandona chiamata"};var cameraButton$b={onLabel:"Disabilita",offLabel:"Abilita",tooltipDisabledContent:"La videocamera è disabilitata",tooltipOnContent:"Spegni la videocamera",tooltipOffContent:"Accendi la videocamera",tooltipVideoLoadingContent:"Il video è in corso di caricamento",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",cameraButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva fotocamera e le opzioni della fotocamera",offSplitButtonAriaLabel:"Attiva fotocamera e le opzioni della fotocamera",cameraActionTurnedOnAnnouncement:"La videocamera è stata attivata",cameraActionTurnedOffAnnouncement:"La videocamera è stata disattivata",onSplitButtonPrimaryActionCamera:"Spegni la videocamera",offSplitButtonPrimaryActionCamera:"Accendi la videocamera",cameraPrimaryActionSplitButtonTitle:"Usa la fotocamera",videoEffectsMenuItemTitle:"Effetti"};var microphoneButton$b={onLabel:"Disattiva audio",offLabel:"Riattiva audio",tooltipDisabledContent:"Il microfono è disabilitato",tooltipOnContent:"Disattiva microfono",tooltipOffContent:"Riattiva microfono",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante",microphoneButtonSplitRoleDescription:"Pulsante di menu combinato",onSplitButtonAriaLabel:"Disattiva microfono e opzioni audio",offSplitButtonAriaLabel:"Attiva microfono e opzioni audio",microphoneActionTurnedOnAnnouncement:"Il microfono è stato attivato",microphoneActionTurnedOffAnnouncement:"Il microfono è stato disattivato",offSplitButtonMicrophonePrimaryAction:"Riattiva microfono",onSplitButtonMicrophonePrimaryAction:"Disattiva microfono",microphonePrimaryActionSplitButtonTitle:"Usa il microfono"};var devicesButton$b={label:"Dispositivi",tooltipContent:"Gestisci dispositivi",cameraMenuTitle:"Fotocamera",cameraMenuTooltip:"Scegli fotocamera",audioDeviceMenuTitle:"Dispositivo audio",audioDeviceMenuTooltip:"Scegli dispositivo audio",microphoneMenuTitle:"Microfono",microphoneMenuTooltip:"Scegli microfono",speakerMenuTitle:"Altoparlante",speakerMenuTooltip:"Scegli altoparlante"};var participantsButton$b={label:"Persone",tooltipContent:"Mostra partecipanti",menuHeader:"In questa chiamata",participantsListButtonLabel:"{numParticipants} persone",muteAllButtonLabel:"Disattiva l'audio di tutti",copyInviteLinkButtonLabel:"Copia il collegamento dell’invito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato"};var screenShareButton$b={onLabel:"Interrompi presentazione",offLabel:"Presentazione",tooltipDisabledContent:"La presentazione è disabilitata.",tooltipOnContent:"Presentazione dello schermo",tooltipOffContent:"Presenta lo schermo"};var messageThread$b={yesterday:"Ieri",sunday:"Domenica",monday:"Lunedì",tuesday:"Martedì",wednesday:"Mercoledì",thursday:"Giovedì",friday:"Venerdì",saturday:"Sabato",participantJoined:"si è unito alla chat.",participantLeft:"ha abbandonato la chat.",editMessage:"Modifica",removeMessage:"Elimina",resendMessage:"Riprova a inviare",failToSendTag:"Invio non riuscito",editedTag:"Modificato",liveAuthorIntro:"{author} dice",messageContentAriaText:"{author} ha detto {message}",messageContentMineAriaText:"Hai detto {message}",editBoxTextLimit:"Il messaggio ha superato il limite di caratteri {limitNumber}",editBoxPlaceholderText:"Modifica il messaggio",newMessagesIndicator:"Nuovi messaggi",noDisplayNameSub:"Nessun nome",editBoxCancelButton:"Annulla",editBoxSubmitButton:"Invia",messageReadCount:"Letto da {messageReadByCount} di {remoteParticipantsCount}",actionMenuMoreOptions:"Altre opzioni",downloadFile:"Scarica file",blockedWarningText:"Questo messaggio è stato eliminato a causa dei criteri dell'organizzazione.",blockedWarningLinkText:"Dettagli",fileCardGroupMessage:"Il messaggio contiene {fileCount} allegato"};var errorBar$b={unableToReachChatService:"Sei offline",accessDenied:"Non è possibile accedere ai servizi di chat. Controllare le credenziali utente specificate",userNotInChatThread:"Non fai più parte di questo thread di chat",sendMessageNotInChatThread:"Non è stato possibile inviare il messaggio perché non sei più in questo thread di chat",sendMessageGeneric:"Impossibile inviare il messaggio",callingNetworkFailure:"Problema di connessione della chiamata: sembra che tu sia offline",startVideoGeneric:"Non è stato possibile avviare il video",stopVideoGeneric:"Non è stato possibile arrestare il video",muteGeneric:"Non è stato possibile disattivare l'audio del microfono",unmuteGeneric:"Non è stato possibile riattivare l'audio del microfono",speakingWhileMuted:"Il microfono è disattivato",startScreenShareGeneric:"Si è verificato un problema durante l'avvio della condivisione dello schermo.",stopScreenShareGeneric:"Non è stato possibile arrestare la condivisione dello schermo",callNetworkQualityLow:"La qualità della rete è bassa.",callNoSpeakerFound:"Non sono stati trovati altoparlanti o cuffie. Connetti un dispositivo audio per ascoltare la chiamata.",callNoMicrophoneFound:"Nessun microfono trovato. Connetti un dispositivo di input audio.",callMicrophoneAccessDenied:"Impossibile accedere al microfono. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callMicrophoneAccessDeniedSafari:"Impossibile accedere al microfono. Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",callMicrophoneMutedBySystem:"Il sistema disattiva l'audio.",callMicrophoneUnmutedBySystem:"Il microfono è stato ripristinato e il sistema ha riattivato l'audio.",callMacOsMicrophoneAccessDenied:"Impossibile accedere al microfono. Concedi l'autorizzazione al microfono nelle impostazioni di privacy di macOS.",callLocalVideoFreeze:"Larghezza di banda di rete insufficiente. Il video potrebbe essere sospeso per gli altri partecipanti alla chiamata.",callCameraAccessDenied:"Non è possibile accedere alla fotocamera. Fare clic sul blocco nella barra degli indirizzi per concedere l'autorizzazione a questa pagina Web.",callCameraAccessDeniedSafari:"Non è possibile accedere alla fotocamera. Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",callCameraAlreadyInUse:"Non è possibile accedere alla fotocamera. Potrebbe essere già in uso da un'altra applicazione.",callVideoStoppedBySystem:"Il video è stato arrestato dal sistema.",callVideoRecoveredBySystem:"Il video è ripreso.",callMacOsCameraAccessDenied:"MacOS sta bloccando l'accesso alla fotocamera. Aggiorna le impostazioni di privacy per consentire a questo browser di accedere alla fotocamera.",callMacOsScreenShareAccessDenied:"MacOS sta bloccando la condivisione dello schermo. Aggiorna le impostazioni di privacy per consentire a questo browser di registrare lo schermo.",dismissButtonAriaLabel:"Chiudi",failedToJoinCallGeneric:"Non è stato possibile partecipare alla chiamata.",failedToJoinCallInvalidMeetingLink:"Impossibile partecipare alla riunione. Collegamento non valido.",cameraFrozenForRemoteParticipants:"Gli utenti della chiamata hanno problemi a visualizzare il video. Controllare i dispositivi e la rete.",unableToStartVideoEffect:"Non è possibile applicare l'effetto video."};var videoGallery$b={screenIsBeingSharedMessage:"Stai condividendo lo schermo",screenShareLoadingMessage:"Caricamento dello schermo di {participant}",localVideoLabel:"Tu",localVideoCameraSwitcherLabel:"Cambia videocamera",localVideoMovementLabel:"Riquadro video locale mobile",localVideoSelectedDescription:"{cameraName} selezionata",displayNamePlaceholder:"Partecipante senza nome",fitRemoteParticipantToFrame:"Adatta all'inquadratura",fillRemoteParticipantFrame:"Riempi l'inquadratura",pinParticipantForMe:"Aggiungi per me",pinParticipantForMeLimitReached:"Segnaposto (limite raggiunto)",unpinParticipantForMe:"Rimuovi",pinParticipantMenuItemAriaLabel:"Aggiungi {participantName}",unpinParticipantMenuItemAriaLabel:"Rimuovi {participantName}",pinnedParticipantAnnouncementAriaLabel:"{participantName} aggiunto",unpinnedParticipantAnnouncementAriaLabel:"{participantName} sbloccato"};var dialpad$b={placeholderText:"Inserisci numero di telefono",deleteButtonAriaLabel:"Elimina"};var holdButton$b={onLabel:"Riprendi",offLabel:"Mantenere",tooltipOnContent:"Riprendi chiamata",tooltipOffContent:"Metti in attesa chiamata"};var videoTile$b={participantStateRinging:"Chiamata in corso...",participantStateHold:"Per l'attesa"};var CameraAndMicrophoneSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare la fotocamera e il microfono",secondaryText:"In questo modo i partecipanti possono vederti e sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera e microfono",ariaLabel:"Consenti l'accesso alla fotocamera e al microfono"};var CameraSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare la fotocamera",secondaryText:"In questo modo i partecipanti possono vederti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera",ariaLabel:"Consenti l'accesso alla fotocamera"};var MicrophoneSitePermissionsRequest$b={primaryText:"Consenti a {appName} di usare il microfono",secondaryText:"In questo modo i partecipanti possono sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza microfono",ariaLabel:"Consenti l'accesso al microfono"};var CameraAndMicrophoneSitePermissionsCheck$b={primaryText:"Verifica dell'accesso alla fotocamera e al microfono",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono vederti e sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera e microfono",ariaLabel:"Verifica dell'accesso alla fotocamera e al microfono. Consenti l'accesso se richiesto."};var CameraSitePermissionsCheck$b={primaryText:"Verifica dell'accesso alla fotocamera",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono vederti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza fotocamera",ariaLabel:"Verifica dell'accesso alla fotocamera. Consenti l'accesso se richiesto."};var MicrophoneSitePermissionsCheck$b={primaryText:"Verifica dell'accesso al microfono",secondaryText:"Consenti l'accesso se richiesto. In questo modo i partecipanti possono sentirti.",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",primaryButtonText:"Continua senza microfono",ariaLabel:"Verifica dell'accesso al microfono. Consenti l'accesso se richiesto."};var CameraAndMicrophoneSitePermissionsDenied$b={primaryText:"Non è possibile accedere alla fotocamera e al microfono",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni del microfono a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza fotocamera e microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraAndMicrophoneSitePermissionsDeniedSafari$b={primaryText:"Non è possibile accedere alla fotocamera e al microfono",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza fotocamera e microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraSitePermissionsDenied$b={primaryText:"Impossibile accedere alla videocamera",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni della fotocamera a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza fotocamera",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var MicrophoneSitePermissionsDenied$b={primaryText:"Impossibile accedere al microfono",secondaryText:"Fare clic sull'icona di blocco nella barra degli indirizzi per concedere le autorizzazioni del microfono a questa pagina Web. Potrebbe essere necessario un aggiornamento della pagina.",primaryButtonText:"Continua senza microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var CameraSitePermissionsDeniedSafari$b={primaryText:"Impossibile accedere alla videocamera",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza fotocamera",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var MicrophoneSitePermissionsDeniedSafari$b={primaryText:"Impossibile accedere al microfono",secondaryText:"Aggiornare la pagina per consentire le autorizzazioni oppure controllare le impostazioni del browser e verificare che le autorizzazioni siano abilitate per questo sito Web.",primaryButtonText:"Continua senza microfono",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var UnsupportedBrowser$b={primaryText:"Browser non supportato",secondaryText:"Partecipa alla chiamata utilizzando un browser compatibile.",moreHelpLinkText:"Visualizza i requisiti di compatibilità"};var UnsupportedBrowserVersion$b={primaryText:"Aggiornamento del browser necessario",secondaryText:"Per garantire la migliore chiamata possibile, aggiorna il browser e riprova a partecipare alla chiamata.",moreHelpLinkText:"Visualizza i requisiti di compatibilità",continueAnywayButtonText:"Avvia chiamata senza aggiornamento"};var UnsupportedOperatingSystem$b={primaryText:"Sistemi operativi non supportati",secondaryText:"Partecipa alla chiamata utilizzando un dispositivo con un sistema operativo compatibile.",moreHelpLinkText:"Visualizza i requisiti di compatibilità"};var BrowserPermissionDenied$b={primaryText:"Non è possibile usare la fotocamera o il microfono",secondaryText:"Il browser potrebbe non avere accesso alla fotocamera o al microfono. Per risolvere il problema, aprire Preferenze di sistema.",primaryButtonText:"Riprova",linkText:"Serve aiuto? Guida alla risoluzione dei problemi"};var BrowserPermissionDeniedIOS$b={primaryText:"Consenti l'accesso al microfono per continuare",secondaryText:"Così gli altri partecipanti possono sentirti.",primaryButtonText:"Riprova",imageAltText:"Posizione dell'autorizzazione del microfono e della fotocamera per iOS",linkText:"Serve aiuto? Guida alla risoluzione dei problemi",step1Text:"Vai alle impostazioni dell'app",step2Text:"Scorri verso il basso fino alle impostazioni per questo browser",step3Text:"Attiva microfono (fotocamera facoltativa)",step4Text:"Prova a partecipare di nuovo alla chiamata",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$b={leftNavButtonAriaLabel:"Pagina precedente",rightNavButtonAriaLabel:"Pagina successiva"};var it_IT$1 = {participantItem:participantItem$b,typingIndicator:typingIndicator$b,sendBox:sendBox$b,mentionPopover:mentionPopover$b,messageStatusIndicator:messageStatusIndicator$b,endCallButton:endCallButton$b,cameraButton:cameraButton$b,microphoneButton:microphoneButton$b,devicesButton:devicesButton$b,participantsButton:participantsButton$b,screenShareButton:screenShareButton$b,messageThread:messageThread$b,errorBar:errorBar$b,videoGallery:videoGallery$b,dialpad:dialpad$b,holdButton:holdButton$b,videoTile:videoTile$b,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$b,CameraSitePermissionsRequest:CameraSitePermissionsRequest$b,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$b,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$b,CameraSitePermissionsCheck:CameraSitePermissionsCheck$b,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$b,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$b,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$b,CameraSitePermissionsDenied:CameraSitePermissionsDenied$b,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$b,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$b,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$b,UnsupportedBrowser:UnsupportedBrowser$b,UnsupportedBrowserVersion:UnsupportedBrowserVersion$b,UnsupportedOperatingSystem:UnsupportedOperatingSystem$b,BrowserPermissionDenied:BrowserPermissionDenied$b,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$b,VerticalGallery:VerticalGallery$b};

var participantItem$a={isMeText:"(自分)",menuTitle:"その他のオプション",removeButtonLabel:"削除",sharingIconLabel:"共有",mutedIconLabel:"ミュート状態",displayNamePlaceholder:"名前のない参加者",participantStateRinging:"呼び出し中...",participantStateHold:"保留中"};var typingIndicator$a={singleUser:"{user} さんが入力しています...",multipleUsers:"{users} さんが入力しています...",multipleUsersAbbreviateOne:"{users} さんとその他 1 人が入力しています...",multipleUsersAbbreviateMany:"{users} さんと他 {numOthers} 人が入力しています...",delimiter:","};var sendBox$a={placeholderText:"メッセージを入力",textTooLong:"メッセージの長さが上限を超えています。",sendButtonAriaLabel:"メッセージの送信",fileUploadsPendingError:"アップロード中です... お待ちください。",removeFile:"ファイルを削除します",uploading:"アップロード中",uploadCompleted:"アップロードが完了しました"};var mentionPopover$a={mentionPopoverHeader:"候補"};var messageStatusIndicator$a={deliveredAriaLabel:"メッセージを送信しました",deliveredTooltipText:"送信しました",seenAriaLabel:"他のユーザーが表示したメッセージ",seenTooltipText:"既読",readByTooltipText:"{remoteParticipantsCount} の {messageThreadReadCount} による読み取り",sendingAriaLabel:"メッセージを送信しています",sendingTooltipText:"送信中",failedToSendAriaLabel:"メッセージの送信に失敗しました",failedToSendTooltipText:"送信できませんでした"};var endCallButton$a={label:"退出",tooltipContent:"通話を終了"};var cameraButton$a={onLabel:"オフにする",offLabel:"オンにする",tooltipDisabledContent:"カメラが無効になっています",tooltipOnContent:"カメラをオフ",tooltipOffContent:"カメラをオンにする",tooltipVideoLoadingContent:"ビデオの読み込み中です",cameraMenuTitle:"カメラ",cameraMenuTooltip:"カメラを選択する",cameraButtonSplitRoleDescription:"分割ボタン",onSplitButtonAriaLabel:"カメラとカメラ オプションをオフにする",offSplitButtonAriaLabel:"カメラとカメラ オプションをオンにする",cameraActionTurnedOnAnnouncement:"カメラがオンになっています",cameraActionTurnedOffAnnouncement:"カメラがオフになっています",onSplitButtonPrimaryActionCamera:"カメラをオフにする",offSplitButtonPrimaryActionCamera:"カメラをオンにする",cameraPrimaryActionSplitButtonTitle:"カメラを使用する",videoEffectsMenuItemTitle:"効果"};var microphoneButton$a={onLabel:"ミュート",offLabel:"ミュート解除",tooltipDisabledContent:"マイクが無効になっています",tooltipOnContent:"マイクをミュートにする",tooltipOffContent:"マイクのミュートを解除する",microphoneMenuTitle:"マイク",microphoneMenuTooltip:"マイクを選択する",speakerMenuTitle:"スピーカー",speakerMenuTooltip:"スピーカーを選択する",microphoneButtonSplitRoleDescription:"分割ボタン",onSplitButtonAriaLabel:"マイクとオーディオのオプションをミュートにする",offSplitButtonAriaLabel:"マイクとオーディオのオプションのミュートを解除する",microphoneActionTurnedOnAnnouncement:"マイクがオンになっています",microphoneActionTurnedOffAnnouncement:"マイクがオフになっています",offSplitButtonMicrophonePrimaryAction:"マイクのミュートを解除する",onSplitButtonMicrophonePrimaryAction:"マイクをミュートにする",microphonePrimaryActionSplitButtonTitle:"マイクを使用する"};var devicesButton$a={label:"デバイス",tooltipContent:"デバイスの管理",cameraMenuTitle:"カメラ",cameraMenuTooltip:"カメラを選択する",audioDeviceMenuTitle:"オーディオ デバイス",audioDeviceMenuTooltip:"オーディオ デバイスを選択する",microphoneMenuTitle:"マイク",microphoneMenuTooltip:"マイクを選択する",speakerMenuTitle:"スピーカー",speakerMenuTooltip:"スピーカーを選択する"};var participantsButton$a={label:"ユーザー",tooltipContent:"参加者を表示",menuHeader:"この通話で",participantsListButtonLabel:"{numParticipants} 人",muteAllButtonLabel:"全員をミュート",copyInviteLinkButtonLabel:"招待用のリンクをコピー",copyInviteLinkActionedAriaLabel:"招待用のリンクがコピーされました"};var screenShareButton$a={onLabel:"プレゼンテーションの停止",offLabel:"提示",tooltipDisabledContent:"プレゼンテーションは無効です",tooltipOnContent:"画面の表示",tooltipOffContent:"画面のプレゼンテーション"};var messageThread$a={yesterday:"昨日",sunday:"日曜日",monday:"月曜日",tuesday:"火曜日",wednesday:"水曜日",thursday:"木曜日",friday:"金曜日",saturday:"土曜日",participantJoined:"チャットに参加しました。",participantLeft:"チャットから退出しました。",editMessage:"編集",removeMessage:"削除",resendMessage:"もう一度送信",failToSendTag:"送信できませんでした",editedTag:"編集済み",liveAuthorIntro:"{author} さんの発言",messageContentAriaText:"{author} が {message} と言いました",messageContentMineAriaText:"{message} と言いました",editBoxTextLimit:"メッセージが{limitNumber}文字の制限を超えています",editBoxPlaceholderText:"メッセージを編集する",newMessagesIndicator:"新しいメッセージ",noDisplayNameSub:"名前がありません",editBoxCancelButton:"取り消し",editBoxSubmitButton:"送信",messageReadCount:"{remoteParticipantsCount} の {messageReadByCount} による読み取り",actionMenuMoreOptions:"その他のオプション",downloadFile:"ファイルをダウンロード",blockedWarningText:"組織のポリシーにより、このメッセージは削除されました。",blockedWarningLinkText:"詳細",fileCardGroupMessage:"メッセージには {fileCount} 個の添付ファイルがあります"};var errorBar$a={unableToReachChatService:"オフラインです",accessDenied:"チャット サービスにアクセスできません- 指定されたユーザー資格情報をご確認ください",userNotInChatThread:"このチャット スレッドにはもう参加していません",sendMessageNotInChatThread:"このチャット スレッドに参加していないため、メッセージを送信できませんでした",sendMessageGeneric:"メッセージを送信できませんでした。",callingNetworkFailure:"通話の接続中に問題が発生しました。オフラインのようです。",startVideoGeneric:"ビデオを開始できませんでした",stopVideoGeneric:"ビデオを停止できませんでした",muteGeneric:"マイクをミュートできませんでした",unmuteGeneric:"マイクのミュートを解除できませんでした",speakingWhileMuted:"マイクがミュートになっています",startScreenShareGeneric:"画面共有の開始中に問題が発生しました。",stopScreenShareGeneric:"画面の共有を停止できませんでした",callNetworkQualityLow:"ネットワークの品質が低くなっています。",callNoSpeakerFound:"スピーカーまたはヘッドフォンが見つかりません。音声デバイスを接続して通話を聞きます。",callNoMicrophoneFound:"マイクが見つかりません。オーディオ入力デバイスを接続します。",callMicrophoneAccessDenied:"マイクにアクセスできません。アドレス バーのロックをクリックして、この Web ページにアクセス許可を付与します。",callMicrophoneAccessDeniedSafari:"マイクにアクセスできません。ページを更新してアクセス許可を可能にするか、このブラウザーの設定を確認し、この Web サイトのアクセス許可が有効になっていることを確認してください。",callMicrophoneMutedBySystem:"システムによってミュートになっています。",callMicrophoneUnmutedBySystem:"マイクが回復し、システムによってミュートが解除されました。",callMacOsMicrophoneAccessDenied:"マイクにアクセスできません。macOS のプライバシー設定でマイクへのアクセス許可を付与します。",callLocalVideoFreeze:"ネットワーク帯域幅が不十分です。通話中に他のユーザーのビデオが一時停止している可能性があります。",callCameraAccessDenied:"カメラにアクセスできません。アドレス バーのロックをクリックして、この Web ページにアクセス許可を付与します。",callCameraAccessDeniedSafari:"カメラにアクセスできません。ページを更新してアクセス許可を可能にするか、このブラウザーの設定を確認し、この Web サイトのアクセス許可が有効になっていることを確認してください。",callCameraAlreadyInUse:"カメラにアクセスできません。別のアプリケーションによって既に使用されている可能性があります。",callVideoStoppedBySystem:"ビデオはシステムによって停止されました。",callVideoRecoveredBySystem:"ビデオが再開されました。",callMacOsCameraAccessDenied:"MacOS がカメラへのアクセスをブロックしています。プライバシー設定を更新して、このブラウザーがカメラにアクセスできるようにします。",callMacOsScreenShareAccessDenied:"MacOS は画面の共有をブロックしています。プライバシー設定を更新して、このブラウザーで画面を録画できるようにします。",dismissButtonAriaLabel:"閉じる",failedToJoinCallGeneric:"通話に参加できませんでした",failedToJoinCallInvalidMeetingLink:"会議に参加できません。リンクが無効です。",cameraFrozenForRemoteParticipants:"通話のユーザーにビデオの表示で問題が発生しています。デバイスとネットワークを確認してください。",unableToStartVideoEffect:"ビデオ効果を適用できません。"};var videoGallery$a={screenIsBeingSharedMessage:"画面を共有しています",screenShareLoadingMessage:"{participant} の画面を読み込んでいます",localVideoLabel:"自分",localVideoCameraSwitcherLabel:"カメラを切り替え",localVideoMovementLabel:"移動可能なローカル ビデオ タイル",localVideoSelectedDescription:"{cameraName} が選択されました。",displayNamePlaceholder:"名前のない参加者",fitRemoteParticipantToFrame:"フレームに収める",fillRemoteParticipantFrame:"トリミングする",pinParticipantForMe:"自分用にピン留め",pinParticipantForMeLimitReached:"ピン留め (上限に達しました)",unpinParticipantForMe:"ピンを外す",pinParticipantMenuItemAriaLabel:"{participantName} さんをピン留めする",unpinParticipantMenuItemAriaLabel:"{participantName} さんのピンを外す",pinnedParticipantAnnouncementAriaLabel:"{participantName} さんをピン留めしました",unpinnedParticipantAnnouncementAriaLabel:"{participantName} さんのピンを外しました"};var dialpad$a={placeholderText:"電話番号を入力してください",deleteButtonAriaLabel:"削除"};var holdButton$a={onLabel:"再開",offLabel:"保留",tooltipOnContent:"通話の再開",tooltipOffContent:"通話の保留"};var videoTile$a={participantStateRinging:"呼び出し中...",participantStateHold:"保留中"};var CameraAndMicrophoneSitePermissionsRequest$a={primaryText:"{appName}にカメラとマイクの使用を許可する",secondaryText:"これは、参加者があなたのことを見たり聞いたりできるようにするものです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"カメラとマイクなしで続行する",ariaLabel:"カメラとマイクへのアクセスが許可する"};var CameraSitePermissionsRequest$a={primaryText:"{appName} にカメラの使用を許可する",secondaryText:"これは、参加者に表示されるようにするためです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"カメラなしで続行",ariaLabel:"カメラへのアクセスを許可"};var MicrophoneSitePermissionsRequest$a={primaryText:"{appName} にマイクの使用を許可する",secondaryText:"これは、参加者に聞こえるようにするためです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"マイクなしで続行",ariaLabel:"マイクへのアクセスを許可する"};var CameraAndMicrophoneSitePermissionsCheck$a={primaryText:"カメラとマイクへのアクセスを確認しています",secondaryText:"プロンプトが表示されたら、アクセスを許可します。これは、参加者があなたを見たり聞いたりできるようにするためです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"カメラとマイクなしで続行する",ariaLabel:"カメラとマイクへのアクセスを確認しています。プロンプトが表示されたら、アクセスを許可します。"};var CameraSitePermissionsCheck$a={primaryText:"カメラへのアクセスを確認しています",secondaryText:"プロンプトが表示されたら、アクセスを許可します。これは、参加者があなたを見ることができるようにするためです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"カメラなしで続行する",ariaLabel:"カメラへのアクセスを確認しています。プロンプトが表示されたら、アクセスを許可します。"};var MicrophoneSitePermissionsCheck$a={primaryText:"マイクへのアクセスを確認しています",secondaryText:"プロンプトが表示されたら、アクセスを許可します。これは、参加者があなたの声を聞くことができるようにするためです。",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",primaryButtonText:"マイクなしで続行する",ariaLabel:"マイクへのアクセスを確認しています。プロンプトが表示されたら、アクセスを許可します。"};var CameraAndMicrophoneSitePermissionsDenied$a={primaryText:"カメラとマイクにアクセスできません",secondaryText:"アドレス バーのロック アイコンをクリックして、この Web ページにマイクのアクセス許可を付与します。ページの更新が必要な可能性があります。",primaryButtonText:"カメラとマイクなしで続行",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var CameraAndMicrophoneSitePermissionsDeniedSafari$a={primaryText:"カメラとマイクにアクセスできません",secondaryText:"ページを更新してアクセス許可を可能にするか、このブラウザーの設定を確認し、この Web サイトのアクセス許可が有効になっていることを確認してください。",primaryButtonText:"カメラとマイクなしで続行",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var CameraSitePermissionsDenied$a={primaryText:"カメラにアクセスできません",secondaryText:"アドレス バーのロック アイコンをクリックして、この Web ページにカメラのアクセス許可を付与します。ページの更新が必要な可能性があります。",primaryButtonText:"カメラなしで続行",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var MicrophoneSitePermissionsDenied$a={primaryText:"マイクにアクセスできません",secondaryText:"アドレス バーのロック アイコンをクリックして、この Web ページにマイクのアクセス許可を付与します。ページの更新が必要な可能性があります。",primaryButtonText:"マイクなしで続行する",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var CameraSitePermissionsDeniedSafari$a={primaryText:"カメラにアクセスできません",secondaryText:"ページを更新してアクセス許可を可能にするか、このブラウザーの設定を確認し、この Web サイトのアクセス許可が有効になっていることを確認してください。",primaryButtonText:"カメラなしで続行する",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var MicrophoneSitePermissionsDeniedSafari$a={primaryText:"マイクにアクセスできません",secondaryText:"ページを更新してアクセス許可を可能にするか、このブラウザーの設定を確認し、この Web サイトのアクセス許可が有効になっていることを確認してください。",primaryButtonText:"マイクなしで続行",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var UnsupportedBrowser$a={primaryText:"サポートされていないブラウザーです",secondaryText:"互換性のあるブラウザーを使用して、この通話に参加してください。",moreHelpLinkText:"互換性要件を確認する"};var UnsupportedBrowserVersion$a={primaryText:"ブラウザーの更新が必要です",secondaryText:"可能な限り最善の通話を行うために、ブラウザーを更新してから、もう一度通話に参加してみてください。",moreHelpLinkText:"互換性要件を確認する",continueAnywayButtonText:"更新せずに通話を開始する"};var UnsupportedOperatingSystem$a={primaryText:"オペレーティング システムがサポートされていません",secondaryText:"互換性のあるオペレーティング システムのデバイスを使用して、この通話に参加してください。",moreHelpLinkText:"互換性要件を確認する"};var BrowserPermissionDenied$a={primaryText:"カメラまたはマイクを使用できません",secondaryText:"お使いのブラウザーはカメラまたはマイクにアクセスできない可能性があります。この問題を解決するには、[システム環境設定] を開きます。",primaryButtonText:"再試行",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示"};var BrowserPermissionDeniedIOS$a={primaryText:"マイクへのアクセスを許可して続行する",secondaryText:"そのため、他の参加者はあなたの声を聞くことができます。",primaryButtonText:"再試行",imageAltText:"iOS のマイクとカメラ デバイスのアクセス許可の場所",linkText:"ヘルプが必要ですか? トラブルシューティングのヘルプを表示",step1Text:"設定アプリに移動します。",step2Text:"このブラウザーの設定まで下にスクロール",step3Text:"マイクをオンにする (カメラはオプション)",step4Text:"もう一度通話に参加してみてください",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$a={leftNavButtonAriaLabel:"前のページ",rightNavButtonAriaLabel:"次のページ"};var ja_JP$1 = {participantItem:participantItem$a,typingIndicator:typingIndicator$a,sendBox:sendBox$a,mentionPopover:mentionPopover$a,messageStatusIndicator:messageStatusIndicator$a,endCallButton:endCallButton$a,cameraButton:cameraButton$a,microphoneButton:microphoneButton$a,devicesButton:devicesButton$a,participantsButton:participantsButton$a,screenShareButton:screenShareButton$a,messageThread:messageThread$a,errorBar:errorBar$a,videoGallery:videoGallery$a,dialpad:dialpad$a,holdButton:holdButton$a,videoTile:videoTile$a,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$a,CameraSitePermissionsRequest:CameraSitePermissionsRequest$a,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$a,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$a,CameraSitePermissionsCheck:CameraSitePermissionsCheck$a,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$a,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$a,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$a,CameraSitePermissionsDenied:CameraSitePermissionsDenied$a,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$a,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$a,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$a,UnsupportedBrowser:UnsupportedBrowser$a,UnsupportedBrowserVersion:UnsupportedBrowserVersion$a,UnsupportedOperatingSystem:UnsupportedOperatingSystem$a,BrowserPermissionDenied:BrowserPermissionDenied$a,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$a,VerticalGallery:VerticalGallery$a};

var participantItem$9={isMeText:"(나)",menuTitle:"추가 옵션",removeButtonLabel:"제거",sharingIconLabel:"공유 중",mutedIconLabel:"음소거됨",displayNamePlaceholder:"명명되지 않은 참가자",participantStateRinging:"전화 거는 중...",participantStateHold:"대기 중"};var typingIndicator$9={singleUser:"{user} 님이 입력 중...",multipleUsers:"{users} 님이 입력하는 중...",multipleUsersAbbreviateOne:"{users} 님 외 1명이 입력 중...",multipleUsersAbbreviateMany:"{users} 님 외 {numOthers} 님이 입력하는 중...",delimiter:"닫는 렌즈형 흰색 괄호"};var sendBox$9={placeholderText:"메시지를 입력하세요",textTooLong:"메시지 길이가 최대 제한을 초과했습니다.",sendButtonAriaLabel:"메시지 보내기",fileUploadsPendingError:"업로드 중... 잠시만 기다려 주세요.",removeFile:"파일 제거",uploading:"업로드 중",uploadCompleted:"업로드 완료"};var mentionPopover$9={mentionPopoverHeader:"제안"};var messageStatusIndicator$9={deliveredAriaLabel:"메시지를 보냄",deliveredTooltipText:"보냄",seenAriaLabel:"다른 사용자가 본 메시지",seenTooltipText:"표시됨",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount}명이 읽음",sendingAriaLabel:"메시지를 보내는 중",sendingTooltipText:"보내는 중",failedToSendAriaLabel:"메시지를 보내지 못함",failedToSendTooltipText:"보내기 실패"};var endCallButton$9={label:"휴가",tooltipContent:"통화에서 나가기"};var cameraButton$9={onLabel:"끄기",offLabel:"켜기",tooltipDisabledContent:"카메라가 비활성화되었습니다",tooltipOnContent:"카메라 끄기",tooltipOffContent:"카메라 켜기",tooltipVideoLoadingContent:"비디오를 로드하는 중입니다.",cameraMenuTitle:"카메라",cameraMenuTooltip:"카메라 선택",cameraButtonSplitRoleDescription:"분할 단추",onSplitButtonAriaLabel:"카메라 사용 안 함 및 카메라 옵션",offSplitButtonAriaLabel:"카메라 사용 및 카메라 옵션",cameraActionTurnedOnAnnouncement:"카메라가 켜져 있습니다.",cameraActionTurnedOffAnnouncement:"카메라가 꺼져 있습니다.",onSplitButtonPrimaryActionCamera:"카메라 끄기",offSplitButtonPrimaryActionCamera:"카메라 켜기",cameraPrimaryActionSplitButtonTitle:"카메라 사용",videoEffectsMenuItemTitle:"효과"};var microphoneButton$9={onLabel:"음소거",offLabel:"음소거 해제",tooltipDisabledContent:"마이크가 비활성화되었습니다",tooltipOnContent:"마이크 음소거",tooltipOffContent:"마이크 음소거 해제",microphoneMenuTitle:"마이크",microphoneMenuTooltip:"마이크 선택",speakerMenuTitle:"발언자",speakerMenuTooltip:"스피커 선택",microphoneButtonSplitRoleDescription:"분할 단추",onSplitButtonAriaLabel:"마이크 및 오디오 음소거 옵션",offSplitButtonAriaLabel:"마이크 및 오디오 음소거 해제 옵션",microphoneActionTurnedOnAnnouncement:"마이크가 켜져 있습니다.",microphoneActionTurnedOffAnnouncement:"마이크가 꺼져 있습니다.",offSplitButtonMicrophonePrimaryAction:"마이크 음소거 해제",onSplitButtonMicrophonePrimaryAction:"마이크 음소거",microphonePrimaryActionSplitButtonTitle:"마이크 사용"};var devicesButton$9={label:"장치",tooltipContent:"장치 관리",cameraMenuTitle:"카메라",cameraMenuTooltip:"카메라 선택",audioDeviceMenuTitle:"오디오 장치",audioDeviceMenuTooltip:"오디오 장치 선택",microphoneMenuTitle:"마이크",microphoneMenuTooltip:"마이크 선택",speakerMenuTitle:"발언자",speakerMenuTooltip:"스피커 선택"};var participantsButton$9={label:"사용자",tooltipContent:"참가자 표시",menuHeader:"이 통화에서",participantsListButtonLabel:"{numParticipants}명",muteAllButtonLabel:"모두 음소거",copyInviteLinkButtonLabel:"초대 링크 복사",copyInviteLinkActionedAriaLabel:"초대 링크를 복사함"};var screenShareButton$9={onLabel:"프레젠테이션 중지",offLabel:"프레젠테이션",tooltipDisabledContent:"프레젠테이션 사용 안 함",tooltipOnContent:"화면을 프레젠테이션하는 중",tooltipOffContent:"화면 프레젠테이션"};var messageThread$9={yesterday:"어제",sunday:"일요일",monday:"월요일",tuesday:"화요일",wednesday:"수요일",thursday:"목요일",friday:"금요일",saturday:"토요일",participantJoined:"채팅에 참여했습니다.",participantLeft:"이 채팅을 나갔습니다.",editMessage:"편집",removeMessage:"삭제",resendMessage:"전송 다시 시도",failToSendTag:"보내기 실패",editedTag:"편집됨",liveAuthorIntro:"{author} 님이 말합니다.",messageContentAriaText:"{author} 님이 {message}(이)라고 말했습니다.",messageContentMineAriaText:"내가 {message}(이)라고 말했습니다.",editBoxTextLimit:"메시지가 {limitNumber} 문자 제한을 초과했습니다.",editBoxPlaceholderText:"메시지 편집",newMessagesIndicator:"새 메시지",noDisplayNameSub:"이름 없음",editBoxCancelButton:"취소",editBoxSubmitButton:"제출",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount}명이 읽음",actionMenuMoreOptions:"추가 옵션",downloadFile:"파일 다운로드",blockedWarningText:"조직 정책으로 인해 이 메시지가 삭제되었습니다.",blockedWarningLinkText:"세부 정보",fileCardGroupMessage:"메시지에 {fileCount}개의 첨부 파일이 있습니다"};var errorBar$9={unableToReachChatService:"오프라인 상태입니다.",accessDenied:"채팅 서비스에 액세스할 수 없습니다. 제공된 사용자 자격 증명을 확인하세요.",userNotInChatThread:"이 채팅 스레드에 더 이상 없습니다.",sendMessageNotInChatThread:"이 채팅 스레드에 더 이상 존재하지 않으므로 메시지를 보내지 못했습니다.",sendMessageGeneric:"메시지를 보내지 못했습니다",callingNetworkFailure:"통화 연결 중 - 오프라인 상태인 것 같습니다.",startVideoGeneric:"비디오를 시작하지 못함",stopVideoGeneric:"비디오를 중지하지 못함",muteGeneric:"마이크를 음소거하지 못함",unmuteGeneric:"마이크 음소거를 해제하지 못함",speakingWhileMuted:"마이크가 음소거됨",startScreenShareGeneric:"화면 공유를 시작하는 동안 문제가 발생했습니다.",stopScreenShareGeneric:"화면 공유를 중지하지 못함",callNetworkQualityLow:"네트워크 품질이 낮습니다.",callNoSpeakerFound:"스피커 또는 헤드폰을 찾을 수 없습니다. 오디오 장치를 연결하여 통화를 들을 수 있습니다.",callNoMicrophoneFound:"마이크를 찾을 수 없습니다. 오디오 입력 장치를 연결합니다.",callMicrophoneAccessDenied:"마이크에 액세스할 수 없습니다. 주소 표시줄에서 잠금을 클릭하여 이 웹 페이지에 권한을 부여합니다.",callMicrophoneAccessDeniedSafari:"마이크에 액세스할 수 없습니다. 사용 권한을 허용하려면 페이지를 새로 고치거나 이 브라우저의 설정을 확인하고 이 웹 사이트에 사용 권한이 설정되어 있는지 확인하세요.",callMicrophoneMutedBySystem:"시스템에 의해 음소거되었습니다.",callMicrophoneUnmutedBySystem:"마이크가 복구되었으며 시스템에서 음소거를 해제했습니다.",callMacOsMicrophoneAccessDenied:"마이크에 액세스할 수 없습니다. macOS 개인 정보 설정에서 마이크 권한을 부여합니다.",callLocalVideoFreeze:"네트워크 대역폭이 불량합니다. 통화 중에 다른 사람에 대해 비디오가 일시 중지된 것 같습니다.",callCameraAccessDenied:"카메라에 액세스할 수 없습니다. 주소 표시줄에서 잠금을 클릭하여 이 웹 페이지에 권한을 부여합니다.",callCameraAccessDeniedSafari:"카메라에 액세스할 수 없습니다. 사용 권한을 허용하려면 페이지를 새로 고치거나 이 브라우저의 설정을 확인하고 이 웹 사이트에 사용 권한이 설정되어 있는지 확인하세요.",callCameraAlreadyInUse:"카메라에 액세스할 수 없습니다. 다른 응용 프로그램에서 이미 사용 중일 수 있습니다.",callVideoStoppedBySystem:"시스템에 의해 비디오가 중지되었습니다.",callVideoRecoveredBySystem:"비디오가 다시 시작되었습니다.",callMacOsCameraAccessDenied:"MacOS에서 카메라에 대한 액세스를 차단하고 있습니다. 이 브라우저에서 카메라에 액세스할 수 있도록 개인 정보 설정을 업데이트합니다.",callMacOsScreenShareAccessDenied:"MacOS에서 화면 공유를 차단하고 있습니다. 이 브라우저에서 화면을 녹화할 수 있도록 개인 정보 설정을 업데이트합니다.",dismissButtonAriaLabel:"닫기",failedToJoinCallGeneric:"통화에 참가하지 못했습니다.",failedToJoinCallInvalidMeetingLink:"모임에 참가할 수 없습니다. 잘못된 링크입니다.",cameraFrozenForRemoteParticipants:"통화 중인 사용자에게 영상이 표시되는 데 문제가 있습니다. 장치와 네트워크를 확인하세요.",unableToStartVideoEffect:"비디오 효과를 적용할 수 없습니다."};var videoGallery$9={screenIsBeingSharedMessage:"화면을 공유 중입니다.",screenShareLoadingMessage:"{participant} 님의 화면 로드 중",localVideoLabel:"나",localVideoCameraSwitcherLabel:"카메라 전환",localVideoMovementLabel:"이동 가능한 로컬 비디오 타일",localVideoSelectedDescription:"{cameraName} 선택함",displayNamePlaceholder:"명명되지 않은 참가자",fitRemoteParticipantToFrame:"프레임에 맞춤",fillRemoteParticipantFrame:"프레임 채우기",pinParticipantForMe:"고정",pinParticipantForMeLimitReached:"핀 제한에 도달함",unpinParticipantForMe:"고정 해제",pinParticipantMenuItemAriaLabel:"{participantName} 고정",unpinParticipantMenuItemAriaLabel:"{participantName} 고정 해제",pinnedParticipantAnnouncementAriaLabel:"{participantName} 고정함",unpinnedParticipantAnnouncementAriaLabel:"{participantName} 고정 해제함"};var dialpad$9={placeholderText:"전화 번호를 입력하세요.",deleteButtonAriaLabel:"삭제"};var holdButton$9={onLabel:"계속",offLabel:"보류",tooltipOnContent:"통화 계속하기",tooltipOffContent:"통화 대기"};var videoTile$9={participantStateRinging:"전화 거는 중...",participantStateHold:"대기 중"};var CameraAndMicrophoneSitePermissionsRequest$9={primaryText:"{appName} 님이 카메라와 마이크를 사용하도록 허용",secondaryText:"참가자가 사용자를 보고 들을 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"카메라 및 마이크 없이 계속",ariaLabel:"카메라 및 마이크 액세스 허용"};var CameraSitePermissionsRequest$9={primaryText:"{appName}에서 카메라를 사용하도록 허용",secondaryText:"참가자가 나를 볼 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"카메라 없이 계속",ariaLabel:"카메라 액세스 허용"};var MicrophoneSitePermissionsRequest$9={primaryText:"{appName}에서 마이크를 사용하도록 허용",secondaryText:"참가자가 내 목소리를 들을 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"마이크 없이 계속",ariaLabel:"마이크 액세스 허용"};var CameraAndMicrophoneSitePermissionsCheck$9={primaryText:"카메라 및 마이크 액세스 확인 중",secondaryText:"메시지가 표시되면 액세스를 허용합니다. 참가자가 사용자를 보고 들을 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"카메라 및 마이크 없이 계속",ariaLabel:"카메라 및 마이크 액세스를 확인하는 중입니다. 메시지가 표시되면 액세스를 허용하세요."};var CameraSitePermissionsCheck$9={primaryText:"카메라 액세스 확인 중",secondaryText:"메시지가 표시되면 액세스를 허용합니다. 참가자가 사용자를 볼 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"카메라 없이 계속",ariaLabel:"카메라 액세스를 확인하는 중입니다. 메시지가 표시되면 액세스를 허용하세요."};var MicrophoneSitePermissionsCheck$9={primaryText:"마이크 액세스 확인 중",secondaryText:"메시지가 표시되면 액세스를 허용합니다. 참가자가 들을 수 있도록 합니다.",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",primaryButtonText:"마이크 없이 계속",ariaLabel:"마이크 액세스를 확인하는 중입니다. 메시지가 표시되면 액세스를 허용하세요."};var CameraAndMicrophoneSitePermissionsDenied$9={primaryText:"카메라 및 마이크에 액세스할 수 없음",secondaryText:"주소 표시줄에서 잠금 아이콘을 클릭하여 이 웹 페이지에 마이크 권한을 부여합니다. 페이지를 새로 고쳐야 할 수 있습니다.",primaryButtonText:"카메라 및 마이크 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var CameraAndMicrophoneSitePermissionsDeniedSafari$9={primaryText:"카메라 및 마이크에 액세스할 수 없음",secondaryText:"사용 권한을 허용하려면 페이지를 새로 고치거나 이 브라우저의 설정을 확인하고 이 웹 사이트에 사용 권한이 설정되어 있는지 확인하세요.",primaryButtonText:"카메라 및 마이크 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var CameraSitePermissionsDenied$9={primaryText:"카메라에 액세스할 수 없음",secondaryText:"주소 표시줄에서 잠금 아이콘을 클릭하여 이 웹 페이지에 카메라 권한을 부여합니다. 페이지를 새로 고쳐야 할 수 있습니다.",primaryButtonText:"카메라 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var MicrophoneSitePermissionsDenied$9={primaryText:"마이크에 액세스할 수 없음",secondaryText:"주소 표시줄에서 잠금 아이콘을 클릭하여 이 웹 페이지에 마이크 권한을 부여합니다. 페이지를 새로 고쳐야 할 수 있습니다.",primaryButtonText:"마이크 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var CameraSitePermissionsDeniedSafari$9={primaryText:"카메라에 액세스할 수 없음",secondaryText:"사용 권한을 허용하려면 페이지를 새로 고치거나 이 브라우저의 설정을 확인하고 이 웹 사이트에 사용 권한이 설정되어 있는지 확인하세요.",primaryButtonText:"카메라 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var MicrophoneSitePermissionsDeniedSafari$9={primaryText:"마이크에 액세스할 수 없음",secondaryText:"사용 권한을 허용하려면 페이지를 새로 고치거나 이 브라우저의 설정을 확인하고 이 웹 사이트에 사용 권한이 설정되어 있는지 확인하세요.",primaryButtonText:"마이크 없이 계속",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var UnsupportedBrowser$9={primaryText:"지원되지 않는 브라우저",secondaryText:"호환되는 브라우저를 사용하여 이 통화에 참여하세요.",moreHelpLinkText:"호환성 요구 사항 보기"};var UnsupportedBrowserVersion$9={primaryText:"브라우저 업데이트 필요",secondaryText:"최상의 통화를 하려면 브라우저를 업데이트한 다음 통화에 다시 참가해 보세요.",moreHelpLinkText:"호환성 요구 사항 보기",continueAnywayButtonText:"업데이트하지 않고 통화 시작"};var UnsupportedOperatingSystem$9={primaryText:"지원되지 않는 운영 체제",secondaryText:"호환되는 운영 체제가 있는 장치를 사용하여 이 통화에 참여하세요.",moreHelpLinkText:"호환성 요구 사항 보기"};var BrowserPermissionDenied$9={primaryText:"카메라 또는 마이크를 사용할 수 없음",secondaryText:"브라우저에서 카메라 또는 마이크에 액세스할 수 없을 수 있습니다. 이 문제를 해결하려면 시스템 기본 설정을 엽니다.",primaryButtonText:"다시 시도",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기"};var BrowserPermissionDeniedIOS$9={primaryText:"계속하려면 마이크 액세스 허용",secondaryText:"따라서 다른 참가자가 여러분의 의견을 들을 수 있습니다.",primaryButtonText:"다시 시도",imageAltText:"iOS용 마이크 및 카메라 장치 권한 위치",linkText:"도움이 필요하신가요? 문제 해결 도움말 보기",step1Text:"설정 앱으로 이동합니다.",step2Text:"이 브라우저의 설정에 Scroll down",step3Text:"마이크 켜기(카메라 선택 사항)",step4Text:"통화에 다시 참가해 보세요.",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$9={leftNavButtonAriaLabel:"이전 페이지",rightNavButtonAriaLabel:"다음 페이지"};var ko_KR$1 = {participantItem:participantItem$9,typingIndicator:typingIndicator$9,sendBox:sendBox$9,mentionPopover:mentionPopover$9,messageStatusIndicator:messageStatusIndicator$9,endCallButton:endCallButton$9,cameraButton:cameraButton$9,microphoneButton:microphoneButton$9,devicesButton:devicesButton$9,participantsButton:participantsButton$9,screenShareButton:screenShareButton$9,messageThread:messageThread$9,errorBar:errorBar$9,videoGallery:videoGallery$9,dialpad:dialpad$9,holdButton:holdButton$9,videoTile:videoTile$9,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$9,CameraSitePermissionsRequest:CameraSitePermissionsRequest$9,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$9,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$9,CameraSitePermissionsCheck:CameraSitePermissionsCheck$9,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$9,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$9,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$9,CameraSitePermissionsDenied:CameraSitePermissionsDenied$9,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$9,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$9,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$9,UnsupportedBrowser:UnsupportedBrowser$9,UnsupportedBrowserVersion:UnsupportedBrowserVersion$9,UnsupportedOperatingSystem:UnsupportedOperatingSystem$9,BrowserPermissionDenied:BrowserPermissionDenied$9,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$9,VerticalGallery:VerticalGallery$9};

var participantItem$8={isMeText:"(deg)",menuTitle:"Flere alternativer",removeButtonLabel:"Fjern",sharingIconLabel:"Deling",mutedIconLabel:"Dempet",displayNamePlaceholder:"Deltaker uten navn",participantStateRinging:"Ringer ...",participantStateHold:"På vent"};var typingIndicator$8={singleUser:"{user} skriver ...",multipleUsers:"{users} skriver ...",multipleUsersAbbreviateOne:"{users} og 1 annen skriver ...",multipleUsersAbbreviateMany:"{users} og {numOthers} andre skriver ...",delimiter:", "};var sendBox$8={placeholderText:"Skriv en melding",textTooLong:"Meldingslengden er over maksimumsgrensen.",sendButtonAriaLabel:"Send melding",fileUploadsPendingError:"Laster opp. Vent litt ...",removeFile:"Fjern fil",uploading:"Laster opp",uploadCompleted:"Opplasting fullført"};var mentionPopover$8={mentionPopoverHeader:"Forslag"};var messageStatusIndicator$8={deliveredAriaLabel:"Melding sendt",deliveredTooltipText:"Sendt",seenAriaLabel:"Melding sett av andre",seenTooltipText:"Sett",readByTooltipText:"Lest av {messageThreadReadCount} av {remoteParticipantsCount}",sendingAriaLabel:"Sending av melding",sendingTooltipText:"Sender",failedToSendAriaLabel:"Melding ikke sendt",failedToSendTooltipText:"Kan ikke sende"};var endCallButton$8={label:"Forlat",tooltipContent:"Forlat samtale"};var cameraButton$8={onLabel:"Deaktiver",offLabel:"Aktiver",tooltipDisabledContent:"Kameraet er deaktivert",tooltipOnContent:"Slå av kamera",tooltipOffContent:"Slå på kamera",tooltipVideoLoadingContent:"Videoen lastes inn",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Velg kamera",cameraButtonSplitRoleDescription:"Rullegardinknapp",onSplitButtonAriaLabel:"Slå av kamera og kameraalternativer",offSplitButtonAriaLabel:"Slå på kamera og kameraalternativer",cameraActionTurnedOnAnnouncement:"Kameraet er slått på",cameraActionTurnedOffAnnouncement:"Kameraet er slått av.",onSplitButtonPrimaryActionCamera:"Slå av kamera",offSplitButtonPrimaryActionCamera:"Slå på kamera",cameraPrimaryActionSplitButtonTitle:"Bruk kamera",videoEffectsMenuItemTitle:"Effekter"};var microphoneButton$8={onLabel:"Deaktiver varsler",offLabel:"Opphev demping",tooltipDisabledContent:"Mikrofonen er deaktivert",tooltipOnContent:"Demp mikrofon",tooltipOffContent:"Opphev demping av mikrofon",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Velg mikrofon",speakerMenuTitle:"Høyttaler",speakerMenuTooltip:"Velg høyttaler",microphoneButtonSplitRoleDescription:"Rullegardinknapp",onSplitButtonAriaLabel:"Demp mikrofon og lydalternativer",offSplitButtonAriaLabel:"Opphev demping av mikrofon og lydalternativer",microphoneActionTurnedOnAnnouncement:"Mikrofonen er slått på",microphoneActionTurnedOffAnnouncement:"Mikrofonen er slått av",offSplitButtonMicrophonePrimaryAction:"Opphev demping av mikrofon",onSplitButtonMicrophonePrimaryAction:"Demp mikrofon",microphonePrimaryActionSplitButtonTitle:"Bruk mikrofon"};var devicesButton$8={label:"Enheter",tooltipContent:"Administrer enheter",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Velg kamera",audioDeviceMenuTitle:"Lydenhet",audioDeviceMenuTooltip:"Velg lydenhet",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Velg mikrofon",speakerMenuTitle:"Høyttaler",speakerMenuTooltip:"Velg høyttaler"};var participantsButton$8={label:"Personer",tooltipContent:"Vis deltakere",menuHeader:"I denne samtalen",participantsListButtonLabel:"{numParticipants} personer",muteAllButtonLabel:"Demp alle",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert"};var screenShareButton$8={onLabel:"Stopp presentasjon",offLabel:"Presenter",tooltipDisabledContent:"Presentasjon er deaktivert",tooltipOnContent:"Presenterer skjermen din",tooltipOffContent:"Presenter skjermen din"};var messageThread$8={yesterday:"I går",sunday:"Søndag",monday:"Mandag",tuesday:"Tirsdag",wednesday:"Onsdag",thursday:"Torsdag",friday:"Fredag",saturday:"Lørdag",participantJoined:"ble med i chatten.",participantLeft:"forlot chatten.",editMessage:"Rediger",removeMessage:"Slett",resendMessage:"Prøv å sende på nytt",failToSendTag:"Kan ikke sende",editedTag:"Redigert",liveAuthorIntro:"{author} sier",messageContentAriaText:"{author} sa {message}",messageContentMineAriaText:"Du sa {message}",editBoxTextLimit:"Meldingen er over grensen på {limitNumber} tegn",editBoxPlaceholderText:"Rediger meldingen",newMessagesIndicator:"Nye meldinger",noDisplayNameSub:"Uten navn",editBoxCancelButton:"Avbryt",editBoxSubmitButton:"Send inn",messageReadCount:"Lest av {messageReadByCount} av {remoteParticipantsCount}",actionMenuMoreOptions:"Flere alternativer",downloadFile:"Last ned fil",blockedWarningText:"Denne meldingen ble slettet på grunn av en organisasjonspolicy.",blockedWarningLinkText:"Detaljer",fileCardGroupMessage:"Meldingen har {fileCount} vedlegg"};var errorBar$8={unableToReachChatService:"Du er frakoblet",accessDenied:"Får ikke tilgang til chattjenester. Kontroller brukerlegitimasjonen som er angitt",userNotInChatThread:"Du er ikke lenger i denne chattetråden",sendMessageNotInChatThread:"Kan ikke sende meldingen fordi du ikke lenger er i denne chattetråden",sendMessageGeneric:"Kan ikke sende meldingen",callingNetworkFailure:"Problemer med å koble til samtalen – du ser ut til å være frakoblet",startVideoGeneric:"Kan ikke starte video",stopVideoGeneric:"Kan ikke stoppe video",muteGeneric:"Kan ikke dempe mikrofonen",unmuteGeneric:"Kan ikke oppheve demping av mikrofon",speakingWhileMuted:"Mikrofonen er dempet",startScreenShareGeneric:"Det oppstod et problem under start av skjermdeling.",stopScreenShareGeneric:"Kan ikke stoppe skjermdeling",callNetworkQualityLow:"Nettverkskvaliteten er lav.",callNoSpeakerFound:"Finner ingen høyttalere eller hodetelefoner. Koble til en lydenhet for å høre samtalen.",callNoMicrophoneFound:"Finner ingen mikrofoner. Koble til en lydinndataenhet.",callMicrophoneAccessDenied:"Får ikke tilgang til mikrofonen. Klikk låsen i adresselinjen for å gi tillatelse til denne nettsiden.",callMicrophoneAccessDeniedSafari:"Får ikke tilgang til mikrofonen. Oppdater siden for å tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",callMicrophoneMutedBySystem:"Du er dempet av systemet.",callMicrophoneUnmutedBySystem:"Mikrofonen ble gjenopprettet, og dempingen ble opphevet av systemet.",callMacOsMicrophoneAccessDenied:"Får ikke tilgang til mikrofonen. Gi mikrofontillatelse i personverninnstillingene for macOS.",callLocalVideoFreeze:"Nettverksbåndbredden er dårlig. Videoen kan være midlertidig stanset for andre i samtalen.",callCameraAccessDenied:"Får ikke tilgang til kameraet. Klikk låsen i adresselinjen for å gi tillatelse til denne nettsiden.",callCameraAccessDeniedSafari:"Får ikke tilgang til kameraet. Oppdater siden for å tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",callCameraAlreadyInUse:"Får ikke tilgang til kameraet. Det kan allerede være i bruk av et annet program.",callVideoStoppedBySystem:"Videoen er stoppet av systemet.",callVideoRecoveredBySystem:"Videoen er gjenopptatt.",callMacOsCameraAccessDenied:"MacOS blokkerer tilgang til kameraet. Oppdater personverninnstillingene for å gi denne nettleseren tilgang til kameraet.",callMacOsScreenShareAccessDenied:"MacOS blokkerer skjermdeling. Oppdater personverninnstillingene for å tillate at denne nettleseren registrerer skjermen.",dismissButtonAriaLabel:"Lukk",failedToJoinCallGeneric:"Kan ikke bli med i samtalen.",failedToJoinCallInvalidMeetingLink:"Kan ikke bli med i møtet. Ugyldig kobling.",cameraFrozenForRemoteParticipants:"Brukere i samtalen har problemer med å se videoen. Kontroller enhetene og nettverket.",unableToStartVideoEffect:"Kan ikke bruke videoeffekt."};var videoGallery$8={screenIsBeingSharedMessage:"Du deler skjermen",screenShareLoadingMessage:"Laster inn skjermen til {participant}",localVideoLabel:"Du",localVideoCameraSwitcherLabel:"Bytt kamera",localVideoMovementLabel:"Flyttbar lokal videoflis",localVideoSelectedDescription:"{cameraName} valgt",displayNamePlaceholder:"Deltaker uten navn",fitRemoteParticipantToFrame:"Tilpass til ramme",fillRemoteParticipantFrame:"Fyll ramme",pinParticipantForMe:"Fest for meg",pinParticipantForMeLimitReached:"Pin-kode (grense nådd)",unpinParticipantForMe:"Løsne",pinParticipantMenuItemAriaLabel:"Fest {participantName}",unpinParticipantMenuItemAriaLabel:"Løsne {participantName}",pinnedParticipantAnnouncementAriaLabel:"Festet {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Løsnet {participantName}"};var dialpad$8={placeholderText:"Skriv inn telefonnummeret",deleteButtonAriaLabel:"Slett"};var holdButton$8={onLabel:"Fortsett",offLabel:"Vent",tooltipOnContent:"Fortsett samtale",tooltipOffContent:"Sett samtalen på vent"};var videoTile$8={participantStateRinging:"Ringer ...",participantStateHold:"På vent"};var CameraAndMicrophoneSitePermissionsRequest$8={primaryText:"Tillat {appName} å bruke kameraet og mikrofonen",secondaryText:"Dette er for at deltakerne skal kunne se og høre deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten kamera og mikrofon",ariaLabel:"Gi tilgang til kamera og mikrofon"};var CameraSitePermissionsRequest$8={primaryText:"Tillat at {appName} bruker kameraet",secondaryText:"Dette er for at deltakerne skal kunne se deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten kamera",ariaLabel:"Gi kameratilgang"};var MicrophoneSitePermissionsRequest$8={primaryText:"Tillat at {appName} bruker mikrofonen",secondaryText:"Dette er for at deltakerne skal kunne høre deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten mikrofon",ariaLabel:"Tillat mikrofontilgang"};var CameraAndMicrophoneSitePermissionsCheck$8={primaryText:"Ser etter tilgang til kamera og mikrofon",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan se og høre deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten kamera og mikrofon",ariaLabel:"Ser etter tilgang til kamera og mikrofon. Gi tilgang hvis du blir bedt om det."};var CameraSitePermissionsCheck$8={primaryText:"Ser etter kameratilgang",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan se deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten kamera",ariaLabel:"Ser etter kameratilgang. Gi tilgang hvis du blir bedt om det."};var MicrophoneSitePermissionsCheck$8={primaryText:"Ser etter mikrofontilgang",secondaryText:"Gi tilgang hvis du blir bedt om det. Dette er slik at deltakerne kan høre deg.",linkText:"Trenger du hjelp? Få hjelp til feilsøking",primaryButtonText:"Fortsett uten mikrofon",ariaLabel:"Ser etter mikrofontilgang. Gi tilgang hvis du blir bedt om det."};var CameraAndMicrophoneSitePermissionsDenied$8={primaryText:"Får ikke tilgang til kamera og mikrofon",secondaryText:"Klikk på låseikonet i adresselinjen for å gi mikrofontillatelser til denne nettsiden. En sideoppdatering kan være nødvendig.",primaryButtonText:"Fortsett uten kamera og mikrofon",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var CameraAndMicrophoneSitePermissionsDeniedSafari$8={primaryText:"Får ikke tilgang til kamera og mikrofon",secondaryText:"Oppdater siden for å tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten kamera og mikrofon",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var CameraSitePermissionsDenied$8={primaryText:"Får ikke tilgang til kamera",secondaryText:"Klikk på låseikonet på adresselinjen for å gi kameratillatelser til denne nettsiden. En sideoppdatering kan være nødvendig.",primaryButtonText:"Fortsett uten kamera",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var MicrophoneSitePermissionsDenied$8={primaryText:"Får ikke tilgang til mikrofonen",secondaryText:"Klikk på låseikonet i adresselinjen for å gi mikrofontillatelser til denne nettsiden. En sideoppdatering kan være nødvendig.",primaryButtonText:"Fortsett uten mikrofon",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var CameraSitePermissionsDeniedSafari$8={primaryText:"Får ikke tilgang til kamera",secondaryText:"Oppdater siden for å tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten kamera",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var MicrophoneSitePermissionsDeniedSafari$8={primaryText:"Får ikke tilgang til mikrofonen",secondaryText:"Oppdater siden for å tillate tillatelser, eller kontroller innstillingene for denne nettleseren og kontroller at tillatelser er aktivert for dette nettstedet.",primaryButtonText:"Fortsett uten mikrofon",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var UnsupportedBrowser$8={primaryText:"Nettleseren støttes ikke",secondaryText:"Bli med i denne samtalen ved hjelp av en kompatibel nettleser.",moreHelpLinkText:"Se kompatibilitetskrav"};var UnsupportedBrowserVersion$8={primaryText:"Nettleseroppdatering kreves",secondaryText:"Hvis du vil sikre best mulig samtale, må du oppdatere nettleseren og deretter prøve å bli med i samtalen på nytt.",moreHelpLinkText:"Se kompatibilitetskrav",continueAnywayButtonText:"Start anrop uten å oppdatere"};var UnsupportedOperatingSystem$8={primaryText:"Operativsystem støttes ikke",secondaryText:"Bli med i denne samtalen ved hjelp av en enhet med et kompatibelt operativsystem.",moreHelpLinkText:"Se kompatibilitetskrav"};var BrowserPermissionDenied$8={primaryText:"Kan ikke bruke kameraet eller mikrofonen",secondaryText:"Nettleseren har kanskje ikke tilgang til kameraet eller mikrofonen. Åpne Systemvalg for å løse dette problemet.",primaryButtonText:"Prøv på nytt",linkText:"Trenger du hjelp? Få hjelp til feilsøking"};var BrowserPermissionDeniedIOS$8={primaryText:"Gi mikrofontilgang for å fortsette",secondaryText:"Slik at andre deltakere kan høre deg.",primaryButtonText:"Prøv på nytt",imageAltText:"Plassering av mikrofon- og kameraenhetstillatelse for iOS",linkText:"Trenger du hjelp? Få hjelp til feilsøking",step1Text:"Gå til Innstillinger-appen",step2Text:"Rull ned til innstillinger for denne nettleseren",step3Text:"Slå på mikrofon (kamera valgfritt)",step4Text:"Prøv å bli med i samtalen på nytt",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$8={leftNavButtonAriaLabel:"forrige side",rightNavButtonAriaLabel:"neste side"};var nb_NO$1 = {participantItem:participantItem$8,typingIndicator:typingIndicator$8,sendBox:sendBox$8,mentionPopover:mentionPopover$8,messageStatusIndicator:messageStatusIndicator$8,endCallButton:endCallButton$8,cameraButton:cameraButton$8,microphoneButton:microphoneButton$8,devicesButton:devicesButton$8,participantsButton:participantsButton$8,screenShareButton:screenShareButton$8,messageThread:messageThread$8,errorBar:errorBar$8,videoGallery:videoGallery$8,dialpad:dialpad$8,holdButton:holdButton$8,videoTile:videoTile$8,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$8,CameraSitePermissionsRequest:CameraSitePermissionsRequest$8,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$8,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$8,CameraSitePermissionsCheck:CameraSitePermissionsCheck$8,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$8,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$8,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$8,CameraSitePermissionsDenied:CameraSitePermissionsDenied$8,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$8,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$8,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$8,UnsupportedBrowser:UnsupportedBrowser$8,UnsupportedBrowserVersion:UnsupportedBrowserVersion$8,UnsupportedOperatingSystem:UnsupportedOperatingSystem$8,BrowserPermissionDenied:BrowserPermissionDenied$8,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$8,VerticalGallery:VerticalGallery$8};

var participantItem$7={isMeText:"(jij)",menuTitle:"Meer opties",removeButtonLabel:"Verwijderen",sharingIconLabel:"Delen",mutedIconLabel:"Gedempt",displayNamePlaceholder:"Naamloze deelnemer",participantStateRinging:"Bellen...",participantStateHold:"In de wacht"};var typingIndicator$7={singleUser:"{user} typt ...",multipleUsers:"{users} typen ...",multipleUsersAbbreviateOne:"{users} en 1 andere persoon typen ...",multipleUsersAbbreviateMany:"{users} en {numOthers} anderen typen ...",delimiter:", "};var sendBox$7={placeholderText:"Een bericht invoeren",textTooLong:"De lengte van uw bericht overschrijdt de maximumlimiet.",sendButtonAriaLabel:"Bericht verzenden",fileUploadsPendingError:"Uploaden.... Een ogenblik geduld.",removeFile:"Bestand verwijderen",uploading:"Uploaden",uploadCompleted:"Upload voltooid"};var mentionPopover$7={mentionPopoverHeader:"Suggesties"};var messageStatusIndicator$7={deliveredAriaLabel:"Bericht verzonden",deliveredTooltipText:"Verzonden",seenAriaLabel:"Bericht gezien door anderen",seenTooltipText:"Gezien",readByTooltipText:"Gelezen door {messageThreadReadCount} van {remoteParticipantsCount}",sendingAriaLabel:"Bericht verzenden",sendingTooltipText:"Verzenden",failedToSendAriaLabel:"Het bericht is niet verzonden",failedToSendTooltipText:"Kan niet verzenden"};var endCallButton$7={label:"Verlaten",tooltipContent:"Gesprek verlaten"};var cameraButton$7={onLabel:"Uitschakelen",offLabel:"Inschakelen",tooltipDisabledContent:"Camera is uitgeschakeld",tooltipOnContent:"Camera uitschakelen",tooltipOffContent:"Camera inschakelen",tooltipVideoLoadingContent:"Video wordt geladen",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",cameraButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Camera- en cameraopties uitschakelen",offSplitButtonAriaLabel:"Camera- en cameraopties inschakelen",cameraActionTurnedOnAnnouncement:"Uw camera is ingeschakeld",cameraActionTurnedOffAnnouncement:"Uw camera is uitgeschakeld",onSplitButtonPrimaryActionCamera:"Camera uitschakelen",offSplitButtonPrimaryActionCamera:"Camera inschakelen",cameraPrimaryActionSplitButtonTitle:"Camera gebruiken",videoEffectsMenuItemTitle:"Effecten"};var microphoneButton$7={onLabel:"Dempen",offLabel:"Dempen opheffen",tooltipDisabledContent:"Microfoon is uitgeschakeld",tooltipOnContent:"Microfoon uitschakelen",tooltipOffContent:"Microfoon inschakelen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Luidspreker",speakerMenuTooltip:"Luidspreker kiezen",microphoneButtonSplitRoleDescription:"Knop Splitsen",onSplitButtonAriaLabel:"Microfoon- en audioopties dempen",offSplitButtonAriaLabel:"Microfoon- en audioopties dempen opheffen",microphoneActionTurnedOnAnnouncement:"Uw microfoon is ingeschakeld",microphoneActionTurnedOffAnnouncement:"Uw microfoon is uitgeschakeld",offSplitButtonMicrophonePrimaryAction:"Microfoon inschakelen",onSplitButtonMicrophonePrimaryAction:"Microfoon uitschakelen",microphonePrimaryActionSplitButtonTitle:"Microfoon gebruiken"};var devicesButton$7={label:"Apparaten",tooltipContent:"Apparaten beheren",cameraMenuTitle:"Camera",cameraMenuTooltip:"Camera kiezen",audioDeviceMenuTitle:"Audioapparaat",audioDeviceMenuTooltip:"Audioapparaat kiezen",microphoneMenuTitle:"Microfoon",microphoneMenuTooltip:"Microfoon kiezen",speakerMenuTitle:"Spreker",speakerMenuTooltip:"Luidspreker kiezen"};var participantsButton$7={label:"Personen",tooltipContent:"Deelnemers weergeven",menuHeader:"In dit gesprek",participantsListButtonLabel:"{numParticipants} personen",muteAllButtonLabel:"Alles dempen",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiëren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd"};var screenShareButton$7={onLabel:"Presenteren stoppen",offLabel:"Presenteren",tooltipDisabledContent:"Presenteren is uitgeschakeld",tooltipOnContent:"Uw scherm presenteren",tooltipOffContent:"Uw scherm presenteren"};var messageThread$7={yesterday:"Gisteren",sunday:"Zondag",monday:"Maandag",tuesday:"Dinsdag",wednesday:"Woensdag",thursday:"Donderdag",friday:"Vrijdag",saturday:"Zaterdag",participantJoined:"neemt nu deel aan de chat.",participantLeft:"heeft de chat verlaten.",editMessage:"Bewerken",removeMessage:"Verwijderen",resendMessage:"Probeer opnieuw te verzenden",failToSendTag:"Verzenden mislukt",editedTag:"Bewerkt",liveAuthorIntro:"{author} zegt",messageContentAriaText:"{author} zei {message}",messageContentMineAriaText:"U zei: {message}",editBoxTextLimit:"Uw bericht heeft de limiet van {limitNumber} tekens overschreden",editBoxPlaceholderText:"Uw bericht bewerken",newMessagesIndicator:"Nieuwe berichten",noDisplayNameSub:"Geen naam",editBoxCancelButton:"Annuleren",editBoxSubmitButton:"Verzenden",messageReadCount:"Gelezen door {messageReadByCount} van {remoteParticipantsCount}",actionMenuMoreOptions:"Meer opties",downloadFile:"Bestand downloaden",blockedWarningText:"Dit bericht is verwijderd vanwege organisatiebeleid.",blockedWarningLinkText:"Details",fileCardGroupMessage:"Het bericht heeft {fileCount} bijlage"};var errorBar$7={unableToReachChatService:"U bent offline",accessDenied:"Kan geen toegang krijgen tot chatservices. Controleer de opgegeven gebruikersreferenties",userNotInChatThread:"U bent niet meer aanwezig in deze chatthread",sendMessageNotInChatThread:"Verzenden van bericht is mislukt omdat u zich niet meer in deze chatthread bevindt",sendMessageGeneric:"Kan bericht niet verzenden",callingNetworkFailure:"Er zijn problemen met het verbinden van een gesprek - Het lijkt erop dat u offline bent",startVideoGeneric:"Kan video niet starten",stopVideoGeneric:"Kan video niet stoppen",muteGeneric:"Kan microfoon niet dempen",unmuteGeneric:"Kan dempen van microfoon niet opheffen",speakingWhileMuted:"De microfoon is gedempt",startScreenShareGeneric:"Er is een probleem opgetreden bij het starten van scherm delen.",stopScreenShareGeneric:"Kan scherm delen niet stoppen",callNetworkQualityLow:"De netwerkkwaliteit is laag.",callNoSpeakerFound:"Geen luidsprekers of hoofdtelefoon gevonden. Sluit een audioapparaat aan om het gesprek te beluisteren.",callNoMicrophoneFound:"Geen microfoons gevonden. Sluit een audio-invoerapparaat aan.",callMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callMicrophoneAccessDeniedSafari:"Kan geen toegang krijgen tot de microfoon. Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",callMicrophoneMutedBySystem:"U bent gedempt door jouw systeem.",callMicrophoneUnmutedBySystem:"De microfoon is hersteld en het dempen van de microfoon is door het systeem opgeheven.",callMacOsMicrophoneAccessDenied:"Kan geen toegang krijgen tot de microfoon. Verleen microfoonmachtiging in de privacyinstellingen voor macOS.",callLocalVideoFreeze:"De netwerkbandbreedte is slecht. Je video wordt mogelijk onderbroken weergegeven voor anderen in het gesprek.",callCameraAccessDenied:"Kan geen toegang krijgen tot de camera. Klik op de vergrendeling in de adresbalk om toestemming te verlenen aan deze webpagina.",callCameraAccessDeniedSafari:"Kan geen toegang krijgen tot de camera. Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",callCameraAlreadyInUse:"Kan geen toegang krijgen tot de camera. Het wordt mogelijk al gebruikt door een andere toepassing.",callVideoStoppedBySystem:"Uw video is gestopt door uw systeem.",callVideoRecoveredBySystem:"Uw video is hervat.",callMacOsCameraAccessDenied:"MacOS blokkeert de toegang tot jouw camera. Werk je privacyinstellingen bij, zodat deze browser toegang heeft tot jouw camera.",callMacOsScreenShareAccessDenied:"MacOS blokkeert scherm delen. Werk je privacyinstellingen bij, zodat deze browser jouw scherm kan opnemen.",dismissButtonAriaLabel:"Sluiten",failedToJoinCallGeneric:"Deelnemen aan gesprek mislukt.",failedToJoinCallInvalidMeetingLink:"Kan niet deelnemen aan vergadering. Ongeldige koppeling.",cameraFrozenForRemoteParticipants:"Gebruikers in het gesprek ondervinden problemen bij het zien van uw video. Controleer uw apparaten en netwerk.",unableToStartVideoEffect:"Kan video-effect niet toepassen."};var videoGallery$7={screenIsBeingSharedMessage:"U deelt uw scherm",screenShareLoadingMessage:"Scherm van {participant} laden",localVideoLabel:"U",localVideoCameraSwitcherLabel:"Camera wisselen",localVideoMovementLabel:"Tegel voor verwisselbare lokale video",localVideoSelectedDescription:"{cameraName} geselecteerd",displayNamePlaceholder:"Naamloze deelnemer",fitRemoteParticipantToFrame:"Aanpassen aan frame",fillRemoteParticipantFrame:"Frame vullen",pinParticipantForMe:"Voor mij vastmaken",pinParticipantForMeLimitReached:"Pin (limiet bereikt)",unpinParticipantForMe:"Losmaken",pinParticipantMenuItemAriaLabel:"{participantName} vastmaken",unpinParticipantMenuItemAriaLabel:"{participantName} losmaken",pinnedParticipantAnnouncementAriaLabel:"{participantName} vastgemaakt",unpinnedParticipantAnnouncementAriaLabel:"{participantName} losgemaakt"};var dialpad$7={placeholderText:"Telefoonnummer invoeren",deleteButtonAriaLabel:"Verwijderen"};var holdButton$7={onLabel:"Hervatten",offLabel:"Pauze",tooltipOnContent:"Gesprek hervatten",tooltipOffContent:"Gesprek in wachtrij plaatsen"};var videoTile$7={participantStateRinging:"Bellen...",participantStateHold:"In de wacht"};var CameraAndMicrophoneSitePermissionsRequest$7={primaryText:"Toestaan dat {appName} uw camera en microfoon gebruikt",secondaryText:"Dit is zodat deelnemers u kunnen zien en horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera en microfoon",ariaLabel:"Toegang tot camera en microfoon toestaan"};var CameraSitePermissionsRequest$7={primaryText:"{appName} toestaan om uw camera te gebruiken",secondaryText:"Dit is zodat deelnemers u kunnen zien.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera",ariaLabel:"Cameratoegang toestaan"};var MicrophoneSitePermissionsRequest$7={primaryText:"{appName} toestaan om uw microfoon te gebruiken",secondaryText:"Dit is zodat deelnemers u kunnen horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder microfoon",ariaLabel:"Microfoontoegang toestaan"};var CameraAndMicrophoneSitePermissionsCheck$7={primaryText:"Controleren op toegang tot camera en microfoon",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen zien en horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera en microfoon",ariaLabel:"Controleren op toegang tot camera en microfoon. Toegang toestaan als hierom wordt gevraagd."};var CameraSitePermissionsCheck$7={primaryText:"Controleren op cameratoegang",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen zien.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder camera",ariaLabel:"Controleren op cameratoegang. Toegang toestaan als hierom wordt gevraagd."};var MicrophoneSitePermissionsCheck$7={primaryText:"Controleren op toegang tot microfoon",secondaryText:"Toegang toestaan als hierom wordt gevraagd. Dit is zodat deelnemers u kunnen horen.",linkText:"Hulp nodig? Hulp bij probleemoplossing",primaryButtonText:"Doorgaan zonder microfoon",ariaLabel:"Controleren op toegang tot microfoon. Toegang toestaan als hierom wordt gevraagd."};var CameraAndMicrophoneSitePermissionsDenied$7={primaryText:"Geen toegang tot camera en microfoon",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om microfoonmachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder camera en microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraAndMicrophoneSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot camera en microfoon",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder camera en microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraSitePermissionsDenied$7={primaryText:"Geen toegang tot camera",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om cameramachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder camera",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var MicrophoneSitePermissionsDenied$7={primaryText:"Geen toegang tot microfoon",secondaryText:"Klik op het vergrendelingspictogram op de adresbalk om microfoonmachtigingen toe te kennen aan deze webpagina. Mogelijk is een paginavernieuwing vereist.",primaryButtonText:"Doorgaan zonder microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var CameraSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot camera",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder camera",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var MicrophoneSitePermissionsDeniedSafari$7={primaryText:"Geen toegang tot microfoon",secondaryText:"Vernieuw de pagina om machtigingen toe te staan of controleer de instellingen van deze browser en controleer of machtigingen zijn ingeschakeld voor deze website.",primaryButtonText:"Doorgaan zonder microfoon",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var UnsupportedBrowser$7={primaryText:"Browser wordt niet ondersteund",secondaryText:"Neem deel aan dit gesprek via een compatibele browser.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken"};var UnsupportedBrowserVersion$7={primaryText:"Browserupdate vereist",secondaryText:"Werk uw browser bij en probeer opnieuw deel te nemen aan het gesprek om ervoor te zorgen dat u het beste kunt bellen.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken",continueAnywayButtonText:"Oproep starten zonder bij te werken"};var UnsupportedOperatingSystem$7={primaryText:"Besturingssysteem niet ondersteund",secondaryText:"Neem deel aan dit gesprek via een apparaat met een compatibel besturingssysteem.",moreHelpLinkText:"Compatibiliteitsvereisten bekijken"};var BrowserPermissionDenied$7={primaryText:"Kan uw camera of microfoon niet gebruiken",secondaryText:"Uw browser heeft mogelijk geen toegang tot uw camera of microfoon. Open Systeemvoorkeuren om dit op te lossen.",primaryButtonText:"Opnieuw proberen",linkText:"Hulp nodig? Hulp bij probleemoplossing"};var BrowserPermissionDeniedIOS$7={primaryText:"Microfoontoegang toestaan om door te gaan",secondaryText:"Zodat andere deelnemers u kunnen horen.",primaryButtonText:"Opnieuw proberen",imageAltText:"Machtigingslocatie voor microfoon en cameraapparaat voor iOS",linkText:"Hulp nodig? Hulp bij probleemoplossing",step1Text:"Ga naar de app Instellingen",step2Text:"Schuif omlaag naar instellingen voor deze browser",step3Text:"Microfoon inschakelen (camera optioneel)",step4Text:"Probeer opnieuw deel te nemen aan het gesprek",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$7={leftNavButtonAriaLabel:"vorige pagina",rightNavButtonAriaLabel:"volgende pagina"};var nl_NL$1 = {participantItem:participantItem$7,typingIndicator:typingIndicator$7,sendBox:sendBox$7,mentionPopover:mentionPopover$7,messageStatusIndicator:messageStatusIndicator$7,endCallButton:endCallButton$7,cameraButton:cameraButton$7,microphoneButton:microphoneButton$7,devicesButton:devicesButton$7,participantsButton:participantsButton$7,screenShareButton:screenShareButton$7,messageThread:messageThread$7,errorBar:errorBar$7,videoGallery:videoGallery$7,dialpad:dialpad$7,holdButton:holdButton$7,videoTile:videoTile$7,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$7,CameraSitePermissionsRequest:CameraSitePermissionsRequest$7,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$7,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$7,CameraSitePermissionsCheck:CameraSitePermissionsCheck$7,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$7,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$7,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$7,CameraSitePermissionsDenied:CameraSitePermissionsDenied$7,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$7,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$7,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$7,UnsupportedBrowser:UnsupportedBrowser$7,UnsupportedBrowserVersion:UnsupportedBrowserVersion$7,UnsupportedOperatingSystem:UnsupportedOperatingSystem$7,BrowserPermissionDenied:BrowserPermissionDenied$7,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$7,VerticalGallery:VerticalGallery$7};

var participantItem$6={isMeText:"(Ty)",menuTitle:"Więcej opcji",removeButtonLabel:"Usuń",sharingIconLabel:"Udostępnianie",mutedIconLabel:"Wyciszono",displayNamePlaceholder:"Uczestnik bez nazwy",participantStateRinging:"Trwa łączenie…",participantStateHold:"Zawieszony"};var typingIndicator$6={singleUser:"Użytkownik {user} pisze...",multipleUsers:"{users} piszą...",multipleUsersAbbreviateOne:"{users} i 1 inny użytkownik piszą...",multipleUsersAbbreviateMany:"{users} i {numOthers} innych użytkowników piszą...",delimiter:", "};var sendBox$6={placeholderText:"Wprowadź wiadomość",textTooLong:"Długość wiadomości przekracza maksymalny limit.",sendButtonAriaLabel:"Wyślij wiadomość",fileUploadsPendingError:"Trwa przekazywanie... Czekaj.",removeFile:"Usuwanie pliku",uploading:"Przekazywanie",uploadCompleted:"Zakończono przekazywanie"};var mentionPopover$6={mentionPopoverHeader:"Sugestie"};var messageStatusIndicator$6={deliveredAriaLabel:"Wiadomość została wysłana",deliveredTooltipText:"Wysłano",seenAriaLabel:"Wiadomość widziana przez inne osoby",seenTooltipText:"Wyświetlono",readByTooltipText:"Przeczytane przez {messageThreadReadCount} z {remoteParticipantsCount}",sendingAriaLabel:"Wysyłanie wiadomości",sendingTooltipText:"Wysyłanie",failedToSendAriaLabel:"Nie udało się wysłać wiadomości",failedToSendTooltipText:"Nie udało się wysłać"};var endCallButton$6={label:"Wyjdź",tooltipContent:"Opuść rozmowę"};var cameraButton$6={onLabel:"Wyłącz",offLabel:"Włącz",tooltipDisabledContent:"Kamera jest wyłączona",tooltipOnContent:"Wyłącz kamerę",tooltipOffContent:"Włącz kamerę",tooltipVideoLoadingContent:"Ładowanie wideo w toku",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Wybierz kamerę",cameraButtonSplitRoleDescription:"Przycisk podziału",onSplitButtonAriaLabel:"Wyłącz kamerę i jej opcje",offSplitButtonAriaLabel:"Włącz kamerę i jej opcje",cameraActionTurnedOnAnnouncement:"Kamera została włączona",cameraActionTurnedOffAnnouncement:"Kamera została wyłączona",onSplitButtonPrimaryActionCamera:"Wyłącz kamerę",offSplitButtonPrimaryActionCamera:"Włącz kamerę",cameraPrimaryActionSplitButtonTitle:"Użyj kamery",videoEffectsMenuItemTitle:"Efekty"};var microphoneButton$6={onLabel:"Wycisz",offLabel:"Wyłącz wyciszenie",tooltipDisabledContent:"Mikrofon jest wyłączony",tooltipOnContent:"Wycisz mikrofon",tooltipOffContent:"Wyłącz wyciszenie mikrofonu",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Wybierz mikrofon",speakerMenuTitle:"Głośnik",speakerMenuTooltip:"Wybierz głośnik",microphoneButtonSplitRoleDescription:"Przycisk podziału",onSplitButtonAriaLabel:"Wyciszenie mikrofonu i opcji dźwięku",offSplitButtonAriaLabel:"Wyłącz wyciszenie mikrofonu i opcji dźwięku",microphoneActionTurnedOnAnnouncement:"Mikrofon został włączony",microphoneActionTurnedOffAnnouncement:"Mikrofon został wyłączony",offSplitButtonMicrophonePrimaryAction:"Wyłącz wyciszenie mikrofonu",onSplitButtonMicrophonePrimaryAction:"Wycisz mikrofon",microphonePrimaryActionSplitButtonTitle:"Użyj mikrofonu"};var devicesButton$6={label:"Urządzenia",tooltipContent:"Zarządzaj urządzeniami",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Wybierz kamerę",audioDeviceMenuTitle:"Urządzenie audio",audioDeviceMenuTooltip:"Wybierz urządzenie audio",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Wybierz mikrofon",speakerMenuTitle:"Głośnik",speakerMenuTooltip:"Wybierz głośnik"};var participantsButton$6={label:"Osoby",tooltipContent:"Pokaż uczestników",menuHeader:"W tej rozmowie",participantsListButtonLabel:"Liczba osób: {numParticipants}",muteAllButtonLabel:"Wycisz wszystkich",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia"};var screenShareButton$6={onLabel:"Zakończ prezentację",offLabel:"Obecne",tooltipDisabledContent:"Prezentowanie jest wyłączone",tooltipOnContent:"Prezentowanie ekranu",tooltipOffContent:"Prezentuj swój ekran"};var messageThread$6={yesterday:"Wczoraj",sunday:"Niedziela",monday:"Poniedziałek",tuesday:"Wtorek",wednesday:"Środa",thursday:"Czwartek",friday:"Piątek",saturday:"Sobota",participantJoined:"dołączył do czatu.",participantLeft:"opuścił czat.",editMessage:"Edytuj",removeMessage:"Usuń",resendMessage:"Spróbuj wysłać ponownie",failToSendTag:"Nie udało się wysłać",editedTag:"Edytowane",liveAuthorIntro:"Autor {author} mówi",messageContentAriaText:"Użytkownik {author} powiedział: {message}",messageContentMineAriaText:"Wypowiedziano: {message}",editBoxTextLimit:"Twoja wiadomość przekracza limit {limitNumber} znaków",editBoxPlaceholderText:"Edytuj wiadomość",newMessagesIndicator:"Nowe wiadomości",noDisplayNameSub:"Bez nazwy",editBoxCancelButton:"Anuluj",editBoxSubmitButton:"Prześlij",messageReadCount:"Przeczytane przez {messageReadByCount} z {remoteParticipantsCount}",actionMenuMoreOptions:"Więcej opcji",downloadFile:"Pobierz plik",blockedWarningText:"Ta wiadomość została usunięta ze względu na zasady organizacyjne.",blockedWarningLinkText:"Szczegóły",fileCardGroupMessage:"Wiadomość ma następującą liczbę załączników: {fileCount}"};var errorBar$6={unableToReachChatService:"Jesteś w trybie offline",accessDenied:"Nie można uzyskać dostępu do usług czatu — sprawdź podane poświadczenia użytkownika",userNotInChatThread:"Nie jesteś już w tym wątku czatu",sendMessageNotInChatThread:"Nie można wysłać wiadomości, ponieważ nie jesteś już w tym wątku czatu",sendMessageGeneric:"Nie udało się wysłać wiadomości",callingNetworkFailure:"Problem z nawiązaniem połączenia — wygląda na to, że jesteś w trybie offline",startVideoGeneric:"Nie można uruchomić wideo",stopVideoGeneric:"Nie można zatrzymać wideo",muteGeneric:"Nie można wyciszyć mikrofonu",unmuteGeneric:"Nie można wyłączyć wyciszenia mikrofonu",speakingWhileMuted:"Mikrofon jest wyciszony",startScreenShareGeneric:"Wystąpił problem podczas uruchamiania udostępniania ekranu.",stopScreenShareGeneric:"Nie można zatrzymać udostępniania ekranu",callNetworkQualityLow:"Niska jakość sieci.",callNoSpeakerFound:"Nie znaleziono głośników ani słuchawek. Podłącz urządzenie audio, aby słyszeć rozmowę.",callNoMicrophoneFound:"Nie znaleziono mikrofonów. Podłącz urządzenie wejściowe audio.",callMicrophoneAccessDenied:"Nie można uzyskać dostępu do mikrofonu. Kliknij blokadę na pasku adresu, aby udzielić uprawnienia do tej strony sieci Web.",callMicrophoneAccessDeniedSafari:"Nie można uzyskać dostępu do mikrofonu. Odśwież stronę, aby zezwolić na uprawnienia, lub sprawdź ustawienia tej przeglądarki i sprawdź, czy uprawnienia są włączone dla tej witryny internetowej.",callMicrophoneMutedBySystem:"System wyciszył Cię.",callMicrophoneUnmutedBySystem:"Mikrofon został odzyskany i system wyłączył wyciszenie.",callMacOsMicrophoneAccessDenied:"Nie można uzyskać dostępu do mikrofonu. Udziel uprawnienia do mikrofonu w ustawieniach prywatności systemu macOS.",callLocalVideoFreeze:"Przepustowość sieci jest słaba. Twoje wideo może być wstrzymane dla innych osób podczas rozmowy.",callCameraAccessDenied:"Nie można uzyskać dostępu do kamery. Kliknij blokadę na pasku adresu, aby udzielić uprawnienia do tej strony sieci Web.",callCameraAccessDeniedSafari:"Nie można uzyskać dostępu do kamery. Odśwież stronę, aby zezwolić na uprawnienia, lub sprawdź ustawienia tej przeglądarki i sprawdź, czy uprawnienia są włączone dla tej witryny internetowej.",callCameraAlreadyInUse:"Nie można uzyskać dostępu do kamery. Być może jest już używany przez inną aplikację.",callVideoStoppedBySystem:"Wideo zostało zatrzymane przez system.",callVideoRecoveredBySystem:"Wideo zostało wznowione.",callMacOsCameraAccessDenied:"System MacOS blokuje dostęp do kamery. Zaktualizuj ustawienia prywatności, aby zezwolić tej przeglądarce na dostęp do kamery.",callMacOsScreenShareAccessDenied:"System MacOS blokuje udostępnianie ekranu. Zaktualizuj ustawienia prywatności, aby zezwolić tej przeglądarce na rejestrowanie ekranu.",dismissButtonAriaLabel:"Zamknij",failedToJoinCallGeneric:"Nie można dołączyć do rozmowy.",failedToJoinCallInvalidMeetingLink:"Nie można dołączyć do spotkania. Nieprawidłowy link.",cameraFrozenForRemoteParticipants:"Użytkownicy w trakcie rozmowy mają problemy z wyświetleniem Twojego wideo. Sprawdź urządzenia i sieć.",unableToStartVideoEffect:"Nie można zastosować efektu wideo."};var videoGallery$6={screenIsBeingSharedMessage:"Udostępniasz ekran",screenShareLoadingMessage:"Ładowanie ekranu uczestnika {participant}",localVideoLabel:"Ty",localVideoCameraSwitcherLabel:"Przełącz kamerę",localVideoMovementLabel:"Ruchomy lokalny kafelek wideo",localVideoSelectedDescription:"Wybrano kamerę {cameraName}",displayNamePlaceholder:"Uczestnik bez nazwy",fitRemoteParticipantToFrame:"Dopasuj do ramki",fillRemoteParticipantFrame:"Wypełnij ramkę",pinParticipantForMe:"Przypnij dla mnie",pinParticipantForMeLimitReached:"Przypięcie (osiągnięto limit)",unpinParticipantForMe:"Odepnij",pinParticipantMenuItemAriaLabel:"Przypnij uczestnika {participantName}",unpinParticipantMenuItemAriaLabel:"Odepnij uczestnika {participantName}",pinnedParticipantAnnouncementAriaLabel:"Przypięty uczestnik {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Odpięty uczestnik {participantName}"};var dialpad$6={placeholderText:"Wprowadź numer telefonu",deleteButtonAriaLabel:"Usuń"};var holdButton$6={onLabel:"Wznów",offLabel:"Zawieś",tooltipOnContent:"Wznów połączenie",tooltipOffContent:"Zawieś połączenie"};var videoTile$6={participantStateRinging:"Trwa łączenie…",participantStateHold:"Zawieszony"};var CameraAndMicrophoneSitePermissionsRequest$6={primaryText:"Zezwalaj {appName} na używanie kamery i mikrofonu",secondaryText:"Dzięki temu uczestnicy będą mogli Cię zobaczyć i usłyszeć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",ariaLabel:"Zezwalaj na dostęp do kamery i mikrofonu"};var CameraSitePermissionsRequest$6={primaryText:"Zezwalaj aplikacji {appName} na korzystanie z kamery",secondaryText:"Dzięki temu uczestnicy będą mogli Cię zobaczyć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez kamery",ariaLabel:"Zezwalaj na dostęp do kamery"};var MicrophoneSitePermissionsRequest$6={primaryText:"Zezwalaj aplikacji {appName} na używanie mikrofonu",secondaryText:"Dzięki temu uczestnicy będą mogli Cię usłyszeć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez mikrofonu",ariaLabel:"Zezwalaj na dostęp do mikrofonu"};var CameraAndMicrophoneSitePermissionsCheck$6={primaryText:"Sprawdzanie dostępu do kamery i mikrofonu",secondaryText:"Zezwalaj na dostęp, jeśli zostanie wyświetlony monit. Dzięki temu uczestnicy będą mogli Cię zobaczyć i usłyszeć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",ariaLabel:"Sprawdzanie dostępu do kamery i mikrofonu. Zezwalaj na dostęp, jeśli zostanie wyświetlony monit."};var CameraSitePermissionsCheck$6={primaryText:"Sprawdzanie dostępu do kamery",secondaryText:"Zezwalaj na dostęp, jeśli zostanie wyświetlony monit. Dzięki temu uczestnicy będą mogli Cię zobaczyć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez kamery",ariaLabel:"Sprawdzanie dostępu do kamery. Zezwalaj na dostęp, jeśli zostanie wyświetlony monit."};var MicrophoneSitePermissionsCheck$6={primaryText:"Sprawdzanie dostępu do mikrofonu",secondaryText:"Zezwalaj na dostęp, jeśli zostanie wyświetlony monit. Dzięki temu uczestnicy będą mogli Cię usłyszeć.",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",primaryButtonText:"Kontynuuj bez mikrofonu",ariaLabel:"Sprawdzanie dostępu do mikrofonu. Zezwalaj na dostęp, jeśli zostanie wyświetlony monit."};var CameraAndMicrophoneSitePermissionsDenied$6={primaryText:"Brak dostępu do kamery i mikrofonu",secondaryText:"Kliknij ikonę blokady na pasku adresu, aby udzielić uprawnień mikrofonu do tej strony sieci Web. Odświeżenie strony może być wymagane.",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var CameraAndMicrophoneSitePermissionsDeniedSafari$6={primaryText:"Brak dostępu do kamery i mikrofonu",secondaryText:"Odśwież stronę, aby zezwolić na uprawnienia, lub sprawdź ustawienia tej przeglądarki i sprawdź, czy uprawnienia są włączone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez kamery i mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var CameraSitePermissionsDenied$6={primaryText:"Brak dostępu do kamery",secondaryText:"Kliknij ikonę blokady na pasku adresu, aby udzielić uprawnień kamery do tej strony sieci Web. Odświeżenie strony może być wymagane.",primaryButtonText:"Kontynuuj bez kamery",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var MicrophoneSitePermissionsDenied$6={primaryText:"Brak dostępu do mikrofonu",secondaryText:"Kliknij ikonę blokady na pasku adresu, aby udzielić uprawnień mikrofonu do tej strony sieci Web. Odświeżenie strony może być wymagane.",primaryButtonText:"Kontynuuj bez mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var CameraSitePermissionsDeniedSafari$6={primaryText:"Brak dostępu do kamery",secondaryText:"Odśwież stronę, aby zezwolić na uprawnienia, lub sprawdź ustawienia tej przeglądarki i sprawdź, czy uprawnienia są włączone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez kamery",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var MicrophoneSitePermissionsDeniedSafari$6={primaryText:"Brak dostępu do mikrofonu",secondaryText:"Odśwież stronę, aby zezwolić na uprawnienia, lub sprawdź ustawienia tej przeglądarki i sprawdź, czy uprawnienia są włączone dla tej witryny internetowej.",primaryButtonText:"Kontynuuj bez mikrofonu",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var UnsupportedBrowser$6={primaryText:"Nieobsługiwana przeglądarka",secondaryText:"Dołącz do tej rozmowy przy użyciu zgodnej przeglądarki.",moreHelpLinkText:"Zobacz wymagania dotyczące zgodności"};var UnsupportedBrowserVersion$6={primaryText:"Wymagana aktualizacja przeglądarki",secondaryText:"Aby zapewnić najlepszą możliwą rozmowę, zaktualizuj przeglądarkę, a następnie spróbuj ponownie dołączyć do rozmowy.",moreHelpLinkText:"Zobacz wymagania dotyczące zgodności",continueAnywayButtonText:"Rozpocznij rozmowę bez aktualizowania"};var UnsupportedOperatingSystem$6={primaryText:"System operacyjny nie jest obsługiwany",secondaryText:"Dołącz do tej rozmowy przy użyciu urządzenia ze zgodnym systemem operacyjnym.",moreHelpLinkText:"Zobacz wymagania dotyczące zgodności"};var BrowserPermissionDenied$6={primaryText:"Nie można użyć kamery lub mikrofonu",secondaryText:"Twoja przeglądarka może nie mieć dostępu do kamery lub mikrofonu. Aby rozwiązać ten problem, otwórz okno Preferencje systemowe.",primaryButtonText:"Spróbuj ponownie",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów"};var BrowserPermissionDeniedIOS$6={primaryText:"Zezwalaj na dostęp do mikrofonu, aby kontynuować",secondaryText:"Inni uczestnicy będą mogli Cię usłyszeć.",primaryButtonText:"Spróbuj ponownie",imageAltText:"Lokalizacja uprawnień urządzenia z mikrofonem i kamerą dla systemu iOS",linkText:"Potrzebujesz pomocy? Uzyskaj pomoc dotyczącą rozwiązywania problemów",step1Text:"Przejdź do aplikacji Ustawienia",step2Text:"Przewiń w dół do ustawień dla tej przeglądarki",step3Text:"Włącz mikrofon (opcjonalnie kamerę)",step4Text:"Spróbuj ponownie dołączyć do rozmowy",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$6={leftNavButtonAriaLabel:"poprzednia strona",rightNavButtonAriaLabel:"następna strona"};var pl_PL$1 = {participantItem:participantItem$6,typingIndicator:typingIndicator$6,sendBox:sendBox$6,mentionPopover:mentionPopover$6,messageStatusIndicator:messageStatusIndicator$6,endCallButton:endCallButton$6,cameraButton:cameraButton$6,microphoneButton:microphoneButton$6,devicesButton:devicesButton$6,participantsButton:participantsButton$6,screenShareButton:screenShareButton$6,messageThread:messageThread$6,errorBar:errorBar$6,videoGallery:videoGallery$6,dialpad:dialpad$6,holdButton:holdButton$6,videoTile:videoTile$6,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$6,CameraSitePermissionsRequest:CameraSitePermissionsRequest$6,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$6,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$6,CameraSitePermissionsCheck:CameraSitePermissionsCheck$6,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$6,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$6,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$6,CameraSitePermissionsDenied:CameraSitePermissionsDenied$6,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$6,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$6,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$6,UnsupportedBrowser:UnsupportedBrowser$6,UnsupportedBrowserVersion:UnsupportedBrowserVersion$6,UnsupportedOperatingSystem:UnsupportedOperatingSystem$6,BrowserPermissionDenied:BrowserPermissionDenied$6,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$6,VerticalGallery:VerticalGallery$6};

var participantItem$5={isMeText:"(você)",menuTitle:"Mais opções",removeButtonLabel:"Remover",sharingIconLabel:"Compartilhamento",mutedIconLabel:"Silenciado",displayNamePlaceholder:"Participante sem nome",participantStateRinging:"Chamando...",participantStateHold:"Em espera"};var typingIndicator$5={singleUser:"{user} está digitando ...",multipleUsers:"{users} estão digitando ...",multipleUsersAbbreviateOne:"{users} e 1 outro estão digitando...",multipleUsersAbbreviateMany:"{users} e {numOthers} outros estão digitando ...",delimiter:", "};var sendBox$5={placeholderText:"Inserir uma mensagem",textTooLong:"O comprimento da mensagem está acima do limite máximo.",sendButtonAriaLabel:"Enviar mensagem",fileUploadsPendingError:"Carregando... Aguarde.",removeFile:"Remover arquivo",uploading:"Carregando",uploadCompleted:"Carregamento concluído"};var mentionPopover$5={mentionPopoverHeader:"Sugestões"};var messageStatusIndicator$5={deliveredAriaLabel:"Mensagem enviada",deliveredTooltipText:"Enviado",seenAriaLabel:"Mensagem vista por outras pessoas",seenTooltipText:"Visto",readByTooltipText:"Lido por {messageThreadReadCount} de {remoteParticipantsCount}",sendingAriaLabel:"Envio de mensagem",sendingTooltipText:"Enviando",failedToSendAriaLabel:"Falha ao enviar mensagem",failedToSendTooltipText:"Falha ao enviar"};var endCallButton$5={label:"Sair",tooltipContent:"Sair da chamada"};var cameraButton$5={onLabel:"Desabilitar",offLabel:"Habilitar",tooltipDisabledContent:"A câmera está desabilitada",tooltipOnContent:"Desabilitar a câmera",tooltipOffContent:"Ligar a câmera",tooltipVideoLoadingContent:"O vídeo está carregando",cameraMenuTitle:"Câmera",cameraMenuTooltip:"Escolher câmera",cameraButtonSplitRoleDescription:"Botão de divisão",onSplitButtonAriaLabel:"Desabilitar a câmera e as opções da câmera",offSplitButtonAriaLabel:"Habilitar a câmera e as opções da câmera",cameraActionTurnedOnAnnouncement:"A câmera foi ligada",cameraActionTurnedOffAnnouncement:"A câmera foi desligada",onSplitButtonPrimaryActionCamera:"Desligar a câmera",offSplitButtonPrimaryActionCamera:"Ligar a câmera",cameraPrimaryActionSplitButtonTitle:"Usar câmera",videoEffectsMenuItemTitle:"Efeitos"};var microphoneButton$5={onLabel:"Mudo",offLabel:"Desativar mudo",tooltipDisabledContent:"O microfone está desabilitado",tooltipOnContent:"Ativar mudo do microfone",tooltipOffContent:"Desativar mudo do microfone",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante",microphoneButtonSplitRoleDescription:"Botão de divisão",onSplitButtonAriaLabel:"Ativar mudo das opções de microfone e áudio",offSplitButtonAriaLabel:"Desativar mudo do microfone e opções de áudio",microphoneActionTurnedOnAnnouncement:"O microfone foi ligado",microphoneActionTurnedOffAnnouncement:"O microfone foi desligado",offSplitButtonMicrophonePrimaryAction:"Desativar mudo do microfone",onSplitButtonMicrophonePrimaryAction:"Ativar mudo do microfone",microphonePrimaryActionSplitButtonTitle:"Usar o microfone"};var devicesButton$5={label:"Dispositivos",tooltipContent:"Gerenciar dispositivos",cameraMenuTitle:"Câmera",cameraMenuTooltip:"Escolher câmera",audioDeviceMenuTitle:"Dispositivo de Áudio",audioDeviceMenuTooltip:"Escolher dispositivo de áudio",microphoneMenuTitle:"Microfone",microphoneMenuTooltip:"Escolher microfone",speakerMenuTitle:"Alto-falante",speakerMenuTooltip:"Escolher alto-falante"};var participantsButton$5={label:"Pessoas",tooltipContent:"Mostrar participantes",menuHeader:"Nesta chamada",participantsListButtonLabel:"{numParticipants} pessoas",muteAllButtonLabel:"Silenciar todos",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado"};var screenShareButton$5={onLabel:"Interromper apresentação",offLabel:"Apresentação",tooltipDisabledContent:"A apresentação está desabilitada.",tooltipOnContent:"Apresentando sua tela",tooltipOffContent:"Apresentar sua tela"};var messageThread$5={yesterday:"Ontem",sunday:"Domingo",monday:"Segunda",tuesday:"Terça-feira",wednesday:"Quarta-feira",thursday:"quinta-feira",friday:"Sexta-feira",saturday:"Sábado",participantJoined:"ingressou no chat.",participantLeft:"saiu do chat.",editMessage:"Editar",removeMessage:"Excluir",resendMessage:"Tente enviar novamente",failToSendTag:"Falha ao enviar",editedTag:"Editado",liveAuthorIntro:"{author} disse",messageContentAriaText:"{author} disse {message}",messageContentMineAriaText:"Você disse {message}",editBoxTextLimit:"Sua mensagem está acima do limite de {limitNumber} caracteres",editBoxPlaceholderText:"Edite sua mensagem",newMessagesIndicator:"Novas mensagens",noDisplayNameSub:"Sem nome",editBoxCancelButton:"Cancelar",editBoxSubmitButton:"Enviar",messageReadCount:"Lido por {messageReadByCount} de {remoteParticipantsCount}",actionMenuMoreOptions:"Mais opções",downloadFile:"Baixar arquivo",blockedWarningText:"Esta mensagem foi excluída devido à política organizacional.",blockedWarningLinkText:"Detalhes",fileCardGroupMessage:"A mensagem tem {fileCount} anexo"};var errorBar$5={unableToReachChatService:"Você está offline",accessDenied:"Não é possível acessar os serviços de chat - verifique as credenciais do usuário fornecidas",userNotInChatThread:"Você não está mais neste tópico de chat",sendMessageNotInChatThread:"Falha ao enviar mensagem porque você não está mais neste thread de chat",sendMessageGeneric:"Falha ao enviar mensagem",callingNetworkFailure:"Chamada de conexão desabilitar - parece que você está offline",startVideoGeneric:"Falha ao iniciar o vídeo",stopVideoGeneric:"Falha ao interromper o vídeo",muteGeneric:"Falha ao ativar mudo do microfone",unmuteGeneric:"Falha ao desativar mudo do microfone",speakingWhileMuted:"O microfone está com o mudo ativado",startScreenShareGeneric:"Ocorreu um problema ao iniciar o compartilhamento de tela.",stopScreenShareGeneric:"Falha ao interromper o compartilhamento de tela",callNetworkQualityLow:"A qualidade da rede é baixa.",callNoSpeakerFound:"Nenhum alto-falante ou fone de ouvido encontrado. Conecte um dispositivo de áudio para ouvir a chamada.",callNoMicrophoneFound:"Nenhum microfone encontrado. Conecte um dispositivo de entrada de áudio.",callMicrophoneAccessDenied:"Não é possível acessar o microfone. Clique no bloqueio na barra de endereços para conceder permissão a esta página da Web.",callMicrophoneAccessDeniedSafari:"Não é possível acessar o microfone. Atualize a página para permitir permissões ou verifique as configurações deste navegador e verifique se as permissões estão habilitadas para este site.",callMicrophoneMutedBySystem:"Você está com as notificações desativada pelo sistema.",callMicrophoneUnmutedBySystem:"Seu microfone se recuperou e você foi desativado pelo sistema.",callMacOsMicrophoneAccessDenied:"Não é possível acessar o microfone. Conceda permissão ao microfone nas configurações de privacidade do macOS.",callLocalVideoFreeze:"A largura de banda da rede é ruim. Seu vídeo pode aparecer em pausa para outras pessoas na chamada.",callCameraAccessDenied:"Não é possível acessar a câmera. Clique no bloqueio na barra de endereços para conceder permissão a esta página da Web.",callCameraAccessDeniedSafari:"Não é possível acessar a câmera. Atualize a página para permitir permissões ou verifique as configurações deste navegador e verifique se as permissões estão habilitadas para este site.",callCameraAlreadyInUse:"Não é possível acessar a câmera. Talvez ele já esteja em uso por outro aplicativo.",callVideoStoppedBySystem:"Seu vídeo foi interrompido pelo sistema.",callVideoRecoveredBySystem:"Seu vídeo foi retomado.",callMacOsCameraAccessDenied:"O MacOS está bloqueando o acesso à sua câmera. Atualize suas configurações de privacidade para permitir que este navegador acesse sua câmera.",callMacOsScreenShareAccessDenied:"O MacOS está bloqueando o compartilhamento de tela. Atualize suas configurações de privacidade para permitir que este navegador grave sua tela.",dismissButtonAriaLabel:"Fechar",failedToJoinCallGeneric:"Ocorreu um erro ao ingressar na chamada.",failedToJoinCallInvalidMeetingLink:"Não é possível ingressar na Reunião. Link Inválido.",cameraFrozenForRemoteParticipants:"Os usuários na chamada estão enfrentando problemas para ver seu vídeo. Verifique seus dispositivos e a rede.",unableToStartVideoEffect:"Não é possível aplicar o efeito de vídeo."};var videoGallery$5={screenIsBeingSharedMessage:"Você está compartilhando sua tela",screenShareLoadingMessage:"Carregando a tela do {participant}",localVideoLabel:"Você",localVideoCameraSwitcherLabel:"Alternar câmera",localVideoMovementLabel:"Bloco de Vídeo Local Removível",localVideoSelectedDescription:"{cameraName} selecionado",displayNamePlaceholder:"Participante sem nome",fitRemoteParticipantToFrame:"Ajustar ao quadro",fillRemoteParticipantFrame:"Preencher quadro",pinParticipantForMe:"Fixar para mim",pinParticipantForMeLimitReached:"PIN (limite alcançado)",unpinParticipantForMe:"Desafixar",pinParticipantMenuItemAriaLabel:"Fixar {participantName}",unpinParticipantMenuItemAriaLabel:"Desafixar {participantName}",pinnedParticipantAnnouncementAriaLabel:"Fixado {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Desafixado {participantName}"};var dialpad$5={placeholderText:"Inserir o número do telefone",deleteButtonAriaLabel:"Excluir"};var holdButton$5={onLabel:"Retomar",offLabel:"Retenção",tooltipOnContent:"Retomar chamada",tooltipOffContent:"Manter chamada em espera"};var videoTile$5={participantStateRinging:"Chamando...",participantStateHold:"Em espera"};var CameraAndMicrophoneSitePermissionsRequest$5={primaryText:"Permitir {appName} usar a câmera e o microfone",secondaryText:"Isso é para que os participantes possam ver e ouvir você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem câmera e microfone",ariaLabel:"Permitir acesso à câmera e ao microfone"};var CameraSitePermissionsRequest$5={primaryText:"Permitir que {appName} use a câmera",secondaryText:"Isso é para que os participantes possam ver você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem a câmera",ariaLabel:"Permitir acesso à câmera"};var MicrophoneSitePermissionsRequest$5={primaryText:"Permitir que {appName} use o microfone",secondaryText:"Isso é para que os participantes possam ouvir você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem o microfone",ariaLabel:"Permitir acesso ao microfone"};var CameraAndMicrophoneSitePermissionsCheck$5={primaryText:"Verificando o acesso à câmera e ao microfone",secondaryText:"Permitir acesso, se solicitado. Isso é para que os participantes possam ver e ouvir você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem câmera e microfone",ariaLabel:"Verificando o acesso à câmera e ao microfone. Permitir o acesso se solicitado."};var CameraSitePermissionsCheck$5={primaryText:"Verificando o acesso à câmera",secondaryText:"Permitir acesso, se solicitado. Isso é para que os participantes possam ver você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem câmera",ariaLabel:"Verificando o acesso à câmera. Permitir o acesso se solicitado."};var MicrophoneSitePermissionsCheck$5={primaryText:"Verificando o acesso ao microfone",secondaryText:"Permitir acesso, se solicitado. Isso é para que os participantes possam ouvir você.",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",primaryButtonText:"Continuar sem microfone",ariaLabel:"Verificando acesso ao microfone. Permitir o acesso se solicitado."};var CameraAndMicrophoneSitePermissionsDenied$5={primaryText:"Não é possível acessar a câmera e o microfone",secondaryText:"Clique no ícone de bloqueio na barra de endereços para conceder permissões de microfone a esta página da Web. Uma atualização de página pode ser necessária.",primaryButtonText:"Continuar sem câmera e microfone",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var CameraAndMicrophoneSitePermissionsDeniedSafari$5={primaryText:"Não é possível acessar a câmera e o microfone",secondaryText:"Atualize a página para permitir permissões ou verifique as configurações deste navegador e verifique se as permissões estão habilitadas para este site.",primaryButtonText:"Continuar sem câmera e microfone",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var CameraSitePermissionsDenied$5={primaryText:"Não é possível acessar a câmera",secondaryText:"Clique no ícone de bloqueio na barra de endereços para conceder permissões de câmera a esta página da Web. Uma atualização de página pode ser necessária.",primaryButtonText:"Continuar sem a câmera",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var MicrophoneSitePermissionsDenied$5={primaryText:"Não é possível acessar o microfone",secondaryText:"Clique no ícone de bloqueio na barra de endereços para conceder permissões de microfone a esta página da Web. Uma atualização de página pode ser necessária.",primaryButtonText:"Continuar sem microfone",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var CameraSitePermissionsDeniedSafari$5={primaryText:"Não é possível acessar a câmera",secondaryText:"Atualize a página para permitir permissões ou verifique as configurações deste navegador e verifique se as permissões estão habilitadas para este site.",primaryButtonText:"Continuar sem câmera",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var MicrophoneSitePermissionsDeniedSafari$5={primaryText:"Não é possível acessar o microfone",secondaryText:"Atualize a página para permitir permissões ou verifique as configurações deste navegador e verifique se as permissões estão habilitadas para este site.",primaryButtonText:"Continuar sem o microfone",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var UnsupportedBrowser$5={primaryText:"Navegador sem suporte",secondaryText:"Ingresse nesta chamada usando um navegador compatível.",moreHelpLinkText:"Consulte os requisitos de compatibilidade"};var UnsupportedBrowserVersion$5={primaryText:"Atualização do navegador necessária",secondaryText:"Para garantir a melhor chamada possível, atualize o navegador e tente ingressar na chamada novamente.",moreHelpLinkText:"Consulte os requisitos de compatibilidade",continueAnywayButtonText:"Iniciar chamada sem atualizar"};var UnsupportedOperatingSystem$5={primaryText:"Sistema operacional sem suporte",secondaryText:"Ingresse nesta chamada usando um dispositivo com um sistema operacional compatível.",moreHelpLinkText:"Consulte os requisitos de compatibilidade"};var BrowserPermissionDenied$5={primaryText:"Não é possível usar sua câmera ou microfone",secondaryText:"Seu navegador pode não ter acesso à câmera ou ao microfone. Para corrigir isso, abra as Preferências do Sistema.",primaryButtonText:"Tentar novamente",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas"};var BrowserPermissionDeniedIOS$5={primaryText:"Permitir acesso ao microfone para continuar",secondaryText:"Para que outros participantes possam ouvi-lo.",primaryButtonText:"Tentar novamente",imageAltText:"Localização da permissão do microfone e do dispositivo da câmera para iOS",linkText:"Preciso de ajuda? Obtenha ajuda para solução de problemas",step1Text:"Acessar o aplicativo Configurações",step2Text:"Rolar para baixo até as configurações deste navegador",step3Text:"Ligar o microfone (Câmera opcional)",step4Text:"Tentar ingressar na chamada novamente",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$5={leftNavButtonAriaLabel:"página anterior",rightNavButtonAriaLabel:"próxima página"};var pt_BR$1 = {participantItem:participantItem$5,typingIndicator:typingIndicator$5,sendBox:sendBox$5,mentionPopover:mentionPopover$5,messageStatusIndicator:messageStatusIndicator$5,endCallButton:endCallButton$5,cameraButton:cameraButton$5,microphoneButton:microphoneButton$5,devicesButton:devicesButton$5,participantsButton:participantsButton$5,screenShareButton:screenShareButton$5,messageThread:messageThread$5,errorBar:errorBar$5,videoGallery:videoGallery$5,dialpad:dialpad$5,holdButton:holdButton$5,videoTile:videoTile$5,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$5,CameraSitePermissionsRequest:CameraSitePermissionsRequest$5,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$5,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$5,CameraSitePermissionsCheck:CameraSitePermissionsCheck$5,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$5,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$5,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$5,CameraSitePermissionsDenied:CameraSitePermissionsDenied$5,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$5,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$5,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$5,UnsupportedBrowser:UnsupportedBrowser$5,UnsupportedBrowserVersion:UnsupportedBrowserVersion$5,UnsupportedOperatingSystem:UnsupportedOperatingSystem$5,BrowserPermissionDenied:BrowserPermissionDenied$5,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$5,VerticalGallery:VerticalGallery$5};

var participantItem$4={isMeText:"(Вы)",menuTitle:"Дополнительные параметры",removeButtonLabel:"Удалить",sharingIconLabel:"Общий доступ",mutedIconLabel:"Микрофон отключен",displayNamePlaceholder:"Участник без имени",participantStateRinging:"Выполняется вызов...",participantStateHold:"На удержании"};var typingIndicator$4={singleUser:"{user} вводит текст...",multipleUsers:"{users} вводят текст...",multipleUsersAbbreviateOne:"{users} и еще 1 вводят текст...",multipleUsersAbbreviateMany:"{users} и еще {numOthers} вводят текст...",delimiter:"; "};var sendBox$4={placeholderText:"Введите сообщение",textTooLong:"Длина сообщения превышает максимально допустимую.",sendButtonAriaLabel:"Отправить сообщение",fileUploadsPendingError:"Выполняется загрузка. Подождите...",removeFile:"Удалить файл",uploading:"Отправка",uploadCompleted:"Отправка завершена"};var mentionPopover$4={mentionPopoverHeader:"Рекомендации"};var messageStatusIndicator$4={deliveredAriaLabel:"Сообщение отправлено",deliveredTooltipText:"Отправлено",seenAriaLabel:"Сообщение просмотрено другими пользователями",seenTooltipText:"Просмотрено",readByTooltipText:"Прочитали: {messageThreadReadCount} из {remoteParticipantsCount}",sendingAriaLabel:"Отправка сообщения",sendingTooltipText:"Отправка",failedToSendAriaLabel:"Не удалось отправить сообщение",failedToSendTooltipText:"Не удалось отправить"};var endCallButton$4={label:"Выйти",tooltipContent:"Покинуть вызов"};var cameraButton$4={onLabel:"Отключить",offLabel:"Включить",tooltipDisabledContent:"Камера отключена",tooltipOnContent:"Выключить камеру",tooltipOffContent:"Включить камеру",tooltipVideoLoadingContent:"Видео загружается",cameraMenuTitle:"Камера",cameraMenuTooltip:"Выбрать камеру",cameraButtonSplitRoleDescription:"Разворачивающаяся кнопка",onSplitButtonAriaLabel:"Отключить камеру и параметры камеры",offSplitButtonAriaLabel:"Включить камеру и параметры камеры",cameraActionTurnedOnAnnouncement:"Камера включена",cameraActionTurnedOffAnnouncement:"Камера отключена",onSplitButtonPrimaryActionCamera:"Выключить камеру",offSplitButtonPrimaryActionCamera:"Включить камеру",cameraPrimaryActionSplitButtonTitle:"Использовать камеру",videoEffectsMenuItemTitle:"Эффекты"};var microphoneButton$4={onLabel:"Отключить звук",offLabel:"Включить звук",tooltipDisabledContent:"Микрофон отключен",tooltipOnContent:"Отключить микрофон",tooltipOffContent:"Включить микрофон",microphoneMenuTitle:"Микрофон",microphoneMenuTooltip:"Выбрать микрофон",speakerMenuTitle:"Динамик",speakerMenuTooltip:"Выбрать динамик",microphoneButtonSplitRoleDescription:"Разворачивающаяся кнопка",onSplitButtonAriaLabel:"Отключить микрофон и параметры звука",offSplitButtonAriaLabel:"Включить микрофон и параметры звука",microphoneActionTurnedOnAnnouncement:"Ваш микрофон включен",microphoneActionTurnedOffAnnouncement:"Ваш микрофон отключен",offSplitButtonMicrophonePrimaryAction:"Включить микрофон",onSplitButtonMicrophonePrimaryAction:"Отключить микрофон",microphonePrimaryActionSplitButtonTitle:"Использовать микрофон"};var devicesButton$4={label:"Устройства",tooltipContent:"Управление устройствами",cameraMenuTitle:"Камера",cameraMenuTooltip:"Выбрать камеру",audioDeviceMenuTitle:"Звуковое устройство",audioDeviceMenuTooltip:"Выбрать звуковое устройство",microphoneMenuTitle:"Микрофон",microphoneMenuTooltip:"Выбрать микрофон",speakerMenuTitle:"Динамик",speakerMenuTooltip:"Выбрать динамик"};var participantsButton$4={label:"Люди",tooltipContent:"Показать участников",menuHeader:"В этом звонке",participantsListButtonLabel:"Пользователей: {numParticipants}",muteAllButtonLabel:"Отключить все микрофоны",copyInviteLinkButtonLabel:"Копировать ссылку с приглашением",copyInviteLinkActionedAriaLabel:"Ссылка на приглашение скопирована"};var screenShareButton$4={onLabel:"Остановить демонстрацию",offLabel:"Демонстрировать",tooltipDisabledContent:"Демонстрация отключена",tooltipOnContent:"Демонстрация экрана",tooltipOffContent:"Демонстрировать экран"};var messageThread$4={yesterday:"Вчера",sunday:"Воскресенье",monday:"Понедельник",tuesday:"Вторник",wednesday:"Среда",thursday:"Четверг",friday:"Пятница",saturday:"Суббота",participantJoined:"присоединился к чату.",participantLeft:"покинул чат.",editMessage:"Изменить",removeMessage:"Удалить",resendMessage:"Отправьте еще раз",failToSendTag:"Не удалось отправить",editedTag:"Изменено",liveAuthorIntro:"{author} говорит",messageContentAriaText:"{author} говорит {message}",messageContentMineAriaText:"Вы сказали {message}",editBoxTextLimit:"Превышено предельное число символов в {limitNumber} сообщении",editBoxPlaceholderText:"Отредактируйте сообщение",newMessagesIndicator:"Новые сообщения",noDisplayNameSub:"Без имени",editBoxCancelButton:"Отмена",editBoxSubmitButton:"Отправить",messageReadCount:"Прочитали: {messageReadByCount} из {remoteParticipantsCount}",actionMenuMoreOptions:"Дополнительные параметры",downloadFile:"Скачать файл",blockedWarningText:"Это сообщение было удалено политикой организации.",blockedWarningLinkText:"Сведения",fileCardGroupMessage:"Сообщение содержит {fileCount} вложение"};var errorBar$4={unableToReachChatService:"Вы не в сети",accessDenied:"Не удалось получить доступ к службам чата. Проверьте предоставленные учетные данные пользователя",userNotInChatThread:"Вы больше не находитесь в цепочке этого чата",sendMessageNotInChatThread:"Не удалось отправить сообщение, так как вы больше не находитесь в цепочке этого чата",sendMessageGeneric:"Не удалось отправить сообщение",callingNetworkFailure:"Тревожное подключение вызова — кажется, вы не в сети",startVideoGeneric:"Не удалось запустить видео",stopVideoGeneric:"Не удалось остановить видео",muteGeneric:"Не удалось отключить микрофон",unmuteGeneric:"Не удалось включить микрофон",speakingWhileMuted:"Микрофон отключен",startScreenShareGeneric:"Возникла проблема с запуском демонстрации экрана.",stopScreenShareGeneric:"Не удалось остановить демонстрацию экрана",callNetworkQualityLow:"Качество работы сети: низкое.",callNoSpeakerFound:"Динамики и наушники не найдены. Подключите звуковое устройство, чтобы услышать звонок.",callNoMicrophoneFound:"Микрофоны не найдены. Подключение звукового устройства ввода.",callMicrophoneAccessDenied:"Не удается получить доступ к микрофону. Щелкните блокировку в адресной строке, чтобы предоставить разрешение на эту веб-страницу.",callMicrophoneAccessDeniedSafari:"Не удается получить доступ к микрофону. Обновите страницу, чтобы разрешить разрешения, или проверьте параметры браузера и убедитесь, что для этого веб-сайта включены разрешения.",callMicrophoneMutedBySystem:"Система отключила ваш микрофон.",callMicrophoneUnmutedBySystem:"Микрофон восстановлен, и система включила ваш звук.",callMacOsMicrophoneAccessDenied:"Не удается получить доступ к микрофону. Предоставьте разрешение на доступ к микрофону в параметрах конфиденциальности macOS.",callLocalVideoFreeze:"Низкая пропускная способность сети. Ваше видео может отображаться как приостановленное для других участников вызова.",callCameraAccessDenied:"Не удается получить доступ к камере. Щелкните блокировку в адресной строке, чтобы предоставить разрешение на эту веб-страницу.",callCameraAccessDeniedSafari:"Не удается получить доступ к камере. Обновите страницу, чтобы разрешить разрешения, или проверьте параметры браузера и убедитесь, что для этого веб-сайта включены разрешения.",callCameraAlreadyInUse:"Не удается получить доступ к камере. Возможно, оно уже используется другим приложением.",callVideoStoppedBySystem:"Воспроизведение видео остановлено системой.",callVideoRecoveredBySystem:"Воспроизведение видео возобновлено.",callMacOsCameraAccessDenied:"MacOS блокирует доступ к камере. Обновите параметры конфиденциальности, чтобы разрешить этому браузеру доступ к камере.",callMacOsScreenShareAccessDenied:"MacOS блокирует демонстрацию экрана. Обновите параметры конфиденциальности, чтобы разрешить этому браузеру записывать ваш экран.",dismissButtonAriaLabel:"Закрыть",failedToJoinCallGeneric:"Не удалось присоединиться к звонку.",failedToJoinCallInvalidMeetingLink:"Не удалось присоединиться к собранию. Недопустимая ссылка.",cameraFrozenForRemoteParticipants:"У участников звонка возникают проблемы с просмотром вашего видео. Проверьте свои устройства и сеть.",unableToStartVideoEffect:"Не удалось применить эффект видео."};var videoGallery$4={screenIsBeingSharedMessage:"Вы демонстрируете свой экран",screenShareLoadingMessage:"Загрузка экрана пользователя {participant}",localVideoLabel:"Вы",localVideoCameraSwitcherLabel:"Переключить камеру",localVideoMovementLabel:"Перемещаемая локальная плитка видео",localVideoSelectedDescription:"Выбрана камера {cameraName}",displayNamePlaceholder:"Участник без имени",fitRemoteParticipantToFrame:"Вписать в кадр",fillRemoteParticipantFrame:"Заполнить кадр",pinParticipantForMe:"Закрепить для меня",pinParticipantForMeLimitReached:"Закрепить (достигнуто ограничение)",unpinParticipantForMe:"Открепить",pinParticipantMenuItemAriaLabel:"Закрепить участника {participantName}",unpinParticipantMenuItemAriaLabel:"Открепить участника {participantName}",pinnedParticipantAnnouncementAriaLabel:"Участник {participantName} закреплен",unpinnedParticipantAnnouncementAriaLabel:"Участник {participantName} откреплен"};var dialpad$4={placeholderText:"Введите номер телефона",deleteButtonAriaLabel:"Удалить"};var holdButton$4={onLabel:"Возобновить",offLabel:"Удержать",tooltipOnContent:"Возобновить звонок",tooltipOffContent:"Поставить звонок на удержание"};var videoTile$4={participantStateRinging:"Выполняется вызов...",participantStateHold:"На удержании"};var CameraAndMicrophoneSitePermissionsRequest$4={primaryText:"Разрешить {appName} использовать камеру и микрофон",secondaryText:"Это необходимо для того, чтобы участники могли видеть и слышать вас.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без камеры и микрофона",ariaLabel:"Разрешить доступ к камере и микрофону"};var CameraSitePermissionsRequest$4={primaryText:"Разрешите приложению {appName} использовать камеру",secondaryText:"Это необходимо для того, чтобы участники могли вас видеть.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без камеры",ariaLabel:"Разрешить доступ к камере"};var MicrophoneSitePermissionsRequest$4={primaryText:"Разрешите приложению {appName} использовать микрофон",secondaryText:"Это делается для того, чтобы участники могли вас слышать.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без микрофона",ariaLabel:"Разрешить доступ к микрофону"};var CameraAndMicrophoneSitePermissionsCheck$4={primaryText:"Проверка доступа к камере и микрофону",secondaryText:"Разрешить доступ при запросе. Это делается для того, чтобы участники могли вас видеть и слышать.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без камеры и микрофона",ariaLabel:"Проверка доступа к камере и микрофону. Разрешить доступ при запросе."};var CameraSitePermissionsCheck$4={primaryText:"Проверка доступа к камере",secondaryText:"Разрешить доступ при запросе. Это необходимо для того, чтобы участники могли вас видеть.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без камеры",ariaLabel:"Проверка доступа к камере. Разрешить доступ при запросе."};var MicrophoneSitePermissionsCheck$4={primaryText:"Проверка доступа к микрофону",secondaryText:"Разрешить доступ при запросе. Это делается для того, чтобы участники могли вас слышать.",linkText:"Нужна помощь? Получите справку по устранению неполадок",primaryButtonText:"Продолжить без микрофона",ariaLabel:"Проверка доступа к микрофону. Разрешить доступ при запросе."};var CameraAndMicrophoneSitePermissionsDenied$4={primaryText:"Не удается получить доступ к камере и микрофону",secondaryText:"Щелкните значок блокировки в адресной строке, чтобы предоставить разрешение на доступ к микрофону для этой веб-страницы. Может потребоваться обновление страницы.",primaryButtonText:"Продолжить без камеры и микрофона",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var CameraAndMicrophoneSitePermissionsDeniedSafari$4={primaryText:"Не удается получить доступ к камере и микрофону",secondaryText:"Обновите страницу, чтобы предоставить разрешения, или проверьте параметры браузера и включите разрешения для этого веб-сайта.",primaryButtonText:"Продолжить без камеры и микрофона",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var CameraSitePermissionsDenied$4={primaryText:"Не удается получить доступ к камере",secondaryText:"Щелкните значок блокировки в адресной строке, чтобы предоставить разрешения камеры для этой веб-страницы. Может потребоваться обновить страницу.",primaryButtonText:"Продолжить без камеры",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var MicrophoneSitePermissionsDenied$4={primaryText:"Не удается получить доступ к микрофону",secondaryText:"Щелкните значок блокировки в адресной строке, чтобы предоставить разрешение на доступ к микрофону для этой веб-страницы. Может потребоваться обновление страницы.",primaryButtonText:"Продолжить без микрофона",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var CameraSitePermissionsDeniedSafari$4={primaryText:"Не удается получить доступ к камере",secondaryText:"Обновите страницу, чтобы предоставить разрешения, или проверьте параметры браузера и включите разрешения для этого веб-сайта.",primaryButtonText:"Продолжить без камеры",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var MicrophoneSitePermissionsDeniedSafari$4={primaryText:"Не удается получить доступ к микрофону",secondaryText:"Обновите страницу, чтобы предоставить разрешения, или проверьте параметры браузера и включите разрешения для этого веб-сайта.",primaryButtonText:"Продолжить без микрофона",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var UnsupportedBrowser$4={primaryText:"Браузер не поддерживается",secondaryText:"Присоединитесь к этому вызову с помощью совместимого браузера.",moreHelpLinkText:"См. требования к совместимости"};var UnsupportedBrowserVersion$4={primaryText:"Необходимо обновление браузера",secondaryText:"Чтобы обеспечить наилучший возможный звонок, обновите браузер и попробуйте присоединиться к звонку еще раз.",moreHelpLinkText:"См. требования к совместимости",continueAnywayButtonText:"Начать звонок без обновления"};var UnsupportedOperatingSystem$4={primaryText:"Операционная система не поддерживается",secondaryText:"Присоединитесь к этому вызову, используя устройство с совместимой операционной системой.",moreHelpLinkText:"См. требования к совместимости"};var BrowserPermissionDenied$4={primaryText:"Не удается использовать камеру или микрофон",secondaryText:"Возможно, у вашего браузера нет доступа к камере или микрофону. Чтобы устранить эту проблему, откройте параметры системы.",primaryButtonText:"Повторить попытку",linkText:"Нужна помощь? Получите справку по устранению неполадок"};var BrowserPermissionDeniedIOS$4={primaryText:"Разрешите доступ к микрофону, чтобы продолжить",secondaryText:"Таким образом, другие участники могут вас слышать.",primaryButtonText:"Повторить попытку",imageAltText:"Разрешение на доступ к микрофону и камере для iOS",linkText:"Нужна помощь? Получите справку по устранению неполадок",step1Text:"Перейдите в приложение \"Параметры\"",step2Text:"Прокрутите страницу вниз до параметров этого браузера",step3Text:"Включите микрофон (камера необязательна)",step4Text:"Попробуйте присоединиться к вызову еще раз",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$4={leftNavButtonAriaLabel:"предыдущая страница",rightNavButtonAriaLabel:"следующая страница"};var ru_RU$1 = {participantItem:participantItem$4,typingIndicator:typingIndicator$4,sendBox:sendBox$4,mentionPopover:mentionPopover$4,messageStatusIndicator:messageStatusIndicator$4,endCallButton:endCallButton$4,cameraButton:cameraButton$4,microphoneButton:microphoneButton$4,devicesButton:devicesButton$4,participantsButton:participantsButton$4,screenShareButton:screenShareButton$4,messageThread:messageThread$4,errorBar:errorBar$4,videoGallery:videoGallery$4,dialpad:dialpad$4,holdButton:holdButton$4,videoTile:videoTile$4,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$4,CameraSitePermissionsRequest:CameraSitePermissionsRequest$4,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$4,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$4,CameraSitePermissionsCheck:CameraSitePermissionsCheck$4,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$4,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$4,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$4,CameraSitePermissionsDenied:CameraSitePermissionsDenied$4,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$4,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$4,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$4,UnsupportedBrowser:UnsupportedBrowser$4,UnsupportedBrowserVersion:UnsupportedBrowserVersion$4,UnsupportedOperatingSystem:UnsupportedOperatingSystem$4,BrowserPermissionDenied:BrowserPermissionDenied$4,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$4,VerticalGallery:VerticalGallery$4};

var participantItem$3={isMeText:"(du)",menuTitle:"Fler alternativ",removeButtonLabel:"Ta bort",sharingIconLabel:"Delar",mutedIconLabel:"Ljudet är avstängt",displayNamePlaceholder:"Namnlös deltagare",participantStateRinging:"Ringer...",participantStateHold:"Parkerat"};var typingIndicator$3={singleUser:"{user} skriver...",multipleUsers:"{users} skriver...",multipleUsersAbbreviateOne:"{users} och 1 annan skriver...",multipleUsersAbbreviateMany:"{users} och {numOthers} andra skriver...",delimiter:", "};var sendBox$3={placeholderText:"Skriv ett meddelande",textTooLong:"Meddelandelängden överskrider maxgränsen.",sendButtonAriaLabel:"Skicka meddelande",fileUploadsPendingError:"Uppladdning pågår... Vänta.",removeFile:"Ta bort filen",uploading:"Laddar upp",uploadCompleted:"Uppladdningen har slutförts"};var mentionPopover$3={mentionPopoverHeader:"Förslag"};var messageStatusIndicator$3={deliveredAriaLabel:"Meddelandet har skickats",deliveredTooltipText:"Skickat",seenAriaLabel:"Meddelande som andra ser",seenTooltipText:"Sett",readByTooltipText:"Läst av {messageThreadReadCount} av {remoteParticipantsCount}",sendingAriaLabel:"Meddelandet skickas",sendingTooltipText:"Skickar",failedToSendAriaLabel:"Meddelandet skickades inte",failedToSendTooltipText:"Inte skickat"};var endCallButton$3={label:"Lämna",tooltipContent:"Lämna samtal"};var cameraButton$3={onLabel:"Inaktivera",offLabel:"Aktivera",tooltipDisabledContent:"Kameran är inaktiverad",tooltipOnContent:"Stäng av kameran",tooltipOffContent:"Aktivera kameran",tooltipVideoLoadingContent:"Videon läses in",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Välj kamera",cameraButtonSplitRoleDescription:"Delningsknapp",onSplitButtonAriaLabel:"Inaktivera kamera- och kameraalternativ",offSplitButtonAriaLabel:"Aktivera kamera- och kameraalternativ",cameraActionTurnedOnAnnouncement:"Kameran har aktiverats",cameraActionTurnedOffAnnouncement:"Kameran har stängts av",onSplitButtonPrimaryActionCamera:"Stäng av kameran",offSplitButtonPrimaryActionCamera:"Aktivera kameran",cameraPrimaryActionSplitButtonTitle:"Använd kamera",videoEffectsMenuItemTitle:"Effekter"};var microphoneButton$3={onLabel:"Mikrofon av",offLabel:"Mikrofon på",tooltipDisabledContent:"Mikrofonen är inaktiverad",tooltipOnContent:"Stäng av mikrofonen",tooltipOffContent:"Slå på mikrofonen",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Välj mikrofon",speakerMenuTitle:"Högtalare",speakerMenuTooltip:"Välj högtalare",microphoneButtonSplitRoleDescription:"Delningsknapp",onSplitButtonAriaLabel:"Ljud av mikrofon och ljudalternativ",offSplitButtonAriaLabel:"Slå på ljudet för mikrofon och ljudalternativ",microphoneActionTurnedOnAnnouncement:"Mikrofonen har aktiverats",microphoneActionTurnedOffAnnouncement:"Mikrofonen har inaktiverats",offSplitButtonMicrophonePrimaryAction:"Slå på mikrofonen",onSplitButtonMicrophonePrimaryAction:"Stäng av mikrofonen",microphonePrimaryActionSplitButtonTitle:"Använd mikrofon"};var devicesButton$3={label:"Enheter",tooltipContent:"Hantera enheter",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Välj kamera",audioDeviceMenuTitle:"Ljudenhet",audioDeviceMenuTooltip:"Välj ljudenhet",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Välj mikrofon",speakerMenuTitle:"Högtalare",speakerMenuTooltip:"Välj högtalare"};var participantsButton$3={label:"Personer",tooltipContent:"Visa deltagare",menuHeader:"I det här samtalet",participantsListButtonLabel:"{numParticipants} personer",muteAllButtonLabel:"Ljud av för alla",copyInviteLinkButtonLabel:"Kopiera inbjudningslänk",copyInviteLinkActionedAriaLabel:"Inbjudningslänken har kopierats"};var screenShareButton$3={onLabel:"Sluta presentera",offLabel:"Present",tooltipDisabledContent:"Presentationen är inaktiverad",tooltipOnContent:"Visar din skärm",tooltipOffContent:"Dela skärmen"};var messageThread$3={yesterday:"I går",sunday:"Söndag",monday:"Måndag",tuesday:"Tisdag",wednesday:"Onsdag",thursday:"Torsdag",friday:"Fredag",saturday:"Lördag",participantJoined:"gick med i chatten.",participantLeft:"lämnade chatten.",editMessage:"Redigera",removeMessage:"Ta bort",resendMessage:"Försök skicka igen",failToSendTag:"Inte skickat",editedTag:"Redigerad",liveAuthorIntro:"{author} säger",messageContentAriaText:"{author} sa {message}",messageContentMineAriaText:"Du sa {message}",editBoxTextLimit:"Meddelandet överskrider gränsen på {limitNumber} tecken",editBoxPlaceholderText:"Redigera meddelandet",newMessagesIndicator:"Nya meddelanden",noDisplayNameSub:"Inget namn",editBoxCancelButton:"Avbryt",editBoxSubmitButton:"Skicka",messageReadCount:"Läst av {messageReadByCount} av {remoteParticipantsCount}",actionMenuMoreOptions:"Fler alternativ",downloadFile:"Ladda ner fil",blockedWarningText:"Det här meddelandet har tagits bort på grund av en organisationsprincip.",blockedWarningLinkText:"Information",fileCardGroupMessage:"Meddelandet har {fileCount} bifogad fil"};var errorBar$3={unableToReachChatService:"Du är offline",accessDenied:"Det går inte att komma åt chatttjänster – kontrollera de angivna autentiseringsuppgifterna",userNotInChatThread:"Du är inte längre i den här chatttråden",sendMessageNotInChatThread:"Det gick inte att skicka meddelandet eftersom du inte längre är i den här chatttråden",sendMessageGeneric:"Meddelandet inte skickat",callingNetworkFailure:"Störande anslutningssamtal – du verkar vara offline",startVideoGeneric:"Det gick inte att starta videon",stopVideoGeneric:"Det gick inte att stoppa videon",muteGeneric:"Det gick inte att stänga av mikrofonen",unmuteGeneric:"Det gick inte att slå på mikrofonen",speakingWhileMuted:"Mikrofonens ljud har stängts av",startScreenShareGeneric:"Det uppstod ett problem när skärmdelningen skulle startas.",stopScreenShareGeneric:"Det gick inte att stoppa skärmdelning",callNetworkQualityLow:"Nätverkskvaliteten är låg.",callNoSpeakerFound:"Inga högtalare eller hörlurar hittades. Anslut en ljudenhet för att höra samtalet.",callNoMicrophoneFound:"Inga mikrofoner hittades. Anslut en ljudinmatningsenhet.",callMicrophoneAccessDenied:"Det går inte att komma åt mikrofonen. Klicka på låset i adressfältet om du vill bevilja behörighet till den här webbsidan.",callMicrophoneAccessDeniedSafari:"Det går inte att komma åt mikrofonen. Uppdatera sidan om du vill tillåta behörigheter, eller kontrollera webbläsarens inställningar och kontrollera att behörigheter är aktiverade för den här webbplatsen.",callMicrophoneMutedBySystem:"Du är avstängt av systemet.",callMicrophoneUnmutedBySystem:"Mikrofonen har återställts och datorn har slagit på ljudet.",callMacOsMicrophoneAccessDenied:"Det går inte att komma åt mikrofonen. Bevilja mikrofonbehörighet i dina sekretessinställningar för macOS.",callLocalVideoFreeze:"Nätverksbandbredden är dålig. Din video kan visas pausad för andra i samtalet.",callCameraAccessDenied:"Det går inte att komma åt kameran. Klicka på låset i adressfältet om du vill bevilja behörighet till den här webbsidan.",callCameraAccessDeniedSafari:"Det går inte att komma åt kameran. Uppdatera sidan om du vill tillåta behörigheter, eller kontrollera webbläsarens inställningar och kontrollera att behörigheter är aktiverade för den här webbplatsen.",callCameraAlreadyInUse:"Det går inte att komma åt kameran. Den kanske redan används av ett annat program.",callVideoStoppedBySystem:"Din video har stoppats av systemet.",callVideoRecoveredBySystem:"Videon har återupptagits.",callMacOsCameraAccessDenied:"MacOS blockerar åtkomsten till kameran. Uppdatera dina sekretessinställningar så att den här webbläsaren får åtkomst till kameran.",callMacOsScreenShareAccessDenied:"MacOS blockerar skärmdelning. Uppdatera dina sekretessinställningar så att den här webbläsaren kan spela in din skärm.",dismissButtonAriaLabel:"Stäng",failedToJoinCallGeneric:"Det gick inte att ansluta till samtalet.",failedToJoinCallInvalidMeetingLink:"Det går inte att ansluta till mötet. Ogiltig länk.",cameraFrozenForRemoteParticipants:"Användare i samtalet har problem med att se din video. Kontrollera dina enheter och nätverk.",unableToStartVideoEffect:"Det går inte att tillämpa videoeffekten."};var videoGallery$3={screenIsBeingSharedMessage:"Du delar din skärm",screenShareLoadingMessage:"Läser in {participant}s skärm",localVideoLabel:"Du",localVideoCameraSwitcherLabel:"Växla kamera",localVideoMovementLabel:"Flyttbar lokal videopanel",localVideoSelectedDescription:"{cameraName} har valts",displayNamePlaceholder:"Namnlös deltagare",fitRemoteParticipantToFrame:"Anpassa till ruta",fillRemoteParticipantFrame:"Fyll ruta",pinParticipantForMe:"Fäst åt mig",pinParticipantForMeLimitReached:"Fäst (gränsen har nåtts)",unpinParticipantForMe:"Ta bort",pinParticipantMenuItemAriaLabel:"Fäst {participantName}",unpinParticipantMenuItemAriaLabel:"Ta bort {participantName}",pinnedParticipantAnnouncementAriaLabel:"Fäst {participantName}",unpinnedParticipantAnnouncementAriaLabel:"Borttagen {participantName}"};var dialpad$3={placeholderText:"Ange telefonnummer",deleteButtonAriaLabel:"Ta bort"};var holdButton$3={onLabel:"Återuppta",offLabel:"Bevarande",tooltipOnContent:"Återuppta samtal",tooltipOffContent:"Parkera samtal"};var videoTile$3={participantStateRinging:"Ringer...",participantStateHold:"Parkerat"};var CameraAndMicrophoneSitePermissionsRequest$3={primaryText:"Tillåt {appName} använda kameran och mikrofonen",secondaryText:"Det här är så att deltagarna kan se och höra dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan kamera och mikrofon",ariaLabel:"Tillåt kamera- och mikrofonåtkomst"};var CameraSitePermissionsRequest$3={primaryText:"Tillåt {appName} att använda kameran",secondaryText:"Det här är så att deltagarna kan se dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan kamera",ariaLabel:"Tillåt kameraåtkomst"};var MicrophoneSitePermissionsRequest$3={primaryText:"Tillåt {appName} att använda mikrofonen",secondaryText:"Det här är så att deltagarna kan höra dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan mikrofon",ariaLabel:"Tillåt mikrofonåtkomst"};var CameraAndMicrophoneSitePermissionsCheck$3={primaryText:"Söker efter åtkomst till kameran och mikrofonen",secondaryText:"Tillåt åtkomst om du uppmanas till det. Det här är så att deltagarna kan se och höra dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan kamera och mikrofon",ariaLabel:"Söker efter åtkomst till kameran och mikrofonen. Tillåt åtkomst om du uppmanas att göra det."};var CameraSitePermissionsCheck$3={primaryText:"Söker efter kameraåtkomst",secondaryText:"Tillåt åtkomst om du uppmanas att göra det. Det här är så att deltagarna kan se dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan kamera",ariaLabel:"Söker efter kameraåtkomst. Tillåt åtkomst om du uppmanas att göra det."};var MicrophoneSitePermissionsCheck$3={primaryText:"Söker efter mikrofonåtkomst",secondaryText:"Tillåt åtkomst om du uppmanas till det. Det här är så att deltagarna kan höra dig.",linkText:"Behöver du hjälp? Få hjälp med felsökning",primaryButtonText:"Fortsätt utan mikrofon",ariaLabel:"Söker efter mikrofonåtkomst. Tillåt åtkomst om du uppmanas att göra det."};var CameraAndMicrophoneSitePermissionsDenied$3={primaryText:"Det går inte att komma åt kameran och mikrofonen",secondaryText:"Klicka på låsikonen i adressfältet om du vill bevilja mikrofonbehörighet till den här webbsidan. Det kan krävas en siduppdatering.",primaryButtonText:"Fortsätt utan kamera och mikrofon",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var CameraAndMicrophoneSitePermissionsDeniedSafari$3={primaryText:"Det går inte att komma åt kameran och mikrofonen",secondaryText:"Uppdatera sidan om du vill tillåta behörigheter, eller kontrollera webbläsarens inställningar och kontrollera att behörigheter är aktiverade för den här webbplatsen.",primaryButtonText:"Fortsätt utan kamera och mikrofon",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var CameraSitePermissionsDenied$3={primaryText:"Det går inte att komma åt kameran",secondaryText:"Klicka på låsikonen i adressfältet om du vill bevilja kamerabehörigheter till den här webbsidan. Det kan krävas en siduppdatering.",primaryButtonText:"Fortsätt utan kamera",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var MicrophoneSitePermissionsDenied$3={primaryText:"Det går inte att komma åt mikrofonen",secondaryText:"Klicka på låsikonen i adressfältet om du vill bevilja mikrofonbehörighet till den här webbsidan. Det kan krävas en siduppdatering.",primaryButtonText:"Fortsätt utan mikrofon",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var CameraSitePermissionsDeniedSafari$3={primaryText:"Det går inte att komma åt kameran",secondaryText:"Uppdatera sidan om du vill tillåta behörigheter, eller kontrollera webbläsarens inställningar och kontrollera att behörigheter är aktiverade för den här webbplatsen.",primaryButtonText:"Fortsätt utan kamera",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var MicrophoneSitePermissionsDeniedSafari$3={primaryText:"Det går inte att komma åt mikrofonen",secondaryText:"Uppdatera sidan om du vill tillåta behörigheter, eller kontrollera webbläsarens inställningar och kontrollera att behörigheter är aktiverade för den här webbplatsen.",primaryButtonText:"Fortsätt utan mikrofon",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var UnsupportedBrowser$3={primaryText:"Webbläsaren stöds inte",secondaryText:"Anslut till samtalet med en kompatibel webbläsare.",moreHelpLinkText:"Se kompatibilitetskrav"};var UnsupportedBrowserVersion$3={primaryText:"Uppdatering av webbläsare krävs",secondaryText:"Uppdatera webbläsaren och försök sedan ansluta till samtalet igen för att säkerställa bästa möjliga samtal.",moreHelpLinkText:"Se kompatibilitetskrav",continueAnywayButtonText:"Starta samtal utan att uppdatera"};var UnsupportedOperatingSystem$3={primaryText:"Operativsystemet stöds inte",secondaryText:"Anslut till det här samtalet med en enhet med ett kompatibelt operativsystem.",moreHelpLinkText:"Se kompatibilitetskrav"};var BrowserPermissionDenied$3={primaryText:"Det går inte att använda kameran eller mikrofonen",secondaryText:"Din webbläsare kanske inte har åtkomst till din kamera eller mikrofon. Åtgärda detta genom att öppna Systeminställningar.",primaryButtonText:"Försök igen",linkText:"Behöver du hjälp? Få hjälp med felsökning"};var BrowserPermissionDeniedIOS$3={primaryText:"Tillåt mikrofonåtkomst för att fortsätta",secondaryText:"Så att andra deltagare kan höra dig.",primaryButtonText:"Försök igen",imageAltText:"Behörighetsplats för mikrofon och kameraenhet för iOS",linkText:"Behöver du hjälp? Få hjälp med felsökning",step1Text:"Gå till appen Inställningar",step2Text:"Rulla ned till inställningarna för den här webbläsaren",step3Text:"Aktivera mikrofon (kamera valfritt)",step4Text:"Försök ansluta till samtalet igen",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$3={leftNavButtonAriaLabel:"föregående sida",rightNavButtonAriaLabel:"nästa sida"};var sv_SE$1 = {participantItem:participantItem$3,typingIndicator:typingIndicator$3,sendBox:sendBox$3,mentionPopover:mentionPopover$3,messageStatusIndicator:messageStatusIndicator$3,endCallButton:endCallButton$3,cameraButton:cameraButton$3,microphoneButton:microphoneButton$3,devicesButton:devicesButton$3,participantsButton:participantsButton$3,screenShareButton:screenShareButton$3,messageThread:messageThread$3,errorBar:errorBar$3,videoGallery:videoGallery$3,dialpad:dialpad$3,holdButton:holdButton$3,videoTile:videoTile$3,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$3,CameraSitePermissionsRequest:CameraSitePermissionsRequest$3,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$3,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$3,CameraSitePermissionsCheck:CameraSitePermissionsCheck$3,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$3,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$3,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$3,CameraSitePermissionsDenied:CameraSitePermissionsDenied$3,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$3,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$3,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$3,UnsupportedBrowser:UnsupportedBrowser$3,UnsupportedBrowserVersion:UnsupportedBrowserVersion$3,UnsupportedOperatingSystem:UnsupportedOperatingSystem$3,BrowserPermissionDenied:BrowserPermissionDenied$3,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$3,VerticalGallery:VerticalGallery$3};

var participantItem$2={isMeText:"(siz)",menuTitle:"Diğer Seçenekler",removeButtonLabel:"Kaldır",sharingIconLabel:"Paylaşım",mutedIconLabel:"Ses kapatıldı",displayNamePlaceholder:"Adsız katılımcı",participantStateRinging:"Arıyor...",participantStateHold:"Beklemede"};var typingIndicator$2={singleUser:"{user} yazıyor...",multipleUsers:"{users} yazıyor ...",multipleUsersAbbreviateOne:"{users} ve 1 kişi daha yazıyor...",multipleUsersAbbreviateMany:"{users} ve {numOthers} kişi daha yazıyor...",delimiter:", "};var sendBox$2={placeholderText:"Bir mesaj girin",textTooLong:"İletinizin uzunluğu üst sınırı aşıyor.",sendButtonAriaLabel:"İleti gönder",fileUploadsPendingError:"Karşıya yükleniyor... Lütfen bekleyin.",removeFile:"Dosyayı kaldır",uploading:"Karşıya yükleniyor",uploadCompleted:"Karşıya yükleme tamamlandı"};var mentionPopover$2={mentionPopoverHeader:"Öneriler"};var messageStatusIndicator$2={deliveredAriaLabel:"İleti gönderildi",deliveredTooltipText:"Gönderilen",seenAriaLabel:"İleti başkaları tarafından görüldü",seenTooltipText:"Görüldü",readByTooltipText:"{messageThreadReadCount} / {remoteParticipantsCount} katılımcı tarafından okundu",sendingAriaLabel:"İleti gönderiliyor",sendingTooltipText:"Gönderiliyor",failedToSendAriaLabel:"İleti gönderilemedi",failedToSendTooltipText:"Gönderilemedi"};var endCallButton$2={label:"Ayrıl",tooltipContent:"Aramadan ayrıl"};var cameraButton$2={onLabel:"Kapat",offLabel:"Aç",tooltipDisabledContent:"Kamera devre dışı",tooltipOnContent:"Kamerayı kapat",tooltipOffContent:"Kamerayı aç",tooltipVideoLoadingContent:"Video yükleniyor",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera seç",cameraButtonSplitRoleDescription:"Bölünmüş düğme",onSplitButtonAriaLabel:"Kamerayı ve kamera seçeneklerini devre dışı bırak",offSplitButtonAriaLabel:"Kamerayı ve kamera seçeneklerini etkinleştir",cameraActionTurnedOnAnnouncement:"Kameranız açıldı",cameraActionTurnedOffAnnouncement:"Kameranız kapatıldı",onSplitButtonPrimaryActionCamera:"Kamerayı kapat",offSplitButtonPrimaryActionCamera:"Kamerayı aç",cameraPrimaryActionSplitButtonTitle:"Kamerayı kullan",videoEffectsMenuItemTitle:"Efektler"};var microphoneButton$2={onLabel:"Sesi kapat",offLabel:"Sesi aç",tooltipDisabledContent:"Mikrofon devre dışı",tooltipOnContent:"Mikrofonun sesini kapat",tooltipOffContent:"Mikrofonun sesini aç",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon seç",speakerMenuTitle:"Hoparlör",speakerMenuTooltip:"Hoparlör seç",microphoneButtonSplitRoleDescription:"Bölünmüş düğme",onSplitButtonAriaLabel:"Mikrofonun ve ses seçeneklerinin sesini kapat",offSplitButtonAriaLabel:"Mikrofonun ve ses seçeneklerinin sesini aç",microphoneActionTurnedOnAnnouncement:"Mikrofonunuz açıldı",microphoneActionTurnedOffAnnouncement:"Mikrofonunuz kapatıldı",offSplitButtonMicrophonePrimaryAction:"Mikrofonun sesini aç",onSplitButtonMicrophonePrimaryAction:"Mikrofonun sesini kapat",microphonePrimaryActionSplitButtonTitle:"Mikrofonu kullan"};var devicesButton$2={label:"Cihazlar",tooltipContent:"Cihazları yönet",cameraMenuTitle:"Kamera",cameraMenuTooltip:"Kamera seç",audioDeviceMenuTitle:"Ses Cihazı",audioDeviceMenuTooltip:"Ses cihazı seç",microphoneMenuTitle:"Mikrofon",microphoneMenuTooltip:"Mikrofon seç",speakerMenuTitle:"Hoparlör",speakerMenuTooltip:"Hoparlör seç"};var participantsButton$2={label:"Kişiler",tooltipContent:"Katılımcıları göster",menuHeader:"Bu aramada",participantsListButtonLabel:"{numParticipants} kişiler",muteAllButtonLabel:"Tümünün sesini kapat",copyInviteLinkButtonLabel:"Davet bağlantısını kopyala",copyInviteLinkActionedAriaLabel:"Davet bağlantısı kopyalandı"};var screenShareButton$2={onLabel:"Sunumu Durdur",offLabel:"Sun",tooltipDisabledContent:"Sunu devre dışı bırakıldı.",tooltipOnContent:"Ekranınızı sunuluyor",tooltipOffContent:"Ekranınızı sunun"};var messageThread$2={yesterday:"Dün",sunday:"Pazar",monday:"Pazartesi",tuesday:"Salı",wednesday:"Çarşamba",thursday:"Perşembe",friday:"Cuma",saturday:"Cumartesi",participantJoined:"sohbete katıldı.",participantLeft:"sohbetten ayrıldı.",editMessage:"Düzenle",removeMessage:"Sil",resendMessage:"Yeniden göndermeyi deneyin",failToSendTag:"Gönderilemedi",editedTag:"Düzenlendi",liveAuthorIntro:"{author} şöyle diyor:",messageContentAriaText:"{author} iletisinde şunu yazdı: {message}",messageContentMineAriaText:"{message}dediniz",editBoxTextLimit:"İletiniz en fazla {limitNumber} aşıyor",editBoxPlaceholderText:"İletinizi düzenleyin",newMessagesIndicator:"Yeni iletiler",noDisplayNameSub:"Ad yok",editBoxCancelButton:"İptal",editBoxSubmitButton:"Gönder",messageReadCount:"{messageReadByCount} / {remoteParticipantsCount} katılımcı tarafından okundu",actionMenuMoreOptions:"Diğer Seçenekler",downloadFile:"Dosyayı indir",blockedWarningText:"Bu ileti kuruluş ilkesi nedeniyle silindi.",blockedWarningLinkText:"Ayrıntılar",fileCardGroupMessage:"İletide {fileCount} ek var"};var errorBar$2={unableToReachChatService:"Çevrimdışısınız",accessDenied:"Sohbet hizmetlerine erişilemedi. Lütfen sağlanan kullanıcı kimlik bilgilerini denetleyin",userNotInChatThread:"Artık bu sohbet yazışması içinde değilsiniz",sendMessageNotInChatThread:"Artık bu sohbet yazışması içinde olmadığınız için ileti gönderilemedi",sendMessageGeneric:"İleti gönderilemedi",callingNetworkFailure:"Arama bağlanırken sorun oluştu; çevrimdışı görünüyorsunuz",startVideoGeneric:"Video başlatılamadı",stopVideoGeneric:"Video durdurulamadı",muteGeneric:"Mikrofonun sesi kapatılamadı",unmuteGeneric:"Mikrofonun sesi açılamadı",speakingWhileMuted:"Mikrofonunuzun sesi kapalı",startScreenShareGeneric:"Ekran paylaşımı başlatılırken bir sorun oluştu.",stopScreenShareGeneric:"Ekran paylaşımı durdurulamadı",callNetworkQualityLow:"Ağ kalitesi düşük.",callNoSpeakerFound:"Hoparlör veya kulaklık bulunamadı. Aramayı dinlemek için bir ses aygıtı bağlayın.",callNoMicrophoneFound:"Mikrofon bulunamadı. Ses giriş cihazı bağlan.",callMicrophoneAccessDenied:"Mikrofona erişemiyor. Bu web sayfası için izin vermek için adres çubuğundaki kilidi tıklatın.",callMicrophoneAccessDeniedSafari:"Mikrofona erişemiyor. İzin vermek için sayfayı yenileyin veya bu tarayıcının ayarlarını denetleyin ve bu web sitesi için izinlerin etkinleştirildiğinden emin olun.",callMicrophoneMutedBySystem:"Sisteminiz tarafından sessize alındınız.",callMicrophoneUnmutedBySystem:"Mikrofonunuz kurtarıldı ve sisteminiz tarafından sesiniz açıldı.",callMacOsMicrophoneAccessDenied:"Mikrofona erişilemiyor. macOS gizlilik ayarlarınızda mikrofon izni verin.",callLocalVideoFreeze:"Ağ bant genişliği düşük. Görüntülü aramada başkaları için duraklatılmış görünüyor olabilir.",callCameraAccessDenied:"Kameraya erişemiyor. Bu web sayfası için izin vermek için adres çubuğundaki kilidi tıklatın.",callCameraAccessDeniedSafari:"Kameraya erişemiyor. İzin vermek için sayfayı yenileyin veya bu tarayıcının ayarlarını denetleyin ve bu web sitesi için izinlerin etkinleştirildiğinden emin olun.",callCameraAlreadyInUse:"Kameraya erişemiyor. Başka bir uygulama tarafından zaten kullanılıyor olabilir.",callVideoStoppedBySystem:"Videonuz sisteminiz tarafından durduruldu.",callVideoRecoveredBySystem:"Videonuz devam ediyor.",callMacOsCameraAccessDenied:"MacOS kameranıza erişimi engelliyor. Bu tarayıcının kameranıza erişmesine izin vermek için gizlilik ayarlarınızı güncelleştirin.",callMacOsScreenShareAccessDenied:"MacOS ekran paylaşımını engelliyor. Bu tarayıcının ekranınızı kaydetmesini izin vermek için gizlilik ayarlarınızı güncelleştirin.",dismissButtonAriaLabel:"Kapat",failedToJoinCallGeneric:"Aramaya katılınamadı.",failedToJoinCallInvalidMeetingLink:"Toplantıya katılınamıyor. Geçersiz Bağlantı.",cameraFrozenForRemoteParticipants:"Aramadaki kullanıcılar videonuzu görmekte sorun yaşıyor. Lütfen cihazlarınızı ve ağlarınızı kontrol edin.",unableToStartVideoEffect:"Video efekti uygulanamıyor."};var videoGallery$2={screenIsBeingSharedMessage:"Ekranınızı paylaşıyorsunuz.",screenShareLoadingMessage:"{participant} adlı katılımcının ekranını yükleme",localVideoLabel:"Siz",localVideoCameraSwitcherLabel:"Kamerayı değiştir",localVideoMovementLabel:"Taşınabilir Yerel Video Kutucuğu",localVideoSelectedDescription:"{cameraName} seçildi",displayNamePlaceholder:"Adsız katılımcı",fitRemoteParticipantToFrame:"Çerçeveye sığdır",fillRemoteParticipantFrame:"Çerçeveyi doldur",pinParticipantForMe:"Benim için sabitle",pinParticipantForMeLimitReached:"Sabitleme (sınıra ulaşıldı)",unpinParticipantForMe:"Sabitlemeyi kaldır",pinParticipantMenuItemAriaLabel:"{participantName} adlı katılımcıyı sabitle",unpinParticipantMenuItemAriaLabel:"{participantName} adlı katılımcının sabitlemesini kaldır",pinnedParticipantAnnouncementAriaLabel:"{participantName} adlı katılımcı sabitlendi",unpinnedParticipantAnnouncementAriaLabel:"{participantName} adlı katılımcının sabitlemesi kaldırıldı"};var dialpad$2={placeholderText:"Telefon numarası gir",deleteButtonAriaLabel:"Sil"};var holdButton$2={onLabel:"Devam et",offLabel:"Beklet",tooltipOnContent:"Görüşmeye devam etme",tooltipOffContent:"Aramayı bekletme"};var videoTile$2={participantStateRinging:"Aranıyor...",participantStateHold:"Beklemede"};var CameraAndMicrophoneSitePermissionsRequest$2={primaryText:"{appName} uygulamasının kameranızı ve mikrofonunuzu kullanmasına izin verin",secondaryText:"Bu, katılımcıların sizi görebilmesi ve duyabilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Kamera ve mikrofon olmadan devam et",ariaLabel:"Kamera ve mikrofon erişimine izin ver"};var CameraSitePermissionsRequest$2={primaryText:"{appName} uygulamasının kameranızı kullanmasına izin verin",secondaryText:"Bu, katılımcıların sizi görebilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Kamera olmadan devam et",ariaLabel:"Kamera erişimine izin ver"};var MicrophoneSitePermissionsRequest$2={primaryText:"{appName} uygulamasının mikrofonunuzu kullanmasına izin verin",secondaryText:"Bu, katılımcıların sizi duyabilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Mikrofon olmadan devam et",ariaLabel:"Mikrofon erişimine izin ver"};var CameraAndMicrophoneSitePermissionsCheck$2={primaryText:"Kamera ve mikrofon erişimi denetleniyor",secondaryText:"İstenirse erişime izin verin. Bu, katılımcıların sizi görebilmesi ve duyabilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Kamera ve mikrofon olmadan devam et",ariaLabel:"Kamera ve mikrofon erişimi denetleniyor. İstenirse erişime izin verin."};var CameraSitePermissionsCheck$2={primaryText:"Kamera erişimi denetleniyor",secondaryText:"İstenirse erişime izin verin. Bu, katılımcıların sizi görebilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Kamera olmadan devam et",ariaLabel:"Kamera erişimi denetleniyor. İstenirse erişime izin verin."};var MicrophoneSitePermissionsCheck$2={primaryText:"Mikrofon erişimi denetleniyor",secondaryText:"İstenirse erişime izin verin. Bu, katılımcıların sizi duyabilmesi içindir.",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",primaryButtonText:"Mikrofon olmadan devam et",ariaLabel:"Mikrofon erişimi denetleniyor. İstenirse erişime izin verin."};var CameraAndMicrophoneSitePermissionsDenied$2={primaryText:"Kamera ve mikrofona erişemiyor",secondaryText:"Bu web sayfası için mikrofon izinleri vermek için adres çubuğundaki kilit simgesine tıklayın. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Kamera ve mikrofon olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var CameraAndMicrophoneSitePermissionsDeniedSafari$2={primaryText:"Kamera ve mikrofona erişemiyor",secondaryText:"İzin vermek için sayfayı yenileyin veya bu tarayıcının ayarlarını denetleyin ve bu web sitesi için izinlerin etkinleştirildiğinden emin olun.",primaryButtonText:"Kamera ve mikrofon olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var CameraSitePermissionsDenied$2={primaryText:"Kameraya erişilemiyor",secondaryText:"Bu web sayfasında kamera izinleri vermek için adres çubuğundaki kilit simgesine tıklayın. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Kamera olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var MicrophoneSitePermissionsDenied$2={primaryText:"Mikrofona erişilemiyor",secondaryText:"Bu web sayfası için mikrofon izinleri vermek için adres çubuğundaki kilit simgesine tıklayın. Sayfa yenilemesi gerekebilir.",primaryButtonText:"Mikrofon olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var CameraSitePermissionsDeniedSafari$2={primaryText:"Kameraya erişilemiyor",secondaryText:"İzin vermek için sayfayı yenileyin veya bu tarayıcının ayarlarını denetleyin ve bu web sitesi için izinlerin etkinleştirildiğinden emin olun.",primaryButtonText:"Kamera olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var MicrophoneSitePermissionsDeniedSafari$2={primaryText:"Mikrofona erişilemiyor",secondaryText:"İzin vermek için sayfayı yenileyin veya bu tarayıcının ayarlarını denetleyin ve bu web sitesi için izinlerin etkinleştirildiğinden emin olun.",primaryButtonText:"Mikrofon olmadan devam et",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var UnsupportedBrowser$2={primaryText:"Tarayıcı desteklenmiyor",secondaryText:"Lütfen uyumlu bir tarayıcı kullanarak bu aramaya katılın.",moreHelpLinkText:"Uyumluluk gereksinimlerini görüntüleyin"};var UnsupportedBrowserVersion$2={primaryText:"Tarayıcı güncelleştirmesi gerekiyor",secondaryText:"Mümkün olan en iyi arama deneyimi için lütfen tarayıcınızı güncelleştirin ve aramaya yeniden katılmayı deneyin.",moreHelpLinkText:"Uyumluluk gereksinimlerini görüntüleyin",continueAnywayButtonText:"Güncelleştirmeden arama başlat"};var UnsupportedOperatingSystem$2={primaryText:"İşletim sistemi desteklenmiyor",secondaryText:"Lütfen uyumlu bir işletim sistemine sahip bir cihaz kullanarak bu çağrıya katılın.",moreHelpLinkText:"Uyumluluk gereksinimlerini görüntüleyin"};var BrowserPermissionDenied$2={primaryText:"Kameranızı veya mikrofonunuzu kullanamazsınız",secondaryText:"Tarayıcınızın kameranıza veya mikrofonunuza erişimi olmayabilir. Bunu düzeltmek için Sistem Tercihleri'ni açın.",primaryButtonText:"Yeniden dene",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın"};var BrowserPermissionDeniedIOS$2={primaryText:"Devam etmek için mikrofon erişimine izin ver",secondaryText:"Böylece diğer katılımcılar sizi duyabilir.",primaryButtonText:"Yeniden dene",imageAltText:"iOS için mikrofon ve kamera cihazı izin konumu",linkText:"Yardıma mı ihtiyacınız var? Sorun giderme yardımı alın",step1Text:"Ayarlar uygulamasına gidin",step2Text:"Bu tarayıcının ayarlarına ilerleyin",step3Text:"Mikrofonu Aç (İsteğe bağlı kamera)",step4Text:"Aramaya tekrar katılmayı deneyin",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$2={leftNavButtonAriaLabel:"önceki sayfa",rightNavButtonAriaLabel:"sonraki sayfa"};var tr_TR$1 = {participantItem:participantItem$2,typingIndicator:typingIndicator$2,sendBox:sendBox$2,mentionPopover:mentionPopover$2,messageStatusIndicator:messageStatusIndicator$2,endCallButton:endCallButton$2,cameraButton:cameraButton$2,microphoneButton:microphoneButton$2,devicesButton:devicesButton$2,participantsButton:participantsButton$2,screenShareButton:screenShareButton$2,messageThread:messageThread$2,errorBar:errorBar$2,videoGallery:videoGallery$2,dialpad:dialpad$2,holdButton:holdButton$2,videoTile:videoTile$2,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$2,CameraSitePermissionsRequest:CameraSitePermissionsRequest$2,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$2,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$2,CameraSitePermissionsCheck:CameraSitePermissionsCheck$2,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$2,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$2,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$2,CameraSitePermissionsDenied:CameraSitePermissionsDenied$2,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$2,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$2,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$2,UnsupportedBrowser:UnsupportedBrowser$2,UnsupportedBrowserVersion:UnsupportedBrowserVersion$2,UnsupportedOperatingSystem:UnsupportedOperatingSystem$2,BrowserPermissionDenied:BrowserPermissionDenied$2,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$2,VerticalGallery:VerticalGallery$2};

var participantItem$1={isMeText:"(我)",menuTitle:"更多选项",removeButtonLabel:"删除",sharingIconLabel:"共享",mutedIconLabel:"已静音",displayNamePlaceholder:"未命名的参与者",participantStateRinging:"正在呼叫...",participantStateHold:"待机音乐"};var typingIndicator$1={singleUser:"{user} 正在键入...",multipleUsers:"{users} 正在键入...",multipleUsersAbbreviateOne:"{users} 和另外 1 人正在键入...",multipleUsersAbbreviateMany:"{users} 和其他 {numOthers} 人正在键入...",delimiter:"、 "};var sendBox$1={placeholderText:"输入消息",textTooLong:"你的消息长度超过了最大限制。",sendButtonAriaLabel:"发送消息",fileUploadsPendingError:"正在上载...请稍候。",removeFile:"删除文件",uploading:"正在上传",uploadCompleted:"已完成上传"};var mentionPopover$1={mentionPopoverHeader:"建议"};var messageStatusIndicator$1={deliveredAriaLabel:"已发送消息",deliveredTooltipText:"已发送",seenAriaLabel:"其他人已查看消息",seenTooltipText:"已查看",readByTooltipText:"{messageThreadReadCount}/{remoteParticipantsCount} 人已读",sendingAriaLabel:"消息发送",sendingTooltipText:"正在发送",failedToSendAriaLabel:"消息发送失败",failedToSendTooltipText:"发送失败"};var endCallButton$1={label:"退出",tooltipContent:"离开通话"};var cameraButton$1={onLabel:"关闭",offLabel:"打开",tooltipDisabledContent:"已禁用照相机",tooltipOnContent:"关闭摄像头",tooltipOffContent:"打开摄像头",tooltipVideoLoadingContent:"正在加载视频",cameraMenuTitle:"相机",cameraMenuTooltip:"选择“相机”",cameraButtonSplitRoleDescription:"拆分按钮",onSplitButtonAriaLabel:"关闭照相机和照相机选项",offSplitButtonAriaLabel:"打开照相机和照相机选项",cameraActionTurnedOnAnnouncement:"你的相机已打开",cameraActionTurnedOffAnnouncement:"你的相机已关闭",onSplitButtonPrimaryActionCamera:"关闭摄像头",offSplitButtonPrimaryActionCamera:"打开摄像头",cameraPrimaryActionSplitButtonTitle:"使用照相机",videoEffectsMenuItemTitle:"效果"};var microphoneButton$1={onLabel:"静音",offLabel:"取消静音",tooltipDisabledContent:"已禁用麦克风",tooltipOnContent:"将麦克风静音",tooltipOffContent:"取消麦克风静音",microphoneMenuTitle:"麦克风",microphoneMenuTooltip:"选择“麦克风”",speakerMenuTitle:"扬声器",speakerMenuTooltip:"选择“扬声器”",microphoneButtonSplitRoleDescription:"拆分按钮",onSplitButtonAriaLabel:"将麦克风和音频选项静音",offSplitButtonAriaLabel:"取消麦克风和音频选项的静音",microphoneActionTurnedOnAnnouncement:"你的麦克风已打开",microphoneActionTurnedOffAnnouncement:"你的麦克风已关闭",offSplitButtonMicrophonePrimaryAction:"取消麦克风静音",onSplitButtonMicrophonePrimaryAction:"将麦克风静音",microphonePrimaryActionSplitButtonTitle:"使用麦克风"};var devicesButton$1={label:"设备",tooltipContent:"管理设备",cameraMenuTitle:"相机",cameraMenuTooltip:"选择“相机”",audioDeviceMenuTitle:"音频设备",audioDeviceMenuTooltip:"选择音频设备",microphoneMenuTitle:"麦克风",microphoneMenuTooltip:"选择“麦克风”",speakerMenuTitle:"免提",speakerMenuTooltip:"选择“扬声器”"};var participantsButton$1={label:"人员",tooltipContent:"显示参与者",menuHeader:"在此通话中",participantsListButtonLabel:"{numParticipants} 人",muteAllButtonLabel:"全部静音",copyInviteLinkButtonLabel:"复制邀请链接",copyInviteLinkActionedAriaLabel:"已复制邀请链接"};var screenShareButton$1={onLabel:"停止演示",offLabel:"演示",tooltipDisabledContent:"已禁用演示。",tooltipOnContent:"演示屏幕",tooltipOffContent:"演示您的屏幕"};var messageThread$1={yesterday:"昨天",sunday:"星期日",monday:"星期一",tuesday:"星期二",wednesday:"星期三",thursday:"星期四",friday:"星期五",saturday:"星期六",participantJoined:"已加入聊天。",participantLeft:"已退出聊天。",editMessage:"编辑",removeMessage:"删除",resendMessage:"尝试再次发送",failToSendTag:"发送失败",editedTag:"已编辑",liveAuthorIntro:"{author} 说",messageContentAriaText:"{author} 说了 {message}",messageContentMineAriaText:"你说了 {message}",editBoxTextLimit:"你的消息超过了{limitNumber}个字符的限制",editBoxPlaceholderText:"编辑消息",newMessagesIndicator:"新消息",noDisplayNameSub:"无名称",editBoxCancelButton:"取消",editBoxSubmitButton:"提交",messageReadCount:"{messageReadByCount}/{remoteParticipantsCount} 人已读",actionMenuMoreOptions:"更多选项",downloadFile:"下载文件",blockedWarningText:"由于组织策略，此消息已被删除。",blockedWarningLinkText:"详细信息",fileCardGroupMessage:"该邮件包含 {fileCount} 个附件"};var errorBar$1={unableToReachChatService:"你已脱机",accessDenied:"无法访问聊天服务 - 请检查提供的用户凭据",userNotInChatThread:"你不再处于此聊天会话中",sendMessageNotInChatThread:"无法发送消息，因为你不再在此聊天会话中",sendMessageGeneric:"未能发送消息",callingNetworkFailure:"正在连接呼叫 - 你似乎处于脱机状态",startVideoGeneric:"无法启动视频",stopVideoGeneric:"无法停止视频",muteGeneric:"无法静音麦克风",unmuteGeneric:"无法取消麦克风静音",speakingWhileMuted:"你的麦克风已静音",startScreenShareGeneric:"启动屏幕共享时出现问题。",stopScreenShareGeneric:"无法停止屏幕共享",callNetworkQualityLow:"网络质量低。",callNoSpeakerFound:"找不到扬声器或耳机。连接音频设备以收听呼叫。",callNoMicrophoneFound:"找不到麦克风。连接音频输入设备。",callMicrophoneAccessDenied:"无法访问麦克风。单击地址栏中的锁定以授予对此网页的权限。",callMicrophoneAccessDeniedSafari:"无法访问麦克风。刷新页面以允许权限，或检查此浏览器的设置并验证是否为此网站启用了权限。",callMicrophoneMutedBySystem:"系统已将你设为静音。",callMicrophoneUnmutedBySystem:"你的麦克风已恢复，系统已取消静音。",callMacOsMicrophoneAccessDenied:"无法访问麦克风。在 macOS 隐私设置中授予麦克风权限。",callLocalVideoFreeze:"网络带宽较差。你的视频可能会在通话中为其他人暂停。",callCameraAccessDenied:"无法访问照相机。单击地址栏中的锁定以授予对此网页的权限。",callCameraAccessDeniedSafari:"无法访问照相机。刷新页面以允许权限，或检查此浏览器的设置并验证是否为此网站启用了权限。",callCameraAlreadyInUse:"无法访问照相机。它可能已被其他应用程序使用。",callVideoStoppedBySystem:"你的系统已停止你的视频。",callVideoRecoveredBySystem:"你的视频已恢复。",callMacOsCameraAccessDenied:"MacOS 正在阻止访问你的相机。更新你的隐私设置以允许此浏览器访问你的相机。",callMacOsScreenShareAccessDenied:"MacOS 正在阻止屏幕共享。更新你的隐私设置以允许此浏览器录制你的屏幕。",dismissButtonAriaLabel:"关闭",failedToJoinCallGeneric:"未能加入通话。",failedToJoinCallInvalidMeetingLink:"无法加入会议。无效的链接。",cameraFrozenForRemoteParticipants:"通话中的用户在查看视频时遇到问题。请检查你的设备和网络。",unableToStartVideoEffect:"无法应用视频效果。"};var videoGallery$1={screenIsBeingSharedMessage:"你正在共享你的屏幕",screenShareLoadingMessage:"正在加载 {participant} 的屏幕",localVideoLabel:"你",localVideoCameraSwitcherLabel:"切换相机",localVideoMovementLabel:"可移动本地视频磁贴",localVideoSelectedDescription:"已选择 {cameraName}",displayNamePlaceholder:"未命名的参与者",fitRemoteParticipantToFrame:"适应帧大小",fillRemoteParticipantFrame:"填充帧",pinParticipantForMe:"为我固定",pinParticipantForMeLimitReached:"固定(已达到上限)",unpinParticipantForMe:"取消固定",pinParticipantMenuItemAriaLabel:"固定 {participantName}",unpinParticipantMenuItemAriaLabel:"取消固定 {participantName}",pinnedParticipantAnnouncementAriaLabel:"已固定 {participantName}",unpinnedParticipantAnnouncementAriaLabel:"已取消固定 {participantName}"};var dialpad$1={placeholderText:"输入电话号码",deleteButtonAriaLabel:"删除"};var holdButton$1={onLabel:"恢复",offLabel:"支持",tooltipOnContent:"继续呼叫",tooltipOffContent:"保持呼叫"};var videoTile$1={participantStateRinging:"正在呼叫...",participantStateHold:"待机音乐"};var CameraAndMicrophoneSitePermissionsRequest$1={primaryText:"允许{appName}使用你的相机和麦克风",secondaryText:"这样参与者就可以看到并听到你的声音。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用相机和麦克风继续",ariaLabel:"允许相机和麦克风访问权限"};var CameraSitePermissionsRequest$1={primaryText:"允许 {appName} 使用你的相机",secondaryText:"这样参与者就可以看到你了。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用摄像头继续",ariaLabel:"允许相机访问权限"};var MicrophoneSitePermissionsRequest$1={primaryText:"允许 {appName} 使用你的麦克风",secondaryText:"这样参与者就可以听到你的声音。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用麦克风继续",ariaLabel:"允许麦克风访问权限"};var CameraAndMicrophoneSitePermissionsCheck$1={primaryText:"检查摄像头和麦克风访问权限",secondaryText:"如果出现提示，请允许访问。这样参与者就可以看到并听到你的声音。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用相机和麦克风继续",ariaLabel:"正在检查摄像头和麦克风访问权限。如果出现提示，请允许访问。"};var CameraSitePermissionsCheck$1={primaryText:"检查摄像头访问权限",secondaryText:"如果出现提示，请允许访问。这样参与者就可以看到你了。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用相机继续",ariaLabel:"正在检查摄像头访问权限。如果出现提示，请允许访问。"};var MicrophoneSitePermissionsCheck$1={primaryText:"正在检查麦克风访问权限",secondaryText:"如果出现提示，请允许访问。这样参与者就可以听到你的声音。",linkText:"需要帮助? 获取疑难解答帮助",primaryButtonText:"不使用麦克风继续",ariaLabel:"正在检查麦克风访问权限。如果出现提示，请允许访问。"};var CameraAndMicrophoneSitePermissionsDenied$1={primaryText:"无法访问相机和麦克风",secondaryText:"单击地址栏中的锁图标以向此网页授予麦克风权限。可能需要页面刷新。",primaryButtonText:"不使用摄像头和麦克风继续",linkText:"需要帮助? 获取疑难解答帮助"};var CameraAndMicrophoneSitePermissionsDeniedSafari$1={primaryText:"无法访问相机和麦克风",secondaryText:"刷新页面以允许权限，或检查此浏览器的设置并验证是否为此网站启用了权限。",primaryButtonText:"不使用摄像头和麦克风继续",linkText:"需要帮助? 获取疑难解答帮助"};var CameraSitePermissionsDenied$1={primaryText:"无法访问摄像头",secondaryText:"单击地址栏中的锁图标以向此网页授予相机权限。可能需要页面刷新。",primaryButtonText:"不使用摄像头继续",linkText:"需要帮助? 获取疑难解答帮助"};var MicrophoneSitePermissionsDenied$1={primaryText:"无法访问麦克风",secondaryText:"单击地址栏中的锁图标以向此网页授予麦克风权限。可能需要页面刷新。",primaryButtonText:"不使用麦克风继续",linkText:"需要帮助? 获取疑难解答帮助"};var CameraSitePermissionsDeniedSafari$1={primaryText:"无法访问相机",secondaryText:"刷新页面以允许权限，或检查此浏览器的设置并验证是否为此网站启用了权限。",primaryButtonText:"不使用相机继续",linkText:"需要帮助? 获取疑难解答帮助"};var MicrophoneSitePermissionsDeniedSafari$1={primaryText:"无法访问麦克风",secondaryText:"刷新页面以允许权限，或检查此浏览器的设置并验证是否为此网站启用了权限。",primaryButtonText:"不使用麦克风继续",linkText:"需要帮助? 获取疑难解答帮助"};var UnsupportedBrowser$1={primaryText:"浏览器不受支持",secondaryText:"请使用兼容的浏览器加入此通话。",moreHelpLinkText:"查看兼容性要求"};var UnsupportedBrowserVersion$1={primaryText:"需要浏览器更新",secondaryText:"为确保通话达到最佳效果，请更新浏览器，然后再次尝试加入呼叫。",moreHelpLinkText:"查看兼容性要求",continueAnywayButtonText:"在不更新的情况下启动呼叫"};var UnsupportedOperatingSystem$1={primaryText:"不支持操作系统",secondaryText:"请使用具有兼容的操作系统的设备加入此通话。",moreHelpLinkText:"查看兼容性要求"};var BrowserPermissionDenied$1={primaryText:"无法使用摄像头或麦克风",secondaryText:"你的浏览器可能无法访问你的相机或麦克风。若要解决此问题，请打开“系统首选项”。",primaryButtonText:"重试",linkText:"需要帮助? 获取疑难解答帮助"};var BrowserPermissionDeniedIOS$1={primaryText:"允许麦克风访问以继续",secondaryText:"这样其他参与者就可以听到你的声音。",primaryButtonText:"重试",imageAltText:"iOS 的麦克风和摄像头设备权限位置",linkText:"需要帮助? 获取疑难解答帮助",step1Text:"转到设置应用",step2Text:"向下滚动到此浏览器的设置",step3Text:"打开麦克风(摄像头可选)",step4Text:"再次尝试加入通话",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery$1={leftNavButtonAriaLabel:"上一页",rightNavButtonAriaLabel:"下一页"};var zh_CN$1 = {participantItem:participantItem$1,typingIndicator:typingIndicator$1,sendBox:sendBox$1,mentionPopover:mentionPopover$1,messageStatusIndicator:messageStatusIndicator$1,endCallButton:endCallButton$1,cameraButton:cameraButton$1,microphoneButton:microphoneButton$1,devicesButton:devicesButton$1,participantsButton:participantsButton$1,screenShareButton:screenShareButton$1,messageThread:messageThread$1,errorBar:errorBar$1,videoGallery:videoGallery$1,dialpad:dialpad$1,holdButton:holdButton$1,videoTile:videoTile$1,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest$1,CameraSitePermissionsRequest:CameraSitePermissionsRequest$1,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest$1,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck$1,CameraSitePermissionsCheck:CameraSitePermissionsCheck$1,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck$1,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied$1,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari$1,CameraSitePermissionsDenied:CameraSitePermissionsDenied$1,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied$1,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari$1,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari$1,UnsupportedBrowser:UnsupportedBrowser$1,UnsupportedBrowserVersion:UnsupportedBrowserVersion$1,UnsupportedOperatingSystem:UnsupportedOperatingSystem$1,BrowserPermissionDenied:BrowserPermissionDenied$1,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS$1,VerticalGallery:VerticalGallery$1};

var participantItem={isMeText:"(您)",menuTitle:"更多選項",removeButtonLabel:"移除",sharingIconLabel:"分享",mutedIconLabel:"已靜音",displayNamePlaceholder:"未命名的參與者",participantStateRinging:"撥號中...",participantStateHold:"電話保留"};var typingIndicator={singleUser:"{user} 正在輸入...",multipleUsers:"{users} 正在輸入...",multipleUsersAbbreviateOne:"{users} 和其他 1 人正在輸入...",multipleUsersAbbreviateMany:"{users} 和其他 {numOthers} 人正在輸入...",delimiter:"， "};var sendBox={placeholderText:"輸入訊息",textTooLong:"您的訊息長度超過上限。",sendButtonAriaLabel:"傳送訊息",fileUploadsPendingError:"正在上傳... 請稍候。",removeFile:"移除檔案",uploading:"正在上傳",uploadCompleted:"上傳完成"};var mentionPopover={mentionPopoverHeader:"建議"};var messageStatusIndicator={deliveredAriaLabel:"訊息已傳送",deliveredTooltipText:"已傳送",seenAriaLabel:"其他人已看到訊息",seenTooltipText:"已讀",readByTooltipText:"讀取者為 {messageThreadReadCount} / {remoteParticipantsCount}",sendingAriaLabel:"正在傳送訊息",sendingTooltipText:"正在傳送",failedToSendAriaLabel:"無法傳送訊息",failedToSendTooltipText:"無法傳送"};var endCallButton={label:"離開",tooltipContent:"離開通話"};var cameraButton={onLabel:"關閉",offLabel:"開啟",tooltipDisabledContent:"相機已停用",tooltipOnContent:"關閉攝影機",tooltipOffContent:"開啟相機",tooltipVideoLoadingContent:"正在載入影片",cameraMenuTitle:"相機",cameraMenuTooltip:"選擇攝影機",cameraButtonSplitRoleDescription:"[分割] 按鈕",onSplitButtonAriaLabel:"關閉相機和相機選項",offSplitButtonAriaLabel:"開啟相機和相機選項",cameraActionTurnedOnAnnouncement:"您的相機已開啟",cameraActionTurnedOffAnnouncement:"您的相機已關閉",onSplitButtonPrimaryActionCamera:"關閉攝影機",offSplitButtonPrimaryActionCamera:"開啟相機",cameraPrimaryActionSplitButtonTitle:"使用相機",videoEffectsMenuItemTitle:"效果"};var microphoneButton={onLabel:"靜音",offLabel:"取消靜音",tooltipDisabledContent:"麥克風已停用",tooltipOnContent:"將麥克風設為靜音",tooltipOffContent:"取消麥克風靜音",microphoneMenuTitle:"麥克風",microphoneMenuTooltip:"選擇麥克風",speakerMenuTitle:"揚聲器",speakerMenuTooltip:"選擇喇叭",microphoneButtonSplitRoleDescription:"[分割] 按鈕",onSplitButtonAriaLabel:"將麥克風和音訊選項設為靜音",offSplitButtonAriaLabel:"將麥克風和音訊選項取消靜音",microphoneActionTurnedOnAnnouncement:"您的麥克風已開啟",microphoneActionTurnedOffAnnouncement:"您的麥克風已關閉",offSplitButtonMicrophonePrimaryAction:"取消麥克風靜音",onSplitButtonMicrophonePrimaryAction:"將麥克風設為靜音",microphonePrimaryActionSplitButtonTitle:"使用麥克風"};var devicesButton={label:"裝置",tooltipContent:"管理裝置",cameraMenuTitle:"攝影機",cameraMenuTooltip:"選擇攝影機",audioDeviceMenuTitle:"音訊裝置",audioDeviceMenuTooltip:"選擇音訊裝置",microphoneMenuTitle:"麥克風",microphoneMenuTooltip:"選擇麥克風",speakerMenuTitle:"演講者",speakerMenuTooltip:"選擇喇叭"};var participantsButton={label:"人員",tooltipContent:"顯示參與者",menuHeader:"在此通話中",participantsListButtonLabel:"{numParticipants} 人員",muteAllButtonLabel:"將所有人設為靜音",copyInviteLinkButtonLabel:"複製邀請連結",copyInviteLinkActionedAriaLabel:"已複製邀請連結"};var screenShareButton={onLabel:"停止簡報",offLabel:"存在",tooltipDisabledContent:"簡報已停用",tooltipOnContent:"展示您的螢幕",tooltipOffContent:"展示您的螢幕"};var messageThread={yesterday:"昨天",sunday:"星期日",monday:"星期一",tuesday:"星期二",wednesday:"星期三",thursday:"星期四",friday:"星期五",saturday:"星期六",participantJoined:"已加入聊天。",participantLeft:"已離開聊天。",editMessage:"編輯",removeMessage:"刪除",resendMessage:"請嘗試再次傳送",failToSendTag:"無法傳送",editedTag:"已編輯",liveAuthorIntro:"{author} 說",messageContentAriaText:"{author} 說 {message}",messageContentMineAriaText:"您說 {message}",editBoxTextLimit:"您的訊息超過 {limitNumber} 個字元的限制",editBoxPlaceholderText:"編輯您的訊息",newMessagesIndicator:"新訊息",noDisplayNameSub:"沒有名稱",editBoxCancelButton:"取消",editBoxSubmitButton:"提交",messageReadCount:"讀取者為 {messageReadByCount} / {remoteParticipantsCount}",actionMenuMoreOptions:"更多選項",downloadFile:"下載檔案",blockedWarningText:"由於組織原則，已刪除此訊息。",blockedWarningLinkText:"詳細資料",fileCardGroupMessage:"郵件有 {fileCount} 個附件"};var errorBar={unableToReachChatService:"您處於離線狀態",accessDenied:"無法存取聊天服務 - 請檢查提供的使用者認證",userNotInChatThread:"您已不在此聊天對話中",sendMessageNotInChatThread:"無法傳送訊息，因為您已不在此聊天對話中",sendMessageGeneric:"無法傳送訊息",callingNetworkFailure:"連線通話發生錯誤 - 您似乎已離線",startVideoGeneric:"無法啟動影片",stopVideoGeneric:"無法停止影片",muteGeneric:"無法將麥克風設為靜音",unmuteGeneric:"無法將麥克風取消靜音",speakingWhileMuted:"您的麥克風已設為靜音",startScreenShareGeneric:"啟動畫面分享時發生問題。",stopScreenShareGeneric:"無法停止螢幕畫面分享",callNetworkQualityLow:"您的網路品質不佳。",callNoSpeakerFound:"找不到喇叭或耳機。請連接音訊裝置以聆聽通話。",callNoMicrophoneFound:"找不到麥克風。請連接音訊輸入裝置。",callMicrophoneAccessDenied:"無法存取麥克風。按一下網址列中的鎖定以授與此網頁的許可權。",callMicrophoneAccessDeniedSafari:"無法存取麥克風。重新整理頁面以允許許可權，或檢查此瀏覽器的設定，並確認已啟用此網站的許可權。",callMicrophoneMutedBySystem:"系統已將您設為靜音。",callMicrophoneUnmutedBySystem:"您的麥克風已復原，系統已取消您的靜音。",callMacOsMicrophoneAccessDenied:"無法存取麥克風。請在您的 MacOS 隱私權設定中授與麥克風權限。",callLocalVideoFreeze:"網路頻寬不佳。通話中的其他人可能會暫停您的視訊。",callCameraAccessDenied:"無法存取相機。按一下網址列中的鎖定以授與此網頁的許可權。",callCameraAccessDeniedSafari:"無法存取相機。重新整理頁面以允許許可權，或檢查此瀏覽器的設定，並確認已啟用此網站的許可權。",callCameraAlreadyInUse:"無法存取相機。其他應用程式可能已在使用它。",callVideoStoppedBySystem:"您的影片已遭系統停止。",callVideoRecoveredBySystem:"您的影片已繼續。",callMacOsCameraAccessDenied:"MacOS 已封鎖您的相機存取權限。請更新您的隱私權設定，允許此瀏覽器存取您的相機。",callMacOsScreenShareAccessDenied:"MacOS 正在封鎖螢幕畫面分享。更新您的隱私權設定，以允許此瀏覽器錄製您的螢幕。",dismissButtonAriaLabel:"關閉",failedToJoinCallGeneric:"無法加入通話。",failedToJoinCallInvalidMeetingLink:"無法加入會議。連結無效。",cameraFrozenForRemoteParticipants:"通話中的使用者在觀看您的視訊時發生問題。請檢查您的裝置和網路。",unableToStartVideoEffect:"無法套用視訊效果。"};var videoGallery={screenIsBeingSharedMessage:"您現在正在分享螢幕畫面。",screenShareLoadingMessage:"正在載入 {participant} 的螢幕畫面",localVideoLabel:"您",localVideoCameraSwitcherLabel:"切換相機",localVideoMovementLabel:"可移動的本機影片磚",localVideoSelectedDescription:"已選取 {cameraName}",displayNamePlaceholder:"未命名的參與者",fitRemoteParticipantToFrame:"調整成畫面大小",fillRemoteParticipantFrame:"填滿畫面",pinParticipantForMe:"為我釘選",pinParticipantForMeLimitReached:"釘選 (已達到限制)",unpinParticipantForMe:"取消釘選",pinParticipantMenuItemAriaLabel:"釘選 {participantName}",unpinParticipantMenuItemAriaLabel:"取消釘選 {participantName}",pinnedParticipantAnnouncementAriaLabel:"已釘選 {participantName}",unpinnedParticipantAnnouncementAriaLabel:"已取消釘選 {participantName}"};var dialpad={placeholderText:"輸入電話號碼",deleteButtonAriaLabel:"刪除"};var holdButton={onLabel:"繼續",offLabel:"保留",tooltipOnContent:"繼續通話",tooltipOffContent:"保留通話"};var videoTile={participantStateRinging:"撥號中...",participantStateHold:"電話保留"};var CameraAndMicrophoneSitePermissionsRequest={primaryText:"允許 {appName} 使用您的相機和麥克風",secondaryText:"這樣參與者才能看到您並聽到您的聲音。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"在沒有相機和麥克風的情況下繼續",ariaLabel:"允許相機和麥克風存取"};var CameraSitePermissionsRequest={primaryText:"允許 {appName} 使用您的相機",secondaryText:"這樣參與者才能看到您。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"繼續但不使用相機",ariaLabel:"允許存取相機"};var MicrophoneSitePermissionsRequest={primaryText:"允許 {appName} 使用您的麥克風",secondaryText:"這樣參與者才能聽到您的聲音。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"在沒有麥克風的情況下繼續",ariaLabel:"允許麥克風存取"};var CameraAndMicrophoneSitePermissionsCheck={primaryText:"正在檢查相機和麥克風存取",secondaryText:"如果系統提示，則允許存取。這樣參與者才能看到您並聽到您的聲音。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"在沒有相機和麥克風的情況下繼續",ariaLabel:"正在檢查相機和麥克風存取。如果系統提示，則允許存取。"};var CameraSitePermissionsCheck={primaryText:"正在檢查相機存取",secondaryText:"如果系統提示，則允許存取。這樣參與者才能看到您。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"在沒有相機的情況下繼續",ariaLabel:"正在檢查相機存取。如果系統提示，則允許存取。"};var MicrophoneSitePermissionsCheck={primaryText:"正在檢查麥克風存取",secondaryText:"如果系統提示，則允許存取。這樣參與者才能聽到您的聲音。",linkText:"需要協助嗎? 取得疑難排解說明",primaryButtonText:"在沒有麥克風的情況下繼續",ariaLabel:"正在檢查麥克風存取。如果系統提示，則允許存取。"};var CameraAndMicrophoneSitePermissionsDenied={primaryText:"無法存取攝影機和麥克風",secondaryText:"按一下網址列中的鎖定圖示，以授與此網頁的麥克風許可權。可能需要重新整理頁面。",primaryButtonText:"在沒有相機和麥克風的情況下繼續",linkText:"需要協助嗎? 取得疑難排解說明"};var CameraAndMicrophoneSitePermissionsDeniedSafari={primaryText:"無法存取攝影機和麥克風",secondaryText:"重新整理頁面以允許許可權，或檢查此瀏覽器的設定，並確認已啟用此網站的權限。",primaryButtonText:"在沒有相機和麥克風的情況下繼續",linkText:"需要協助嗎? 取得疑難排解說明"};var CameraSitePermissionsDenied={primaryText:"無法存取相機",secondaryText:"按一下網址列中的鎖定圖示，以授與此網頁的相機許可權。可能需要重新整理頁面。",primaryButtonText:"在沒有相機的情況下繼續",linkText:"需要協助嗎? 取得疑難排解說明"};var MicrophoneSitePermissionsDenied={primaryText:"無法存取麥克風",secondaryText:"按一下網址列中的鎖定圖示，以授與此網頁的麥克風許可權。可能需要重新整理頁面。",primaryButtonText:"在沒有麥克風的情況下繼續",linkText:"需要協助嗎? 取得疑難排解說明"};var CameraSitePermissionsDeniedSafari={primaryText:"無法存取攝影機",secondaryText:"重新整理頁面以允許許可權，或檢查此瀏覽器的設定，並確認已啟用此網站的權限。",primaryButtonText:"在沒有相機的情況下繼續",linkText:"需要協助嗎? 取得疑難排解說明"};var MicrophoneSitePermissionsDeniedSafari={primaryText:"無法存取麥克風",secondaryText:"重新整理頁面以允許許可權，或檢查此瀏覽器的設定，並確認已啟用此網站的權限。",primaryButtonText:"繼續但不使用麥克風",linkText:"需要協助嗎? 取得疑難排解說明"};var UnsupportedBrowser={primaryText:"不支援瀏覽器",secondaryText:"請使用相容的瀏覽器加入此通話。",moreHelpLinkText:"查看相容性需求"};var UnsupportedBrowserVersion={primaryText:"需要更新瀏覽器",secondaryText:"為確保通話品質最佳，請更新瀏覽器，然後再次嘗試加入通話。",moreHelpLinkText:"查看相容性需求",continueAnywayButtonText:"不更新即開始通話"};var UnsupportedOperatingSystem={primaryText:"不支援作業系統",secondaryText:"請使用具有相容作業系統的裝置加入此通話。",moreHelpLinkText:"查看相容性需求"};var BrowserPermissionDenied={primaryText:"無法使用您的相機或麥克風",secondaryText:"您的瀏覽器可能無法存取您的相機或麥克風。若要修正此問題，請開啟 [系統喜好設定]。",primaryButtonText:"重試",linkText:"需要協助嗎? 取得疑難排解說明"};var BrowserPermissionDeniedIOS={primaryText:"允許存取麥克風以繼續",secondaryText:"讓其他參與者可聽到您的聲音。",primaryButtonText:"重試",imageAltText:"iOS 的麥克風和相機裝置權限位置",linkText:"需要協助嗎? 取得疑難排解說明",step1Text:"移至 [設定] 應用程式",step2Text:"向下捲動到此瀏覽器的設定",step3Text:"開啟麥克風 (相機選用)",step4Text:"再次嘗試加入通話",step1DigitText:"1",step2DigitText:"2",step3DigitText:"3",step4DigitText:"4"};var VerticalGallery={leftNavButtonAriaLabel:"上一頁",rightNavButtonAriaLabel:"下一頁"};var zh_TW$1 = {participantItem:participantItem,typingIndicator:typingIndicator,sendBox:sendBox,mentionPopover:mentionPopover,messageStatusIndicator:messageStatusIndicator,endCallButton:endCallButton,cameraButton:cameraButton,microphoneButton:microphoneButton,devicesButton:devicesButton,participantsButton:participantsButton,screenShareButton:screenShareButton,messageThread:messageThread,errorBar:errorBar,videoGallery:videoGallery,dialpad:dialpad,holdButton:holdButton,videoTile:videoTile,CameraAndMicrophoneSitePermissionsRequest:CameraAndMicrophoneSitePermissionsRequest,CameraSitePermissionsRequest:CameraSitePermissionsRequest,MicrophoneSitePermissionsRequest:MicrophoneSitePermissionsRequest,CameraAndMicrophoneSitePermissionsCheck:CameraAndMicrophoneSitePermissionsCheck,CameraSitePermissionsCheck:CameraSitePermissionsCheck,MicrophoneSitePermissionsCheck:MicrophoneSitePermissionsCheck,CameraAndMicrophoneSitePermissionsDenied:CameraAndMicrophoneSitePermissionsDenied,CameraAndMicrophoneSitePermissionsDeniedSafari:CameraAndMicrophoneSitePermissionsDeniedSafari,CameraSitePermissionsDenied:CameraSitePermissionsDenied,MicrophoneSitePermissionsDenied:MicrophoneSitePermissionsDenied,CameraSitePermissionsDeniedSafari:CameraSitePermissionsDeniedSafari,MicrophoneSitePermissionsDeniedSafari:MicrophoneSitePermissionsDeniedSafari,UnsupportedBrowser:UnsupportedBrowser,UnsupportedBrowserVersion:UnsupportedBrowserVersion,UnsupportedOperatingSystem:UnsupportedOperatingSystem,BrowserPermissionDenied:BrowserPermissionDenied,BrowserPermissionDeniedIOS:BrowserPermissionDeniedIOS,VerticalGallery:VerticalGallery};

// Copyright (c) Microsoft Corporation.
const createComponentStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US$1);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_US = {
    strings: en_US$1
};
/**
 * Locale for English (GB).
 *
 * @public
 */
const COMPONENT_LOCALE_EN_GB = {
    strings: createComponentStrings(en_GB$1)
};
/**
 * Locale for Arabic (Saudi Arabia).
 *
 * @public
 */
const COMPONENT_LOCALE_AR_SA = {
    strings: createComponentStrings(ar_SA$1)
};
/**
 * Locale for  German (Germany).
 *
 * @public
 */
const COMPONENT_LOCALE_DE_DE = {
    strings: createComponentStrings(de_DE$1)
};
/**
 * Locale for Spanish (Spain).
 *
 * @public
 */
const COMPONENT_LOCALE_ES_ES = {
    strings: createComponentStrings(es_ES$1)
};
/**
 * Locale for Finnish (Finland).
 *
 * @public
 */
const COMPONENT_LOCALE_FI_FI = {
    strings: createComponentStrings(fi_FI$1)
};
/**
 * Locale for French (France).
 *
 * @public
 */
const COMPONENT_LOCALE_FR_FR = {
    strings: createComponentStrings(fr_FR$1)
};
/**
 * Locale for Hebrew (Israel).
 *
 * @public
 */
const COMPONENT_LOCALE_HE_IL = {
    strings: createComponentStrings(he_IL$1)
};
/**
 * Locale for Italian (Italy).
 *
 * @public
 */
const COMPONENT_LOCALE_IT_IT = {
    strings: createComponentStrings(it_IT$1)
};
/**
 * Locale for Japanese (Japan).
 *
 * @public
 */
const COMPONENT_LOCALE_JA_JP = {
    strings: createComponentStrings(ja_JP$1)
};
/**
 * Locale for Korean (South Korea).
 *
 * @public
 */
const COMPONENT_LOCALE_KO_KR = {
    strings: createComponentStrings(ko_KR$1)
};
/**
 * Locale for Norwegian Bokmål (Norway) .
 *
 * @public
 */
const COMPONENT_LOCALE_NB_NO = {
    strings: createComponentStrings(nb_NO$1)
};
/**
 * Locale for Dutch (Netherlands).
 *
 * @public
 */
const COMPONENT_LOCALE_NL_NL = {
    strings: createComponentStrings(nl_NL$1)
};
/**
 * Locale for Polish (Poland).
 *
 * @public
 */
const COMPONENT_LOCALE_PL_PL = {
    strings: createComponentStrings(pl_PL$1)
};
/**
 * Locale for Portuguese (Brazil).
 *
 * @public
 */
const COMPONENT_LOCALE_PT_BR = {
    strings: createComponentStrings(pt_BR$1)
};
/**
 * Locale for Russian (Russia).
 *
 * @public
 */
const COMPONENT_LOCALE_RU_RU = {
    strings: createComponentStrings(ru_RU$1)
};
/**
 * Locale for Swedish (Sweden) .
 *
 * @public
 */
const COMPONENT_LOCALE_SV_SE = {
    strings: createComponentStrings(sv_SE$1)
};
/**
 * Locale for Turkish (Turkey).
 *
 * @public
 */
const COMPONENT_LOCALE_TR_TR = {
    strings: createComponentStrings(tr_TR$1)
};
/**
 * Locale for Chinese (Mainland China).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_CN = {
    strings: createComponentStrings(zh_CN$1)
};
/**
 * Locale for Chinese (Taiwan).
 *
 * @public
 */
const COMPONENT_LOCALE_ZH_TW = {
    strings: createComponentStrings(zh_TW$1)
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components exported from this library.
 *
 * @public
 */
const LocaleContext$1 = React.createContext(COMPONENT_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's react components.
 *
 * @remarks Components will be provided localized strings in English (US) by default if this
 * provider is not used.
 *
 * @public
 */
const LocalizationProvider$1 = (props) => {
    const { locale, children } = props;
    return React__default['default'].createElement(LocaleContext$1.Provider, { value: locale }, children);
};
/** React hook to access locale */
const useLocale$1 = () => React.useContext(LocaleContext$1);

// Copyright (c) Microsoft Corporation.
const defaultIdentifiers = {
    sendboxTextField: 'sendbox-textfield',
    participantButtonPeopleMenuItem: 'participant-button-people-menu-item',
    participantItemMenuButton: 'participant-item-menu-button',
    participantList: 'participant-list',
    participantListPeopleButton: 'participant-list-people-button',
    participantListRemoveParticipantButton: 'participant-list-remove-participant-button',
    messageContent: 'message-content',
    messageTimestamp: 'message-timestamp',
    typingIndicator: 'typing-indicator',
    videoGallery: 'video-gallery',
    videoTile: 'video-tile',
    overflowGalleryLeftNavButton: 'overflow-gallery-left-nav-button',
    overflowGalleryRightNavButton: 'overflow-gallery-right-nav-button',
    horizontalGalleryVideoTile: 'horizontal-gallery-video-tile'
};
/**
 * @private
 */
const IdentifierContext = React.createContext(defaultIdentifiers);
/**
 * React Context provider for {@link _Identifiers}.
 *
 * @experimental
 *
 * See documentation for {@link _Identifiers}.
 *
 * @internal
 */
const _IdentifierProvider = (props) => {
    const { identifiers, children } = props;
    return React__default['default'].createElement(IdentifierContext.Provider, { value: identifiers !== null && identifiers !== void 0 ? identifiers : defaultIdentifiers }, children);
};
/**
 * @private
 */
const useIdentifiers = () => React.useContext(IdentifierContext);

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_TYPING_USERS = 35;
/**
 * Helper function to create element wrapping all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @param onRenderUser optional callback to render each typing user
 * @param userDisplayNameStyles optional additional IStyle to apply to each element containing users name
 * @returns element wrapping all typing users
 */
const getUsersElement = (typingUsers, delimiter, onRenderUser, userDisplayNameStyles) => {
    const userElements = [];
    typingUsers.forEach((user, index) => {
        userElements.push(onRenderUser ? onRenderUser(user) : React__default['default'].createElement(react.Text, { className: react.mergeStyles(userDisplayNameStyles), key: `user-${index}` }, user.displayName));
        userElements.push(React__default['default'].createElement(react.Text, { key: `comma-${index}` }, `${delimiter}`));
    });
    // pop last comma
    userElements.pop();
    return React__default['default'].createElement(React__default['default'].Fragment, null, userElements);
};
/**
 * Helper function to get a string of all typing users
 * @param typingUsers typing users
 * @param delimiter string to separate typing users
 * @returns string of all typing users
 */
const getNamesString = (typingUsers, delimiter) => {
    const userNames = [];
    typingUsers.forEach(user => {
        if (user.displayName) {
            userNames.push(user.displayName);
        }
    });
    return userNames.join(delimiter);
};
/**
 * Helper function to create span elements making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param usersElement JSX.Element containing all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns array of span elements making up the typing indicator string
 */
const getSpanElements = (strings, usersElement, numTypingUsers, numTypingUsersAbbreviated) => {
    let variables = {};
    let typingString = '';
    if (numTypingUsers === 1) {
        typingString = strings.singleUser;
        variables = {
            user: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        typingString = strings.multipleUsers;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        typingString = strings.multipleUsersAbbreviateOne;
        variables = {
            users: usersElement
        };
    }
    else if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        typingString = strings.multipleUsersAbbreviateMany;
        variables = {
            users: usersElement,
            numOthers: React__default['default'].createElement(React__default['default'].Fragment, null, numTypingUsersAbbreviated)
        };
    }
    return formatInlineElements(typingString, variables);
};
/**
 * Helper function to get the string making up the typing indicator string
 * @param strings TypingIndicatorStrings containing strings to create span elements
 * @param namesString string of all typing users
 * @param numTypingUsers number of total typing users
 * @param numUserNotMentioned number of typing users abbreviated
 * @returns typing indicator string
 */
const getIndicatorString = (strings, namesString, numTypingUsers, numTypingUsersAbbreviated) => {
    if (numTypingUsers === 1) {
        return strings.singleUser.replace('{user}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {
        return strings.multipleUsers.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {
        return strings.multipleUsersAbbreviateOne.replace('{users}', namesString);
    }
    if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {
        return strings.multipleUsersAbbreviateMany.replace('{users}', namesString).replace('{numOthers}', `${numTypingUsersAbbreviated}`);
    }
    return undefined;
};
const IndicatorComponent = (typingUsers, strings, onRenderUser, styles) => {
    const typingUsersMentioned = [];
    let totalCharacterCount = 0;
    const ids = useIdentifiers();
    for (const typingUser of typingUsers) {
        if (!typingUser.displayName) {
            continue;
        }
        let additionalCharCount = typingUser.displayName.length;
        // The typing users will be separated by the delimiter. We account for that additional length when we generate the final string.
        if (typingUsersMentioned.length > 0) {
            additionalCharCount += strings.delimiter.length;
        }
        if (totalCharacterCount + additionalCharCount <= MAXIMUM_LENGTH_OF_TYPING_USERS || typingUsersMentioned.length === 0) {
            typingUsersMentioned.push(typingUser);
            totalCharacterCount += additionalCharCount;
        }
        else {
            break;
        }
    }
    const usersElement = getUsersElement(typingUsersMentioned, strings.delimiter, onRenderUser, styles === null || styles === void 0 ? void 0 : styles.typingUserDisplayName);
    const numUserNotMentioned = typingUsers.length - typingUsersMentioned.length;
    const spanElements = getSpanElements(strings, usersElement, typingUsers.length, numUserNotMentioned);
    const labelString = getIndicatorString(strings, getNamesString(typingUsersMentioned, strings.delimiter), typingUsers.length, numUserNotMentioned);
    return React__default['default'].createElement("div", { "data-ui-id": ids.typingIndicator, className: react.mergeStyles(typingIndicatorStringStyle, styles === null || styles === void 0 ? void 0 : styles.typingString), key: "typingStringKey", role: "status", "aria-label": labelString }, spanElements);
};
/**
 * Component to notify local user when one or more participants in the chat thread are typing.
 *
 * @public
 */
const TypingIndicator = (props) => {
    const { typingUsers, onRenderUser, styles } = props;
    const { strings } = useLocale$1();
    const typingUsersToRender = typingUsers.filter(typingUser => typingUser.displayName !== undefined);
    const indicatorComponent = IndicatorComponent(typingUsersToRender, Object.assign(Object.assign({}, strings.typingIndicator), props.strings), onRenderUser, styles);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(typingIndicatorContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root) }, indicatorComponent);
};
/**
 * Create an array of span elements by replacing the pattern "\{\}" in str with the elements
 * passed in as vars and creating inline elements from the rest
 *
 * @param str - The string to be formatted
 * @param vars - Variables to use to format the string
 * @returns formatted JSX elements
 */
const formatInlineElements = (str, vars) => {
    if (!str) {
        return [];
    }
    if (!vars) {
        return [];
    }
    const elements = [];
    // regex to search for the pattern "{}"
    const placeholdersRegex = /{(\w+)}/g;
    const regex = RegExp(placeholdersRegex);
    let array = regex.exec(str);
    let prev = 0;
    while (array !== null) {
        if (prev !== array.index) {
            elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev, array.index)));
        }
        elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, vars[array[0].substring(1, array[0].length - 1)]));
        prev = regex.lastIndex;
        array = regex.exec(str);
    }
    elements.push(React__default['default'].createElement(react.Text, { key: elements.length }, str.substring(prev)));
    return elements;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 *
 * @param fileName
 * @returns string
 */
const extension = (fileName) => fileName.split('.').pop() || '';
/**
 * @private
 * @param dismissedErrors
 * @param toDismiss
 * @returns DismissedError[]
 * Always returns a new Array so that the state variable is updated, trigerring a render.
 */
const dismissError = (dismissedErrors, toDismiss) => {
    var _a;
    const now = new Date(Date.now());
    for (const error of dismissedErrors) {
        if (error.type === toDismiss.type) {
            // Bump the timestamp for latest dismissal of this error to now.
            error.dismissedAt = now;
            error.activeSince = toDismiss.timestamp;
            return Array.from(dismissedErrors);
        }
    }
    const toDismissTimestamp = (_a = toDismiss.timestamp) !== null && _a !== void 0 ? _a : now;
    // Record that this error was dismissed for the first time right now.
    return [...dismissedErrors, {
            type: toDismiss.type,
            // the error time could be sometimes later than the button click time, which cause the dismiss not working
            // so we set the dismiss time to the later one
            dismissedAt: now > toDismissTimestamp ? now : toDismissTimestamp,
            activeSince: toDismiss.timestamp
        }];
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns DismissedError[]
 *  Returns a new Array if and only if contents change, to avoid re-rendering when nothing was dropped.
 */
const dropDismissalsForInactiveErrors = (activeErrorMessages, dismissedErrors) => {
    const active = new Map();
    for (const message of activeErrorMessages) {
        active.set(message.type, message);
    }
    // For an error such that:
    // * It was previously active, and dismissed.
    // * It did not have a timestamp associated with it.
    // * It is no longer active.
    //
    // We remove it from dismissals. When it becomes active again next time, it will be shown again on the UI.
    const shouldDeleteDismissal = (dismissed) => dismissed.activeSince === undefined && active.get(dismissed.type) === undefined;
    if (dismissedErrors.some(dismissed => shouldDeleteDismissal(dismissed))) {
        return dismissedErrors.filter(dismissed => !shouldDeleteDismissal(dismissed));
    }
    return dismissedErrors;
};
/**
 * @private
 * @param activeErrorMessages
 * @param dismissedErrors
 * @returns ActiveErrorMessage[]
 */
const errorsToShow = (activeErrorMessages, dismissedErrors, mountTimestamp) => {
    const dismissed = new Map();
    for (const error of dismissedErrors) {
        dismissed.set(error.type, error);
    }
    return activeErrorMessages.filter(error => {
        if (mountTimestamp && error.timestamp && mountTimestamp > error.timestamp) {
            // Error has a timestamp and it is older than when the component was mounted.
            return false;
        }
        const dismissal = dismissed.get(error.type);
        if (!dismissal) {
            // This error was never dismissed.
            return true;
        }
        if (!error.timestamp) {
            // No timestamp associated with the error. In this case, the existence of a dismissal is enough to suppress the error.
            return false;
        }
        // Error has an associated timestamp, so compare with last dismissal.
        return error.timestamp > dismissal.dismissedAt;
    });
};
/**
 * @private
 * @param errorType
 * @returns MessageBarType
 */
const messageBarType = (errorType) => {
    switch (errorType) {
        case 'callNetworkQualityLow':
        case 'callNoSpeakerFound':
        case 'callNoMicrophoneFound':
        case 'callMicrophoneAccessDenied':
        case 'callMicrophoneAccessDeniedSafari':
        case 'callMicrophoneMutedBySystem':
        case 'callMicrophoneUnmutedBySystem':
        case 'callMacOsMicrophoneAccessDenied':
        case 'callLocalVideoFreeze':
        case 'callCameraAccessDenied':
        case 'callCameraAccessDeniedSafari':
        case 'callCameraAlreadyInUse':
        case 'callVideoStoppedBySystem':
        case 'callVideoRecoveredBySystem':
        case 'callMacOsCameraAccessDenied':
        case 'callMacOsScreenShareAccessDenied':
        case 'startScreenShareGeneric':
        case 'cameraFrozenForRemoteParticipants':
            return react.MessageBarType.warning;
        default:
            return react.MessageBarType.error;
    }
};
/**
 * @private
 * @param errorType
 * @returns IIconProps | undefined
 */
const messageBarIconProps = (errorType) => {
    const iconName = customIconName[errorType];
    return iconName ? {
        iconName
    } : undefined;
};
/**
 * @private
 */
const customIconName = {
    callNetworkQualityLow: 'ErrorBarCallNetworkQualityLow',
    callNoSpeakerFound: 'ErrorBarCallNoSpeakerFound',
    callNoMicrophoneFound: 'ErrorBarCallNoMicrophoneFound',
    callMicrophoneAccessDenied: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneAccessDeniedSafari: 'ErrorBarCallMicrophoneAccessDenied',
    callMicrophoneMutedBySystem: 'ErrorBarCallMicrophoneMutedBySystem',
    callMicrophoneUnmutedBySystem: 'ErrorBarCallMicrophoneUnmutedBySystem',
    callMacOsMicrophoneAccessDenied: 'ErrorBarCallMacOsMicrophoneAccessDenied',
    callLocalVideoFreeze: 'ErrorBarCallLocalVideoFreeze',
    callCameraAccessDenied: 'ErrorBarCallCameraAccessDenied',
    callCameraAccessDeniedSafari: 'ErrorBarCallCameraAccessDenied',
    callCameraAlreadyInUse: 'ErrorBarCallCameraAlreadyInUse',
    callVideoStoppedBySystem: 'ErrorBarCallVideoStoppedBySystem',
    callVideoRecoveredBySystem: 'ErrorBarCallVideoRecoveredBySystem',
    callMacOsCameraAccessDenied: 'ErrorBarCallMacOsCameraAccessDenied'
};
/**
 * @private
 */
const SAFARI_COMPOSITION_KEYCODE = 229;
/**
 * Determine if the press of the enter key is from a composition session or not (Safari only)
 *
 * @private
 */
const isEnterKeyEventFromCompositionSession = (e) => 
// Uses KeyCode 229 and which code 229 to determine if the press of the enter key is from a composition session or not (Safari only)
e.nativeEvent.isComposing || e.nativeEvent.keyCode === SAFARI_COMPOSITION_KEYCODE || e.nativeEvent.which === SAFARI_COMPOSITION_KEYCODE;

// Copyright (c) Microsoft Corporation.
/**
 * A component to show error messages on the UI.
 * All strings that can be shown are accepted as the {@link ErrorBarProps.strings} so that they can be localized.
 * Active errors are selected by {@link ErrorBarProps.activeErrorMessages}.
 *
 * This component internally tracks dismissed by the user.
 *   * Errors that have an associated timestamp: The error is shown on the UI again if it occurs after being dismissed.
 *   * Errors that do not have a timestamp: The error is dismissed until it disappears from the props.
 *         If the error recurs, it is shown in the UI.
 *
 * Uses {@link @fluentui/react#MessageBar} UI element.
 *
 * @public
 */
const ErrorBar = (props) => {
    var _a;
    const localeStrings = useLocale$1().strings.errorBar;
    const strings = (_a = props.strings) !== null && _a !== void 0 ? _a : localeStrings;
    // Timestamp for when this comopnent is first mounted.
    // Never updated through the lifecycle of this component.
    const mountTimestamp = React.useRef(new Date(Date.now()));
    const [dismissedErrors, setDismissedErrors] = React.useState([]);
    // dropDismissalsForInactiveErrors only returns a new object if `dismissedErrors` actually changes.
    // Without this behaviour, this `useEffect` block would cause a render loop.
    React.useEffect(() => setDismissedErrors(dropDismissalsForInactiveErrors(props.activeErrorMessages, dismissedErrors)), [props.activeErrorMessages, dismissedErrors]);
    const toShow = errorsToShow(props.activeErrorMessages, dismissedErrors, props.ignorePremountErrors ? mountTimestamp.current : undefined);
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "error-bar-stack" }, toShow.map(error => React__default['default'].createElement(react.MessageBar, Object.assign({}, props, { styles: {
            innerText: {
                alignSelf: 'center'
            },
            icon: {
                height: 0
            },
            content: {
                lineHeight: 'inherit'
            },
            dismissal: {
                height: 0,
                paddingTop: '0.8rem'
            }
        }, key: error.type, messageBarType: messageBarType(error.type), messageBarIconProps: messageBarIconProps(error.type), onDismiss: () => setDismissedErrors(dismissError(dismissedErrors, error)), dismissButtonAriaLabel: strings.dismissButtonAriaLabel, dismissIconProps: {
            iconName: 'ErrorBarClear'
        } }), strings[error.type])));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const gridLayoutStyle = react.mergeStyles({
    width: '100%',
    height: '100%',
    display: 'grid',
    gridGap: '0.5rem'
});

// Copyright (c) Microsoft Corporation.
/**
 * A component to lay out audio / video participants tiles in a call.
 *
 * @public
 */
const GridLayout = (props) => {
    const { children, styles } = props;
    const numberOfChildren = React__default['default'].Children.count(children);
    const [currentWidth, setCurrentWidth] = React.useState(0);
    const [currentHeight, setCurrentHeight] = React.useState(0);
    const containerRef = React.useRef(null);
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        setCurrentWidth(width);
        setCurrentHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, containerRef]);
    const gridProps = React.useMemo(() => {
        return calculateGridProps(numberOfChildren, currentWidth, currentHeight);
    }, [numberOfChildren, currentWidth, currentHeight]);
    const cssGridStyles = React.useMemo(() => createGridStyles(numberOfChildren, gridProps), [numberOfChildren, gridProps]);
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(gridLayoutStyle, cssGridStyles, styles === null || styles === void 0 ? void 0 : styles.root), "data-ui-id": "grid-layout" }, children);
};
/**
 * The cell aspect ratio we aim for in a grid
 */
const TARGET_CELL_ASPECT_RATIO = 16 / 9;
/**
 * The minimum cell aspect ratio we allow
 */
const MINIMUM_CELL_ASPECT_RATIO_ALLOWED = 8 / 9;
const isCloserThan = (a, b, target) => {
    return Math.abs(target - a) < Math.abs(target - b);
};
/**
 * Get the best GridProps to place a number of items in a grid as evenly as possible given the width and height of the grid
 * @param numberOfItems - number of items to place in grid
 * @param width - width of grid
 * @param height - height of grid
 * @returns GridProps
 */
const calculateGridProps = (numberOfItems, width, height) => {
    if (numberOfItems <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: 0,
            columns: 0
        };
    }
    // If width or height are 0 then we return rows and column evenly
    if (width <= 0 || height <= 0) {
        return {
            fillDirection: 'horizontal',
            rows: Math.ceil(Math.sqrt(numberOfItems)),
            columns: Math.ceil(Math.sqrt(numberOfItems))
        };
    }
    const aspectRatio = width / height;
    // Approximate how many rows to divide the grid to achieve cells close to the TARGET_CELL_ASPECT_RATIO
    let rows = Math.floor(Math.sqrt(TARGET_CELL_ASPECT_RATIO / aspectRatio * numberOfItems)) || 1;
    // Make sure rows do not exceed numberOfItems
    rows = Math.min(rows, numberOfItems);
    // Given the rows, get the minimum columns needed to create enough cells for the number of items
    let columns = Math.ceil(numberOfItems / rows);
    // Default fill direction to horizontal
    let fillDirection = 'horizontal';
    while (rows < numberOfItems) {
        // If cell aspect ratio is less than MINIMUM_CELL_ASPECT_RATIO_ALLOWED then try more rows
        if (rows / columns * aspectRatio < MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
            rows += 1;
            columns = Math.ceil(numberOfItems / rows);
            continue;
        }
        if (numberOfItems < rows * columns) {
            // We need to check that stretching columns vertically will result in only one less cell in stretched columns.
            // Likewise, we need to check that stretching rows horizonally will result in only one less cell in stretched rows.
            // e.g. For 4 rows, 2 columns, but only 6 items, we cannot stretch vertically because that would result in a
            // column of 2 cells which is less by more than 1 compared to the unstretched column.
            //  _________
            // |____|    |
            // |____|____|
            // |____|    |
            // |____|____|
            const canStretchVertically = numberOfItems >= rows + (columns - 1) * (rows - 1);
            const canStretchHorizontally = numberOfItems >= columns + (rows - 1) * (columns - 1);
            if (!canStretchVertically && !canStretchHorizontally) {
                rows += 1;
                columns = Math.ceil(numberOfItems / rows);
                continue;
            }
            else if (!canStretchVertically) {
                break;
            }
            else if (!canStretchHorizontally) {
                fillDirection = 'vertical';
                break;
            }
            // We need to figure out whether the big cells should stretch horizontally or vertically
            // to fill in the empty spaces
            // e.g. For 2 rows, 3 columns, but only 5 items, we need to choose whether to stretch cells
            //       horizontally            or           vertically
            //  ______________________               _______________________
            // |       |       |      |             |       |       |       |
            // |_______|_______|______|             |_______|_______|       |
            // |           |          |             |       |       |       |
            // |___________|__________|             |_______|_______|_______|
            // Calculate the aspect ratio of big cells stretched horizontally
            const horizontallyStretchedCellRatio = rows / (columns - 1) * aspectRatio;
            // Calculate the aspect ratio of big cells stretched vertically
            const verticallyStretchedCellRatio = (rows - 1) / columns * aspectRatio;
            // We know the horizontally stretched cells aspect ratio is higher than MINIMUM_CELL_ASPECT_RATIO_ALLOWED. If vertically stretched cells
            // is also higher than the MINIMUM_CELL_ASPECT_RATIO_ALLOWED, then choose which aspect ratio is better.
            if (verticallyStretchedCellRatio >= MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {
                // If vertically stetched cell has an aspect ratio closer to TARGET_CELL_ASPECT_RATIO then change the fill direction to vertical
                if (isCloserThan(verticallyStretchedCellRatio, horizontallyStretchedCellRatio, TARGET_CELL_ASPECT_RATIO)) {
                    fillDirection = 'vertical';
                }
            }
        }
        break;
    }
    return {
        fillDirection,
        rows,
        columns
    };
};
/**
 * Creates a styles classname with CSS Grid related styles given GridProps and the number of items to distribute as evenly as possible.
 * @param numberOfItems - number of items to place in grid
 * @param gridProps - GridProps that define the number of rows, number of columns, and the fill direction
 * @returns - classname
 */
const createGridStyles = (numberOfItems, gridProps) => {
    const isHorizontal = gridProps.fillDirection === 'horizontal';
    // Blocks are either rows or columns depending on whether we fill horizontally or vertically. Each block may differ in the number of cells.
    const blocks = isHorizontal ? gridProps.rows : gridProps.columns;
    const smallCellsPerBlock = Math.ceil(numberOfItems / blocks);
    const bigCellsPerBlock = Math.floor(numberOfItems / blocks);
    const numBigCells = (gridProps.rows * gridProps.columns - numberOfItems) * bigCellsPerBlock;
    // Get grid units
    // e.g. If some blocks have 2 big cells while others have 3 small cells, we need to work with 6 units per block
    const units = smallCellsPerBlock * bigCellsPerBlock;
    const gridStyles = isHorizontal ? {
        gridTemplateColumns: `repeat(${units}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${blocks}, minmax(0, 1fr))`,
        gridAutoFlow: 'row'
    } : {
        gridTemplateColumns: `repeat(${blocks}, minmax(0, 1fr))`,
        gridTemplateRows: `repeat(${units}, minmax(0, 1fr))`,
        gridAutoFlow: 'column'
    };
    const smallCellStyle = isHorizontal ? {
        '> *': {
            gridColumn: `auto / span ${units / smallCellsPerBlock}`
        }
    } : {
        '> *': {
            gridRow: `auto / span ${units / smallCellsPerBlock}`
        }
    };
    // If there are big cells, we are choosing to place the latest children into the big cells.
    // That is why we use the '> *:nth-last-child(-n + ${numBigCells})' CSS selector below
    const bigCellStyle = numBigCells ? {
        [`> *:nth-last-child(-n + ${numBigCells})`]: isHorizontal ? {
            gridColumn: `auto / span ${units / bigCellsPerBlock}`
        } : {
            gridRow: `auto / span ${units / bigCellsPerBlock}`
        }
    } : {};
    return react.mergeStyles(gridStyles, smallCellStyle, bigCellStyle);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const sendBoxWrapperStyles = react.mergeStyles({
    margin: '0.25rem',
    overflow: 'hidden',
    /**
     * margin-top set for all the child components of sendbox except first
     */
    ':not(:first-child)': {
        marginTop: '0.25rem'
    }
});
/**
 * @private
 */
const sendButtonStyle = react.mergeStyles({
    height: '1.25rem',
    width: '1.25rem',
    marginRight: '0.313rem' // 5px
});
/**
 * @private
 */
const sendIconStyle = react.mergeStyles({
    width: '1.25rem',
    height: '1.25rem',
    margin: 'auto'
});
/**
 * @private
 */
react.mergeStyles({
    margin: '0 0.25rem 0.25rem 0.25rem',
    maxHeight: '12.5rem',
    overflow: 'auto'
});
/**
 * @private
 */
react.mergeStyles({
    width: '100%',
    padding: '0.50rem'
});
const defaultSendBoxInactiveBorderThicknessREM = 0.0625;
const defaultSendBoxActiveBorderThicknessREM = 0.125;
/**
 * @private
 */
const borderAndBoxShadowStyle = (props) => {
    const { theme, hasErrorMessage, disabled } = props;
    const borderColor = hasErrorMessage ? theme.semanticColors.errorText : theme.palette.neutralSecondary;
    const borderColorActive = hasErrorMessage ? theme.semanticColors.errorText : theme.palette.themePrimary;
    const borderThickness = disabled ? 0 : defaultSendBoxInactiveBorderThicknessREM;
    const borderActiveThickness = disabled ? 0 : defaultSendBoxActiveBorderThicknessREM;
    return {
        borderRadius: theme.effects.roundedCorner4,
        border: `${borderThickness}rem solid ${borderColor}`,
        // The border thickness of the sendbox wrapper changes on hover, to prevent the border thickness change causing the
        // input box to shift we apply a margin to compensate. This margin is then removed on hover when the border is thicker.
        margin: `${defaultSendBoxActiveBorderThicknessREM - borderThickness}rem`,
        ':hover, :active, :focus, :focus-within': {
            border: `${borderActiveThickness}rem solid ${borderColorActive}`,
            margin: `${defaultSendBoxActiveBorderThicknessREM - borderActiveThickness}rem`
        }
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Preset light theme for components exported from this library.
 *
 * @public
 */
const lightTheme = {
    palette: {
        themePrimary: '#0078d4',
        themeLighterAlt: '#eff6fc',
        themeLighter: '#deecf9',
        themeLight: '#c7e0f4',
        themeTertiary: '#71afe5',
        themeSecondary: '#2b88d8',
        themeDarkAlt: '#106ebe',
        themeDark: '#59b0f7',
        themeDarker: '#004578',
        neutralLighterAlt: '#faf9f8',
        neutralLighter: '#f3f2f1',
        neutralLight: '#edebe9',
        neutralQuaternaryAlt: '#e1dfdd',
        neutralQuaternary: '#d0d0d0',
        neutralTertiaryAlt: '#c8c6c4',
        neutralTertiary: '#a19f9d',
        neutralSecondary: '#605e5c',
        neutralPrimaryAlt: '#3b3a39',
        neutralPrimary: '#323130',
        neutralDark: '#201f1e',
        black: '#000000',
        white: '#ffffff'
    },
    callingPalette: {
        callRed: '#a42e43',
        callRedDark: '#8b2c3d',
        callRedDarker: '#772a38',
        iconWhite: '#ffffff'
    },
    semanticColors: {
        errorText: '#a80000'
    }
};
/**
 * Preset dark theme for components exported from this library.
 *
 * @public
 */
const darkTheme = {
    palette: {
        themePrimary: '#2899f5',
        themeLighterAlt: '#02060a',
        themeLighter: '#061827',
        themeLight: '#0c2e49',
        themeTertiary: '#185b93',
        themeSecondary: '#2286d7',
        themeDarkAlt: '#3ca2f6',
        themeDark: '#59b0f7',
        themeDarker: '#84c5f9',
        neutralLighterAlt: '#302e2d',
        neutralLighter: '#383735',
        neutralLight: '#464443',
        neutralQuaternaryAlt: '#4e4d4b',
        neutralQuaternary: '#4d4b49',
        neutralTertiaryAlt: '#72706e',
        neutralTertiary: '#c8c8c8',
        neutralSecondary: '#d0d0d0',
        neutralPrimaryAlt: '#dadada',
        neutralPrimary: '#ffffff',
        neutralDark: '#f4f4f4',
        black: '#f8f8f8',
        white: '#252423'
    },
    callingPalette: {
        callRed: '#c4314b',
        callRedDark: '#a42e43',
        callRedDarker: '#8b2c3d',
        iconWhite: '#ffffff'
    },
    semanticColors: {
        errorText: '#f1707b'
    }
};

/*! For license information please see index.js.LICENSE.txt */
var o={583:(e,r)=>{var o;!function(){var t={}.hasOwnProperty;function n(){for(var e=[],r=0;r<arguments.length;r++){var o=arguments[r];if(o){var a=typeof o;if("string"===a||"number"===a)e.push(o);else if(Array.isArray(o)){if(o.length){var i=n.apply(null,o);i&&e.push(i);}}else if("object"===a){if(o.toString!==Object.prototype.toString&&!o.toString.toString().includes("[native code]")){e.push(o.toString());continue}for(var l in o)t.call(o,l)&&o[l]&&e.push(l);}}}return e.join(" ")}e.exports?(n.default=n,e.exports=n):void 0===(o=function(){return n}.apply(r,[]))||(e.exports=o);}();},2700:(e,r)=>{function o(e){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o(e)}function t(e,r){(null==r||r>e.length)&&(r=e.length);for(var o=0,t=new Array(r);o<r;o++)t[o]=e[o];return t}function n(e){return e.filter((function(r,o){return e.lastIndexOf(r)===o}))}r.Z=function e(r){for(var a=0,i=arguments.length<=1?0:arguments.length-1;a<i;++a){var l=a+1<1||arguments.length<=a+1?void 0:arguments[a+1];for(var s in l){var c=l[s],d=r[s];if(d&&c){if(Array.isArray(d)){r[s]=n(d.concat(c));continue}if(Array.isArray(c)){r[s]=n([d].concat(function(e){if(Array.isArray(e))return t(e)}(u=c)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(u)||function(e,r){if(e){if("string"==typeof e)return t(e,r);var o=Object.prototype.toString.call(e).slice(8,-1);return "Object"===o&&e.constructor&&(o=e.constructor.name),"Map"===o||"Set"===o?Array.from(o):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?t(e,r):void 0}}(u)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()));continue}if("object"===o(c)){r[s]=e({},d,c);continue}}r[s]=c;}}var u;return r};},3140:(e,r)=>{r.Z=function(e){if(n.hasOwnProperty(e))return n[e];var r=e.replace(o,a).replace(t,"ms");return n[e]=r,r};var o=/-([a-z])/g,t=/^Ms/g,n={};function a(e){return e[1].toUpperCase()}},2787:(e,r,o)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,r){return (0, n.default)(e)+":"+r};var t,n=(t=o(3182))&&t.__esModule?t:{default:t};},3235:(e,r,o)=>{r.Z=function(e){var r="";for(var o in e){var t=e[o];"string"!=typeof t&&"number"!=typeof t||(r&&(r+=";"),r+=(0, n.default)(o,t));}return r};var t,n=(t=o(2787))&&t.__esModule?t:{default:t};},3182:(e,r,o)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return (0, n.default)(e)};var t,n=(t=o(6038))&&t.__esModule?t:{default:t};},9811:(e,r,o)=>{r.Z=function(e,r){return r.join(";"+(0, n.default)(e)+":")};var t,n=(t=o(3182))&&t.__esModule?t:{default:t};},6368:(e,r)=>{r.Z=function(e,r){for(var o=0,t=e.length;o<t;++o)r(e[o],o,t,e);};},4488:(e,r)=>{r.Z=function(e,r,o){for(var t=0,n=e.length;t<n;++t)o=r(o,e[t],t,n,e);return o};},9332:(e,r)=>{r.Z=function(e,r){for(var o in e)r(e[o],o,e);};},2370:(e,r)=>{r.Z=function(e,r,o){for(var t in e)o=r(o,e[t],t,e);return o};},6038:(e,r,o)=>{o.r(r),o.d(r,{default:()=>l});var t=/[A-Z]/g,n=/^ms-/,a={};function i(e){return "-"+e.toLowerCase()}const l=function(e){if(a.hasOwnProperty(e))return a[e];var r=e.replace(t,i);return a[e]=n.test(r)?"-"+r:r};},980:e=>{e.exports=function(e){return null!=e&&"object"==typeof e&&!1===Array.isArray(e)};},4594:(e,r,o)=>{var t=o(916)(o(9226),"DataView");e.exports=t;},2618:(e,r,o)=>{var t=o(5804),n=o(9546),a=o(478),i=o(3374),l=o(1798);function s(e){var r=-1,o=null==e?0:e.length;for(this.clear();++r<o;){var t=e[r];this.set(t[0],t[1]);}}s.prototype.clear=t,s.prototype.delete=n,s.prototype.get=a,s.prototype.has=i,s.prototype.set=l,e.exports=s;},5699:(e,r,o)=>{var t=o(2298),n=o(2593),a=o(8345),i=o(4517),l=o(3711);function s(e){var r=-1,o=null==e?0:e.length;for(this.clear();++r<o;){var t=e[r];this.set(t[0],t[1]);}}s.prototype.clear=t,s.prototype.delete=n,s.prototype.get=a,s.prototype.has=i,s.prototype.set=l,e.exports=s;},2998:(e,r,o)=>{var t=o(916)(o(9226),"Map");e.exports=t;},5126:(e,r,o)=>{var t=o(8945),n=o(1722),a=o(2966),i=o(1846),l=o(5061);function s(e){var r=-1,o=null==e?0:e.length;for(this.clear();++r<o;){var t=e[r];this.set(t[0],t[1]);}}s.prototype.clear=t,s.prototype.delete=n,s.prototype.get=a,s.prototype.has=i,s.prototype.set=l,e.exports=s;},4876:(e,r,o)=>{var t=o(916)(o(9226),"Promise");e.exports=t;},2558:(e,r,o)=>{var t=o(916)(o(9226),"Set");e.exports=t;},7655:(e,r,o)=>{var t=o(5126),n=o(7115),a=o(1675);function i(e){var r=-1,o=null==e?0:e.length;for(this.__data__=new t;++r<o;)this.add(e[r]);}i.prototype.add=i.prototype.push=n,i.prototype.has=a,e.exports=i;},2160:(e,r,o)=>{var t=o(5699),n=o(5681),a=o(9487),i=o(4539),l=o(9999),s=o(2060);function c(e){var r=this.__data__=new t(e);this.size=r.size;}c.prototype.clear=n,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=l,c.prototype.set=s,e.exports=c;},7841:(e,r,o)=>{var t=o(9226).Symbol;e.exports=t;},922:(e,r,o)=>{var t=o(9226).Uint8Array;e.exports=t;},2805:(e,r,o)=>{var t=o(916)(o(9226),"WeakMap");e.exports=t;},3341:e=>{e.exports=function(e,r,o){switch(o.length){case 0:return e.call(r);case 1:return e.call(r,o[0]);case 2:return e.call(r,o[0],o[1]);case 3:return e.call(r,o[0],o[1],o[2])}return e.apply(r,o)};},3666:e=>{e.exports=function(e,r){for(var o=-1,t=null==e?0:e.length;++o<t&&!1!==r(e[o],o,e););return e};},7187:e=>{e.exports=function(e,r){for(var o=-1,t=null==e?0:e.length,n=0,a=[];++o<t;){var i=e[o];r(i,o,e)&&(a[n++]=i);}return a};},7583:(e,r,o)=>{var t=o(7549);e.exports=function(e,r){return !(null==e||!e.length)&&t(e,r,0)>-1};},5623:e=>{e.exports=function(e,r,o){for(var t=-1,n=null==e?0:e.length;++t<n;)if(o(r,e[t]))return !0;return !1};},2483:(e,r,o)=>{var t=o(1547),n=o(150),a=o(4490),i=o(4772),l=o(7999),s=o(345),c=Object.prototype.hasOwnProperty;e.exports=function(e,r){var o=a(e),d=!o&&n(e),u=!o&&!d&&i(e),f=!o&&!d&&!u&&s(e),g=o||d||u||f,p=g?t(e.length,String):[],b=p.length;for(var m in e)!r&&!c.call(e,m)||g&&("length"==m||u&&("offset"==m||"parent"==m)||f&&("buffer"==m||"byteLength"==m||"byteOffset"==m)||l(m,b))||p.push(m);return p};},1732:e=>{e.exports=function(e,r){for(var o=-1,t=null==e?0:e.length,n=Array(t);++o<t;)n[o]=r(e[o],o,e);return n};},2149:e=>{e.exports=function(e,r){for(var o=-1,t=r.length,n=e.length;++o<t;)e[n+o]=r[o];return e};},5733:e=>{e.exports=function(e,r){for(var o=-1,t=null==e?0:e.length;++o<t;)if(r(e[o],o,e))return !0;return !1};},2759:e=>{e.exports=function(e){return e.split("")};},1997:(e,r,o)=>{var t=o(7274),n=o(9954);e.exports=function(e,r,o){(void 0!==o&&!n(e[r],o)||void 0===o&&!(r in e))&&t(e,r,o);};},7807:(e,r,o)=>{var t=o(7274),n=o(9954),a=Object.prototype.hasOwnProperty;e.exports=function(e,r,o){var i=e[r];a.call(e,r)&&n(i,o)&&(void 0!==o||r in e)||t(e,r,o);};},9186:(e,r,o)=>{var t=o(9954);e.exports=function(e,r){for(var o=e.length;o--;)if(t(e[o][0],r))return o;return -1};},7274:(e,r,o)=>{var t=o(6773);e.exports=function(e,r,o){"__proto__"==r&&t?t(e,r,{configurable:!0,enumerable:!0,value:o,writable:!0}):e[r]=o;};},7632:(e,r,o)=>{var t=o(6139),n=Object.create,a=function(){function e(){}return function(r){if(!t(r))return {};if(n)return n(r);e.prototype=r;var o=new e;return e.prototype=void 0,o}}();e.exports=a;},9315:(e,r,o)=>{var t=o(7655),n=o(7583),a=o(5623),i=o(1732),l=o(9912),s=o(6806);e.exports=function(e,r,o,c){var d=-1,u=n,f=!0,g=e.length,p=[],b=r.length;if(!g)return p;o&&(r=i(r,l(o))),c?(u=a,f=!1):r.length>=200&&(u=s,f=!1,r=new t(r));e:for(;++d<g;){var m=e[d],h=null==o?m:o(m);if(m=c||0!==m?m:0,f&&h==h){for(var v=b;v--;)if(r[v]===h)continue e;p.push(m);}else u(r,h,c)||p.push(m);}return p};},1039:(e,r,o)=>{var t=o(8968),n=o(5750)(t);e.exports=n;},9405:(e,r,o)=>{var t=o(6080);e.exports=function(e,r,o){for(var n=-1,a=e.length;++n<a;){var i=e[n],l=r(i);if(null!=l&&(void 0===s?l==l&&!t(l):o(l,s)))var s=l,c=i;}return c};},9800:(e,r,o)=>{var t=o(1039);e.exports=function(e,r){var o=[];return t(e,(function(e,t,n){r(e,t,n)&&o.push(e);})),o};},4331:e=>{e.exports=function(e,r,o,t){for(var n=e.length,a=o+(t?1:-1);t?a--:++a<n;)if(r(e[a],a,e))return a;return -1};},4777:(e,r,o)=>{var t=o(2149),n=o(3285);e.exports=function e(r,o,a,i,l){var s=-1,c=r.length;for(a||(a=n),l||(l=[]);++s<c;){var d=r[s];o>0&&a(d)?o>1?e(d,o-1,a,i,l):t(l,d):i||(l[l.length]=d);}return l};},7798:(e,r,o)=>{var t=o(1365)();e.exports=t;},8968:(e,r,o)=>{var t=o(7798),n=o(5211);e.exports=function(e,r){return e&&t(e,r,n)};},7245:(e,r,o)=>{var t=o(450),n=o(2823);e.exports=function(e,r){for(var o=0,a=(r=t(r,e)).length;null!=e&&o<a;)e=e[n(r[o++])];return o&&o==a?e:void 0};},4240:(e,r,o)=>{var t=o(2149),n=o(4490);e.exports=function(e,r,o){var a=r(e);return n(e)?a:t(a,o(e))};},4815:(e,r,o)=>{var t=o(7841),n=o(2429),a=o(9930),i=t?t.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":i&&i in Object(e)?n(e):a(e)};},8983:e=>{var r=Object.prototype.hasOwnProperty;e.exports=function(e,o){return null!=e&&r.call(e,o)};},2014:e=>{e.exports=function(e,r){return null!=e&&r in Object(e)};},2244:e=>{var r=Math.max,o=Math.min;e.exports=function(e,t,n){return e>=o(t,n)&&e<r(t,n)};},7549:(e,r,o)=>{var t=o(4331),n=o(309),a=o(2914);e.exports=function(e,r,o){return r==r?a(e,r,o):t(e,n,o)};},3601:(e,r,o)=>{var t=o(3341),n=o(450),a=o(1805),i=o(5968),l=o(2823);e.exports=function(e,r,o){r=n(r,e);var s=null==(e=i(e,r))?e:e[l(a(r))];return null==s?void 0:t(s,e,o)};},5911:(e,r,o)=>{var t=o(4815),n=o(4394);e.exports=function(e){return n(e)&&"[object Arguments]"==t(e)};},7283:(e,r,o)=>{var t=o(7626),n=o(4394);e.exports=function e(r,o,a,i,l){return r===o||(null==r||null==o||!n(r)&&!n(o)?r!=r&&o!=o:t(r,o,a,i,e,l))};},7626:(e,r,o)=>{var t=o(2160),n=o(8288),a=o(4697),i=o(194),l=o(4305),s=o(4490),c=o(4772),d=o(345),u="[object Arguments]",f="[object Array]",g="[object Object]",p=Object.prototype.hasOwnProperty;e.exports=function(e,r,o,b,m,h){var v=s(e),y=s(r),C=v?f:l(e),k=y?f:l(r),w=(C=C==u?g:C)==g,x=(k=k==u?g:k)==g,S=C==k;if(S&&c(e)){if(!c(r))return !1;v=!0,w=!1;}if(S&&!w)return h||(h=new t),v||d(e)?n(e,r,o,b,m,h):a(e,r,C,o,b,m,h);if(!(1&o)){var B=w&&p.call(e,"__wrapped__"),E=x&&p.call(r,"__wrapped__");if(B||E){var O=B?e.value():e,F=E?r.value():r;return h||(h=new t),m(O,F,o,b,h)}}return !!S&&(h||(h=new t),i(e,r,o,b,m,h))};},1842:(e,r,o)=>{var t=o(2160),n=o(7283);e.exports=function(e,r,o,a){var i=o.length,l=i,s=!a;if(null==e)return !l;for(e=Object(e);i--;){var c=o[i];if(s&&c[2]?c[1]!==e[c[0]]:!(c[0]in e))return !1}for(;++i<l;){var d=(c=o[i])[0],u=e[d],f=c[1];if(s&&c[2]){if(void 0===u&&!(d in e))return !1}else {var g=new t;if(a)var p=a(u,f,d,e,r,g);if(!(void 0===p?n(f,u,3,a,g):p))return !1}}return !0};},309:e=>{e.exports=function(e){return e!=e};},20:(e,r,o)=>{var t=o(9274),n=o(5575),a=o(6139),i=o(82),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,f=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=function(e){return !(!a(e)||n(e))&&(t(e)?f:l).test(i(e))};},241:(e,r,o)=>{var t=o(4815),n=o(483),a=o(4394),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,e.exports=function(e){return a(e)&&n(e.length)&&!!i[t(e)]};},1051:(e,r,o)=>{var t=o(3954),n=o(1204),a=o(9205),i=o(4490),l=o(850);e.exports=function(e){return "function"==typeof e?e:null==e?a:"object"==typeof e?i(e)?n(e[0],e[1]):t(e):l(e)};},679:(e,r,o)=>{var t=o(2649),n=o(5689),a=Object.prototype.hasOwnProperty;e.exports=function(e){if(!t(e))return n(e);var r=[];for(var o in Object(e))a.call(e,o)&&"constructor"!=o&&r.push(o);return r};},260:(e,r,o)=>{var t=o(6139),n=o(2649),a=o(7375),i=Object.prototype.hasOwnProperty;e.exports=function(e){if(!t(e))return a(e);var r=n(e),o=[];for(var l in e)("constructor"!=l||!r&&i.call(e,l))&&o.push(l);return o};},1619:e=>{e.exports=function(e,r){return e<r};},7578:(e,r,o)=>{var t=o(1039),n=o(2054);e.exports=function(e,r){var o=-1,a=n(e)?Array(e.length):[];return t(e,(function(e,t,n){a[++o]=r(e,t,n);})),a};},3954:(e,r,o)=>{var t=o(1842),n=o(5145),a=o(8049);e.exports=function(e){var r=n(e);return 1==r.length&&r[0][2]?a(r[0][0],r[0][1]):function(o){return o===e||t(o,e,r)}};},1204:(e,r,o)=>{var t=o(7283),n=o(7882),a=o(3476),i=o(5137),l=o(3633),s=o(8049),c=o(2823);e.exports=function(e,r){return i(e)&&l(r)?s(c(e),r):function(o){var i=n(o,e);return void 0===i&&i===r?a(o,e):t(r,i,3)}};},6161:(e,r,o)=>{var t=o(2160),n=o(1997),a=o(7798),i=o(2512),l=o(6139),s=o(5531),c=o(8330);e.exports=function e(r,o,d,u,f){r!==o&&a(o,(function(a,s){if(f||(f=new t),l(a))i(r,o,s,d,e,u,f);else {var g=u?u(c(r,s),a,s+"",r,o,f):void 0;void 0===g&&(g=a),n(r,s,g);}}),s);};},2512:(e,r,o)=>{var t=o(1997),n=o(8675),a=o(8140),i=o(7218),l=o(9602),s=o(150),c=o(4490),d=o(6778),u=o(4772),f=o(9274),g=o(6139),p=o(3064),b=o(345),m=o(8330),h=o(9655);e.exports=function(e,r,o,v,y,C,k){var w=m(e,o),x=m(r,o),S=k.get(x);if(S)t(e,o,S);else {var B=C?C(w,x,o+"",e,r,k):void 0,E=void 0===B;if(E){var O=c(x),F=!O&&u(x),A=!O&&!F&&b(x);B=x,O||F||A?c(w)?B=w:d(w)?B=i(w):F?(E=!1,B=n(x,!0)):A?(E=!1,B=a(x,!0)):B=[]:p(x)||s(x)?(B=w,s(w)?B=h(w):g(w)&&!f(w)||(B=l(x))):E=!1;}E&&(k.set(x,B),y(B,x,v,C,k),k.delete(x)),t(e,o,B);}};},388:(e,r,o)=>{var t=o(1732),n=o(7245),a=o(1051),i=o(7578),l=o(8259),s=o(9912),c=o(2815),d=o(9205),u=o(4490);e.exports=function(e,r,o){r=r.length?t(r,(function(e){return u(e)?function(r){return n(r,1===e.length?e[0]:e)}:e})):[d];var f=-1;r=t(r,s(a));var g=i(e,(function(e,o,n){return {criteria:t(r,(function(r){return r(e)})),index:++f,value:e}}));return l(g,(function(e,r){return c(e,r,o)}))};},9831:(e,r,o)=>{var t=o(699),n=o(3476);e.exports=function(e,r){return t(e,r,(function(r,o){return n(e,o)}))};},699:(e,r,o)=>{var t=o(7245),n=o(4720),a=o(450);e.exports=function(e,r,o){for(var i=-1,l=r.length,s={};++i<l;){var c=r[i],d=t(e,c);o(d,c)&&n(s,a(c,e),d);}return s};},3021:e=>{e.exports=function(e){return function(r){return null==r?void 0:r[e]}};},8874:(e,r,o)=>{var t=o(7245);e.exports=function(e){return function(r){return t(r,e)}};},8386:(e,r,o)=>{var t=o(9205),n=o(1570),a=o(6748);e.exports=function(e,r){return a(n(e,r,t),e+"")};},4720:(e,r,o)=>{var t=o(7807),n=o(450),a=o(7999),i=o(6139),l=o(2823);e.exports=function(e,r,o,s){if(!i(e))return e;for(var c=-1,d=(r=n(r,e)).length,u=d-1,f=e;null!=f&&++c<d;){var g=l(r[c]),p=o;if("__proto__"===g||"constructor"===g||"prototype"===g)return e;if(c!=u){var b=f[g];void 0===(p=s?s(b,g,f):void 0)&&(p=i(b)?b:a(r[c+1])?[]:{});}t(f,g,p),f=f[g];}return e};},4066:(e,r,o)=>{var t=o(8395),n=o(6773),a=o(9205),i=n?function(e,r){return n(e,"toString",{configurable:!0,enumerable:!1,value:t(r),writable:!0})}:a;e.exports=i;},4253:e=>{e.exports=function(e,r,o){var t=-1,n=e.length;r<0&&(r=-r>n?0:n+r),(o=o>n?n:o)<0&&(o+=n),n=r>o?0:o-r>>>0,r>>>=0;for(var a=Array(n);++t<n;)a[t]=e[t+r];return a};},6353:(e,r,o)=>{var t=o(1039);e.exports=function(e,r){var o;return t(e,(function(e,t,n){return !(o=r(e,t,n))})),!!o};},8259:e=>{e.exports=function(e,r){var o=e.length;for(e.sort(r);o--;)e[o]=e[o].value;return e};},7706:e=>{e.exports=function(e,r){for(var o,t=-1,n=e.length;++t<n;){var a=r(e[t]);void 0!==a&&(o=void 0===o?a:o+a);}return o};},1547:e=>{e.exports=function(e,r){for(var o=-1,t=Array(e);++o<e;)t[o]=r(o);return t};},2205:(e,r,o)=>{var t=o(7841),n=o(1732),a=o(4490),i=o(6080),l=t?t.prototype:void 0,s=l?l.toString:void 0;e.exports=function e(r){if("string"==typeof r)return r;if(a(r))return n(r,e)+"";if(i(r))return s?s.call(r):"";var o=r+"";return "0"==o&&1/r==-1/0?"-0":o};},4482:(e,r,o)=>{var t=o(8460),n=/^\s+/;e.exports=function(e){return e?e.slice(0,t(e)+1).replace(n,""):e};},9912:e=>{e.exports=function(e){return function(r){return e(r)}};},8168:(e,r,o)=>{var t=o(7655),n=o(7583),a=o(5623),i=o(6806),l=o(3174),s=o(2365);e.exports=function(e,r,o){var c=-1,d=n,u=e.length,f=!0,g=[],p=g;if(o)f=!1,d=a;else if(u>=200){var b=r?null:l(e);if(b)return s(b);f=!1,d=i,p=new t;}else p=r?[]:g;e:for(;++c<u;){var m=e[c],h=r?r(m):m;if(m=o||0!==m?m:0,f&&h==h){for(var v=p.length;v--;)if(p[v]===h)continue e;r&&p.push(h),g.push(m);}else d(p,h,o)||(p!==g&&p.push(h),g.push(m));}return g};},457:(e,r,o)=>{var t=o(1732);e.exports=function(e,r){return t(r,(function(r){return e[r]}))};},6806:e=>{e.exports=function(e,r){return e.has(r)};},3860:(e,r,o)=>{var t=o(9205);e.exports=function(e){return "function"==typeof e?e:t};},450:(e,r,o)=>{var t=o(4490),n=o(5137),a=o(3596),i=o(6478);e.exports=function(e,r){return t(e)?e:n(e,r)?[e]:a(i(e))};},7477:(e,r,o)=>{var t=o(4253);e.exports=function(e,r,o){var n=e.length;return o=void 0===o?n:o,!r&&o>=n?e:t(e,r,o)};},7032:(e,r,o)=>{var t=o(7549);e.exports=function(e,r){for(var o=e.length;o--&&t(r,e[o],0)>-1;);return o};},1656:(e,r,o)=>{var t=o(7549);e.exports=function(e,r){for(var o=-1,n=e.length;++o<n&&t(r,e[o],0)>-1;);return o};},6020:(e,r,o)=>{var t=o(922);e.exports=function(e){var r=new e.constructor(e.byteLength);return new t(r).set(new t(e)),r};},8675:(e,r,o)=>{e=o.nmd(e);var t=o(9226),n=r&&!r.nodeType&&r,a=n&&e&&!e.nodeType&&e,i=a&&a.exports===n?t.Buffer:void 0,l=i?i.allocUnsafe:void 0;e.exports=function(e,r){if(r)return e.slice();var o=e.length,t=l?l(o):new e.constructor(o);return e.copy(t),t};},8140:(e,r,o)=>{var t=o(6020);e.exports=function(e,r){var o=r?t(e.buffer):e.buffer;return new e.constructor(o,e.byteOffset,e.length)};},2878:(e,r,o)=>{var t=o(6080);e.exports=function(e,r){if(e!==r){var o=void 0!==e,n=null===e,a=e==e,i=t(e),l=void 0!==r,s=null===r,c=r==r,d=t(r);if(!s&&!d&&!i&&e>r||i&&l&&c&&!s&&!d||n&&l&&c||!o&&c||!a)return 1;if(!n&&!i&&!d&&e<r||d&&o&&a&&!n&&!i||s&&o&&a||!l&&a||!c)return -1}return 0};},2815:(e,r,o)=>{var t=o(2878);e.exports=function(e,r,o){for(var n=-1,a=e.criteria,i=r.criteria,l=a.length,s=o.length;++n<l;){var c=t(a[n],i[n]);if(c)return n>=s?c:c*("desc"==o[n]?-1:1)}return e.index-r.index};},7218:e=>{e.exports=function(e,r){var o=-1,t=e.length;for(r||(r=Array(t));++o<t;)r[o]=e[o];return r};},681:(e,r,o)=>{var t=o(7807),n=o(7274);e.exports=function(e,r,o,a){var i=!o;o||(o={});for(var l=-1,s=r.length;++l<s;){var c=r[l],d=a?a(o[c],e[c],c,o,e):void 0;void 0===d&&(d=e[c]),i?n(o,c,d):t(o,c,d);}return o};},9356:(e,r,o)=>{var t=o(9226)["__core-js_shared__"];e.exports=t;},5969:(e,r,o)=>{var t=o(8386),n=o(2251);e.exports=function(e){return t((function(r,o){var t=-1,a=o.length,i=a>1?o[a-1]:void 0,l=a>2?o[2]:void 0;for(i=e.length>3&&"function"==typeof i?(a--,i):void 0,l&&n(o[0],o[1],l)&&(i=a<3?void 0:i,a=1),r=Object(r);++t<a;){var s=o[t];s&&e(r,s,t,i);}return r}))};},5750:(e,r,o)=>{var t=o(2054);e.exports=function(e,r){return function(o,n){if(null==o)return o;if(!t(o))return e(o,n);for(var a=o.length,i=r?a:-1,l=Object(o);(r?i--:++i<a)&&!1!==n(l[i],i,l););return o}};},1365:e=>{e.exports=function(e){return function(r,o,t){for(var n=-1,a=Object(r),i=t(r),l=i.length;l--;){var s=i[e?l:++n];if(!1===o(a[s],s,a))break}return r}};},3174:(e,r,o)=>{var t=o(2558),n=o(299),a=o(2365),i=t&&1/a(new t([,-0]))[1]==1/0?function(e){return new t(e)}:n;e.exports=i;},6773:(e,r,o)=>{var t=o(916),n=function(){try{var e=t(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=n;},8288:(e,r,o)=>{var t=o(7655),n=o(5733),a=o(6806);e.exports=function(e,r,o,i,l,s){var c=1&o,d=e.length,u=r.length;if(d!=u&&!(c&&u>d))return !1;var f=s.get(e),g=s.get(r);if(f&&g)return f==r&&g==e;var p=-1,b=!0,m=2&o?new t:void 0;for(s.set(e,r),s.set(r,e);++p<d;){var h=e[p],v=r[p];if(i)var y=c?i(v,h,p,r,e,s):i(h,v,p,e,r,s);if(void 0!==y){if(y)continue;b=!1;break}if(m){if(!n(r,(function(e,r){if(!a(m,r)&&(h===e||l(h,e,o,i,s)))return m.push(r)}))){b=!1;break}}else if(h!==v&&!l(h,v,o,i,s)){b=!1;break}}return s.delete(e),s.delete(r),b};},4697:(e,r,o)=>{var t=o(7841),n=o(922),a=o(9954),i=o(8288),l=o(2840),s=o(2365),c=t?t.prototype:void 0,d=c?c.valueOf:void 0;e.exports=function(e,r,o,t,c,u,f){switch(o){case"[object DataView]":if(e.byteLength!=r.byteLength||e.byteOffset!=r.byteOffset)return !1;e=e.buffer,r=r.buffer;case"[object ArrayBuffer]":return !(e.byteLength!=r.byteLength||!u(new n(e),new n(r)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+e,+r);case"[object Error]":return e.name==r.name&&e.message==r.message;case"[object RegExp]":case"[object String]":return e==r+"";case"[object Map]":var g=l;case"[object Set]":var p=1&t;if(g||(g=s),e.size!=r.size&&!p)return !1;var b=f.get(e);if(b)return b==r;t|=2,f.set(e,r);var m=i(g(e),g(r),t,c,u,f);return f.delete(e),m;case"[object Symbol]":if(d)return d.call(e)==d.call(r)}return !1};},194:(e,r,o)=>{var t=o(7935),n=Object.prototype.hasOwnProperty;e.exports=function(e,r,o,a,i,l){var s=1&o,c=t(e),d=c.length;if(d!=t(r).length&&!s)return !1;for(var u=d;u--;){var f=c[u];if(!(s?f in r:n.call(r,f)))return !1}var g=l.get(e),p=l.get(r);if(g&&p)return g==r&&p==e;var b=!0;l.set(e,r),l.set(r,e);for(var m=s;++u<d;){var h=e[f=c[u]],v=r[f];if(a)var y=s?a(v,h,f,r,e,l):a(h,v,f,e,r,l);if(!(void 0===y?h===v||i(h,v,o,a,l):y)){b=!1;break}m||(m="constructor"==f);}if(b&&!m){var C=e.constructor,k=r.constructor;C==k||!("constructor"in e)||!("constructor"in r)||"function"==typeof C&&C instanceof C&&"function"==typeof k&&k instanceof k||(b=!1);}return l.delete(e),l.delete(r),b};},2082:(e,r,o)=>{var t=o(610),n=o(1570),a=o(6748);e.exports=function(e){return a(n(e,void 0,t),e+"")};},6947:(e,r,o)=>{var t="object"==typeof o.g&&o.g&&o.g.Object===Object&&o.g;e.exports=t;},7935:(e,r,o)=>{var t=o(4240),n=o(3101),a=o(5211);e.exports=function(e){return t(e,a,n)};},4727:(e,r,o)=>{var t=o(1388);e.exports=function(e,r){var o=e.__data__;return t(r)?o["string"==typeof r?"string":"hash"]:o.map};},5145:(e,r,o)=>{var t=o(3633),n=o(5211);e.exports=function(e){for(var r=n(e),o=r.length;o--;){var a=r[o],i=e[a];r[o]=[a,i,t(i)];}return r};},916:(e,r,o)=>{var t=o(20),n=o(2795);e.exports=function(e,r){var o=n(e,r);return t(o)?o:void 0};},809:(e,r,o)=>{var t=o(2526)(Object.getPrototypeOf,Object);e.exports=t;},2429:(e,r,o)=>{var t=o(7841),n=Object.prototype,a=n.hasOwnProperty,i=n.toString,l=t?t.toStringTag:void 0;e.exports=function(e){var r=a.call(e,l),o=e[l];try{e[l]=void 0;var t=!0;}catch(e){}var n=i.call(e);return t&&(r?e[l]=o:delete e[l]),n};},3101:(e,r,o)=>{var t=o(7187),n=o(3735),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,l=i?function(e){return null==e?[]:(e=Object(e),t(i(e),(function(r){return a.call(e,r)})))}:n;e.exports=l;},4305:(e,r,o)=>{var t=o(4594),n=o(2998),a=o(4876),i=o(2558),l=o(2805),s=o(4815),c=o(82),d="[object Map]",u="[object Promise]",f="[object Set]",g="[object WeakMap]",p="[object DataView]",b=c(t),m=c(n),h=c(a),v=c(i),y=c(l),C=s;(t&&C(new t(new ArrayBuffer(1)))!=p||n&&C(new n)!=d||a&&C(a.resolve())!=u||i&&C(new i)!=f||l&&C(new l)!=g)&&(C=function(e){var r=s(e),o="[object Object]"==r?e.constructor:void 0,t=o?c(o):"";if(t)switch(t){case b:return p;case m:return d;case h:return u;case v:return f;case y:return g}return r}),e.exports=C;},2795:e=>{e.exports=function(e,r){return null==e?void 0:e[r]};},1060:(e,r,o)=>{var t=o(450),n=o(150),a=o(4490),i=o(7999),l=o(483),s=o(2823);e.exports=function(e,r,o){for(var c=-1,d=(r=t(r,e)).length,u=!1;++c<d;){var f=s(r[c]);if(!(u=null!=e&&o(e,f)))break;e=e[f];}return u||++c!=d?u:!!(d=null==e?0:e.length)&&l(d)&&i(f,d)&&(a(e)||n(e))};},2682:e=>{var r=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");e.exports=function(e){return r.test(e)};},5804:(e,r,o)=>{var t=o(7945);e.exports=function(){this.__data__=t?t(null):{},this.size=0;};},9546:e=>{e.exports=function(e){var r=this.has(e)&&delete this.__data__[e];return this.size-=r?1:0,r};},478:(e,r,o)=>{var t=o(7945),n=Object.prototype.hasOwnProperty;e.exports=function(e){var r=this.__data__;if(t){var o=r[e];return "__lodash_hash_undefined__"===o?void 0:o}return n.call(r,e)?r[e]:void 0};},3374:(e,r,o)=>{var t=o(7945),n=Object.prototype.hasOwnProperty;e.exports=function(e){var r=this.__data__;return t?void 0!==r[e]:n.call(r,e)};},1798:(e,r,o)=>{var t=o(7945);e.exports=function(e,r){var o=this.__data__;return this.size+=this.has(e)?0:1,o[e]=t&&void 0===r?"__lodash_hash_undefined__":r,this};},9602:(e,r,o)=>{var t=o(7632),n=o(809),a=o(2649);e.exports=function(e){return "function"!=typeof e.constructor||a(e)?{}:t(n(e))};},3285:(e,r,o)=>{var t=o(7841),n=o(150),a=o(4490),i=t?t.isConcatSpreadable:void 0;e.exports=function(e){return a(e)||n(e)||!!(i&&e&&e[i])};},7999:e=>{var r=/^(?:0|[1-9]\d*)$/;e.exports=function(e,o){var t=typeof e;return !!(o=null==o?9007199254740991:o)&&("number"==t||"symbol"!=t&&r.test(e))&&e>-1&&e%1==0&&e<o};},2251:(e,r,o)=>{var t=o(9954),n=o(2054),a=o(7999),i=o(6139);e.exports=function(e,r,o){if(!i(o))return !1;var l=typeof r;return !!("number"==l?n(o)&&a(r,o.length):"string"==l&&r in o)&&t(o[r],e)};},5137:(e,r,o)=>{var t=o(4490),n=o(6080),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;e.exports=function(e,r){if(t(e))return !1;var o=typeof e;return !("number"!=o&&"symbol"!=o&&"boolean"!=o&&null!=e&&!n(e))||i.test(e)||!a.test(e)||null!=r&&e in Object(r)};},1388:e=>{e.exports=function(e){var r=typeof e;return "string"==r||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==e:null===e};},5575:(e,r,o)=>{var t,n=o(9356),a=(t=/[^.]+$/.exec(n&&n.keys&&n.keys.IE_PROTO||""))?"Symbol(src)_1."+t:"";e.exports=function(e){return !!a&&a in e};},2649:e=>{var r=Object.prototype;e.exports=function(e){var o=e&&e.constructor;return e===("function"==typeof o&&o.prototype||r)};},3633:(e,r,o)=>{var t=o(6139);e.exports=function(e){return e==e&&!t(e)};},2298:e=>{e.exports=function(){this.__data__=[],this.size=0;};},2593:(e,r,o)=>{var t=o(9186),n=Array.prototype.splice;e.exports=function(e){var r=this.__data__,o=t(r,e);return !(o<0||(o==r.length-1?r.pop():n.call(r,o,1),--this.size,0))};},8345:(e,r,o)=>{var t=o(9186);e.exports=function(e){var r=this.__data__,o=t(r,e);return o<0?void 0:r[o][1]};},4517:(e,r,o)=>{var t=o(9186);e.exports=function(e){return t(this.__data__,e)>-1};},3711:(e,r,o)=>{var t=o(9186);e.exports=function(e,r){var o=this.__data__,n=t(o,e);return n<0?(++this.size,o.push([e,r])):o[n][1]=r,this};},8945:(e,r,o)=>{var t=o(2618),n=o(5699),a=o(2998);e.exports=function(){this.size=0,this.__data__={hash:new t,map:new(a||n),string:new t};};},1722:(e,r,o)=>{var t=o(4727);e.exports=function(e){var r=t(this,e).delete(e);return this.size-=r?1:0,r};},2966:(e,r,o)=>{var t=o(4727);e.exports=function(e){return t(this,e).get(e)};},1846:(e,r,o)=>{var t=o(4727);e.exports=function(e){return t(this,e).has(e)};},5061:(e,r,o)=>{var t=o(4727);e.exports=function(e,r){var o=t(this,e),n=o.size;return o.set(e,r),this.size+=o.size==n?0:1,this};},2840:e=>{e.exports=function(e){var r=-1,o=Array(e.size);return e.forEach((function(e,t){o[++r]=[t,e];})),o};},8049:e=>{e.exports=function(e,r){return function(o){return null!=o&&o[e]===r&&(void 0!==r||e in Object(o))}};},8773:(e,r,o)=>{var t=o(1925);e.exports=function(e){var r=t(e,(function(e){return 500===o.size&&o.clear(),e})),o=r.cache;return r};},7945:(e,r,o)=>{var t=o(916)(Object,"create");e.exports=t;},5689:(e,r,o)=>{var t=o(2526)(Object.keys,Object);e.exports=t;},7375:e=>{e.exports=function(e){var r=[];if(null!=e)for(var o in Object(e))r.push(o);return r};},9343:(e,r,o)=>{e=o.nmd(e);var t=o(6947),n=r&&!r.nodeType&&r,a=n&&e&&!e.nodeType&&e,i=a&&a.exports===n&&t.process,l=function(){try{return a&&a.require&&a.require("util").types||i&&i.binding&&i.binding("util")}catch(e){}}();e.exports=l;},9930:e=>{var r=Object.prototype.toString;e.exports=function(e){return r.call(e)};},2526:e=>{e.exports=function(e,r){return function(o){return e(r(o))}};},1570:(e,r,o)=>{var t=o(3341),n=Math.max;e.exports=function(e,r,o){return r=n(void 0===r?e.length-1:r,0),function(){for(var a=arguments,i=-1,l=n(a.length-r,0),s=Array(l);++i<l;)s[i]=a[r+i];i=-1;for(var c=Array(r+1);++i<r;)c[i]=a[i];return c[r]=o(s),t(e,this,c)}};},5968:(e,r,o)=>{var t=o(7245),n=o(4253);e.exports=function(e,r){return r.length<2?e:t(e,n(r,0,-1))};},9226:(e,r,o)=>{var t=o(6947),n="object"==typeof self&&self&&self.Object===Object&&self,a=t||n||Function("return this")();e.exports=a;},8330:e=>{e.exports=function(e,r){if(("constructor"!==r||"function"!=typeof e[r])&&"__proto__"!=r)return e[r]};},7115:e=>{e.exports=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this};},1675:e=>{e.exports=function(e){return this.__data__.has(e)};},2365:e=>{e.exports=function(e){var r=-1,o=Array(e.size);return e.forEach((function(e){o[++r]=e;})),o};},6748:(e,r,o)=>{var t=o(4066),n=o(8539)(t);e.exports=n;},8539:e=>{var r=Date.now;e.exports=function(e){var o=0,t=0;return function(){var n=r(),a=16-(n-t);if(t=n,a>0){if(++o>=800)return arguments[0]}else o=0;return e.apply(void 0,arguments)}};},5681:(e,r,o)=>{var t=o(5699);e.exports=function(){this.__data__=new t,this.size=0;};},9487:e=>{e.exports=function(e){var r=this.__data__,o=r.delete(e);return this.size=r.size,o};},4539:e=>{e.exports=function(e){return this.__data__.get(e)};},9999:e=>{e.exports=function(e){return this.__data__.has(e)};},2060:(e,r,o)=>{var t=o(5699),n=o(2998),a=o(5126);e.exports=function(e,r){var o=this.__data__;if(o instanceof t){var i=o.__data__;if(!n||i.length<199)return i.push([e,r]),this.size=++o.size,this;o=this.__data__=new a(i);}return o.set(e,r),this.size=o.size,this};},2914:e=>{e.exports=function(e,r,o){for(var t=o-1,n=e.length;++t<n;)if(e[t]===r)return t;return -1};},8441:(e,r,o)=>{var t=o(2759),n=o(2682),a=o(8897);e.exports=function(e){return n(e)?a(e):t(e)};},3596:(e,r,o)=>{var t=o(8773),n=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=t((function(e){var r=[];return 46===e.charCodeAt(0)&&r.push(""),e.replace(n,(function(e,o,t,n){r.push(t?n.replace(a,"$1"):o||e);})),r}));e.exports=i;},2823:(e,r,o)=>{var t=o(6080);e.exports=function(e){if("string"==typeof e||t(e))return e;var r=e+"";return "0"==r&&1/e==-1/0?"-0":r};},82:e=>{var r=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return r.call(e)}catch(e){}try{return e+""}catch(e){}}return ""};},8460:e=>{var r=/\s/;e.exports=function(e){for(var o=e.length;o--&&r.test(e.charAt(o)););return o};},8897:e=>{var r="\\ud800-\\udfff",o="["+r+"]",t="[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",n="\\ud83c[\\udffb-\\udfff]",a="[^"+r+"]",i="(?:\\ud83c[\\udde6-\\uddff]){2}",l="[\\ud800-\\udbff][\\udc00-\\udfff]",s="(?:"+t+"|"+n+")?",c="[\\ufe0e\\ufe0f]?",d=c+s+"(?:\\u200d(?:"+[a,i,l].join("|")+")"+c+s+")*",u="(?:"+[a+t+"?",t,i,l,o].join("|")+")",f=RegExp(n+"(?="+n+")|"+u+d,"g");e.exports=function(e){return e.match(f)||[]};},7506:e=>{e.exports=function(e){for(var r=-1,o=null==e?0:e.length,t=0,n=[];++r<o;){var a=e[r];a&&(n[t++]=a);}return n};},8395:e=>{e.exports=function(e){return function(){return e}};},3629:(e,r,o)=>{var t=o(6139),n=o(9939),a=o(738),i=Math.max,l=Math.min;e.exports=function(e,r,o){var s,c,d,u,f,g,p=0,b=!1,m=!1,h=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function v(r){var o=s,t=c;return s=c=void 0,p=r,u=e.apply(t,o)}function y(e){var o=e-g;return void 0===g||o>=r||o<0||m&&e-p>=d}function C(){var e=n();if(y(e))return k(e);f=setTimeout(C,function(e){var o=r-(e-g);return m?l(o,d-(e-p)):o}(e));}function k(e){return f=void 0,h&&s?v(e):(s=c=void 0,u)}function w(){var e=n(),o=y(e);if(s=arguments,c=this,g=e,o){if(void 0===f)return function(e){return p=e,f=setTimeout(C,r),b?v(e):u}(g);if(m)return clearTimeout(f),f=setTimeout(C,r),v(g)}return void 0===f&&(f=setTimeout(C,r)),u}return r=a(r)||0,t(o)&&(b=!!o.leading,d=(m="maxWait"in o)?i(a(o.maxWait)||0,r):d,h="trailing"in o?!!o.trailing:h),w.cancel=function(){void 0!==f&&clearTimeout(f),p=0,s=g=c=f=void 0;},w.flush=function(){return void 0===f?u:k(n())},w};},1894:(e,r,o)=>{var t=o(9315),n=o(4777),a=o(8386),i=o(6778),l=a((function(e,r){return i(e)?t(e,n(r,1,i,!0)):[]}));e.exports=l;},690:(e,r,o)=>{var t=o(9315),n=o(4777),a=o(1051),i=o(8386),l=o(6778),s=o(1805),c=i((function(e,r){var o=s(r);return l(o)&&(o=void 0),l(e)?t(e,n(r,1,l,!0),a(o,2)):[]}));e.exports=c;},9954:e=>{e.exports=function(e,r){return e===r||e!=e&&r!=r};},2347:(e,r,o)=>{var t=o(7187),n=o(9800),a=o(1051),i=o(4490);e.exports=function(e,r){return (i(e)?t:n)(e,a(r,3))};},2654:(e,r,o)=>{var t=o(4331),n=o(1051),a=o(3792),i=Math.max;e.exports=function(e,r,o){var l=null==e?0:e.length;if(!l)return -1;var s=null==o?0:a(o);return s<0&&(s=i(l+s,0)),t(e,n(r,3),s)};},6380:(e,r,o)=>{e.exports=o(1806);},610:(e,r,o)=>{var t=o(4777);e.exports=function(e){return null!=e&&e.length?t(e,1):[]};},3296:(e,r,o)=>{var t=o(3666),n=o(1039),a=o(3860),i=o(4490);e.exports=function(e,r){return (i(e)?t:n)(e,a(r))};},7882:(e,r,o)=>{var t=o(7245);e.exports=function(e,r,o){var n=null==e?void 0:t(e,r);return void 0===n?o:n};},576:(e,r,o)=>{var t=o(8983),n=o(1060);e.exports=function(e,r){return null!=e&&n(e,r,t)};},3476:(e,r,o)=>{var t=o(2014),n=o(1060);e.exports=function(e,r){return null!=e&&n(e,r,t)};},1806:e=>{e.exports=function(e){return e&&e.length?e[0]:void 0};},9205:e=>{e.exports=function(e){return e};},3379:(e,r,o)=>{var t=o(2244),n=o(5525),a=o(738);e.exports=function(e,r,o){return r=n(r),void 0===o?(o=r,r=0):o=n(o),e=a(e),t(e,r,o)};},3873:(e,r,o)=>{var t=o(3601),n=o(8386)(t);e.exports=n;},150:(e,r,o)=>{var t=o(5911),n=o(4394),a=Object.prototype,i=a.hasOwnProperty,l=a.propertyIsEnumerable,s=t(function(){return arguments}())?t:function(e){return n(e)&&i.call(e,"callee")&&!l.call(e,"callee")};e.exports=s;},4490:e=>{var r=Array.isArray;e.exports=r;},2054:(e,r,o)=>{var t=o(9274),n=o(483);e.exports=function(e){return null!=e&&n(e.length)&&!t(e)};},6778:(e,r,o)=>{var t=o(2054),n=o(4394);e.exports=function(e){return n(e)&&t(e)};},2304:(e,r,o)=>{var t=o(4815),n=o(4394);e.exports=function(e){return !0===e||!1===e||n(e)&&"[object Boolean]"==t(e)};},4772:(e,r,o)=>{e=o.nmd(e);var t=o(9226),n=o(9171),a=r&&!r.nodeType&&r,i=a&&e&&!e.nodeType&&e,l=i&&i.exports===a?t.Buffer:void 0,s=(l?l.isBuffer:void 0)||n;e.exports=s;},7693:(e,r,o)=>{var t=o(679),n=o(4305),a=o(150),i=o(4490),l=o(2054),s=o(4772),c=o(2649),d=o(345),u=Object.prototype.hasOwnProperty;e.exports=function(e){if(null==e)return !0;if(l(e)&&(i(e)||"string"==typeof e||"function"==typeof e.splice||s(e)||d(e)||a(e)))return !e.length;var r=n(e);if("[object Map]"==r||"[object Set]"==r)return !e.size;if(c(e))return !t(e).length;for(var o in e)if(u.call(e,o))return !1;return !0};},8838:(e,r,o)=>{var t=o(7283);e.exports=function(e,r){return t(e,r)};},9274:(e,r,o)=>{var t=o(4815),n=o(6139);e.exports=function(e){if(!n(e))return !1;var r=t(e);return "[object Function]"==r||"[object GeneratorFunction]"==r||"[object AsyncFunction]"==r||"[object Proxy]"==r};},483:e=>{e.exports=function(e){return "number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991};},253:e=>{e.exports=function(e){return null==e};},5413:(e,r,o)=>{var t=o(4815),n=o(4394);e.exports=function(e){return "number"==typeof e||n(e)&&"[object Number]"==t(e)};},6139:e=>{e.exports=function(e){var r=typeof e;return null!=e&&("object"==r||"function"==r)};},4394:e=>{e.exports=function(e){return null!=e&&"object"==typeof e};},3064:(e,r,o)=>{var t=o(4815),n=o(809),a=o(4394),i=Function.prototype,l=Object.prototype,s=i.toString,c=l.hasOwnProperty,d=s.call(Object);e.exports=function(e){if(!a(e)||"[object Object]"!=t(e))return !1;var r=n(e);if(null===r)return !0;var o=c.call(r,"constructor")&&r.constructor;return "function"==typeof o&&o instanceof o&&s.call(o)==d};},6080:(e,r,o)=>{var t=o(4815),n=o(4394);e.exports=function(e){return "symbol"==typeof e||n(e)&&"[object Symbol]"==t(e)};},345:(e,r,o)=>{var t=o(241),n=o(9912),a=o(9343),i=a&&a.isTypedArray,l=i?n(i):t;e.exports=l;},5211:(e,r,o)=>{var t=o(2483),n=o(679),a=o(2054);e.exports=function(e){return a(e)?t(e):n(e)};},5531:(e,r,o)=>{var t=o(2483),n=o(260),a=o(2054);e.exports=function(e){return a(e)?t(e,!0):n(e)};},1805:e=>{e.exports=function(e){var r=null==e?0:e.length;return r?e[r-1]:void 0};},6601:(e,r,o)=>{var t=o(1732),n=o(1051),a=o(7578),i=o(4490);e.exports=function(e,r){return (i(e)?t:a)(e,n(r,3))};},1925:(e,r,o)=>{var t=o(5126);function n(e,r){if("function"!=typeof e||null!=r&&"function"!=typeof r)throw new TypeError("Expected a function");var o=function(){var t=arguments,n=r?r.apply(this,t):t[0],a=o.cache;if(a.has(n))return a.get(n);var i=e.apply(this,t);return o.cache=a.set(n,i)||a,i};return o.cache=new(n.Cache||t),o}n.Cache=t,e.exports=n;},6186:(e,r,o)=>{var t=o(6161),n=o(5969)((function(e,r,o){t(e,r,o);}));e.exports=n;},2534:(e,r,o)=>{var t=o(9405),n=o(1619),a=o(9205);e.exports=function(e){return e&&e.length?t(e,a,n):void 0};},299:e=>{e.exports=function(){};},9939:(e,r,o)=>{var t=o(9226);e.exports=function(){return t.Date.now()};},6614:(e,r,o)=>{var t=o(9831),n=o(2082)((function(e,r){return null==e?{}:t(e,r)}));e.exports=n;},850:(e,r,o)=>{var t=o(3021),n=o(8874),a=o(5137),i=o(2823);e.exports=function(e){return a(e)?t(i(e)):n(e)};},5313:(e,r,o)=>{var t=o(5733),n=o(1051),a=o(6353),i=o(4490),l=o(2251);e.exports=function(e,r,o){var s=i(e)?t:a;return o&&l(e,r,o)&&(r=void 0),s(e,n(r,3))};},5395:(e,r,o)=>{var t=o(4777),n=o(388),a=o(8386),i=o(2251),l=a((function(e,r){if(null==e)return [];var o=r.length;return o>1&&i(e,r[0],r[1])?r=[]:o>2&&i(r[0],r[1],r[2])&&(r=[r[0]]),n(e,t(r,1),[])}));e.exports=l;},3735:e=>{e.exports=function(){return []};},9171:e=>{e.exports=function(){return !1};},4077:(e,r,o)=>{var t=o(7706),n=o(9205);e.exports=function(e){return e&&e.length?t(e,n):0};},8864:(e,r,o)=>{var t=o(4253),n=o(3792);e.exports=function(e,r,o){return e&&e.length?(r=o||void 0===r?1:n(r),t(e,0,r<0?0:r)):[]};},5525:(e,r,o)=>{var t=o(738);e.exports=function(e){return e?Infinity===(e=t(e))||e===-1/0?17976931348623157e292*(e<0?-1:1):e==e?e:0:0===e?e:0};},3792:(e,r,o)=>{var t=o(5525);e.exports=function(e){var r=t(e),o=r%1;return r==r?o?r-o:r:0};},738:(e,r,o)=>{var t=o(4482),n=o(6139),a=o(6080),i=/^[-+]0x[0-9a-f]+$/i,l=/^0b[01]+$/i,s=/^0o[0-7]+$/i,c=parseInt;e.exports=function(e){if("number"==typeof e)return e;if(a(e))return NaN;if(n(e)){var r="function"==typeof e.valueOf?e.valueOf():e;e=n(r)?r+"":r;}if("string"!=typeof e)return 0===e?e:+e;e=t(e);var o=l.test(e);return o||s.test(e)?c(e.slice(2),o?2:8):i.test(e)?NaN:+e};},9655:(e,r,o)=>{var t=o(681),n=o(5531);e.exports=function(e){return t(e,n(e))};},6478:(e,r,o)=>{var t=o(2205);e.exports=function(e){return null==e?"":t(e)};},9120:(e,r,o)=>{var t=o(2205),n=o(4482),a=o(7477),i=o(7032),l=o(1656),s=o(8441),c=o(6478);e.exports=function(e,r,o){if((e=c(e))&&(o||void 0===r))return n(e);if(!e||!(r=t(r)))return e;var d=s(e),u=s(r),f=l(d,u),g=i(d,u)+1;return a(d,f,g).join("")};},8857:(e,r,o)=>{var t=o(4777),n=o(8386),a=o(8168),i=o(6778),l=n((function(e){return a(t(e,1,i,!0))}));e.exports=l;},9899:(e,r,o)=>{var t=o(8168);e.exports=function(e){return e&&e.length?t(e):[]};},1764:(e,r,o)=>{var t=o(6478),n=0;e.exports=function(e){var r=++n;return t(e)+r};},2948:(e,r,o)=>{var t=o(457),n=o(5211);e.exports=function(e){return null==e?[]:t(e,n(e))};},6256:(e,r,o)=>{var t=o(6112);function n(){}function a(){}a.resetWarningCache=n,e.exports=function(){function e(e,r,o,n,a,i){if(i!==t){var l=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw l.name="Invariant Violation",l}}function r(){return e}e.isRequired=e;var o={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:r,element:e,elementType:e,instanceOf:r,node:e,objectOf:r,oneOf:r,oneOfType:r,shape:r,exact:r,checkPropTypes:a,resetWarningCache:n};return o.PropTypes=o,o};},7094:(e,r,o)=>{e.exports=o(6256)();},6112:e=>{e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";},5846:(e,r)=>{var o="function"==typeof Symbol&&Symbol.for,t=o?Symbol.for("react.element"):60103,n=o?Symbol.for("react.portal"):60106,a=o?Symbol.for("react.fragment"):60107,i=o?Symbol.for("react.strict_mode"):60108,l=o?Symbol.for("react.profiler"):60114,s=o?Symbol.for("react.provider"):60109,c=o?Symbol.for("react.context"):60110,d=o?Symbol.for("react.async_mode"):60111,u=o?Symbol.for("react.concurrent_mode"):60111,f=o?Symbol.for("react.forward_ref"):60112,g=o?Symbol.for("react.suspense"):60113,p=o?Symbol.for("react.suspense_list"):60120,b=o?Symbol.for("react.memo"):60115,m=o?Symbol.for("react.lazy"):60116,h=o?Symbol.for("react.block"):60121,v=o?Symbol.for("react.fundamental"):60117,y=o?Symbol.for("react.responder"):60118,C=o?Symbol.for("react.scope"):60119;function k(e){if("object"==typeof e&&null!==e){var r=e.$$typeof;switch(r){case t:switch(e=e.type){case d:case u:case a:case l:case i:case g:return e;default:switch(e=e&&e.$$typeof){case c:case f:case m:case b:case s:return e;default:return r}}case n:return r}}}r.isForwardRef=function(e){return k(e)===f},r.isValidElementType=function(e){return "string"==typeof e||"function"==typeof e||e===a||e===u||e===l||e===i||e===g||e===p||"object"==typeof e&&null!==e&&(e.$$typeof===m||e.$$typeof===b||e.$$typeof===s||e.$$typeof===c||e.$$typeof===f||e.$$typeof===v||e.$$typeof===y||e.$$typeof===C||e.$$typeof===h)};},8286:(e,r,o)=>{e.exports=o(5846);},6051:(e,r)=>{var o,t,n,a;if("object"==typeof performance&&"function"==typeof performance.now){var i=performance;r.unstable_now=function(){return i.now()};}else {var l=Date,s=l.now();r.unstable_now=function(){return l.now()-s};}if("undefined"==typeof window||"function"!=typeof MessageChannel){var c=null,d=null,u=function(){if(null!==c)try{var e=r.unstable_now();c(!0,e),c=null;}catch(e){throw setTimeout(u,0),e}};o=function(e){null!==c?setTimeout(o,0,e):(c=e,setTimeout(u,0));},t=function(e,r){d=setTimeout(e,r);},n=function(){clearTimeout(d);},r.unstable_shouldYield=function(){return !1},a=r.unstable_forceFrameRate=function(){};}else {var f=window.setTimeout,g=window.clearTimeout;if("undefined"!=typeof console){var p=window.cancelAnimationFrame;"function"!=typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!=typeof p&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");}var b=!1,m=null,h=-1,v=5,y=0;r.unstable_shouldYield=function(){return r.unstable_now()>=y},a=function(){},r.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):v=0<e?Math.floor(1e3/e):5;};var C=new MessageChannel,k=C.port2;C.port1.onmessage=function(){if(null!==m){var e=r.unstable_now();y=e+v;try{m(!0,e)?k.postMessage(null):(b=!1,m=null);}catch(e){throw k.postMessage(null),e}}else b=!1;},o=function(e){m=e,b||(b=!0,k.postMessage(null));},t=function(e,o){h=f((function(){e(r.unstable_now());}),o);},n=function(){g(h),h=-1;};}function w(e,r){var o=e.length;e.push(r);e:for(;;){var t=o-1>>>1,n=e[t];if(!(void 0!==n&&0<B(n,r)))break e;e[t]=r,e[o]=n,o=t;}}function x(e){return void 0===(e=e[0])?null:e}function S(e){var r=e[0];if(void 0!==r){var o=e.pop();if(o!==r){e[0]=o;e:for(var t=0,n=e.length;t<n;){var a=2*(t+1)-1,i=e[a],l=a+1,s=e[l];if(void 0!==i&&0>B(i,o))void 0!==s&&0>B(s,i)?(e[t]=s,e[l]=o,t=l):(e[t]=i,e[a]=o,t=a);else {if(!(void 0!==s&&0>B(s,o)))break e;e[t]=s,e[l]=o,t=l;}}}return r}return null}function B(e,r){var o=e.sortIndex-r.sortIndex;return 0!==o?o:e.id-r.id}var E=[],O=[],F=1,A=null,P=3,j=!1,R=!1,I=!1;function M(e){for(var r=x(O);null!==r;){if(null===r.callback)S(O);else {if(!(r.startTime<=e))break;S(O),r.sortIndex=r.expirationTime,w(E,r);}r=x(O);}}function D(e){if(I=!1,M(e),!R)if(null!==x(E))R=!0,o(z);else {var r=x(O);null!==r&&t(D,r.startTime-e);}}function z(e,o){R=!1,I&&(I=!1,n()),j=!0;var a=P;try{for(M(o),A=x(E);null!==A&&(!(A.expirationTime>o)||e&&!r.unstable_shouldYield());){var i=A.callback;if("function"==typeof i){A.callback=null,P=A.priorityLevel;var l=i(A.expirationTime<=o);o=r.unstable_now(),"function"==typeof l?A.callback=l:A===x(E)&&S(E),M(o);}else S(E);A=x(E);}if(null!==A)var s=!0;else {var c=x(O);null!==c&&t(D,c.startTime-o),s=!1;}return s}finally{A=null,P=a,j=!1;}}var _=a;r.unstable_IdlePriority=5,r.unstable_ImmediatePriority=1,r.unstable_LowPriority=4,r.unstable_NormalPriority=3,r.unstable_Profiling=null,r.unstable_UserBlockingPriority=2,r.unstable_cancelCallback=function(e){e.callback=null;},r.unstable_continueExecution=function(){R||j||(R=!0,o(z));},r.unstable_getCurrentPriorityLevel=function(){return P},r.unstable_getFirstCallbackNode=function(){return x(E)},r.unstable_next=function(e){switch(P){case 1:case 2:case 3:var r=3;break;default:r=P;}var o=P;P=r;try{return e()}finally{P=o;}},r.unstable_pauseExecution=function(){},r.unstable_requestPaint=_,r.unstable_runWithPriority=function(e,r){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3;}var o=P;P=e;try{return r()}finally{P=o;}},r.unstable_scheduleCallback=function(e,a,i){var l=r.unstable_now();switch(i="object"==typeof i&&null!==i&&"number"==typeof(i=i.delay)&&0<i?l+i:l,e){case 1:var s=-1;break;case 2:s=250;break;case 5:s=1073741823;break;case 4:s=1e4;break;default:s=5e3;}return e={id:F++,callback:a,priorityLevel:e,startTime:i,expirationTime:s=i+s,sortIndex:-1},i>l?(e.sortIndex=i,w(O,e),null===x(E)&&e===x(O)&&(I?n():I=!0,t(D,i-l))):(e.sortIndex=s,w(E,e),R||j||(R=!0,o(z))),e},r.unstable_wrapCallback=function(e){var r=P;return function(){var o=P;P=r;try{return e.apply(this,arguments)}finally{P=o;}}};},2279:(e,r,o)=>{e.exports=o(6051);},1685:e=>{e.exports=function e(r){var o=/^\0+/g,t=/[\0\r\f]/g,n=/: */g,a=/zoo|gra/,i=/([,: ])(transform)/g,l=/,+\s*(?![^(]*[)])/g,s=/ +\s*(?![^(]*[)])/g,c=/ *[\0] */g,d=/,\r+?/g,u=/([\t\r\n ])*\f?&/g,f=/:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g,g=/\W+/g,p=/@(k\w+)\s*(\S*)\s*/,b=/::(place)/g,m=/:(read-only)/g,h=/\s+(?=[{\];=:>])/g,v=/([[}=:>])\s+/g,y=/(\{[^{]+?);(?=\})/g,C=/\s{2,}/g,k=/([^\(])(:+) */g,w=/[svh]\w+-[tblr]{2}/,x=/\(\s*(.*)\s*\)/g,S=/([\s\S]*?);/g,B=/-self|flex-/g,E=/[^]*?(:[rp][el]a[\w-]+)[^]*/,O=/stretch|:\s*\w+\-(?:conte|avail)/,F=/([^-])(image-set\()/,A="-webkit-",P="-moz-",j="-ms-",R=59,I=125,M=123,D=40,z=41,_=91,H=93,T=10,W=13,L=9,N=64,U=32,Z=38,V=45,G=95,X=42,Y=44,$=58,K=39,q=34,J=47,Q=62,ee=43,re=126,oe=0,te=12,ne=11,ae=107,ie=109,le=115,se=112,ce=111,de=105,ue=99,fe=100,ge=112,pe=1,be=1,me=0,he=1,ve=1,ye=1,Ce=0,ke=0,we=0,xe=[],Se=[],Be=0,Ee=null,Oe=-2,Fe=-1,Ae=0,Pe=1,je=2,Re=3,Ie=0,Me=1,De="",ze="",_e="";function He(e,r,n,a,i){for(var l,s,d=0,u=0,f=0,g=0,h=0,v=0,y=0,C=0,w=0,S=0,B=0,E=0,O=0,F=0,G=0,Ce=0,Se=0,Ee=0,Oe=0,Fe=n.length,We=Fe-1,Ge="",Xe="",Ye="",$e="",Ke="",qe="";G<Fe;){if(y=n.charCodeAt(G),G===We&&u+g+f+d!==0&&(0!==u&&(y=u===J?T:J),g=f=d=0,Fe++,We++),u+g+f+d===0){if(G===We&&(Ce>0&&(Xe=Xe.replace(t,"")),Xe.trim().length>0)){switch(y){case U:case L:case R:case W:case T:break;default:Xe+=n.charAt(G);}y=R;}if(1===Se)switch(y){case M:case I:case R:case q:case K:case D:case z:case Y:Se=0;case L:case W:case T:case U:break;default:for(Se=0,Oe=G,h=y,G--,y=R;Oe<Fe;)switch(n.charCodeAt(Oe++)){case T:case W:case R:++G,y=h,Oe=Fe;break;case $:Ce>0&&(++G,y=h);case M:Oe=Fe;}}switch(y){case M:for(h=(Xe=Xe.trim()).charCodeAt(0),B=1,Oe=++G;G<Fe;){switch(y=n.charCodeAt(G)){case M:B++;break;case I:B--;break;case J:switch(v=n.charCodeAt(G+1)){case X:case J:G=Ve(v,G,We,n);}break;case _:y++;case D:y++;case q:case K:for(;G++<We&&n.charCodeAt(G)!==y;);}if(0===B)break;G++;}if(Ye=n.substring(Oe,G),h===oe&&(h=(Xe=Xe.replace(o,"").trim()).charCodeAt(0)),h===N){switch(Ce>0&&(Xe=Xe.replace(t,"")),v=Xe.charCodeAt(1)){case fe:case ie:case le:case V:l=r;break;default:l=xe;}if(Oe=(Ye=He(r,l,Ye,v,i+1)).length,we>0&&0===Oe&&(Oe=Xe.length),Be>0&&(l=Te(xe,Xe,Ee),s=Ze(Re,Ye,l,r,be,pe,Oe,v,i,a),Xe=l.join(""),void 0!==s&&0===(Oe=(Ye=s.trim()).length)&&(v=0,Ye="")),Oe>0)switch(v){case le:Xe=Xe.replace(x,Ue);case fe:case ie:case V:Ye=Xe+"{"+Ye+"}";break;case ae:Ye=(Xe=Xe.replace(p,"$1 $2"+(Me>0?De:"")))+"{"+Ye+"}",Ye=1===ve||2===ve&&Ne("@"+Ye,3)?"@"+A+Ye+"@"+Ye:"@"+Ye;break;default:Ye=Xe+Ye,a===ge&&($e+=Ye,Ye="");}else Ye="";}else Ye=He(r,Te(r,Xe,Ee),Ye,a,i+1);Ke+=Ye,E=0,Se=0,F=0,Ce=0,Ee=0,O=0,Xe="",Ye="",y=n.charCodeAt(++G);break;case I:case R:if((Oe=(Xe=(Ce>0?Xe.replace(t,""):Xe).trim()).length)>1)switch(0===F&&((h=Xe.charCodeAt(0))===V||h>96&&h<123)&&(Oe=(Xe=Xe.replace(" ",":")).length),Be>0&&void 0!==(s=Ze(Pe,Xe,r,e,be,pe,$e.length,a,i,a))&&0===(Oe=(Xe=s.trim()).length)&&(Xe="\0\0"),h=Xe.charCodeAt(0),v=Xe.charCodeAt(1),h){case oe:break;case N:if(v===de||v===ue){qe+=Xe+n.charAt(G);break}default:if(Xe.charCodeAt(Oe-1)===$)break;$e+=Le(Xe,h,v,Xe.charCodeAt(2));}E=0,Se=0,F=0,Ce=0,Ee=0,Xe="",y=n.charCodeAt(++G);}}switch(y){case W:case T:if(u+g+f+d+ke===0)switch(S){case z:case K:case q:case N:case re:case Q:case X:case ee:case J:case V:case $:case Y:case R:case M:case I:break;default:F>0&&(Se=1);}u===J?u=0:he+E===0&&a!==ae&&Xe.length>0&&(Ce=1,Xe+="\0"),Be*Ie>0&&Ze(Ae,Xe,r,e,be,pe,$e.length,a,i,a),pe=1,be++;break;case R:case I:if(u+g+f+d===0){pe++;break}default:switch(pe++,Ge=n.charAt(G),y){case L:case U:if(g+d+u===0)switch(C){case Y:case $:case L:case U:Ge="";break;default:y!==U&&(Ge=" ");}break;case oe:Ge="\\0";break;case te:Ge="\\f";break;case ne:Ge="\\v";break;case Z:g+u+d===0&&he>0&&(Ee=1,Ce=1,Ge="\f"+Ge);break;case 108:if(g+u+d+me===0&&F>0)switch(G-F){case 2:C===se&&n.charCodeAt(G-3)===$&&(me=C);case 8:w===ce&&(me=w);}break;case $:g+u+d===0&&(F=G);break;case Y:u+f+g+d===0&&(Ce=1,Ge+="\r");break;case q:case K:0===u&&(g=g===y?0:0===g?y:g);break;case _:g+u+f===0&&d++;break;case H:g+u+f===0&&d--;break;case z:g+u+d===0&&f--;break;case D:g+u+d===0&&(0===E&&(2*C+3*w==533||(B=0,E=1)),f++);break;case N:u+f+g+d+F+O===0&&(O=1);break;case X:case J:if(g+d+f>0)break;switch(u){case 0:switch(2*y+3*n.charCodeAt(G+1)){case 235:u=J;break;case 220:Oe=G,u=X;}break;case X:y===J&&C===X&&Oe+2!==G&&(33===n.charCodeAt(Oe+2)&&($e+=n.substring(Oe,G+1)),Ge="",u=0);}}if(0===u){if(he+g+d+O===0&&a!==ae&&y!==R)switch(y){case Y:case re:case Q:case ee:case z:case D:if(0===E){switch(C){case L:case U:case T:case W:Ge+="\0";break;default:Ge="\0"+Ge+(y===Y?"":"\0");}Ce=1;}else switch(y){case D:F+7===G&&108===C&&(F=0),E=++B;break;case z:0==(E=--B)&&(Ce=1,Ge+="\0");}break;case L:case U:switch(C){case oe:case M:case I:case R:case Y:case te:case L:case U:case T:case W:break;default:0===E&&(Ce=1,Ge+="\0");}}Xe+=Ge,y!==U&&y!==L&&(S=y);}}w=C,C=y,G++;}if(Oe=$e.length,we>0&&0===Oe&&0===Ke.length&&0===r[0].length==0&&(a!==ie||1===r.length&&(he>0?ze:_e)===r[0])&&(Oe=r.join(",").length+2),Oe>0){if(l=0===he&&a!==ae?function(e){for(var r,o,n=0,a=e.length,i=Array(a);n<a;++n){for(var l=e[n].split(c),s="",d=0,u=0,f=0,g=0,p=l.length;d<p;++d)if(!(0===(u=(o=l[d]).length)&&p>1)){if(f=s.charCodeAt(s.length-1),g=o.charCodeAt(0),r="",0!==d)switch(f){case X:case re:case Q:case ee:case U:case D:break;default:r=" ";}switch(g){case Z:o=r+ze;case re:case Q:case ee:case U:case z:case D:break;case _:o=r+o+ze;break;case $:switch(2*o.charCodeAt(1)+3*o.charCodeAt(2)){case 530:if(ye>0){o=r+o.substring(8,u-1);break}default:(d<1||l[d-1].length<1)&&(o=r+ze+o);}break;case Y:r="";default:o=u>1&&o.indexOf(":")>0?r+o.replace(k,"$1"+ze+"$2"):r+o+ze;}s+=o;}i[n]=s.replace(t,"").trim();}return i}(r):r,Be>0&&void 0!==(s=Ze(je,$e,l,e,be,pe,Oe,a,i,a))&&0===($e=s).length)return qe+$e+Ke;if($e=l.join(",")+"{"+$e+"}",ve*me!=0){switch(2!==ve||Ne($e,2)||(me=0),me){case ce:$e=$e.replace(m,":"+P+"$1")+$e;break;case se:$e=$e.replace(b,"::"+A+"input-$1")+$e.replace(b,"::"+P+"$1")+$e.replace(b,":"+j+"input-$1")+$e;}me=0;}}return qe+$e+Ke}function Te(e,r,o){var t=r.trim().split(d),n=t,a=t.length,i=e.length;switch(i){case 0:case 1:for(var l=0,s=0===i?"":e[0]+" ";l<a;++l)n[l]=We(s,n[l],o,i).trim();break;default:l=0;var c=0;for(n=[];l<a;++l)for(var u=0;u<i;++u)n[c++]=We(e[u]+" ",t[l],o,i).trim();}return n}function We(e,r,o,t){var n=r,a=n.charCodeAt(0);switch(a<33&&(a=(n=n.trim()).charCodeAt(0)),a){case Z:switch(he+t){case 0:case 1:if(0===e.trim().length)break;default:return n.replace(u,"$1"+e.trim())}break;case $:if(103!==n.charCodeAt(1))return e.trim()+n.replace(u,"$1"+e.trim());if(ye>0&&he>0)return n.replace(f,"$1").replace(u,"$1"+_e);default:if(o*he>0&&n.indexOf("\f")>0)return n.replace(u,(e.charCodeAt(0)===$?"":"$1")+e.trim())}return e+n}function Le(e,r,o,t){var c,d=0,u=e+";",f=2*r+3*o+4*t;if(944===f)return function(e){var r=e.length,o=e.indexOf(":",9)+1,t=e.substring(0,o).trim(),n=e.substring(o,r-1).trim();switch(e.charCodeAt(9)*Me){case 0:break;case V:if(110!==e.charCodeAt(10))break;default:var a=n.split((n="",l)),i=0;for(o=0,r=a.length;i<r;o=0,++i){for(var c=a[i],d=c.split(s);c=d[o];){var u=c.charCodeAt(0);if(1===Me&&(u>N&&u<90||u>96&&u<123||u===G||u===V&&c.charCodeAt(1)!==V)&&isNaN(parseFloat(c))+(-1!==c.indexOf("("))===1)switch(c){case"infinite":case"alternate":case"backwards":case"running":case"normal":case"forwards":case"both":case"none":case"linear":case"ease":case"ease-in":case"ease-out":case"ease-in-out":case"paused":case"reverse":case"alternate-reverse":case"inherit":case"initial":case"unset":case"step-start":case"step-end":break;default:c+=De;}d[o++]=c;}n+=(0===i?"":",")+d.join(" ");}}return n=t+n+";",1===ve||2===ve&&Ne(n,1)?A+n+n:n}(u);if(0===ve||2===ve&&!Ne(u,1))return u;switch(f){case 1015:return 97===u.charCodeAt(10)?A+u+u:u;case 951:return 116===u.charCodeAt(3)?A+u+u:u;case 963:return 110===u.charCodeAt(5)?A+u+u:u;case 1009:if(100!==u.charCodeAt(4))break;case 969:case 942:return A+u+u;case 978:return A+u+P+u+u;case 1019:case 983:return A+u+P+u+j+u+u;case 883:return u.charCodeAt(8)===V?A+u+u:u.indexOf("image-set(",11)>0?u.replace(F,"$1"+A+"$2")+u:u;case 932:if(u.charCodeAt(4)===V)switch(u.charCodeAt(5)){case 103:return A+"box-"+u.replace("-grow","")+A+u+j+u.replace("grow","positive")+u;case 115:return A+u+j+u.replace("shrink","negative")+u;case 98:return A+u+j+u.replace("basis","preferred-size")+u}return A+u+j+u+u;case 964:return A+u+j+"flex-"+u+u;case 1023:if(99!==u.charCodeAt(8))break;return c=u.substring(u.indexOf(":",15)).replace("flex-","").replace("space-between","justify"),A+"box-pack"+c+A+u+j+"flex-pack"+c+u;case 1005:return a.test(u)?u.replace(n,":"+A)+u.replace(n,":"+P)+u:u;case 1e3:switch(d=(c=u.substring(13).trim()).indexOf("-")+1,c.charCodeAt(0)+c.charCodeAt(d)){case 226:c=u.replace(w,"tb");break;case 232:c=u.replace(w,"tb-rl");break;case 220:c=u.replace(w,"lr");break;default:return u}return A+u+j+c+u;case 1017:if(-1===u.indexOf("sticky",9))return u;case 975:switch(d=(u=e).length-10,f=(c=(33===u.charCodeAt(d)?u.substring(0,d):u).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|c.charCodeAt(7))){case 203:if(c.charCodeAt(8)<111)break;case 115:u=u.replace(c,A+c)+";"+u;break;case 207:case 102:u=u.replace(c,A+(f>102?"inline-":"")+"box")+";"+u.replace(c,A+c)+";"+u.replace(c,j+c+"box")+";"+u;}return u+";";case 938:if(u.charCodeAt(5)===V)switch(u.charCodeAt(6)){case 105:return c=u.replace("-items",""),A+u+A+"box-"+c+j+"flex-"+c+u;case 115:return A+u+j+"flex-item-"+u.replace(B,"")+u;default:return A+u+j+"flex-line-pack"+u.replace("align-content","").replace(B,"")+u}break;case 973:case 989:if(u.charCodeAt(3)!==V||122===u.charCodeAt(4))break;case 931:case 953:if(!0===O.test(e))return 115===(c=e.substring(e.indexOf(":")+1)).charCodeAt(0)?Le(e.replace("stretch","fill-available"),r,o,t).replace(":fill-available",":stretch"):u.replace(c,A+c)+u.replace(c,P+c.replace("fill-",""))+u;break;case 962:if(u=A+u+(102===u.charCodeAt(5)?j+u:"")+u,o+t===211&&105===u.charCodeAt(13)&&u.indexOf("transform",10)>0)return u.substring(0,u.indexOf(";",27)+1).replace(i,"$1"+A+"$2")+u}return u}function Ne(e,r){var o=e.indexOf(1===r?":":"{"),t=e.substring(0,3!==r?o:10),n=e.substring(o+1,e.length-1);return Ee(2!==r?t:t.replace(E,"$1"),n,r)}function Ue(e,r){var o=Le(r,r.charCodeAt(0),r.charCodeAt(1),r.charCodeAt(2));return o!==r+";"?o.replace(S," or ($1)").substring(4):"("+r+")"}function Ze(e,r,o,t,n,a,i,l,s,c){for(var d,u=0,f=r;u<Be;++u)switch(d=Se[u].call(Xe,e,f,o,t,n,a,i,l,s,c)){case void 0:case!1:case!0:case null:break;default:f=d;}if(f!==r)return f}function Ve(e,r,o,t){for(var n=r+1;n<o;++n)switch(t.charCodeAt(n)){case J:if(e===X&&t.charCodeAt(n-1)===X&&r+2!==n)return n+1;break;case T:if(e===J)return n+1}return n}function Ge(e){for(var r in e){var o=e[r];switch(r){case"keyframe":Me=0|o;break;case"global":ye=0|o;break;case"cascade":he=0|o;break;case"compress":Ce=0|o;break;case"semicolon":ke=0|o;break;case"preserve":we=0|o;break;case"prefix":Ee=null,o?"function"!=typeof o?ve=1:(ve=2,Ee=o):ve=0;}}return Ge}function Xe(r,o){if(void 0!==this&&this.constructor===Xe)return e(r);var n=r,a=n.charCodeAt(0);a<33&&(a=(n=n.trim()).charCodeAt(0)),Me>0&&(De=n.replace(g,a===_?"":"-")),a=1,1===he?_e=n:ze=n;var i,l=[_e];Be>0&&void 0!==(i=Ze(Fe,o,l,l,be,pe,0,0,0,0))&&"string"==typeof i&&(o=i);var s=He(xe,l,o,0,0);return Be>0&&void 0!==(i=Ze(Oe,s,l,l,be,pe,s.length,0,0,0))&&"string"!=typeof(s=i)&&(a=0),De="",_e="",ze="",me=0,be=1,pe=1,Ce*a==0?s:function(e){return e.replace(t,"").replace(h,"").replace(v,"$1").replace(y,"$1").replace(C," ")}(s)}return Xe.use=function e(r){switch(r){case void 0:case null:Be=Se.length=0;break;default:if("function"==typeof r)Se[Be++]=r;else if("object"==typeof r)for(var o=0,t=r.length;o<t;++o)e(r[o]);else Ie=0|!!r;}return e},Xe.set=Ge,void 0!==r&&Ge(r),Xe}(null);}},t={};function n(e){var r=t[e];if(void 0!==r)return r.exports;var a=t[e]={id:e,loaded:!1,exports:{}};return o[e](a,a.exports,n),a.loaded=!0,a.exports}n.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return n.d(r,{a:r}),r},n.d=(e,r)=>{for(var o in r)n.o(r,o)&&!n.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]});},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var a={};(()=>{n.d(a,{en:()=>$a,kC:()=>An,zt:()=>hs,Rl:()=>qo,xv:()=>Ta,y0:()=>Y,It:()=>$,$v:()=>xb});var o={};n.r(o),n.d(o,{bodyBackground:()=>Ac,bodyColor:()=>Pc,bodyFontFamily:()=>Oc,bodyFontSize:()=>Fc,bodyLineHeight:()=>jc,bodyMargin:()=>Ec,bodyPadding:()=>Bc,borderRadiusMedium:()=>Ks,borderRadiusSmall:()=>$s,borderRadiusXLarge:()=>qs,borderWidth:()=>Ys,categoryColorScheme:()=>Xs,categoryColors:()=>Vs,colorScheme:()=>Ls,colors:()=>Ts,contextualColors:()=>Ms,focusInnerBorderColor:()=>Js,focusOuterBorderColor:()=>Qs,fontSizes:()=>uc,fontWeightBold:()=>mc,fontWeightLight:()=>fc,fontWeightRegular:()=>pc,fontWeightSemibold:()=>bc,fontWeightSemilight:()=>gc,lineHeightDefault:()=>hc,lineHeightLarge:()=>kc,lineHeightLarger:()=>wc,lineHeightLargest:()=>xc,lineHeightMedium:()=>Cc,lineHeightSmall:()=>yc,lineHeightSmaller:()=>vc,naturalColors:()=>Ds,primitiveColors:()=>_s,shadow16:()=>sc,shadow2:()=>ac,shadow28:()=>cc,shadow4:()=>ic,shadow64:()=>dc,shadow8:()=>lc,shadowLevel1:()=>ec,shadowLevel1Dark:()=>nc,shadowLevel2:()=>rc,shadowLevel3:()=>oc,shadowLevel4:()=>tc,transparentColors:()=>Hs,zIndexes:()=>Sc});var t={};n.r(t),n.d(t,{Accordion:()=>Rc,AccordionTitle:()=>Rc,Alert:()=>Mc,AlertDismissAction:()=>Mc,Attachment:()=>Ic,AttachmentAction:()=>Ic,AttachmentBody:()=>Ic,AttachmentDescription:()=>Ic,AttachmentHeader:()=>Ic,AttachmentIcon:()=>Ic,Avatar:()=>zc,AvatarIcon:()=>zc,AvatarImage:()=>zc,AvatarLabel:()=>zc,AvatarStatus:()=>zc,AvatarStatusIcon:()=>zc,Breadcrumb:()=>Hc,BreadcrumbDivider:()=>Hc,BreadcrumbItem:()=>Hc,BreadcrumbLink:()=>Hc,Button:()=>_c,ButtonContent:()=>_c,ButtonGroup:()=>_c,Card:()=>eu,CardBody:()=>eu,CardExpandableBox:()=>eu,CardFooter:()=>eu,CardHeader:()=>eu,CardPreview:()=>eu,CardTopControls:()=>eu,Carousel:()=>Kd,CarouselItem:()=>Kd,CarouselNavigation:()=>Jd,CarouselNavigationItem:()=>Jd,CarouselPaddle:()=>Kd,CarouselPaddlesContainer:()=>Kd,Chat:()=>Tc,ChatItem:()=>Wc,ChatMessage:()=>Lc,ChatMessageDetails:()=>Nc,ChatMessageReadStatus:()=>Uc,Checkbox:()=>Xc,Datepicker:()=>ru,DatepickerCalendar:()=>ru,DatepickerCalendarCell:()=>ru,DatepickerCalendarCellButton:()=>ru,DatepickerCalendarGrid:()=>ru,DatepickerCalendarGridRow:()=>ru,DatepickerCalendarHeader:()=>ru,DatepickerCalendarHeaderCell:()=>ru,Dialog:()=>Yc,Divider:()=>od,Dropdown:()=>td,DropdownItem:()=>td,DropdownSearchInput:()=>td,DropdownSelectedItem:()=>td,Embed:()=>nd,Flex:()=>ad,FlexItem:()=>id,Form:()=>ld,FormField:()=>cd,FormFieldCustom:()=>cd,FormLabel:()=>fd,FormMessage:()=>ud,Grid:()=>gd,Header:()=>bd,HeaderDescription:()=>hd,Image:()=>Cd,Input:()=>kd,InputLabel:()=>wd,ItemLayout:()=>Ed,Label:()=>xd,Layout:()=>Sd,ListItem:()=>Od,ListItemContent:()=>Od,ListItemContentMedia:()=>Od,ListItemHeader:()=>Od,ListItemHeaderMedia:()=>Od,ListItemMedia:()=>Od,Loader:()=>Bd,Menu:()=>Ad,MenuDivider:()=>Ad,MenuItem:()=>Ad,MenuItemContent:()=>Ad,MenuItemIcon:()=>Ad,MenuItemIndicator:()=>Ad,MenuItemWrapper:()=>Ad,Pill:()=>Pd,PillAction:()=>Pd,PillContent:()=>Pd,PillIcon:()=>Pd,PillImage:()=>Pd,PopupContent:()=>jd,Provider:()=>Rd,RadioGroupItem:()=>Id,Reaction:()=>Md,ReactionGroup:()=>Dd,Segment:()=>_d,Skeleton:()=>Hd,SkeletonAvatar:()=>Hd,SkeletonButton:()=>Hd,SkeletonInput:()=>Hd,SkeletonLine:()=>Hd,SkeletonShape:()=>Hd,SkeletonText:()=>Hd,Slider:()=>Td,SplitButton:()=>$d,SplitButtonDivider:()=>$d,SplitButtonToggle:()=>$d,Status:()=>Wd,SvgIcon:()=>yd,Table:()=>Qd,TableCell:()=>Qd,TableRow:()=>Qd,Text:()=>Nd,TextArea:()=>Ud,Toolbar:()=>Vd,ToolbarCustomItem:()=>Vd,ToolbarDivider:()=>Vd,ToolbarItem:()=>Vd,ToolbarMenu:()=>Vd,ToolbarMenuDivider:()=>Vd,ToolbarMenuItem:()=>Vd,ToolbarMenuItemActiveIndicator:()=>Vd,ToolbarMenuItemIcon:()=>Vd,ToolbarMenuItemSubmenuIndicator:()=>Vd,ToolbarMenuRadioGroup:()=>Vd,ToolbarMenuRadioGroupWrapper:()=>Vd,TooltipContent:()=>Yd,TreeTitle:()=>Gd,Video:()=>Xd});var i={};n.r(i),n.d(i,{Accordion:()=>ou,AccordionContent:()=>tu,AccordionTitle:()=>nu,Alert:()=>iu,AlertDismissAction:()=>gu,Attachment:()=>bu,AttachmentAction:()=>yu,AttachmentBody:()=>Cu,AttachmentDescription:()=>ku,AttachmentHeader:()=>wu,AttachmentIcon:()=>xu,Avatar:()=>Bu,AvatarIcon:()=>Ru,AvatarImage:()=>Au,AvatarLabel:()=>Mu,AvatarStatus:()=>Ou,AvatarStatusIcon:()=>Fu,Breadcrumb:()=>Nu,BreadcrumbDivider:()=>Wu,BreadcrumbItem:()=>Tu,BreadcrumbLink:()=>Lu,Button:()=>Du,ButtonContent:()=>Hu,ButtonGroup:()=>_u,Card:()=>ib,CardBody:()=>sb,CardExpandableBox:()=>fb,CardFooter:()=>cb,CardHeader:()=>lb,CardPreview:()=>db,CardTopControls:()=>ub,Carousel:()=>Vp,CarouselItem:()=>Gp,CarouselNavigation:()=>Xp,CarouselNavigationItem:()=>Kp,CarouselPaddle:()=>eb,CarouselPaddlesContainer:()=>rb,Chat:()=>Uu,ChatItem:()=>Gu,ChatMessage:()=>qu,ChatMessageDetails:()=>Ju,ChatMessageReadStatus:()=>Qu,Checkbox:()=>af,Datepicker:()=>bb,DatepickerCalendar:()=>mb,DatepickerCalendarCell:()=>yb,DatepickerCalendarCellButton:()=>Cb,DatepickerCalendarGrid:()=>kb,DatepickerCalendarGridRow:()=>wb,DatepickerCalendarHeader:()=>hb,DatepickerCalendarHeaderCell:()=>vb,Dialog:()=>lf,DialogFooter:()=>sf,Divider:()=>df,DividerContent:()=>uf,Dropdown:()=>hf,DropdownItem:()=>Ef,DropdownSearchInput:()=>vf,DropdownSelectedItem:()=>kf,Embed:()=>Af,Flex:()=>Df,FlexItem:()=>zf,Form:()=>Pf,FormField:()=>jf,FormFieldCustom:()=>jf,FormLabel:()=>Rf,FormMessage:()=>If,Grid:()=>Hf,Header:()=>Wf,HeaderDescription:()=>Lf,Image:()=>Zf,Input:()=>Vf,InputLabel:()=>Gf,ItemLayout:()=>rg,Label:()=>Xf,Layout:()=>Jf,List:()=>og,ListItem:()=>ng,ListItemContent:()=>ag,ListItemContentMedia:()=>ig,ListItemEndMedia:()=>lg,ListItemHeader:()=>sg,ListItemHeaderMedia:()=>cg,ListItemMedia:()=>dg,Loader:()=>eg,Menu:()=>ug,MenuButton:()=>Sg,MenuDivider:()=>wg,MenuItem:()=>mg,MenuItemContent:()=>vg,MenuItemIcon:()=>hg,MenuItemIndicator:()=>Cg,MenuItemWrapper:()=>kg,Pill:()=>Bg,PillAction:()=>Og,PillContent:()=>Eg,PillGroup:()=>Pg,PillIcon:()=>Ag,PillImage:()=>Fg,PopupContent:()=>Ig,Provider:()=>Mg,RadioGroup:()=>Dg,RadioGroupItem:()=>Tg,Reaction:()=>cp,ReactionGroup:()=>dp,Segment:()=>Wg,Skeleton:()=>Kg,SkeletonAvatar:()=>op,SkeletonButton:()=>Qg,SkeletonInput:()=>rp,SkeletonLine:()=>qg,SkeletonShape:()=>Jg,SkeletonText:()=>ep,Slider:()=>lp,SplitButton:()=>bp,SplitButtonDivider:()=>yp,SplitButtonToggle:()=>vp,Status:()=>pp,SvgIcon:()=>Uf,Table:()=>ob,TableCell:()=>nb,TableRow:()=>tb,Text:()=>Cp,TextArea:()=>kp,Toolbar:()=>wp,ToolbarCustomItem:()=>Sp,ToolbarDivider:()=>Bp,ToolbarItem:()=>Ep,ToolbarMenu:()=>Op,ToolbarMenuDivider:()=>Fp,ToolbarMenuItem:()=>Rp,ToolbarMenuItemActiveIndicator:()=>Dp,ToolbarMenuItemIcon:()=>Ip,ToolbarMenuItemSubmenuIndicator:()=>Mp,ToolbarMenuRadioGroup:()=>zp,ToolbarMenuRadioGroupWrapper:()=>_p,ToolbarRadioGroup:()=>xp,TooltipContent:()=>Zp,Tree:()=>Hp,TreeItem:()=>Lp,TreeTitle:()=>Np,Video:()=>Up});var l=n(6601),s=n.n(l),c={3:"Cancel",6:"Help",8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",28:"Convert",29:"NonConvert",30:"Accept",31:"ModeChange",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",41:"Select",42:"Print",43:"Execute",44:"PrintScreen",45:"Insert",46:"Delete",48:["0",")"],49:["1","!"],50:["2","@"],51:["3","#"],52:["4","$"],53:["5","%"],54:["6","^"],55:["7","&"],56:["8","*"],57:["9","("],65:["a","A"],66:["b","B"],67:["c","C"],68:["d","D"],69:["e","E"],70:["f","F"],71:["g","G"],72:["h","H"],73:["i","I"],74:["j","J"],75:["k","K"],76:["l","L"],77:["m","M"],78:["n","N"],79:["o","O"],80:["p","P"],81:["q","Q"],82:["r","R"],83:["s","S"],84:["t","T"],85:["u","U"],86:["v","V"],87:["w","W"],88:["x","X"],89:["y","Y"],90:["z","Z"],91:"OS",93:"ContextMenu",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",124:"F13",125:"F14",126:"F15",127:"F16",128:"F17",129:"F18",130:"F19",131:"F20",132:"F21",133:"F22",134:"F23",135:"F24",144:"NumLock",145:"ScrollLock",181:"VolumeMute",182:"VolumeDown",183:"VolumeUp",186:[";",":"],187:["=","+"],188:[",","<"],189:["-","_"],190:[".",">"],191:["/","?"],192:["`","~"],219:["[","{"],220:["\\","|"],221:["]","}"],222:["'",'"'],224:"Meta",225:"AltGraph",246:"Attn",247:"CrSel",248:"ExSel",249:"EraseEof",250:"Play",251:"ZoomOut"},d=function(e){return null!==e&&!Array.isArray(e)&&"object"==typeof e};function u(e){return d(e)?e.keyCode||e.which||f[e.key]:f[e]}var f={};for(var g in c)if(c.hasOwnProperty(g)){var p=c[g];if("string"==typeof p)f[p]=Number(g);else for(var b=0;b<p.length;b++)f[p[b]]=Number(g);}var m,h,v=f[" "],y=("data-is-focusable");!function(e){e[e.none=0]="none",e[e.all=1]="all",e[e.inputOnly=2]="inputOnly";}(m||(m={})),function(e){e[e.vertical=0]="vertical",e[e.horizontal=1]="horizontal",e[e.bidirectional=2]="bidirectional",e[e.bidirectionalDomOrder=3]="bidirectionalDomOrder";}(h||(h={}));var C=function(e){var r;return {attributes:{root:Object.assign((r={},r[y]=!0,r.tabIndex=-1,r),e.hasActionMenu&&!e.inlineActionMenu&&{"aria-owns":e.actionMenuId})},focusZone:{props:{handleTabKey:m.all,isCircularNavigation:!0,direction:h.vertical,pagingSupportDisabled:!0}},keyActions:{root:{preventDefault:{keyCombinations:[{keyCode:f.ArrowUp},{keyCode:f.ArrowDown}]},focus:{keyCombinations:[{keyCode:f.Escape}]}}}}},k="chat-focuszone",w=function(){var e;return {attributes:{root:{}},focusZone:{props:(e={shouldEnterInnerZone:function(e){return u(e)===f.Enter},direction:h.vertical,shouldResetActiveElementWhenTabFromZone:!0,defaultTabbableElement:x},e[k]="",e.pagingSupportDisabled=!0,e)},childBehaviors:{item:void 0,message:C}}},x=function(e){var r=e.querySelector('[data-last-visible="true"]');if(r)return r;var o=e.querySelectorAll("["+k+"] .ui-chat__message["+y+'="true"]');return o.length>0?o[o.length-1]:null};const S=(B={Children:()=>React__namespace.Children,Component:()=>React__namespace.Component,Fragment:()=>React__namespace.Fragment,cloneElement:()=>React__namespace.cloneElement,createContext:()=>React__namespace.createContext,createElement:()=>React__namespace.createElement,forwardRef:()=>React__namespace.forwardRef,isValidElement:()=>React__namespace.isValidElement,useCallback:()=>React__namespace.useCallback,useContext:()=>React__namespace.useContext,useEffect:()=>React__namespace.useEffect,useImperativeHandle:()=>React__namespace.useImperativeHandle,useLayoutEffect:()=>React__namespace.useLayoutEffect,useMemo:()=>React__namespace.useMemo,useReducer:()=>React__namespace.useReducer,useRef:()=>React__namespace.useRef,useState:()=>React__namespace.useState},E={},n.d(E,B),E);var B,E,O={registerUsage:function(){},unregisterUsage:function(){},renderFont:function(){},renderGlobal:function(){},renderRule:function(){return ""},Provider:function(e){return S.createElement(S.Fragment,null,e.children)}},F=n(3296),A=n.n(F),P=n(5211),j=n.n(P),R=n(8857),I=n.n(R),M=n(6186),D=n.n(M),z=function(e){return function(){return "function"==typeof e?e.apply(void 0,arguments):e}},_=function(e){return null!==e&&"object"==typeof e&&!Array.isArray(e)},H=function(){for(var e=function e(r,o){return Object.keys(o).forEach((function(t){(function(e){return "__proto__"!==e&&"prototype"!==e&&"constructor"!==e})(t)&&(_(o[t])?(_(r[t])||(r[t]={}),e(r[t],o[t])):r[t]=o[t]);})),r},r=arguments.length,o=new Array(r),t=0;t<r;t++)o[t]=arguments[t];return o.filter(Boolean).reduce((function(r,o){return e(r,o)}),{})},T=function(){var e;return (e=[]).concat.apply(e,arguments).filter(Boolean)},W=function(e,r){return e},L={siteVariables:{fontSizes:{}},componentVariables:{},componentStyles:{},fontFaces:[],staticStyles:[],animations:{}},N=function(e,r){var o={};return e&&Object.keys(e).forEach((function(t){var n=e[t],a=null==r?void 0:r[t];null!=n&&(null!=a?n===a&&(o[t]="function"==typeof n?n:function(){return n}):o[t]="function"==typeof n?n:function(){return n});})),r&&Object.keys(r).forEach((function(t){var n=null==e?void 0:e[t],a=r[t];null!=a&&(null!=n?n!==a&&(o[t]=function(e){return D()("function"==typeof n?n(e):n,"function"==typeof a?a(e):a)}):o[t]="function"==typeof a?a:function(){return a});})),o},U=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];var t=r.filter(Boolean);return 1===t.length?"function"==typeof t[0]?t[0]:z(t[0]):t.reduce((function(e,r){return function(){var o=e.apply(void 0,arguments),t=("function"==typeof r?r:z(r)).apply(void 0,arguments);return H(o,t)}}),(function(){return {}}))},Z=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return H.apply(void 0,[{fontSizes:{}}].concat(r))},V=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return I().apply(void 0,s()(r,j())).reduce((function(e,o){return e[o]=U.apply(void 0,s()(r,o)),e}),{})},G=function(){return T.apply(void 0,arguments)},X=function(){return T.apply(void 0,arguments)},Y=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return function(){for(var e=arguments.length,o=new Array(e),t=0;t<e;t++)o[t]=arguments[t];return r.reduce((function(e,r){return D()(e,z(r).apply(void 0,o))}),{})}},$=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return r.reduce((function(e,r){if(!r)return e;r._debugId;return e.siteVariables=Z(e.siteVariables,W(r.siteVariables)),e.componentVariables=V(e.componentVariables,W(r.componentVariables)),e.componentStyles=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return r.reduce((function(e,r){return A()(r,(function(o,t){e[t]=N(e[t],W(o,r._debugId));})),e}),{})}(e.componentStyles,W(r.componentStyles)),e.fontFaces=G.apply(void 0,e.fontFaces.concat(r.fontFaces||[])),e.staticStyles=X.apply(void 0,e.staticStyles.concat(r.staticStyles||[])),e.animations=function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return Object.assign.apply(Object,[{}].concat(r))}(e.animations,r.animations),e}),Object.assign({},L))},K={rtl:void 0,disableAnimations:!1,performance:{enableSanitizeCssPlugin:!1,enableStylesCaching:!0,enableVariablesCaching:!0,enableBooleanVariablesCaching:!1},renderer:O,theme:L,telemetry:void 0,target:void 0},q=S.createContext(K);function J(){return S.useContext(q)}var Q,ee=q.Provider,re=function(e,r){return function(e,r,o){var t=-1;return {setStart:function(){null!=r&&r.enabled&&(t=performance.now(),r.performance[e]||(r.performance[e]={instances:0,renders:0,msTotal:0,msMin:Number.MAX_SAFE_INTEGER,msMax:0,msResolveVariablesTotal:0,msResolveStylesTotal:0,msRenderStylesTotal:0,stylesRootCacheHits:0,stylesSlotsCacheHits:0}));},setEnd:function(){if(null!=r&&r.enabled&&-1!==t){var n=performance.now()-t;r.performance[e].instances+=Number(o.current),r.performance[e].renders++,r.performance[e].msTotal+=n,r.performance[e].msMin=Math.min(n,r.performance[e].msMin),r.performance[e].msMax=Math.max(n,r.performance[e].msMax),o.current=!1;}}}}(e,r,S.useRef(!0))},oe=function(e,r){return void 0===r||e===r},te=((Q={})[f.ArrowRight]=f.ArrowLeft,Q[f.ArrowLeft]=f.ArrowRight,Q),ne={attributes:{},keyHandlers:{}};function ae(){return ae=Object.assign?Object.assign.bind():function(e){for(var r=1;r<arguments.length;r++){var o=arguments[r];for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&(e[t]=o[t]);}return e},ae.apply(this,arguments)}function ie(e,r){return ie=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,r){return e.__proto__=r,e},ie(e,r)}function le(e,r){e.prototype=Object.create(r.prototype),e.prototype.constructor=e,ie(e,r);}var se=n(3873),ce=n.n(se),de=n(1764),ue=n.n(de),fe=n(583),ge=n.n(fe),pe=n(7094),be=n.n(pe),he=void 0;try{he=window;}catch(e){}function ve(e){if(void 0!==he){var r=e;return r&&r.ownerDocument&&r.ownerDocument.defaultView?r.ownerDocument.defaultView:he}}function ye(e,r){return void 0===r&&(r=!0),e&&(r&&function(e){var r,o;return e&&(o=e)&&o._virtual&&(r=e._virtual.parent),r}(e)||e.parentNode&&e.parentNode)}function Ce(e){if("undefined"!=typeof document){var r=e;return r&&r.ownerDocument?r.ownerDocument:document}}function ke(e,r,o){void 0===o&&(o=!0);var t=!1;if(e&&r)if(o)if(e===r)t=!0;else for(t=!1;r;){var n=ye(r);if(n===e){t=!0;break}r=n;}else e.contains&&(t=e.contains(r));return t}var we,xe=function(){return xe=Object.assign||function(e){for(var r,o=1,t=arguments.length;o<t;o++)for(var n in r=arguments[o])Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n]);return e},xe.apply(this,arguments)},Se="__stylesheet__",Be="undefined"!=typeof navigator&&/rv:11.0/.test(navigator.userAgent),Ee={};try{Ee=window;}catch(Me){}var Oe,Fe=function(){function e(e){this._rules=[],this._preservedRules=[],this._rulesToInsert=[],this._counter=0,this._keyToClassName={},this._onResetCallbacks=[],this._classNameToArgs={},this._config=xe({injectionMode:1,defaultPrefix:"css",namespace:void 0,cspSettings:void 0},e),this._keyToClassName=this._config.classNameCache||{};}return e.getInstance=function(){var r;if(!(we=Ee[Se])||we._lastStyleElement&&we._lastStyleElement.ownerDocument!==document){var o=(null===(r=Ee)||void 0===r?void 0:r.FabricConfig)||{};we=Ee[Se]=new e(o.mergeStyles);}return we},e.prototype.setConfig=function(e){this._config=xe(xe({},this._config),e);},e.prototype.onReset=function(e){this._onResetCallbacks.push(e);},e.prototype.getClassName=function(e){var r=this._config.namespace;return (r?r+"-":"")+(e||this._config.defaultPrefix)+"-"+this._counter++},e.prototype.cacheClassName=function(e,r,o,t){this._keyToClassName[r]=e,this._classNameToArgs[e]={args:o,rules:t};},e.prototype.classNameFromKey=function(e){return this._keyToClassName[e]},e.prototype.getClassNameCache=function(){return this._keyToClassName},e.prototype.argsFromClassName=function(e){var r=this._classNameToArgs[e];return r&&r.args},e.prototype.insertedRulesFromClassName=function(e){var r=this._classNameToArgs[e];return r&&r.rules},e.prototype.insertRule=function(e,r){var o=0!==this._config.injectionMode?this._getStyleElement():void 0;if(r&&this._preservedRules.push(e),o)switch(this._config.injectionMode){case 1:var t=o.sheet;try{t.insertRule(e,t.cssRules.length);}catch(e){}break;case 2:o.appendChild(document.createTextNode(e));}else this._rules.push(e);this._config.onInsertRule&&this._config.onInsertRule(e);},e.prototype.getRules=function(e){return (e?this._preservedRules.join(""):"")+this._rules.join("")+this._rulesToInsert.join("")},e.prototype.reset=function(){this._rules=[],this._rulesToInsert=[],this._counter=0,this._classNameToArgs={},this._keyToClassName={},this._onResetCallbacks.forEach((function(e){return e()}));},e.prototype.resetKeys=function(){this._keyToClassName={};},e.prototype._getStyleElement=function(){var e=this;return this._styleElement||"undefined"==typeof document||(this._styleElement=this._createStyleElement(),Be||window.requestAnimationFrame((function(){e._styleElement=void 0;}))),this._styleElement},e.prototype._createStyleElement=function(){var e=document.head,r=document.createElement("style"),o=null;r.setAttribute("data-merge-styles","true");var t=this._config.cspSettings;if(t&&t.nonce&&r.setAttribute("nonce",t.nonce),this._lastStyleElement)o=this._lastStyleElement.nextElementSibling;else {var n=this._findPlaceholderStyleTag();o=n?n.nextElementSibling:e.childNodes[0];}return e.insertBefore(r,e.contains(o)?o:null),this._lastStyleElement=r,r},e.prototype._findPlaceholderStyleTag=function(){var e=document.head;return e?e.querySelector("style[data-merge-styles]"):null},e}();function Ae(){return void 0===Oe&&(Oe="undefined"!=typeof document&&!!document.documentElement&&"rtl"===document.documentElement.getAttribute("dir")),Oe}Oe=Ae();var Pe,je={},Re={"user-select":1};function Ie(e,r){var o=function(){var e,r;if(!Pe){var o="undefined"!=typeof document?document:void 0,t="undefined"!=typeof navigator?navigator:void 0,n=null===(r=null===(e=t)||void 0===e?void 0:e.userAgent)||void 0===r?void 0:r.toLowerCase();Pe=o?{isWebkit:!(!o||!("WebkitAppearance"in o.documentElement.style)),isMoz:!!(n&&n.indexOf("firefox")>-1),isOpera:!!(n&&n.indexOf("opera")>-1),isMs:!(!t||!/rv:11.0/i.test(t.userAgent)&&!/Edge\/\d./i.test(navigator.userAgent))}:{isWebkit:!0,isMoz:!0,isOpera:!0,isMs:!0};}return Pe}(),t=e[r];if(Re[t]){var n=e[r+1];Re[t]&&(o.isWebkit&&e.push("-webkit-"+t,n),o.isMoz&&e.push("-moz-"+t,n),o.isMs&&e.push("-ms-"+t,n),o.isOpera&&e.push("-o-"+t,n));}}var Me,De=["column-count","font-weight","flex","flex-grow","flex-shrink","fill-opacity","opacity","order","z-index","zoom"];function ze(e,r){var o=e[r],t=e[r+1];if("number"==typeof t){var n=De.indexOf(o)>-1,a=o.indexOf("--")>-1,i=n||a?"":"px";e[r+1]=""+t+i;}}var _e="left",He="right",Te="@noflip",We=((Me={})[_e]=He,Me[He]=_e,Me),Le={"w-resize":"e-resize","sw-resize":"se-resize","nw-resize":"ne-resize"};function Ne(e,r,o){if(e.rtl){var t=r[o];if(!t)return;var n=r[o+1];if("string"==typeof n&&n.indexOf(Te)>=0)r[o+1]=n.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g,"");else if(t.indexOf(_e)>=0)r[o]=t.replace(_e,He);else if(t.indexOf(He)>=0)r[o]=t.replace(He,_e);else if(String(n).indexOf(_e)>=0)r[o+1]=n.replace(_e,He);else if(String(n).indexOf(He)>=0)r[o+1]=n.replace(He,_e);else if(We[t])r[o]=We[t];else if(Le[n])r[o+1]=Le[n];else switch(t){case"margin":case"padding":r[o+1]=function(e){if("string"==typeof e){var r=e.split(" ");if(4===r.length)return r[0]+" "+r[3]+" "+r[2]+" "+r[1]}return e}(n);break;case"box-shadow":r[o+1]=function(e,r){var o=e.split(" "),t=parseInt(o[0],10);return o[0]=o[0].replace(String(t),String(-1*t)),o.join(" ")}(n);}}}var Ue="displayName",Ze=/\:global\((.+?)\)/g;function Ve(e,r){return e.indexOf(":global(")>=0?e.replace(Ze,"$1"):0===e.indexOf(":")?r+e:e.indexOf("&")<0?r+" "+e:e}function Ge(e,r,o,t){void 0===r&&(r={__order:[]}),0===o.indexOf("@")?Xe([t],r,o=o+"{"+e):o.indexOf(",")>-1?function(e){if(!Ze.test(e))return e;for(var r=[],o=/\:global\((.+?)\)/g,t=null;t=o.exec(e);)t[1].indexOf(",")>-1&&r.push([t.index,t.index+t[0].length,t[1].split(",").map((function(e){return ":global("+e.trim()+")"})).join(", ")]);return r.reverse().reduce((function(e,r){var o=r[0],t=r[1],n=r[2];return e.slice(0,o)+n+e.slice(t)}),e)}(o).split(",").map((function(e){return e.trim()})).forEach((function(o){return Xe([t],r,Ve(o,e))})):Xe([t],r,Ve(o,e));}function Xe(e,r,o){void 0===r&&(r={__order:[]}),void 0===o&&(o="&");var t=Fe.getInstance(),n=r[o];n||(n={},r[o]=n,r.__order.push(o));for(var a=0,i=e;a<i.length;a++){var l=i[a];if("string"==typeof l){var s=t.argsFromClassName(l);s&&Xe(s,r,o);}else if(Array.isArray(l))Xe(l,r,o);else for(var c in l)if(l.hasOwnProperty(c)){var d=l[c];if("selectors"===c){var u=l.selectors;for(var f in u)u.hasOwnProperty(f)&&Ge(o,r,f,u[f]);}else "object"==typeof d?null!==d&&Ge(o,r,c,d):void 0!==d&&("margin"===c||"padding"===c?Ye(n,c,d):n[c]=d);}}return r}function Ye(e,r,o){var t="string"==typeof o?o.split(" "):[o];e[r+"Top"]=t[0],e[r+"Right"]=t[1]||t[0],e[r+"Bottom"]=t[2]||t[0],e[r+"Left"]=t[3]||t[1]||t[0];}function $e(e,r){return r<=0?"":1===r?e:e+$e(e,r-1)}function Ke(e,r){if(!r)return "";var o,t,n,a=[];for(var i in r)r.hasOwnProperty(i)&&i!==Ue&&void 0!==r[i]&&a.push(i,r[i]);for(var l=0;l<a.length;l+=2)n=void 0,"-"!==(n=(o=a)[t=l]).charAt(0)&&(o[t]=je[n]=je[n]||n.replace(/([A-Z])/g,"-$1").toLowerCase()),ze(a,l),Ne(e,a,l),Ie(a,l);for(l=1;l<a.length;l+=4)a.splice(l,1,":",a[l],";");return a.join("")}function qe(e){for(var r=[],o=1;o<arguments.length;o++)r[o-1]=arguments[o];var t=Xe(r),n=function(e,r){for(var o=[e.rtl?"rtl":"ltr"],t=!1,n=0,a=r.__order;n<a.length;n++){var i=a[n];o.push(i);var l=r[i];for(var s in l)l.hasOwnProperty(s)&&void 0!==l[s]&&(t=!0,o.push(s,l[s]));}return t?o.join(""):void 0}(e,t);if(n){var a=Fe.getInstance(),i={className:a.classNameFromKey(n),key:n,args:r};if(!i.className){i.className=a.getClassName(function(e){var r=e&&e["&"];return r?r.displayName:void 0}(t));for(var l=[],s=0,c=t.__order;s<c.length;s++){var d=c[s];l.push(d,Ke(e,t[d]));}i.rulesToInsert=l;}return i}}function Je(e){for(var r=[],o=1;o<arguments.length;o++)r[o-1]=arguments[o];var t=qe.apply(void 0,function(){for(var e=0,r=0,o=arguments.length;r<o;r++)e+=arguments[r].length;var t=Array(e),n=0;for(r=0;r<o;r++)for(var a=arguments[r],i=0,l=a.length;i<l;i++,n++)t[n]=a[i];return t}([e],r));return t?(function(e,r){void 0===r&&(r=1);var o=Fe.getInstance(),t=e.className,n=e.key,a=e.args,i=e.rulesToInsert;if(i){for(var l=0;l<i.length;l+=2){var s=i[l+1];if(s){var c=i[l],d=(c=c.replace(/&/g,$e("."+e.className,r)))+"{"+s+"}"+(0===c.indexOf("@")?"}":"");o.insertRule(d);}}o.cacheClassName(t,n,a,i);}}(t,e.specificityMultiplier),t.className):""}!function(){for(var e=[],r=0;r<arguments.length;r++)e[r]=arguments[r];!function(e,r){var o=function(){for(var e=[],r=0;r<arguments.length;r++)e[r]=arguments[r];var o=[],t=[],n=Fe.getInstance();return function e(r){for(var a=0,i=r;a<i.length;a++){var l=i[a];if(l)if("string"==typeof l)if(l.indexOf(" ")>=0)e(l.split(" "));else {var s=n.argsFromClassName(l);s?e(s):-1===o.indexOf(l)&&o.push(l);}else Array.isArray(l)?e(l):"object"==typeof l&&t.push(l);}}(e),{classes:o,objects:t}}(e instanceof Array?e:[e]),t=o.classes,n=o.objects;n.length&&t.push(Je(r||{},n)),t.join(" ");}(e,{rtl:Ae()});}({overflow:"hidden !important"});var Qe="data-is-scrollable";function er(e,r){return e&&e!==document.body?r(e)?e:er(ye(e),r):null}function rr(e,r){var o=er(e,(function(e){return e.hasAttribute(r)}));return o&&o.getAttribute(r)}function or(e){return e.as||"div"}function tr(e,r){return Object.keys(r).reduce((function(o,t){return -1===e.indexOf(t)&&(o[t]=r[t]),o}),{})}function nr(e,r){(null==r||r>e.length)&&(r=e.length);for(var o=0,t=new Array(r);o<r;o++)t[o]=e[o];return t}var ar="data-is-visible",ir="data-focuszone-id",lr="data-is-sub-focuszone";function sr(e,r,o,t,n,a,i){if(!r||r===e)return null;var l=dr(r);if(n&&l&&(a||!fr(r)&&!gr(r))){var s=sr(e,r.lastElementChild,!0,!0,!0,a,i);if(s){if(i&&ur(s,!0)||!i)return s;var c=sr(e,s.previousElementSibling,!0,!0,!0,a,i);if(c)return c;for(var d=s.parentElement;d&&d!==r;){var u=sr(e,d.previousElementSibling,!0,!0,!0,a,i);if(u)return u;d=d.parentElement;}}}return o&&l&&ur(r,i)?r:sr(e,r.previousElementSibling,!0,!0,!0,a,i)||(t?null:sr(e,r.parentElement,!0,!1,!1,a,i))}function cr(e,r,o,t,n,a,i){if(!r||r===e&&n)return null;var l=dr(r);if(o&&l&&ur(r,i))return r;if(!n&&l&&(a||!fr(r)&&!gr(r))){var s=cr(e,r.firstElementChild,!0,!0,!1,a,i);if(s)return s}return r===e?null:cr(e,r.nextElementSibling,!0,!0,!1,a,i)||(t?null:cr(e,r.parentElement,!1,!1,!0,a,i))}function dr(e){if(!e||!e.getAttribute)return !1;var r=e.getAttribute(ar);return null!=r?"true"===r:0!==e.offsetHeight||null!==e.offsetParent||!0===e.isVisible}function ur(e,r){if(!e||e.disabled)return !1;var o=0,t=null;e&&e.getAttribute&&(t=e.getAttribute("tabIndex"))&&(o=parseInt(t,10));var n=e.getAttribute?e.getAttribute(y):null,a=null!==t&&o>=0,i=!!e&&"false"!==n&&("A"===e.tagName||"BUTTON"===e.tagName||"INPUT"===e.tagName||"TEXTAREA"===e.tagName||"true"===n||a||e.getAttribute&&"button"===e.getAttribute("role"));return r?-1!==o&&i:i}function fr(e){return !!(e&&e.getAttribute&&e.getAttribute(ir))}function gr(e){return !(!e||!e.getAttribute||"true"!==e.getAttribute(lr))}var pr=void 0;function br(e){if(e){if(pr)return void(pr=e);pr=e;var r=ve(e);r&&r.requestAnimationFrame((function(){pr&&pr.focus(),pr=void 0;}));}}var mr=function(e,r){"function"!=typeof e?null!==e&&"object"==typeof e&&(e.current=r):e(r);},hr="tabindex",vr="data-no-vertical-wrap",yr="data-no-horizontal-wrap",Cr=999999999,kr=-999999999,wr={},xr={_windowToOuterZoneMap:new Map,register:function(e,r){var o,t;return this._windowToOuterZoneMap.get(e)?null==(t=this._windowToOuterZoneMap.get(e))||t.add(r):this._windowToOuterZoneMap.set(e,new Set([r])),null==(o=this._windowToOuterZoneMap.get(e))?void 0:o.size},unregister:function(e,r){var o,t;null==(o=this._windowToOuterZoneMap.get(e))||o.delete(r),0===(null==(t=this._windowToOuterZoneMap.get(e))?void 0:t.size)&&this._windowToOuterZoneMap.delete(e);},getOutZone:function(e){return this._windowToOuterZoneMap.get(e)}},Sr=["text","number","password","email","tel","url","search"],Br=!1;function Er(e,r){var o=new MouseEvent("click",{ctrlKey:null==r?void 0:r.ctrlKey,metaKey:null==r?void 0:r.metaKey,shiftKey:null==r?void 0:r.shiftKey,altKey:null==r?void 0:r.altKey,bubbles:null==r?void 0:r.bubbles,cancelable:null==r?void 0:r.cancelable});e.dispatchEvent(o);}function Or(e){var r;u(e)===f.Tab&&(null==(r=xr.getOutZone(ve(e.target)))||r.forEach((function(e){return e.updateTabIndexes()})));}var Fr=function(e){function r(r){var o;return (o=e.call(this,r)||this)._root={current:null},o._id=void 0,o._activeElement=void 0,o._lastIndexPath=void 0,o._isParked=!1,o._parkedTabIndex=void 0,o._defaultFocusElement=void 0,o._focusAlignment=void 0,o._isInnerZone=void 0,o._processingTabKey=void 0,o.windowElement=void 0,o.setRef=function(e){o._root.current=e,mr(o.props.innerRef,e);},o._onBlur=function(){o.setParkedFocus(!1);},o._onFocus=function(e){var r,t=o.props,n=t.onActiveElementChanged,a=t.stopFocusPropagation,i=t.shouldFocusInnerElementWhenReceivedFocus,l=t.defaultTabbableElement;if(!t.shouldIgnoreNotFocusable||"false"!==(null==(r=e.target)?void 0:r.dataset.isFocusable)){var s,c=o.isImmediateDescendantOfZone(e.target);if(c)s=e.target;else for(var d=e.target;d&&d!==o._root.current;){if(ur(d)&&o.isImmediateDescendantOfZone(d)){s=d;break}d=ye(d,Br);}if(i&&e.target===o._root.current){var u=l&&"function"==typeof l&&o._root.current&&l(o._root.current);u&&ur(u)?(s=u,u.focus()):(o.focus(!0),o._activeElement&&(s=null));}s&&s!==o._activeElement&&(o._activeElement=s,c&&(o.setFocusAlignment(o._activeElement),o.updateTabIndexes())),n&&n(o._activeElement,e),a&&e.stopPropagation(),ce()(o.props,"onFocus",e);}},o._onMouseDown=function(e){if(!o.props.disabled){for(var r=e.target,t=[];r&&r!==o._root.current;)t.push(r),r=ye(r,Br);for(;t.length&&((r=t.pop())&&ur(r)&&o.setActiveElement(r,!0),!fr(r)););}},o._onKeyDown=function(e){var r=o.props,t=r.direction,n=r.disabled,a=r.shouldEnterInnerZone,i=r.pagingSupportDisabled;if(!n){var l=Ce(o._root.current);if(o.props.onKeyDown&&o.props.onKeyDown(e),!(l.activeElement===o._root.current&&o._isInnerZone||e.isDefaultPrevented())){if(a&&a(e)&&o.isImmediateDescendantOfZone(e.target)){var s=o.getFirstInnerZone();if(s){if(!s.focus(!0))return}else {if(!gr(e.target))return;if(!o.focusElement(cr(e.target,e.target.firstChild,!0)))return}}else {if(e.altKey)return;switch(u(e)){case v:if(o.tryInvokeClickForFocusable(e.target,e))break;return;case f.ArrowLeft:if(t!==h.vertical&&(o.preventDefaultWhenHandled(e),o.moveFocusLeft()))break;return;case f.ArrowRight:if(t!==h.vertical&&(o.preventDefaultWhenHandled(e),o.moveFocusRight()))break;return;case f.ArrowUp:if(t!==h.horizontal&&(o.preventDefaultWhenHandled(e),o.moveFocusUp()))break;return;case f.ArrowDown:if(t!==h.horizontal&&(o.preventDefaultWhenHandled(e),o.moveFocusDown()))break;return;case f.PageDown:if(!i&&o.moveFocusPaging(!0))break;return;case f.PageUp:if(!i&&o.moveFocusPaging(!1))break;return;case f.Tab:if(o.props.handleTabKey===m.all||o.props.handleTabKey===m.inputOnly&&o.isElementInput(e.target)){var c=!1;if(o._processingTabKey=!0,c=t!==h.vertical&&o.shouldWrapFocus(o._activeElement,yr)?(o.props.isRtl?!e.shiftKey:e.shiftKey)?o.moveFocusLeft():o.moveFocusRight():e.shiftKey?o.moveFocusUp():o.moveFocusDown(),o._processingTabKey=!1,c)break}else o.props.shouldResetActiveElementWhenTabFromZone&&(o._activeElement=null);return;case f.Home:if(o.isContentEditableElement(e.target)||o.isElementInput(e.target)&&!o.shouldInputLoseFocus(e.target,!1))return !1;var d=o._root.current&&o._root.current.firstChild;if(o._root.current&&d&&o.focusElement(cr(o._root.current,d,!0)))break;return;case f.End:if(o.isContentEditableElement(e.target)||o.isElementInput(e.target)&&!o.shouldInputLoseFocus(e.target,!1))return !1;var g=o._root.current&&o._root.current.lastChild;if(o._root.current&&o.focusElement(sr(o._root.current,g,!0,!0,!0)))break;return;case f.Enter:if(o.tryInvokeClickForFocusable(e.target,e))break;return;default:return}}e.preventDefault(),e.stopPropagation();}}},o.getHorizontalDistanceFromCenter=function(e,r,t){var n=o._focusAlignment.left,a=Math.floor(t.top),i=Math.floor(r.bottom),l=Math.floor(t.bottom),s=Math.floor(r.top);return e&&a>i||!e&&l<s?n>=t.left&&n<=t.left+t.width?0:Math.abs(t.left+t.width/2-n):o.shouldWrapFocus(o._activeElement,vr)?Cr:kr},o._id=ue()("FocusZone"),o._focusAlignment={left:0,top:0},o._processingTabKey=!1,o}le(r,e);var o=r.prototype;return o.componentDidMount=function(){if(wr[this._id]=this,this._root.current){this.windowElement=ve(this._root.current);for(var e,r=ye(this._root.current,Br),o=Ce(this._root.current);r&&r!==o.body&&1===r.nodeType;){if(fr(r)){this._isInnerZone=!0;break}r=ye(r,Br);}!this._isInnerZone&&this.windowElement&&(xr.register(this.windowElement,this),1===(null==(e=xr.getOutZone(this.windowElement))?void 0:e.size)&&this.windowElement.addEventListener("keydown",Or,!0)),this._root.current.addEventListener("blur",this._onBlur,!0),this.updateTabIndexes(),this.props.defaultTabbableElement&&"string"==typeof this.props.defaultTabbableElement&&(this._activeElement=this.getDocument().querySelector(this.props.defaultTabbableElement)),this.props.shouldFocusOnMount&&this.focus();}},o.componentDidUpdate=function(){if(this._root.current){var e=Ce(this._root.current);if(!this.props.preventFocusRestoration&&e&&this._lastIndexPath&&(e.activeElement===e.body||null===e.activeElement||e.activeElement===this._root.current)){var r=function(e,r){for(var o,t=e,n=function(e,r){var o="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(o)return (o=o.call(e)).next.bind(o);if(Array.isArray(e)||(o=function(e,r){if(e){if("string"==typeof e)return nr(e,r);var o=Object.prototype.toString.call(e).slice(8,-1);return "Object"===o&&e.constructor&&(o=e.constructor.name),"Map"===o||"Set"===o?Array.from(e):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?nr(e,r):void 0}}(e))||r&&e&&"number"==typeof e.length){o&&(e=o);var t=0;return function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(r);!(o=n()).done;){var a=o.value,i=t.children[Math.min(a,t.children.length-1)];if(!i)break;t=i;}return ur(t)&&dr(t)?t:cr(e,t,!0)||sr(e,t)}(this._root.current,this._lastIndexPath);r?(this.setActiveElement(r,!0),r.focus(),this.setParkedFocus(!1)):this.setParkedFocus(!0);}}},o.componentWillUnmount=function(){delete wr[this._id],xr.unregister(this.windowElement,this),this._isInnerZone||this.windowElement&&!xr.getOutZone(this.windowElement)&&this.windowElement.removeEventListener("keydown",Or,!0),this._root.current&&this._root.current.removeEventListener("blur",this._onBlur,!0),this._activeElement=null,this._defaultFocusElement=null;},o.render=function(){var e=this.props.className,o=or(this.props),t=tr(j()(r.propTypes),this.props);return this.evaluateFocusBeforeRender(),S.createElement(o,ae({},t,{ref:this.setRef,className:ge()(r.className,e),"data-focuszone-id":this._id,onKeyDown:this._onKeyDown,onFocus:this._onFocus,onMouseDownCapture:this._onMouseDown}),this.props.children)},o.focus=function(e){if(void 0===e&&(e=!1),this._root.current){if(!e&&"true"===this._root.current.getAttribute(y)&&this._isInnerZone){var r=this.getOwnerZone(this._root.current);if(r!==this._root.current){var o=wr[r.getAttribute(ir)];return !!o&&o.focusElement(this._root.current)}return !1}if(!e&&this._activeElement&&ke(this._root.current,this._activeElement,Br)&&ur(this._activeElement))return this._activeElement.focus(),!0;var t=this._root.current.firstChild;return this.focusElement(cr(this._root.current,t,!0))}return !1},o.focusLast=function(){if(this._root.current){var e=this._root.current&&this._root.current.lastChild;return this.focusElement(sr(this._root.current,e,!0,!0,!0))}return !1},o.focusElement=function(e,r){var o=this.props.shouldReceiveFocus;return !(o&&!o(e)||!e||(this.setActiveElement(e,r),this._activeElement&&this._activeElement.focus(),0))},o.evaluateFocusBeforeRender=function(){if(this._root.current){var e=Ce(this._root.current);if(e){var r=e.activeElement;if(r!==this._root.current){var o=ke(this._root.current,r,Br);this._lastIndexPath=o?function(e,r){for(var o=[],t=r;t&&e&&t!==e;){var n=ye(t,!1);if(null===n)return [];o.unshift(Array.prototype.indexOf.call(n.children,t)),t=n;}return o}(this._root.current,e.activeElement):void 0;}}}},o.setParkedFocus=function(e){this._root.current&&this._isParked!==e&&(this._isParked=e,e?(this.props.allowFocusRoot||(this._parkedTabIndex=this._root.current.getAttribute("tabindex"),this._root.current.setAttribute("tabindex","-1")),this._root.current.focus()):this.props.allowFocusRoot||(this._parkedTabIndex?(this._root.current.setAttribute("tabindex",this._parkedTabIndex),this._parkedTabIndex=void 0):this._root.current.removeAttribute("tabindex")));},o.setActiveElement=function(e,r){var o=this._activeElement;this._activeElement=e,o&&(fr(o)&&this.updateTabIndexes(o),o.tabIndex=-1),this._activeElement&&(this._focusAlignment&&!r||this.setFocusAlignment(e,!0,!0),this._activeElement.tabIndex=0);},o.preventDefaultWhenHandled=function(e){this.props.preventDefaultWhenHandled&&e.preventDefault();},o.tryInvokeClickForFocusable=function(e,r){var o=e;if(o===this._root.current||!this.props.shouldRaiseClicks)return !1;do{if("BUTTON"===o.tagName||"A"===o.tagName||"INPUT"===o.tagName||"TEXTAREA"===o.tagName)return !1;if(this.isImmediateDescendantOfZone(o)&&"true"===o.getAttribute(y)&&"true"!==o.getAttribute("data-disable-click-on-enter"))return Er(o,r),!0;o=ye(o,Br);}while(o!==this._root.current);return !1},o.getFirstInnerZone=function(e){var r=e||this._activeElement||this._root.current;if(!r)return null;if(fr(r))return wr[r.getAttribute(ir)];for(var o=r.firstElementChild;o;){if(fr(o))return wr[o.getAttribute(ir)];var t=this.getFirstInnerZone(o);if(t)return t;o=o.nextElementSibling;}return null},o.moveFocus=function(e,r,o,t){void 0===t&&(t=!0);var n=this._activeElement,a=-1,i=void 0,l=!1,s=this.props.direction===h.bidirectional;if(!n||!this._root.current)return !1;if(this.isElementInput(n)&&!this.shouldInputLoseFocus(n,e))return !1;var c=s?n.getBoundingClientRect():null;do{if(n=e?cr(this._root.current,n):sr(this._root.current,n),!s){i=n;break}if(n){var d=r(c,n.getBoundingClientRect());if(-1===d&&-1===a){i=n;break}if(d>-1&&(-1===a||d<a)&&(a=d,i=n),a>=0&&d<0)break}}while(n);if(i&&i!==this._activeElement)l=!0,this.focusElement(i);else if(this.props.isCircularNavigation&&t)return e?this.focusElement(cr(this._root.current,this._root.current.firstElementChild,!0)):this.focusElement(sr(this._root.current,this._root.current.lastElementChild,!0,!0,!0));return l},o.moveFocusDown=function(){var e=this,r=-1,o=this._focusAlignment.left;return !!this.moveFocus(!0,(function(t,n){var a=-1,i=Math.floor(n.top),l=Math.floor(t.bottom);return i<l?e.shouldWrapFocus(e._activeElement,vr)?Cr:kr:((-1===r&&i>=l||i===r)&&(r=i,a=o>=n.left&&o<=n.left+n.width?0:Math.abs(n.left+n.width/2-o)),a)}))&&(this.setFocusAlignment(this._activeElement,!0,!0),!0)},o.moveFocusUp=function(){var e=this,r=-1,o=this._focusAlignment.left;return !!this.moveFocus(!1,(function(t,n){var a=-1,i=Math.floor(n.bottom),l=Math.floor(n.top),s=Math.floor(t.top);return i>s?e.shouldWrapFocus(e._activeElement,vr)?Cr:kr:((-1===r&&i<=s||l===r)&&(r=l,a=o>=n.left&&o<=n.left+n.width?0:Math.abs(n.left+n.width/2-o)),a)}))&&(this.setFocusAlignment(this._activeElement,!0,!0),!0)},o.moveFocusLeft=function(){var e=this,r=this.shouldWrapFocus(this._activeElement,yr);return !!this.moveFocus(this.props.isRtl,(function(o,t){var n=-1;return (e.props.isRtl?parseFloat(t.top.toFixed(3))<parseFloat(o.bottom.toFixed(3)):parseFloat(t.bottom.toFixed(3))>parseFloat(o.top.toFixed(3)))&&t.right<=o.right&&e.props.direction!==h.vertical?n=o.right-t.right:r||(n=kr),n}),void 0,r)&&(this.setFocusAlignment(this._activeElement,!0,!1),!0)},o.moveFocusRight=function(){var e=this,r=this.shouldWrapFocus(this._activeElement,yr);return !!this.moveFocus(!this.props.isRtl,(function(o,t){var n=-1;return (e.props.isRtl?parseFloat(t.bottom.toFixed(3))>parseFloat(o.top.toFixed(3)):parseFloat(t.top.toFixed(3))<parseFloat(o.bottom.toFixed(3)))&&t.left>=o.left&&e.props.direction!==h.vertical?n=t.left-o.left:r||(n=kr),n}),void 0,r)&&(this.setFocusAlignment(this._activeElement,!0,!1),!0)},o.moveFocusPaging=function(e,r){void 0===r&&(r=!0);var o=this._activeElement;if(!o||!this._root.current)return !1;if(this.isElementInput(o)&&!this.shouldInputLoseFocus(o,e))return !1;var t=function(e){for(var r=e,o=Ce(e);r&&r!==o.body;){if("true"===r.getAttribute(Qe))return r;r=r.parentElement;}for(r=e;r&&r!==o.body;){if("false"!==r.getAttribute(Qe)){var t=getComputedStyle(r),n=t?t.getPropertyValue("overflow-y"):"";if(n&&("scroll"===n||"auto"===n))return r}r=r.parentElement;}return r&&r!==o.body||(r=ve(e)),r}(o);if(!t)return !1;var n=-1,a=void 0,i=-1,l=-1,s=t.clientHeight,c=o.getBoundingClientRect();do{if(o=e?cr(this._root.current,o):sr(this._root.current,o)){var d=o.getBoundingClientRect(),u=Math.floor(d.top),f=Math.floor(c.bottom),g=Math.floor(d.bottom),p=Math.floor(c.top),b=this.getHorizontalDistanceFromCenter(e,c,d);if(e&&u>f+s||!e&&g<p-s)break;b>-1&&(e&&u>i?(i=u,n=b,a=o):!e&&g<l?(l=g,n=b,a=o):(-1===n||b<=n)&&(n=b,a=o));}}while(o);var m=!1;if(a&&a!==this._activeElement)m=!0,this.focusElement(a),this.setFocusAlignment(a,!1,!0);else if(this.props.isCircularNavigation&&r)return e?this.focusElement(cr(this._root.current,this._root.current.firstElementChild,!0)):this.focusElement(sr(this._root.current,this._root.current.lastElementChild,!0,!0,!0));return m},o.setFocusAlignment=function(e,r,o){if(this.props.direction===h.bidirectional&&(!this._focusAlignment||r||o)){var t=e.getBoundingClientRect(),n=t.left+t.width/2,a=t.top+t.height/2;this._focusAlignment||(this._focusAlignment={left:n,top:a}),r&&(this._focusAlignment.left=n),o&&(this._focusAlignment.top=a);}},o.isImmediateDescendantOfZone=function(e){return this.getOwnerZone(e)===this._root.current},o.getOwnerZone=function(e){for(var r=Ce(this._root.current),o=ye(e,Br);o&&o!==this._root.current&&o!==r.body;){if(fr(o))return o;o=ye(o,Br);}return this._root.current},o.updateTabIndexes=function(e){var r=e;!this._activeElement&&this.props.defaultTabbableElement&&"function"==typeof this.props.defaultTabbableElement&&(this._activeElement=this.props.defaultTabbableElement(this._root.current)),!r&&this._root.current&&(this._defaultFocusElement=null,r=this._root.current,this._activeElement&&!ke(r,this._activeElement,Br)&&(this._activeElement=null)),this._activeElement&&!ur(this._activeElement)&&(this._activeElement=null);for(var o=r&&r.children,t=0;o&&t<o.length;t++){var n=o[t];fr(n)?"true"===n.getAttribute(y)&&(this._isInnerZone||(this._activeElement||this._defaultFocusElement)&&this._activeElement!==n?"-1"!==n.getAttribute(hr)&&n.setAttribute(hr,"-1"):(this._defaultFocusElement=n,"0"!==n.getAttribute(hr)&&n.setAttribute(hr,"0"))):(n.getAttribute&&"false"===n.getAttribute(y)&&n.setAttribute(hr,"-1"),ur(n)?this.props.disabled?n.setAttribute(hr,"-1"):this._isInnerZone||(this._activeElement||this._defaultFocusElement)&&this._activeElement!==n?"-1"!==n.getAttribute(hr)&&n.setAttribute(hr,"-1"):(this._defaultFocusElement=n,"0"!==n.getAttribute(hr)&&n.setAttribute(hr,"0")):"svg"===n.tagName&&"false"!==n.getAttribute("focusable")&&n.setAttribute("focusable","false")),this.updateTabIndexes(n);}},o.isContentEditableElement=function(e){return e&&"true"===e.getAttribute("contenteditable")},o.isElementInput=function(e){return !(!e||!e.tagName||"input"!==e.tagName.toLowerCase()&&"textarea"!==e.tagName.toLowerCase())},o.shouldInputLoseFocus=function(e,r){if(!this._processingTabKey&&e&&e.type&&Sr.indexOf(e.type.toLowerCase())>-1){var o=e.selectionStart,t=o!==e.selectionEnd,n=e.value,a=e.readOnly;if(t||o>0&&!r&&!a||o!==n.length&&r&&!a||this.props.handleTabKey&&(!this.props.shouldInputLoseFocusOnArrowKey||!this.props.shouldInputLoseFocusOnArrowKey(e)))return !1}return !0},o.shouldWrapFocus=function(e,r){return !this.props.checkForNoWrap||function(e,r){return "true"!==rr(e,r)}(e,r)},o.getDocument=function(){return Ce(this._root.current)},r}(S.Component);Fr.propTypes={className:pe.string,direction:pe.number,defaultTabbableElement:pe.func,shouldFocusOnMount:pe.bool,shouldResetActiveElementWhenTabFromZone:pe.bool,shouldRaiseClicks:pe.bool,shouldFocusInnerElementWhenReceivedFocus:pe.bool,disabled:pe.bool,as:pe.elementType,isCircularNavigation:pe.bool,shouldEnterInnerZone:pe.func,onActiveElementChanged:pe.func,shouldReceiveFocus:pe.func,handleTabKey:pe.number,shouldInputLoseFocusOnArrowKey:pe.func,stopFocusPropagation:pe.bool,onFocus:pe.func,preventDefaultWhenHandled:pe.bool,isRtl:pe.bool,preventFocusRestoration:pe.bool,pagingSupportDisabled:pe.bool,shouldIgnoreNotFocusable:pe.bool,innerRef:pe.any},Fr.defaultProps={isCircularNavigation:!1,direction:h.bidirectional,as:"div",preventDefaultWhenHandled:!0,shouldRaiseClicks:!1},Fr.displayName="FocusZone",Fr.className="ms-FocusZone",Fr.outerZones=xr;var Ar="undefined"!=typeof window?S.useLayoutEffect:S.useEffect,Pr=function(e,r){void 0===r&&(r={});var o=r,t=o.actionHandlers,n=(o.debugName,o.mapPropsToBehavior),a=void 0===n?function(){return {}}:n,i=o.rtl,l=void 0!==i&&i,s=function(e,r,o,t,n){if(null==r)return ne;var a=r(o),i=n&&a.keyActions?function(e,r,o){var t={};if(!e||!r)return t;var n=Object.keys(e);return Object.keys(r).forEach((function(a){var i=r[a],l=Object.keys(i).filter((function(e){var r=i[e],o=Array.isArray(r.keyCombinations)&&r.keyCombinations.length>0,t=-1!==n.indexOf(e);return o&&t}));l.length>0&&(t[a]={onKeyDown:function(r){l.forEach((function(t){var n=i[t].keyCombinations;n&&(o&&(n=n.map((function(e){var r=te[e.keyCode];return r&&(e.keyCode=r),e}))),function(e,r){return r.some((function(r){return r.keyCode===u(e)&&oe(e.altKey,r.altKey)&&oe(e.shiftKey,r.shiftKey)&&oe(e.metaKey,r.metaKey)&&oe(e.ctrlKey,r.ctrlKey)}))}(r,n)&&e[t](r));}));}});})),t}(n,a.keyActions,t):{};return a.focusZone&&(a.focusZone.props=Object.assign({preventFocusRestoration:!0},a.focusZone.props)),Object.assign({},ne,a,{keyHandlers:i})}(0,e,a(),l,t),c=S.useRef(),d=S.useRef({}),f=S.useRef({});Ar((function(){c.current=s;}));var g=function(e,r){var o=Boolean(s.keyHandlers[e]||r.onKeyDown),t=s.childBehaviors?s.childBehaviors[e]:void 0;return f.current[e]=r,o?d.current[e]||(d.current[e]=function(r){var o,t,n=null==(o=c.current)||null==(t=o.keyHandlers[e])?void 0:t.onKeyDown,a=f.current[e].onKeyDown;n&&n(r);for(var i=arguments.length,l=new Array(i>1?i-1:0),s=1;s<i;s++)l[s-1]=arguments[s];a&&a.apply(void 0,[r].concat(l));}):delete d.current[e],Object.assign({},t&&{accessibility:t},s.attributes[e],r,{onKeyDown:d.current[e]})};return g.unstable_wrapWithFocusZone=function(e){if(s.focusZone){var r=e;return S.createElement(Fr,Object.assign({},s.focusZone.props,r.props,{innerRef:r.ref,as:r.type,isRtl:l}))}return e},g.unstable_behaviorDefinition=function(){return s},g},jr=(n(7693),n(2347)),Rr=n.n(jr),Ir=new WeakMap,Mr=n(253),Dr=n.n(Mr),zr=n(3064),_r=n.n(zr),Hr=new WeakMap,Tr=new WeakMap,Wr=function(e){var r=e.primaryDisplayName,o=e.telemetry,t=null!=o&&o.enabled?performance.now():0,n=function(e,r,o,t){var n,a=e.filter((function(e){return !!r.componentVariables[e]}));if(t){Ir.has(r)||Ir.set(r,{});var i=Ir.get(r)||{},l=a[a.length-1];i[l]||(1===a.length?i[l]=z(r.componentVariables[l])(r.siteVariables):i[l]=U.apply(void 0,a.map((function(e){return r.componentVariables[e]})))(r.siteVariables),Ir.set(r,i)),n=i[l];}else n=1===a.length?z(r.componentVariables[a[0]])(r.siteVariables)||{}:U.apply(void 0,a.map((function(e){return r.componentVariables[e]})))(r.siteVariables);return void 0===o?n:U(n,W(o))(r.siteVariables)}(e.allDisplayNames,e.theme,e.inlineStylesProps.variables,e.performance.enableVariablesCaching);null!=o&&o.enabled&&o.performance[r]&&(o.performance[r].msResolveVariablesTotal+=performance.now()-t);var a=function(e,r){var o=e.allDisplayNames,t=e.className,n=e.theme,a=e.primaryDisplayName,i=e.componentProps,l=e.inlineStylesProps,s=e.rtl,c=e.disableAnimations,d=e.renderer,u=e.performance,f=e.telemetry,g=l.className,p=l.design,b=l.styles,m=l.variables,h=!(p||b),v=u.enableBooleanVariablesCaching||!m;u.enableBooleanVariablesCaching&&(_r()(m)?Object.keys(m).every((function(e){return null===m[e]||void 0===m[e]||"boolean"==typeof m[e]}))||(v=!1):Dr()(m)||(v=!1));var y,C=u.enableStylesCaching&&h&&v;if(1===o.length)y=n.componentStyles[o[0]]||{root:function(){return {}}};else {var k=o.map((function(e){return n.componentStyles[e]})).filter(Boolean);y=k.length>0?k.reduce((function(e,r){return N(e,r)}),{}):{root:function(){return {}}};}h||(y=N(y,N(p&&W({root:p}),b&&W({root:b}))));var w={props:i,variables:r,theme:n,rtl:s,disableAnimations:c},x={direction:s?"rtl":"ltr",disableAnimations:c,displayName:o.join(":"),sanitizeCss:u.enableSanitizeCssPlugin},S={};C&&n&&(Tr.has(n)||Tr.set(n,{}),Hr.has(n)||Hr.set(n,{}));var B=C?JSON.stringify(i):"",E=C&&u.enableBooleanVariablesCaching?JSON.stringify(m):"",O=C?o.join(":")+":"+B+":"+E+":"+w.rtl+w.disableAnimations:"";if("undefined"==typeof Proxy){var F={},A={};return Object.keys(y).forEach((function(e){var r=e+"__return",o=O+e;Object.defineProperty(F,e,{enumerable:!1,configurable:!1,set:function(e){var t;C&&n&&Tr.set(n,Object.assign({},Tr.get(n),((t={})[o]=e,t))),F[r]=e;},get:function(){if(C&&n){var t=Tr.get(n)||{};if(t[o])return t[o]}if(F[r])return F[r];var i,l=null!=f&&f.enabled?performance.now():0;return F[r]=y[e](w),C&&n&&Tr.set(n,Object.assign({},Tr.get(n),((i={})[o]=F[r],i))),null!=f&&f.enabled&&f.performance[a]&&(f.performance[a].msResolveStylesTotal+=performance.now()-l),F[r]}}),Object.defineProperty(A,e,{enumerable:!1,configurable:!1,set:function(e){var t;C&&n&&Hr.set(n,Object.assign({},Hr.get(n),((t={})[o]=e,t))),A[r]=e;},get:function(){if(C&&n){var i=Hr.get(n)||{};if(i[o]||""===i[o])return null!=f&&f.performance[a]&&("root"===e?f.performance[a].stylesRootCacheHits++:f.performance[a].stylesSlotsCacheHits++),"root"===e?ge()(t,i[o],g):i[o]}if(A[r])return "root"===e?ge()(t,A[r],g):A[r];var l,s=F[e],c=null!=f&&f.enabled?performance.now():0;s&&(A[r]=d.renderRule(s,x),C&&n&&Hr.set(n,Object.assign({},Hr.get(n),((l={})[o]=A[r],l))));var u="root"===e?ge()(t,A[r],g):A[r];return null!=f&&f.enabled&&f.performance[a]&&(f.performance[a].msRenderStylesTotal+=performance.now()-c),u}});})),{resolvedStyles:F,resolvedStylesDebug:S,classes:A}}var P=new Proxy({},{get:function(e,r){var o,t,i=O+r;if(C&&n){var l=Tr.get(n)||{};if(l[i])return l[i]}if(e[r])return e[r];var s,c=null!=f&&f.enabled?performance.now():0;return e[r]=null==(o=(t=y)[r])?void 0:o.call(t,w),C&&n&&Tr.set(n,Object.assign({},Tr.get(n),((s={})[i]=e[r],s))),null!=f&&f.enabled&&f.performance[a]&&(f.performance[a].msResolveStylesTotal+=performance.now()-c),e[r]}}),j=new Proxy({},{get:function(e,r){var o=O+r;if(C&&n){var i=Hr.get(n)||{};if(i[o]||""===i[o])return null!=f&&f.performance[a]&&("root"===r?f.performance[a].stylesRootCacheHits++:f.performance[a].stylesSlotsCacheHits++),"root"===r?ge()(t,i[o],g):i[o]}if(e[r])return "root"===r?ge()(t,e[r],g):e[r];var l,s=P[r],c=null!=f&&f.enabled?performance.now():0;s&&(e[r]=d.renderRule(s,x),C&&n&&Hr.set(n,Object.assign({},Hr.get(n),((l={})[o]=e[r],l))));var u="root"===r?ge()(t,e[r],g):e[r];return null!=f&&f.enabled&&f.performance[a]&&(f.performance[a].msRenderStylesTotal+=performance.now()-c),u}});return {resolvedStyles:P,resolvedStylesDebug:S,classes:j}}(e,n),i=a.classes,l=a.resolvedStyles;return a.resolvedStylesDebug,{classes:i,variables:n,styles:l,theme:e.theme}},Lr=function(e,r){var o,t=J(),n=r.className,a=void 0===n?"":n,i=r.composeOptions,l=r.mapPropsToStyles,s=void 0===l?function(){return {}}:l,c=r.mapPropsToInlineStyles,d=void 0===c?function(){return {}}:c,u=r.unstable_props,f=void 0===u?{}:u,g=r.rtl,p=void 0!==g&&g,b=s(),m=Object.assign({},f,b),h=null==i||null==(o=i.mapPropsToStylesPropsChain)?void 0:o.reduce((function(e,r){return Object.assign({},e,r(m))}),{}),v=S.useRef({fluentUIDebug:null}),y=Wr({allDisplayNames:(null==i?void 0:i.displayNames)||[e],className:(null==i?void 0:i.className)||a,primaryDisplayName:(null==i?void 0:i.displayName)||e,componentProps:Object.assign({},b,h),inlineStylesProps:d(),disableAnimations:t.disableAnimations,renderer:t.renderer,rtl:p,saveDebug:function(e){return v.current={fluentUIDebug:e}},theme:t.theme,performance:t.performance,telemetry:t.telemetry});return {classes:y.classes,styles:y.styles}};function Nr(e,r){return tr(e,r)}n(1894),n(9120),n(6139),n(6614);var Ur=n(9274),Zr=n.n(Ur),Vr=n(7506),Gr=n.n(Vr),Xr=n(6380),Yr=n.n(Xr),$r=(n(2534),n(4077),n(5395),n(8864),n(1925),function(e){return Object.prototype.toString.call(e)}),Kr=function(e,r){if(void 0!==e[r]){if(null===e[r])return null;if(!(e[r]instanceof Element))return new Error('Invalid prop "'+r+'" supplied, expected a DOM node.')}},qr=function(e){return function(r,o,t){if(!Array.isArray(e))throw new Error(["Invalid argument supplied to disallow, expected an instance of array."," See `"+o+"` prop in `"+t+"`."].join(""));if(!Dr()(r[o])&&!1!==r[o]){var n=e.reduce((function(e,o){return Dr()(r[o])||!1===r[o]?e:[].concat(e,[o])}),[]);return n.length>0?new Error(["Prop `"+o+"` in `"+t+"` conflicts with props: `"+n.join("`, `")+"`.","They cannot be defined together, choose one or the other."].join(" ")):void 0}}},Jr=function(e){return function(r,o,t){for(var n=arguments.length,a=new Array(n>3?n-3:0),i=3;i<n;i++)a[i-3]=arguments[i];if(!Array.isArray(e))throw new Error(["Invalid argument supplied to every, expected an instance of array.","See `"+o+"` prop in `"+t+"`."].join(" "));return Yr()(Gr()(s()(e,(function(e){if("function"!=typeof e)throw new Error('every() argument "validators" should contain functions, found: '+$r(e)+".");return e.apply(void 0,[r,o,t].concat(a))}))))}},Qr=Jr([qr(["children"]),pe.node]),eo=(pe.oneOfType([pe.node,pe.object,pe.arrayOf(pe.oneOfType([pe.node,pe.object]))]),pe.oneOfType([pe.node,pe.object,pe.func])),ro=(pe.oneOfType([pe.object,pe.func]),Jr([qr(["children"]),eo])),oo=Jr([qr(["children"]),eo]),to=function(e){return Jr([qr(["children"]),pe.oneOfType([pe.node,pe.shape({kind:pe.oneOf(e)}),pe.func])])},no=Jr([qr(["children"]),pe.oneOfType([pe.func,pe.number,pe.object,pe.string,pe.oneOf([!1])])]),ao=(Jr([qr(["children"]),pe.arrayOf(ro)]),Jr([qr(["children"]),pe.arrayOf(oo)])),io=pe.func,lo=pe.oneOf(["smallest","smaller","small","medium","large","larger","largest"]),so=pe.oneOf(["start","end","center","justify"]),co=(pe.oneOfType([pe.shape({name:pe.string.isRequired,delay:pe.string,direction:pe.string,duration:pe.string,fillMode:pe.string,iterationCount:pe.string,playState:pe.string,timingFunction:pe.string}),pe.string]),pe.shape({position:pe.string,display:pe.string,top:pe.string,right:pe.string,bottom:pe.string,left:pe.string,padding:pe.string,paddingTop:pe.string,paddingRight:pe.string,paddingBottom:pe.string,paddingLeft:pe.string,margin:pe.string,marginTop:pe.string,marginRight:pe.string,marginBottom:pe.string,marginLeft:pe.string,width:pe.string,height:pe.string,minWidth:pe.string,maxWidth:pe.string,minHeight:pe.string,maxHeight:pe.string})),uo=(pe.oneOfType([pe.func,pe.object]),function(e){var r=e.condition,o=void 0===r||r,t=e.forElements;return o&&(void 0===t?[]:t).some((function(e){return e&&"string"==typeof e}))?{dir:"auto"}:{}}),fo=function(e){return null!=e&&("number"==typeof e?!isNaN(e):Array.isArray(e)?e.length>0:!!e)},go=function(e){void 0===e&&(e={});var r=e,o=r.accessibility,t=void 0===o||o,n=r.as,a=void 0===n||n,i=r.children,l=void 0===i?"node":i,s=r.className,c=void 0===s||s,d=r.color,u=void 0!==d&&d,f=r.content,g=void 0===f?"node":f,p=r.styled,b=void 0===p||p;return Object.assign({},t&&{accessibility:io},a&&{as:pe.elementType},l&&{children:"element"===l?pe.element:pe.node},c&&{className:pe.string},u&&{color:pe.string},g&&{content:"shorthand"===g?oo:Qr},b&&{styles:pe.oneOfType([pe.object,pe.func]),variables:pe.oneOfType([pe.object,pe.func]),design:co})},po=n(9899),bo=n.n(po),mo=n(4490),ho=n.n(mo),vo=n(8286),yo={iframe:"src",img:"src",input:"type"};function Co(e){var r=e.Component,o=e.mappedProp,t=e.mappedArrayProp,n=e.allowsJSX;if(!vo.isValidElementType(r))throw new Error("createShorthandFactory() Component must be a string or function.");return function(e,a){return ko({allowsJSX:n,Component:r,mappedProp:o,mappedArrayProp:t,value:e,options:a})}}function ko(e){var r=e.Component,o=e.mappedProp,t=e.mappedArrayProp,n=e.value,a=e.options,i=void 0===a?{}:a,l=e.allowsJSX,s=void 0===l||l;if(!vo.isValidElementType(r))throw new Error("createShorthand() Component must be a string or function.");if((Dr()(n)||"boolean"==typeof n)&&!i.render)return null;var c="string"==typeof n||"number"==typeof n,d=_r()(n),u=ho()(n),f=S.isValidElement(n),g=i.defaultProps&&i.defaultProps()||{},p=f&&{}||d&&n||{},b="function"==typeof i.overrideProps?i.overrideProps(Object.assign({},g,p)):i.overrideProps||{},m=Object.assign({},g,p,b),h=yo[b.as||g.as];if((c||f)&&(m[h||o||"children"]=n),u&&(m[h||t||"children"]=n),g.className||b.className||p.className){var v=ge()(g.className,b.className,p.className);m.className=bo()(v.split(" ")).join(" ");}(g.style||b.style||p.style)&&(m.style=Object.assign({},g.style,p.style,b.style)),(g.styles||b.styles||p.styles)&&(m.styles=Y(g.styles,p.styles,b.styles));var y=i.generateKey;if((void 0===y||y)&&Dr()(m.key)&&(c&&(m.key=n),f)){var C=n.key;null===C||(m.key=C);}delete m.kind;var k=i.render;return k?k(r,m):"function"==typeof m.children?m.children(r,Object.assign({},m,{children:void 0})):!s&&f?null:c||d||u||f?S.createElement(r,m):null}function wo(e,r,o){var t,n=e.shorthandConfig||(null==(t=e.fluentComposeConfig)?void 0:t.shorthandConfig)||{},a=n.mappedProp,i=void 0===a?"children":a,l=n.allowsJSX;return ko({Component:e,mappedProp:i,allowsJSX:void 0===l||l,mappedArrayProp:n.mappedArrayProp,value:r,options:o||{}})}var xo=n(2279),So="undefined"==typeof window||/ServerSideRendering/.test(window.navigator&&window.navigator.userAgent)?S.useEffect:S.useLayoutEffect,Bo=function(e){var r,o=S.createContext({value:{current:e},version:{current:-1},listeners:[]});return o.Provider=(r=o.Provider,function(e){var o=S.useRef(e.value),t=S.useRef(0),n=S.useRef();return n.current||(n.current={value:o,version:t,listeners:[]}),So((function(){var r;o.current=e.value,t.current+=1,r=function(){n.current.listeners.forEach((function(r){r([t.current,e.value]);}));},(0, xo.unstable_runWithPriority)(xo.unstable_NormalPriority,r);}),[e.value]),S.createElement(r,{value:n.current},e.children)}),delete o.Consumer,o},Eo=function(e,r){var o=S.useContext(e),t=o.value.current,n=o.version.current,a=o.listeners,i={};Object.keys(r).forEach((function(e){i[e]=r[e](t);}));var l=S.useReducer((function(e,o){if(!o)return [t,i];if(o[0]<=n)return Object.keys(r).every((function(r){return Object.is(e[1][r],i[r])}))?e:[t,i];try{if(!Object.keys(e[0]).some((function(r){return !Object.is(e[0][r],o[1][r])})))return e;var a={};return Object.keys(r).forEach((function(e){a[e]=r[e](o[1]);})),Object.keys(r).every((function(r){return Object.is(e[1][r],a[r])}))?e:[o[1],a]}catch(e){}return [].concat(e)}),[t,i]),s=l[0],c=l[1];return void 0!==Object.keys(r).find((function(e){return !Object.is(s[1][e],i[e])}))&&c(void 0),So((function(){return a.push(c),function(){var e=a.indexOf(c);a.splice(e,1);}}),[a]),s[1]},Oo="comfy",Fo=Bo({density:Oo,behaviors:{item:void 0,message:void 0}}),Ao=Fo.Provider,Po=function(e){return Eo(Fo,e)},jo={className:"",classes:[],displayName:"",displayNames:[],mapPropsToStylesPropsChain:[],render:function(){return null},handledProps:[],overrideStyles:!1,slots:{__self:function(){return null}},slotProps:[],state:function(e){return e},resolveSlotProps:function(){return {}},shorthandConfig:{}};function Ro(e,r){return e.overrideStyles?[e.displayName].filter(Boolean):e.displayName?r.displayNames.concat(e.displayName):r.displayNames}const Io=function(e,r){void 0===r&&(r={});var o=function(e,r,o){void 0===o&&(o=jo);var t=r.slotProps?[].concat(o.slotProps,[r.slotProps]):o.slotProps,n=Array.isArray(r.classes)?r.classes:[r.classes];return {className:r.className||o.className,classes:[].concat(o.classes,n),displayName:r.displayName||o.displayName,displayNames:Ro(r,o),mapPropsToStylesPropsChain:r.mapPropsToStylesProps?[].concat(o.mapPropsToStylesPropsChain,[r.mapPropsToStylesProps]):o.mapPropsToStylesPropsChain,render:"function"==typeof e?e:o.render,handledProps:[].concat(o.handledProps,r.handledProps||[]),overrideStyles:r.overrideStyles||!1,slots:Object.assign({},o.slots,r.slots),slotProps:t,state:function(e,t,n){return r.state?r.state(o.state(e,t,n),t,n):o.state(e,t,n)},resolveSlotProps:function(e){return t.reduce((function(r,o){var t=Object.assign({},o(e)),n=[].concat(Object.keys(r),Object.keys(t)),a={};return n.forEach((function(e){a[e]||(a[e]=Object.assign({},r[e],t[e]));})),a}),{})},shorthandConfig:Object.assign({},o.shorthandConfig,r.shorthandConfig)}}(e,r,function(e){return !!e.fluentComposeConfig}(e)?e.fluentComposeConfig:void 0),t=S.forwardRef((function(e,r){return o.render(e,r,Object.assign({},o,{state:o.state(e,r,o),slots:Object.assign({},o.slots,{__self:t})}))}));return t.displayName=o.displayName,e.defaultProps&&(t.defaultProps=e.defaultProps),t.fluentComposeConfig=o,t};var Mo=function(){var e=Io((function(e,r,o){var t=J(),n=re(o.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=e.accessibility,s=e.className,c=e.design,d=e.styles,u=e.variables,f=e.children,g=e.content,p=Pr(l,{debugName:o.displayName,rtl:t.rtl}),b=Lr(o.displayName,{className:o.className,composeOptions:o,mapPropsToInlineStyles:function(){return {className:s,design:c,styles:d,variables:u}},rtl:t.rtl,unstable_props:e}).classes,m=Nr(o.handledProps,e),h=or(e),v=p.unstable_wrapWithFocusZone(S.createElement(h,p("root",Object.assign({},uo({forElements:[f,g]}),{className:b.root,ref:r},m)),fo(f)?f:g));return i(),v}),{className:"ui-box",displayName:"Box",handledProps:["accessibility","as","className","children","content","design","styles","variables"]});return e.propTypes=go(),e.create=Co({Component:e}),e}(),Do=Bo({attached:!1}),zo=Do.Provider,_o="ui-chat__item",Ho={message:_o+"__message",gutter:_o+"__gutter"},To=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l,s,c=Po({density:function(e){return e.density},accessibility:function(e){return e.behaviors.item}}),d=Object.assign({},c,r),u=d.accessibility,f=d.attached,g=d.children,p=d.className,b=d.contentPosition,m=d.density,h=d.design,v=d.gutter,y=d.message,C=d.styles,k=d.variables,w=Pr(u,{debugName:e.displayName,rtl:t.rtl}),x=Lr(e.displayName,{className:_o,mapPropsToStyles:function(){return {attached:f,contentPosition:b,density:m}},mapPropsToInlineStyles:function(){return {className:p,design:h,styles:C,variables:k}},rtl:t.rtl}),B=x.classes,E=x.styles,O=or(d),F=Nr(e.handledProps,d),A=S.createElement(O,w("root",Object.assign({className:B.root,ref:o},uo({forElements:[g]}),F)),fo(g)?g:(l=Mo.create(v,{defaultProps:function(){return w("gutter",{className:Ho.gutter,styles:E.gutter})}}),s=Mo.create(y,{defaultProps:function(){return w("message",{className:Ho.message,styles:E.message})}}),S.createElement(zo,{value:{attached:f}},("start"===b||"compact"===m)&&l,s,"end"===b&&"comfy"===m&&l)));return i(),A}));return e.displayName="ChatItem",e.defaultProps={as:"li",contentPosition:"start",attached:!1},e.propTypes=Object.assign({},go({content:!1}),{attached:pe.oneOfType([pe.bool,pe.oneOf(["top","bottom"])]),contentPosition:pe.oneOf(["start","end"]),density:pe.oneOf(["comfy","compact"]),gutter:oo,message:oo}),e.handledProps=Object.keys(e.propTypes),e.create=Co({Component:e,mappedProp:"message"}),e}();function Wo(e,r){if(null==e)return {};var o,t,n={},a=Object.keys(e);for(t=0;t<a.length;t++)o=a[t],r.indexOf(o)>=0||(n[o]=e[o]);return n}var Lo=function(e){var r;return {attributes:{wrapper:{role:"presentation"},root:(r={role:"button",tabIndex:0,"aria-haspopup":e.hasMenu?"true":void 0,"aria-disabled":e.disabled,"aria-label":e["aria-label"],"aria-labelledby":e["aria-labelledby"],"aria-describedby":e["aria-describedby"]},r[y]=!0,r)},keyActions:{wrapper:{performClick:{keyCombinations:[{keyCode:f.Enter},{keyCode:v}]},closeMenuAndFocusTrigger:{keyCombinations:[{keyCode:f.Escape}]},openMenu:!e.vertical&&{keyCombinations:[{keyCode:f.ArrowDown}]},doNotNavigateNextParentItem:{keyCombinations:e.hasMenu&&e.menuOpen?[{keyCode:f.ArrowLeft},{keyCode:f.ArrowRight}]:null}}}}},No=function(){return {attributes:{root:{role:"toolbar"}},focusZone:{props:{shouldFocusInnerElementWhenReceivedFocus:!0,direction:h.bidirectionalDomOrder}},childBehaviors:{item:Lo}}},Uo=function(e){return void 0===e},Zo=function(e){var r=S.useState(Uo(e.defaultValue)?e.initialValue:e.defaultValue),o=r[0],t=r[1],n=Uo(e.value)?o:e.value,a=S.useRef(n);S.useEffect((function(){a.current=n;}),[n]);var i=S.useCallback((function(e){a.current="function"==typeof e?e(a.current):e,t(a.current);}),[]);return [n,i]};function Vo(e,r){(null==r||r>e.length)&&(r=e.length);for(var o=0,t=new Array(r);o<r;o++)t[o]=e[o];return t}function Go(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];var t=S.useCallback((function(e){t.current=e;for(var o,n=function(e,r){var o="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(o)return (o=o.call(e)).next.bind(o);if(Array.isArray(e)||(o=function(e,r){if(e){if("string"==typeof e)return Vo(e,r);var o=Object.prototype.toString.call(e).slice(8,-1);return "Object"===o&&e.constructor&&(o=e.constructor.name),"Map"===o||"Set"===o?Array.from(e):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?Vo(e,r):void 0}}(e))||r&&e&&"number"==typeof e.length){o&&(e=o);var t=0;return function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(r);!(o=n()).done;){var a=o.value;"function"==typeof a?a(e):a&&(a.current=e);}}),[].concat(r));return t}const Xo=(e=>{var r={};return n.d(r,e),r})({createPortal:()=>r__namespace.createPortal,findDOMNode:()=>r__namespace.findDOMNode});var Yo=function(e){function r(){for(var r,o=arguments.length,t=new Array(o),n=0;n<o;n++)t[n]=arguments[n];return (r=e.call.apply(e,[this].concat(t))||this).prevNode=void 0,r}le(r,e);var o=r.prototype;return o.componentDidMount=function(){var e=Xo.findDOMNode(this);this.prevNode=e,mr(this.props.innerRef,e);},o.componentDidUpdate=function(e){var r=Xo.findDOMNode(this);this.prevNode!==r&&(this.prevNode=r,mr(this.props.innerRef,r)),e.innerRef!==this.props.innerRef&&mr(this.props.innerRef,r);},o.componentWillUnmount=function(){mr(this.props.innerRef,null),delete this.prevNode;},o.render=function(){return this.props.children},r}(S.Component),$o=function(e){function r(){for(var r,o=arguments.length,t=new Array(o),n=0;n<o;n++)t[n]=arguments[n];return (r=e.call.apply(e,[this].concat(t))||this).currentNode=void 0,r.handleRefOverride=function(e){var o=r.props,t=o.children,n=o.innerRef;mr(t.ref,e),mr(n,e),r.currentNode=e;},r}le(r,e);var o=r.prototype;return o.componentDidUpdate=function(e){e.innerRef!==this.props.innerRef&&mr(this.props.innerRef,this.currentNode);},o.componentWillUnmount=function(){delete this.currentNode;},o.render=function(){var e=this.props.children;return S.cloneElement(e,{ref:this.handleRefOverride})},r}(S.Component),Ko=["children","innerRef"],qo=function(e){var r=e.children,o=e.innerRef,t=Wo(e,Ko),n=S.Children.only(r),a=vo.isForwardRef(n)?$o:Yo,i=n&&t&&Object.keys(t).length>0?S.cloneElement(n,t):n;return S.createElement(a,{innerRef:o},i)},Jo=["popper"];function Qo(e){if("object"==typeof e&&null!==e&&!Array.isArray(e)){var r=e,o=r.popper;return [Wo(r,Jo),o]}return [e,{}]}var et=function e(r){var o=r&&function(e){return "HTML"===e.nodeName?e:e.parentNode||e.host}(r);if(!o)return document.body;switch(o.nodeName){case"HTML":case"BODY":return o.ownerDocument.body;case"#document":return o.body}var t=function(e){return 1!==e.nodeType?{}:e.ownerDocument.defaultView.getComputedStyle(e,null)}(o),n=t.overflow,a=t.overflowX,i=t.overflowY;return /(auto|scroll|overlay)/.test(n+i+a)?o:e(o)},rt=function(e){var r=S.useRef((function(){throw new Error("Cannot call an event handler while rendering")}));return Ar((function(){r.current=e;}),[e]),S.useCallback((function(){return r.current.apply(void 0,arguments)}),[r])},ot=n(8838),tt=n.n(ot);function nt(e,r,o){var t=S.useRef(!0),n=S.useState((function(){return {value:e,callback:r,facade:{get current(){return a.value},set current(e){var r=a.value;if(r!==e){if(a.value=e,o&&t.current)return;a.callback(e,r);}}}}})),a=n[0];return Ar((function(){t.current=!1;}),[]),a.callback=r,a.facade}function at(e){var r=e.getBoundingClientRect();return {width:r.width,height:r.height,top:r.top,right:r.right,bottom:r.bottom,left:r.left,x:r.left,y:r.top}}var it="top",lt="bottom",st="right",ct="left",dt="auto",ut=[it,lt,st,ct],ft="start",gt="end",pt="clippingParents",bt="viewport",mt="popper",ht="reference",vt=ut.reduce((function(e,r){return e.concat([r+"-"+ft,r+"-"+gt])}),[]),yt=[].concat(ut,[dt]).reduce((function(e,r){return e.concat([r,r+"-"+ft,r+"-"+gt])}),[]),Ct=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function kt(e){if("[object Window]"!==e.toString()){var r=e.ownerDocument;return r?r.defaultView:window}return e}function wt(e){return e instanceof kt(e).Element||e instanceof Element}function xt(e){return e instanceof kt(e).HTMLElement||e instanceof HTMLElement}function St(e){return (wt(e)?e.ownerDocument:e.document).documentElement}function Bt(e){var r=kt(e);return {scrollLeft:r.pageXOffset,scrollTop:r.pageYOffset}}function Et(e){return at(St(e)).left+Bt(e).scrollLeft}function Ot(e){return kt(e).getComputedStyle(e)}function Ft(e){return e?(e.nodeName||"").toLowerCase():null}function At(e){return "html"===Ft(e)?e:e.assignedSlot||e.parentNode||e.host||St(e)}function Pt(e){var r=Ot(e),o=r.overflow,t=r.overflowX,n=r.overflowY;return /auto|scroll|overlay|hidden/.test(o+n+t)}function jt(e){return ["html","body","#document"].indexOf(Ft(e))>=0?e.ownerDocument.body:xt(e)&&Pt(e)?e:jt(At(e))}function Rt(e,r){void 0===r&&(r=[]);var o=jt(e),t="body"===Ft(o),n=kt(o),a=t?[n].concat(n.visualViewport||[],Pt(o)?o:[]):o,i=r.concat(a);return t?i:i.concat(Rt(At(a)))}function It(e){return ["table","td","th"].indexOf(Ft(e))>=0}function Mt(e){if(!xt(e)||"fixed"===Ot(e).position)return null;var r=e.offsetParent;if(r){var o=St(r);if("body"===Ft(r)&&"static"===Ot(r).position&&"static"!==Ot(o).position)return o}return r}function Dt(e){for(var r=kt(e),o=Mt(e);o&&It(o)&&"static"===Ot(o).position;)o=Mt(o);return o&&"body"===Ft(o)&&"static"===Ot(o).position?r:o||function(e){for(var r=At(e);xt(r)&&["html","body"].indexOf(Ft(r))<0;){var o=Ot(r);if("none"!==o.transform||"none"!==o.perspective||o.willChange&&"auto"!==o.willChange)return r;r=r.parentNode;}return null}(e)||r}function zt(e,r){var o=Boolean(r.getRootNode&&r.getRootNode().host);if(e.contains(r))return !0;if(o){var t=r;do{if(t&&e.isSameNode(t))return !0;t=t.parentNode||t.host;}while(t)}return !1}function _t(e){return Object.assign(Object.assign({},e),{},{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function Ht(e,r){return r===bt?_t(function(e){var r=kt(e),o=St(e),t=r.visualViewport,n=o.clientWidth,a=o.clientHeight,i=0,l=0;return t&&(n=t.width,a=t.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(i=t.offsetLeft,l=t.offsetTop)),{width:n,height:a,x:i+Et(e),y:l}}(e)):xt(r)?function(e){var r=at(e);return r.top=r.top+e.clientTop,r.left=r.left+e.clientLeft,r.bottom=r.top+e.clientHeight,r.right=r.left+e.clientWidth,r.width=e.clientWidth,r.height=e.clientHeight,r.x=r.left,r.y=r.top,r}(r):_t(function(e){var r=St(e),o=Bt(e),t=e.ownerDocument.body,n=Math.max(r.scrollWidth,r.clientWidth,t?t.scrollWidth:0,t?t.clientWidth:0),a=Math.max(r.scrollHeight,r.clientHeight,t?t.scrollHeight:0,t?t.clientHeight:0),i=-o.scrollLeft+Et(e),l=-o.scrollTop;return "rtl"===Ot(t||r).direction&&(i+=Math.max(r.clientWidth,t?t.clientWidth:0)-n),{width:n,height:a,x:i,y:l}}(St(e)))}function Tt(e){return e.split("-")[0]}function Wt(e){return e.split("-")[1]}function Lt(e){return ["top","bottom"].indexOf(e)>=0?"x":"y"}function Nt(e){var r,o=e.reference,t=e.element,n=e.placement,a=n?Tt(n):null,i=n?Wt(n):null,l=o.x+o.width/2-t.width/2,s=o.y+o.height/2-t.height/2;switch(a){case it:r={x:l,y:o.y-t.height};break;case lt:r={x:l,y:o.y+o.height};break;case st:r={x:o.x+o.width,y:s};break;case ct:r={x:o.x-t.width,y:s};break;default:r={x:o.x,y:o.y};}var c=a?Lt(a):null;if(null!=c){var d="y"===c?"height":"width";switch(i){case ft:r[c]=Math.floor(r[c])-Math.floor(o[d]/2-t[d]/2);break;case gt:r[c]=Math.floor(r[c])+Math.ceil(o[d]/2-t[d]/2);}}return r}function Ut(e){return Object.assign(Object.assign({},{top:0,right:0,bottom:0,left:0}),e)}function Zt(e,r){return r.reduce((function(r,o){return r[o]=e,r}),{})}function Vt(e,r){void 0===r&&(r={});var o=r,t=o.placement,n=void 0===t?e.placement:t,a=o.boundary,i=void 0===a?pt:a,l=o.rootBoundary,s=void 0===l?bt:l,c=o.elementContext,d=void 0===c?mt:c,u=o.altBoundary,f=void 0!==u&&u,g=o.padding,p=void 0===g?0:g,b=Ut("number"!=typeof p?p:Zt(p,ut)),m=d===mt?ht:mt,h=e.elements.reference,v=e.rects.popper,y=e.elements[f?m:d],C=function(e,r,o){var t="clippingParents"===r?function(e){var r=Rt(At(e)),o=["absolute","fixed"].indexOf(Ot(e).position)>=0&&xt(e)?Dt(e):e;return wt(o)?r.filter((function(e){return wt(e)&&zt(e,o)&&"body"!==Ft(e)})):[]}(e):[].concat(r),n=[].concat(t,[o]),a=n[0],i=n.reduce((function(r,o){var t=Ht(e,o);return r.top=Math.max(t.top,r.top),r.right=Math.min(t.right,r.right),r.bottom=Math.min(t.bottom,r.bottom),r.left=Math.max(t.left,r.left),r}),Ht(e,a));return i.width=i.right-i.left,i.height=i.bottom-i.top,i.x=i.left,i.y=i.top,i}(wt(y)?y:y.contextElement||St(e.elements.popper),i,s),k=at(h),w=Nt({reference:k,element:v,strategy:"absolute",placement:n}),x=_t(Object.assign(Object.assign({},v),w)),S=d===mt?x:k,B={top:C.top-S.top+b.top,bottom:S.bottom-C.bottom+b.bottom,left:C.left-S.left+b.left,right:S.right-C.right+b.right},E=e.modifiersData.offset;if(d===mt&&E){var O=E[n];Object.keys(B).forEach((function(e){var r=[st,lt].indexOf(e)>=0?1:-1,o=[it,lt].indexOf(e)>=0?"y":"x";B[e]+=O[o]*r;}));}return B}function Gt(e,r,o){void 0===o&&(o=!1);var t,n,a=St(r),i=at(e),l=xt(r),s={scrollLeft:0,scrollTop:0},c={x:0,y:0};return (l||!l&&!o)&&(("body"!==Ft(r)||Pt(a))&&(s=(t=r)!==kt(t)&&xt(t)?{scrollLeft:(n=t).scrollLeft,scrollTop:n.scrollTop}:Bt(t)),xt(r)?((c=at(r)).x+=r.clientLeft,c.y+=r.clientTop):a&&(c.x=Et(a))),{x:i.left+s.scrollLeft-c.x,y:i.top+s.scrollTop-c.y,width:i.width,height:i.height}}function Xt(e){return {x:e.offsetLeft,y:e.offsetTop,width:e.offsetWidth,height:e.offsetHeight}}function Yt(e){var r=new Map,o=new Set,t=[];function n(e){o.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!o.has(e)){var t=r.get(e);t&&n(t);}})),t.push(e);}return e.forEach((function(e){r.set(e.name,e);})),e.forEach((function(e){o.has(e.name)||n(e);})),t}var $t={placement:"bottom",modifiers:[],strategy:"absolute"};function Kt(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return !r.some((function(e){return !(e&&"function"==typeof e.getBoundingClientRect)}))}function qt(e){void 0===e&&(e={});var r=e,o=r.defaultModifiers,t=void 0===o?[]:o,n=r.defaultOptions,a=void 0===n?$t:n;return function(e,r,o){void 0===o&&(o=a);var n,i,l={placement:"bottom",orderedModifiers:[],options:Object.assign(Object.assign({},$t),a),modifiersData:{},elements:{reference:e,popper:r},attributes:{},styles:{}},s=[],c=!1,d={state:l,setOptions:function(o){u(),l.options=Object.assign(Object.assign(Object.assign({},a),l.options),o),l.scrollParents={reference:wt(e)?Rt(e):e.contextElement?Rt(e.contextElement):[],popper:Rt(r)};var n,i,c=function(e){var r=Yt(e);return Ct.reduce((function(e,o){return e.concat(r.filter((function(e){return e.phase===o})))}),[])}((n=[].concat(t,l.options.modifiers),i=n.reduce((function(e,r){var o=e[r.name];return e[r.name]=o?Object.assign(Object.assign(Object.assign({},o),r),{},{options:Object.assign(Object.assign({},o.options),r.options),data:Object.assign(Object.assign({},o.data),r.data)}):r,e}),{}),Object.keys(i).map((function(e){return i[e]}))));return l.orderedModifiers=c.filter((function(e){return e.enabled})),l.orderedModifiers.forEach((function(e){var r=e.name,o=e.options,t=void 0===o?{}:o,n=e.effect;if("function"==typeof n){var a=n({state:l,name:r,instance:d,options:t});s.push(a||function(){});}})),d.update()},forceUpdate:function(){if(!c){var e=l.elements,r=e.reference,o=e.popper;if(Kt(r,o)){l.rects={reference:Gt(r,Dt(o),"fixed"===l.options.strategy),popper:Xt(o)},l.reset=!1,l.placement=l.options.placement,l.orderedModifiers.forEach((function(e){return l.modifiersData[e.name]=Object.assign({},e.data)}));for(var t=0;t<l.orderedModifiers.length;t++)if(!0!==l.reset){var n=l.orderedModifiers[t],a=n.fn,i=n.options,s=void 0===i?{}:i,u=n.name;"function"==typeof a&&(l=a({state:l,options:s,name:u,instance:d})||l);}else l.reset=!1,t=-1;}}},update:(n=function(){return new Promise((function(e){d.forceUpdate(),e(l);}))},function(){return i||(i=new Promise((function(e){Promise.resolve().then((function(){i=void 0,e(n());}));}))),i}),destroy:function(){u(),c=!0;}};if(!Kt(e,r))return d;function u(){s.forEach((function(e){return e()})),s=[];}return d.setOptions(o).then((function(e){!c&&o.onFirstUpdate&&o.onFirstUpdate(e);})),d}}var Jt={passive:!0},Qt={top:"auto",right:"auto",bottom:"auto",left:"auto"};function en(e){var r,o=e.popper,t=e.popperRect,n=e.placement,a=e.offsets,i=e.position,l=e.gpuAcceleration,s=e.adaptive,c=function(e){var r=e.x,o=e.y,t=window.devicePixelRatio||1;return {x:Math.round(r*t)/t||0,y:Math.round(o*t)/t||0}}(a),d=c.x,u=c.y,f=a.hasOwnProperty("x"),g=a.hasOwnProperty("y"),p=ct,b=it,m=window;if(s){var h=Dt(o);h===kt(o)&&(h=St(o)),n===it&&(b=lt,u-=h.clientHeight-t.height,u*=l?1:-1),n===ct&&(p=st,d-=h.clientWidth-t.width,d*=l?1:-1);}var v,y=Object.assign({position:i},s&&Qt);return l?Object.assign(Object.assign({},y),{},((v={})[b]=g?"0":"",v[p]=f?"0":"",v.transform=(m.devicePixelRatio||1)<2?"translate("+d+"px, "+u+"px)":"translate3d("+d+"px, "+u+"px, 0)",v)):Object.assign(Object.assign({},y),{},((r={})[b]=g?u+"px":"",r[p]=f?d+"px":"",r.transform="",r))}const rn={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var r=e.state;Object.keys(r.elements).forEach((function(e){var o=r.styles[e]||{},t=r.attributes[e]||{},n=r.elements[e];xt(n)&&Ft(n)&&(Object.assign(n.style,o),Object.keys(t).forEach((function(e){var r=t[e];!1===r?n.removeAttribute(e):n.setAttribute(e,!0===r?"":r);})));}));},effect:function(e){var r=e.state,o={popper:{position:r.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(r.elements.popper.style,o.popper),r.elements.arrow&&Object.assign(r.elements.arrow.style,o.arrow),function(){Object.keys(r.elements).forEach((function(e){var t=r.elements[e],n=r.attributes[e]||{},a=Object.keys(r.styles.hasOwnProperty(e)?r.styles[e]:o[e]).reduce((function(e,r){return e[r]="",e}),{});xt(t)&&Ft(t)&&(Object.assign(t.style,a),Object.keys(n).forEach((function(e){t.removeAttribute(e);})));}));}},requires:["computeStyles"]},on={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var r=e.state,o=e.options,t=e.name,n=o.offset,a=void 0===n?[0,0]:n,i=yt.reduce((function(e,o){return e[o]=function(e,r,o){var t=Tt(e),n=[ct,it].indexOf(t)>=0?-1:1,a="function"==typeof o?o(Object.assign(Object.assign({},r),{},{placement:e})):o,i=a[0],l=a[1];return i=i||0,l=(l||0)*n,[ct,st].indexOf(t)>=0?{x:l,y:i}:{x:i,y:l}}(o,r.rects,a),e}),{}),l=i[r.placement],s=l.x,c=l.y;null!=r.modifiersData.popperOffsets&&(r.modifiersData.popperOffsets.x+=s,r.modifiersData.popperOffsets.y+=c),r.modifiersData[t]=i;}};var tn={left:"right",right:"left",bottom:"top",top:"bottom"};function nn(e){return e.replace(/left|right|bottom|top/g,(function(e){return tn[e]}))}var an={start:"end",end:"start"};function ln(e){return e.replace(/start|end/g,(function(e){return an[e]}))}const sn={name:"flip",enabled:!0,phase:"main",fn:function(e){var r=e.state,o=e.options,t=e.name;if(!r.modifiersData[t]._skip){for(var n=o.mainAxis,a=void 0===n||n,i=o.altAxis,l=void 0===i||i,s=o.fallbackPlacements,c=o.padding,d=o.boundary,u=o.rootBoundary,f=o.altBoundary,g=o.flipVariations,p=void 0===g||g,b=o.allowedAutoPlacements,m=r.options.placement,h=Tt(m),v=s||(h!==m&&p?function(e){if(Tt(e)===dt)return [];var r=nn(e);return [ln(e),r,ln(r)]}(m):[nn(m)]),y=[m].concat(v).reduce((function(e,o){return e.concat(Tt(o)===dt?function(e,r){void 0===r&&(r={});var o=r,t=o.placement,n=o.boundary,a=o.rootBoundary,i=o.padding,l=o.flipVariations,s=o.allowedAutoPlacements,c=void 0===s?yt:s,d=Wt(t),u=d?l?vt:vt.filter((function(e){return Wt(e)===d})):ut,f=u.filter((function(e){return c.indexOf(e)>=0}));0===f.length&&(f=u);var g=f.reduce((function(r,o){return r[o]=Vt(e,{placement:o,boundary:n,rootBoundary:a,padding:i})[Tt(o)],r}),{});return Object.keys(g).sort((function(e,r){return g[e]-g[r]}))}(r,{placement:o,boundary:d,rootBoundary:u,padding:c,flipVariations:p,allowedAutoPlacements:b}):o)}),[]),C=r.rects.reference,k=r.rects.popper,w=new Map,x=!0,S=y[0],B=0;B<y.length;B++){var E=y[B],O=Tt(E),F=Wt(E)===ft,A=[it,lt].indexOf(O)>=0,P=A?"width":"height",j=Vt(r,{placement:E,boundary:d,rootBoundary:u,altBoundary:f,padding:c}),R=A?F?st:ct:F?lt:it;C[P]>k[P]&&(R=nn(R));var I=nn(R),M=[];if(a&&M.push(j[O]<=0),l&&M.push(j[R]<=0,j[I]<=0),M.every((function(e){return e}))){S=E,x=!1;break}w.set(E,M);}if(x)for(var D=function(e){var r=y.find((function(r){var o=w.get(r);if(o)return o.slice(0,e).every((function(e){return e}))}));if(r)return S=r,"break"},z=p?3:1;z>0&&"break"!==D(z);z--);r.placement!==S&&(r.modifiersData[t]._skip=!0,r.placement=S,r.reset=!0);}},requiresIfExists:["offset"],data:{_skip:!1}};function cn(e,r,o){return Math.max(e,Math.min(r,o))}const dn={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var r=e.state,o=e.options,t=e.name,n=o.mainAxis,a=void 0===n||n,i=o.altAxis,l=void 0!==i&&i,s=o.boundary,c=o.rootBoundary,d=o.altBoundary,u=o.padding,f=o.tether,g=void 0===f||f,p=o.tetherOffset,b=void 0===p?0:p,m=Vt(r,{boundary:s,rootBoundary:c,padding:u,altBoundary:d}),h=Tt(r.placement),v=Wt(r.placement),y=!v,C=Lt(h),k="x"===C?"y":"x",w=r.modifiersData.popperOffsets,x=r.rects.reference,S=r.rects.popper,B="function"==typeof b?b(Object.assign(Object.assign({},r.rects),{},{placement:r.placement})):b,E={x:0,y:0};if(w){if(a){var O="y"===C?it:ct,F="y"===C?lt:st,A="y"===C?"height":"width",P=w[C],j=w[C]+m[O],R=w[C]-m[F],I=g?-S[A]/2:0,M=v===ft?x[A]:S[A],D=v===ft?-S[A]:-x[A],z=r.elements.arrow,_=g&&z?Xt(z):{width:0,height:0},H=r.modifiersData["arrow#persistent"]?r.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},T=H[O],W=H[F],L=cn(0,x[A],_[A]),N=y?x[A]/2-I-L-T-B:M-L-T-B,U=y?-x[A]/2+I+L+W+B:D+L+W+B,Z=r.elements.arrow&&Dt(r.elements.arrow),V=Z?"y"===C?Z.clientTop||0:Z.clientLeft||0:0,G=r.modifiersData.offset?r.modifiersData.offset[r.placement][C]:0,X=w[C]+N-G-V,Y=w[C]+U-G,$=cn(g?Math.min(j,X):j,P,g?Math.max(R,Y):R);w[C]=$,E[C]=$-P;}if(l){var K="x"===C?it:ct,q="x"===C?lt:st,J=w[k],Q=cn(J+m[K],J,J-m[q]);w[k]=Q,E[k]=Q-J;}r.modifiersData[t]=E;}},requiresIfExists:["offset"]},un={name:"arrow",enabled:!0,phase:"main",fn:function(e){var r,o=e.state,t=e.name,n=o.elements.arrow,a=o.modifiersData.popperOffsets,i=Tt(o.placement),l=Lt(i),s=[ct,st].indexOf(i)>=0?"height":"width";if(n&&a){var c=o.modifiersData[t+"#persistent"].padding,d=Xt(n),u="y"===l?it:ct,f="y"===l?lt:st,g=o.rects.reference[s]+o.rects.reference[l]-a[l]-o.rects.popper[s],p=a[l]-o.rects.reference[l],b=Dt(n),m=b?"y"===l?b.clientHeight||0:b.clientWidth||0:0,h=g/2-p/2,v=c[u],y=m-d[s]-c[f],C=m/2-d[s]/2+h,k=cn(v,C,y),w=l;o.modifiersData[t]=((r={})[w]=k,r.centerOffset=k-C,r);}},effect:function(e){var r=e.state,o=e.options,t=e.name,n=o.element,a=void 0===n?"[data-popper-arrow]":n,i=o.padding,l=void 0===i?0:i;null!=a&&("string"!=typeof a||(a=r.elements.popper.querySelector(a)))&&zt(r.elements.popper,a)&&(r.elements.arrow=a,r.modifiersData[t+"#persistent"]={padding:Ut("number"!=typeof l?l:Zt(l,ut))});},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function fn(e,r,o){return void 0===o&&(o={x:0,y:0}),{top:e.top-r.height-o.y,right:e.right-r.width+o.x,bottom:e.bottom-r.height+o.y,left:e.left-r.width-o.x}}function gn(e){return [it,st,lt,ct].some((function(r){return e[r]>=0}))}var pn=qt({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var r=e.state,o=e.instance,t=e.options,n=t.scroll,a=void 0===n||n,i=t.resize,l=void 0===i||i,s=kt(r.elements.popper),c=[].concat(r.scrollParents.reference,r.scrollParents.popper);return a&&c.forEach((function(e){e.addEventListener("scroll",o.update,Jt);})),l&&s.addEventListener("resize",o.update,Jt),function(){a&&c.forEach((function(e){e.removeEventListener("scroll",o.update,Jt);})),l&&s.removeEventListener("resize",o.update,Jt);}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var r=e.state,o=e.name;r.modifiersData[o]=Nt({reference:r.rects.reference,element:r.rects.popper,strategy:"absolute",placement:r.placement});},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var r=e.state,o=e.options,t=o.gpuAcceleration,n=void 0===t||t,a=o.adaptive,i=void 0===a||a,l={placement:Tt(r.placement),popper:r.elements.popper,popperRect:r.rects.popper,gpuAcceleration:n};null!=r.modifiersData.popperOffsets&&(r.styles.popper=Object.assign(Object.assign({},r.styles.popper),en(Object.assign(Object.assign({},l),{},{offsets:r.modifiersData.popperOffsets,position:r.options.strategy,adaptive:i})))),null!=r.modifiersData.arrow&&(r.styles.arrow=Object.assign(Object.assign({},r.styles.arrow),en(Object.assign(Object.assign({},l),{},{offsets:r.modifiersData.arrow,position:"absolute",adaptive:!1})))),r.attributes.popper=Object.assign(Object.assign({},r.attributes.popper),{},{"data-popper-placement":r.placement});},data:{}},rn,on,sn,dn,un,{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var r=e.state,o=e.name,t=r.rects.reference,n=r.rects.popper,a=r.modifiersData.preventOverflow,i=Vt(r,{elementContext:"reference"}),l=Vt(r,{altBoundary:!0}),s=fn(i,t),c=fn(l,n,a),d=gn(s),u=gn(c);r.modifiersData[o]={referenceClippingOffsets:s,popperEscapeOffsets:c,isReferenceHidden:d,hasPopperEscaped:u},r.attributes.popper=Object.assign(Object.assign({},r.attributes.popper),{},{"data-popper-reference-hidden":d,"data-popper-escaped":u});}}]}),bn="object"==typeof document&&null!==document,mn="object"==typeof window&&null!==window&&window.self===window,hn=function(){return bn&&mn};function vn(e,r){if("window"===r)return e.ownerDocument.documentElement;if("scrollParent"===r){var o=et(e);return "BODY"===o.nodeName&&(o=e.ownerDocument.documentElement),o}return r}var yn,Cn={name:"is-intersecting-modifier",enabled:!0,phase:"main",requires:["preventOverflow"],fn:function(e){var r=e.state,o=e.name,t=r.rects.popper,n=Vt(r,{altBoundary:!0}),a=n.top<t.height&&n.top>0,i=n.bottom<t.height&&n.bottom>0,l=a||i;r.modifiersData[o]={isIntersecting:l},r.attributes.popper=Object.assign({},r.attributes.popper,{"data-popper-is-intersecting":l});}};!function(e){e.top="top",e.bottom="bottom",e.start="start",e.end="end",e.left="left",e.right="right",e.center="";}(yn||(yn={}));var kn=function(e,r,o){var t,n,a,i,l=(i="top"===(n=e)||"bottom"===n,(a="above"===(t=r)||"below"===t)&&i||!a&&!i?"center":e),s=function(e){return {above:yn.top,below:yn.bottom,before:e?yn.right:yn.left,after:e?yn.left:yn.right}}(o)[r],c=function(e){return {start:e?yn.end:yn.start,end:e?yn.start:yn.end,top:yn.start,bottom:yn.end,center:yn.center}}(o)[l];return ""+s+(c&&"-"+c)},wn=function e(r){if(void 0!==r)return Array.isArray(r)?(r[0]=-1*r[0],r):function(o){return e(r(o))}};function xn(e,r){var o,t,n=e.autoSize,a=e.flipBoundary,i=e.offset,l=e.onStateUpdate,s=e.overflowBoundary,c=e.rtl,d=e.unstable_disableTether,u=e.unstable_pinned,f=kn(e.align,e.position,e.rtl),g=e.positionFixed?"fixed":"absolute",p=rt((function(e){var r=e.state;l&&l(r);})),b=S.useMemo((function(){return i?{name:"offset",options:{offset:c?wn(i):i}}:null}),[i,c]),m=(o=e.modifiers,(t=S.useRef()).current&&tt()(o,t.current.key)||(t.current={key:o,value:e.modifiers}),t.current.value);return S.useCallback((function(e,o,t){var i=et(o),l=!!i&&i!==i.ownerDocument.body,c=[Cn,{name:"positionStyleFix",enabled:!0,phase:"afterWrite",effect:function(e){var o=e.state;return !1!==e.instance.isFirstRun&&(r.current=o.elements.popper.style.position,o.elements.popper.style.position="fixed"),function(){}},requires:[]},{name:"flip",options:{flipVariations:!0}},u&&{name:"flip",enabled:!1},l&&{name:"flip",options:{boundary:"clippingParents"}},l&&{name:"preventOverflow",options:{boundary:"clippingParents"}},b].concat("function"==typeof m?m(e,o,t):m,[d&&{name:"preventOverflow",options:{altAxis:"all"===d,tether:!1}},a&&{name:"flip",options:{altBoundary:!0,boundary:vn(o,a)}},s&&{name:"preventOverflow",options:{altBoundary:!0,boundary:vn(o,s)}},{name:"onUpdate",enabled:!0,phase:"afterWrite",fn:p},n&&{name:"applyMaxSize",enabled:!0,phase:"beforeWrite",requiresIfExists:["offset","preventOverflow","flip"],options:{altBoundary:!0,boundary:vn(o,s)},fn:function(e){var r=e.state,o=Vt(r,e.options),t=r.modifiersData.preventOverflow||{x:0,y:0},a=t.x,i=t.y,l=r.rects.popper,s=l.width,c=l.height,d=r.placement.split("-")[0],u="left"===d?"left":"right",f="top"===d?"top":"bottom",g="always"===n||"width-always"===n||o[u]>0&&(!0===n||"width"===n),p="always"===n||"height-always"===n||o[f]>0&&(!0===n||"height"===n);g&&(r.styles.popper.maxWidth=s-o[u]-a+"px"),p&&(r.styles.popper.maxHeight=c-o[f]-i+"px");}},{name:"arrow",enabled:!!t,options:{element:t}}]).filter(Boolean);return {modifiers:c,placement:f,strategy:g,onFirstUpdate:function(e){return p({state:e})}}}),[n,a,b,s,f,g,d,u,m,p,r])}function Sn(e){void 0===e&&(e={});var r,o=e.enabled,t=void 0===o||o,n=(r=S.useRef(!0)).current?(r.current=!1,!0):r.current,a=S.useRef("absolute"),i=xn(e,a),l=S.useRef(null),s=rt((function(){var e;null==(e=l.current)||e.destroy(),l.current=null;var r=null;if(hn()&&t&&c.current&&d.current&&(r=pn(c.current,d.current,i(c.current,d.current,u.current))),r){var o=r.forceUpdate;r.isFirstRun=!0,r.forceUpdate=function(){r.isFirstRun&&(r.state.elements.popper.style.position=a.current,r.isFirstRun=!1),o();};}l.current=r;})),c=nt(null,s,!0),d=nt(null,s,!0),u=nt(null,s,!0);return S.useImperativeHandle(e.popperRef,(function(){return {updatePosition:function(){var e;null==(e=l.current)||e.update();}}}),[]),Ar((function(){return s(),function(){var e;null==(e=l.current)||e.destroy(),l.current=null;}}),[e.enabled]),Ar((function(){var e;n||null==(e=l.current)||e.setOptions(i(c.current,d.current,u.current));}),[i]),{targetRef:c,containerRef:d,arrowRef:u}}var Bn=n(7882),En=n.n(Bn),On=function(){var e=function e(r){var o=J(),t=re(e.displayName,o.telemetry),n=t.setStart,a=t.setEnd;n();var i,l=r.align,s=r.children,c=r.className,d=r.design,u=r.grow,f=r.flexDirection,g=r.push,p=r.shrink,b=r.size,m=r.styles,h=r.variables,v=Lr(e.displayName,{className:"ui-flex__item",mapPropsToStyles:function(){return {align:l,grow:u,flexDirection:f,push:g,shrink:p,size:b}},mapPropsToInlineStyles:function(){return {className:c,design:d,styles:m,variables:h}},rtl:o.rtl}),y=v.classes,C=v.styles;return i="function"==typeof s?s({styles:C.root,classes:y.root}):Dr()(s)?null:function(e,r,o){return r?"string"==typeof e.type?S.cloneElement(e,{className:ge()(e.props.className,o.root)}):S.cloneElement(e,{styles:Y(r.root||{},e.props.styles)}):e}(S.Children.only(s),C,y),a(),i};return e.displayName="FlexItem",e.propTypes=Object.assign({},go({children:!1,accessibility:!1,content:!1}),{children:pe.oneOfType([pe.element,pe.func]),align:pe.oneOf(["auto","start","end","center","baseline","stretch"]),size:pe.oneOfType([pe.oneOf(["size.half","size.quarter","size.small","size.medium","size.large"]),pe.string]),shrink:pe.oneOfType([pe.bool,pe.number]),push:pe.bool,flexDirection:pe.oneOf(["row","column"])}),e.__isFlexItem=!0,e}(),Fn="ui-flex",An=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.children,s=r.className,c=r.column,d=r.debug,u=r.design,f=r.fill,g=r.gap,p=r.hAlign,b=r.inline,m=r.padding,h=r.space,v=r.styles,y=r.variables,C=r.vAlign,k=r.wrap,w=Lr(e.displayName,{className:Fn,mapPropsToStyles:function(){return {column:c,debug:d,fill:f,gap:g,hAlign:p,inline:b,padding:m,space:h,vAlign:C,wrap:k}},mapPropsToInlineStyles:function(){return {className:s,design:u,styles:v,variables:y}},rtl:t.rtl}).classes,x=or(r),B=Nr(e.handledProps,r),E=S.Children.map(l,(function(e){return En()(e,"type.__isFlexItem")?S.cloneElement(e,{flexDirection:c?"column":"row"}):e})),O=S.createElement(x,ae({className:w.root},B,{ref:o}),E);return i(),O}));return e.displayName="Flex",e.propTypes=Object.assign({},go({accessibility:!1,content:!1}),{inline:pe.bool,column:pe.bool,wrap:pe.bool,hAlign:pe.oneOf(["start","center","end","stretch"]),vAlign:pe.oneOf(["start","center","end","stretch"]),space:pe.oneOf(["around","between","evenly"]),gap:pe.oneOf(["gap.smaller","gap.small","gap.medium","gap.large"]),padding:pe.oneOf(["padding.medium"]),fill:pe.bool,debug:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.Item=On,e}(),Pn=n(576),jn=n.n(Pn),Rn=function(e){return {attributes:{root:{"aria-hidden":e.alt||e["aria-label"]?void 0:"true"}}}},In=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.accessibility,s=r.alt,c=r["aria-label"],d=r.avatar,u=r.circular,f=r.className,g=r.design,p=r.fluid,b=r.styles,m=r.variables,h=Pr(l,{debugName:e.displayName,mapPropsToBehavior:function(){return {alt:s,"aria-label":c}},rtl:t.rtl}),v=Lr(e.displayName,{className:"ui-image",mapPropsToStyles:function(){return {avatar:d,circular:u,fluid:p}},mapPropsToInlineStyles:function(){return {className:f,design:g,styles:b,variables:m}},rtl:t.rtl}).classes,y=or(r),C=Nr(e.handledProps,r),k=S.createElement(y,h("root",Object.assign({className:v.root,ref:o},C)));return i(),k}));return e.displayName="Image",e.defaultProps={as:"img",accessibility:Rn},e.propTypes=Object.assign({},go({children:!1,content:!1}),{avatar:pe.bool,circular:pe.bool,fluid:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.create=Co({Component:e,mappedProp:"src",allowsJSX:!1}),e}(),Mn=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.accessibility,s=r.children,c=r.className,d=r.circular,u=r.color,f=r.content,g=r.icon,p=r.iconPosition,b=r.design,m=r.styles,h=r.variables,v=r.image,y=r.imagePosition,C=Pr(l,{debugName:e.displayName,rtl:t.rtl}),k=Lr(e.displayName,{className:"ui-label",mapPropsToStyles:function(){return {hasActionableIcon:jn()(g,"onClick"),hasImage:!!v,hasIcon:!!g,circular:d,color:u,imagePosition:y,iconPosition:p}},mapPropsToInlineStyles:function(){return {className:c,design:b,styles:m,variables:h}},rtl:t.rtl}),w=k.classes,x=k.styles,B=or(r),E=Nr(e.handledProps,r);if(fo(s)){var O=S.createElement(B,C("root",Object.assign({className:w.root,ref:o},uo({forElements:[s]}),E)),s);return i(),O}var F=In.create(v,{defaultProps:function(){return {styles:x.image}}}),A=Mo.create(g,{defaultProps:function(){return {styles:x.icon}}}),P=Mo.create(f,{defaultProps:function(){return {styles:x.content}}}),j="start"===y&&F,R="start"===p&&A,I="end"===p&&A,M="end"===y&&F,D=S.createElement(B,C("root",Object.assign({className:w.root,ref:o},E)),j,R,P,I,M);return i(),D}));return e.displayName="Label",e.propTypes=Object.assign({},go({color:!0,content:"shorthand"}),{circular:pe.bool,icon:eo,iconPosition:pe.oneOf(["start","end"]),image:no,imagePosition:pe.oneOf(["start","end"]),fluid:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.defaultProps={as:"span",imagePosition:"start",iconPosition:"end"},e.create=Co({Component:e,mappedProp:"content"}),e}(),Dn=n(2948),zn=n.n(Dn),_n=function(e){var r;return {attributes:{wrapper:{role:"presentation"},root:(r={role:"menuitem",tabIndex:0,"aria-expanded":e.hasMenu?e.menuOpen||!1:void 0,"aria-haspopup":e.hasMenu?"true":void 0,"aria-label":e["aria-label"],"aria-labelledby":e["aria-labelledby"],"aria-describedby":e["aria-describedby"],"aria-disabled":e.disabled},r[y]=!0,r)},keyActions:{root:{performClick:{keyCombinations:[{keyCode:f.Enter},{keyCode:v}]}},wrapper:{closeAllMenus:{keyCombinations:[{keyCode:f.Enter},{keyCode:v}]},closeAllMenusAndFocusNextParentItem:{keyCombinations:[{keyCode:f.ArrowRight}]},closeMenuAndFocusTrigger:{keyCombinations:[{keyCode:f.Escape}]},closeMenu:{keyCombinations:[{keyCode:f.ArrowLeft}]},openMenu:{keyCombinations:[{keyCode:e.vertical?f.ArrowRight:f.ArrowDown}]}}}}},Hn=function(){return {attributes:{root:{role:"presentation"}}}},Tn=function(e){return {attributes:{root:{role:"menu"}},focusZone:{props:{isCircularNavigation:!0,shouldFocusInnerElementWhenReceivedFocus:!0,direction:e.vertical?h.vertical:h.horizontal}},childBehaviors:{item:_n,divider:Hn}}};function Wn(e,r){return e&&r?_r()(e)&&_r()(r)?H(e,r):U(e,r):e||r}var Ln=function(e,r){return "object"==typeof e&&e.kind?e.kind:r},Nn=function(){return {attributes:{root:{role:"menu"}},focusZone:{props:{isCircularNavigation:!0,shouldFocusOnMount:!0,direction:h.vertical}},childBehaviors:{item:_n}}},Un=function(e,r){return !!e&&!!e[r]},Zn=function(){function e(e){return function(e){var r=e.capture,o=e.listener,t=e.type,n=e.target,a=e.targetRef,i=S.useRef(o);i.current=o;var l=S.useCallback((function(e){return i.current(e)}),[]),s=S.useRef(void 0);S.useEffect((function(){var e=void 0===a?n:a.current,o=function(e){var r,o,t;if(e)return "object"==typeof e.window&&e.window===e?e.event:null!=(r=null==(o=e.ownerDocument)||null==(t=o.defaultView)?void 0:t.event)?r:void 0}(window),i=function(e){e!==o?l(e):o=void 0;};return Un(e,"addEventListener")&&e.addEventListener(t,i,r),s.current=setTimeout((function(){o=void 0;}),1),function(){clearTimeout(s.current),o=void 0,Un(e,"removeEventListener")&&e.removeEventListener(t,i,r);}}),[r,l,n,a,t]);}(e),null}return e.defaultProps={capture:!1},e}(),Vn="fuiframefocus",Gn=n(3379),Xn=n.n(Gn),Yn=n(5313),$n=n.n(Yn),Kn=function(e,r,o,t){if(void 0===o&&(o=document),void 0===t&&(t=!0),$n()([r,e],Dr()))return !1;if(r.target&&(ce()(r.target,"setAttribute","data-suir-click-target",!0),o.querySelector("[data-suir-click-target=true]")))return ce()(r.target,"removeAttribute","data-suir-click-target"),ke(e,r.target,t);var n=r.clientX,a=r.clientY;if($n()([n,a],Dr()))return !1;var i=e.getClientRects();if(!(e.offsetWidth&&e.offsetHeight&&i&&i.length))return !1;var l=Yr()(i),s=l.top,c=l.bottom,d=l.left,u=l.right;return !$n()([s,c,d,u],Dr())&&Xn()(a,s,c+.001)&&Xn()(n,d,u+.001)},qn="initial",Jn=null,Qn=[16,17,18,91,93],ea="whatInputInitialized",ra={keydown:"keyboard",keyup:"keyboard",mousedown:"mouse",mousemove:"mouse",MSPointerDown:"pointer",MSPointerMove:"pointer",pointerdown:"pointer",pointermove:"pointer",touchstart:"touch"},oa=!1,ta={2:"touch",3:"touch",4:"mouse"},na=!1;try{var aa=Object.defineProperty({},"passive",{get:function(){na=!0;}});window.addEventListener("test",null,aa);}catch(e){}var ia=function(e){var r=!na||{passive:!0,capture:!0};e.PointerEvent?e.addEventListener("pointerdown",la):window.MSPointerEvent?e.addEventListener("MSPointerDown",la):(e.addEventListener("mousedown",la,!0),"ontouchstart"in e&&(e.addEventListener("touchstart",ca,r),e.addEventListener("touchend",la,!0))),e.addEventListener("keydown",ca,!0),e.addEventListener("keyup",ca,!0);},la=function(e){if(!oa){var r=e.which,o=ra[e.type];"pointer"===o&&(o=da(e));var t=-1===Qn.indexOf(r);qn!==o&&("keyboard"===o&&r&&t||"mouse"===o||"touch"===o)&&(qn=o,sa(e.view.document));}},sa=function(e){e.documentElement.setAttribute("data-whatinput",qn);},ca=function(e){la(e),window.clearTimeout(Jn),oa=!0,Jn=window.setTimeout((function(){oa=!1;}),100);},da=function(e){return "number"==typeof e.pointerType?ta[e.pointerType]:"pen"===e.pointerType?"touch":e.pointerType};hn()&&"addEventListener"in window&&Array.prototype.indexOf&&(ra["onwheel"in document.createElement("div")?"wheel":void 0!==document.onmousewheel?"mousewheel":"DOMMouseScroll"]="mouse",ia(window),sa(window.document));var ua=function(e,r){qn=r,sa(e);},fa=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.className,s=r.children,c=r.design,d=r.styles,u=r.variables,f=r.content,g=r.hasContent,p=r.iconOnly,b=Lr(e.displayName,{className:"ui-menu__itemicon",mapPropsToStyles:function(){return {hasContent:g,iconOnly:p}},mapPropsToInlineStyles:function(){return {className:l,design:c,styles:d,variables:u}},rtl:t.rtl}).classes,m=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),h=or(r),v=Nr(e.handledProps,r),y=S.createElement(h,m("root",Object.assign({className:b.root,ref:o},v)),fo(s)?s:f);return i(),y}));return e.displayName="MenuItemIcon",e.defaultProps={as:"span"},e.propTypes=Object.assign({},go(),{hasContent:pe.bool,iconOnly:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.shorthandConfig={mappedProp:"content"},e}(),ga=Bo({activeIndex:-1,vertical:!1,variables:{},onItemClick:null,onItemSelect:null,slotProps:{item:{},divider:{}},behaviors:{item:void 0,divider:void 0}}),pa=ga.Provider,ba=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=Eo(ga,{vertical:function(e){return e.vertical}}),s=r.className,c=r.children,d=r.design,u=r.styles,f=r.variables,g=r.content,p=r.hasMenu,b=r.hasIcon,m=r.vertical,h=r.inSubmenu,v=Lr(e.displayName,{className:"ui-menu__itemcontent",mapPropsToStyles:function(){return {hasMenu:p,hasIcon:b,vertical:m||l.vertical,inSubmenu:h}},mapPropsToInlineStyles:function(){return {className:s,design:d,styles:u,variables:f}},rtl:t.rtl}).classes,y=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),C=or(r),k=Nr(e.handledProps,r),w=S.createElement(C,y("root",Object.assign({className:v.root},uo({forElements:[c,g]}),{ref:o},k)),fo(c)?c:g);return i(),w}));return e.displayName="MenuItemContent",e.defaultProps={as:"span"},e.propTypes=Object.assign({},go(),{hasIcon:pe.bool,hasMenu:pe.bool,vertical:pe.bool,inSubmenu:pe.bool}),e.shorthandConfig={mappedProp:"content"},e.handledProps=Object.keys(e.propTypes),e}(),ma=function(){return {attributes:{root:{role:"img","aria-hidden":"true"}}}},ha="ui-menu__itemindicator",va=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.className,s=r.children,c=r.design,d=r.styles,u=r.variables,f=r.content,g=r.iconOnly,p=r.vertical,b=r.inSubmenu,m=r.active,h=r.primary,v=r.underlined,y=Lr(e.displayName,{className:ha,mapPropsToStyles:function(){return {iconOnly:g,vertical:p,inSubmenu:b,active:m,primary:h,underlined:v}},mapPropsToInlineStyles:function(){return {className:l,design:c,styles:d,variables:u}},rtl:t.rtl}).classes,C=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),k=or(r),w=Nr(e.handledProps,r),x=S.createElement(k,C("root",Object.assign({className:y.root,ref:o},w)),fo(s)?s:f);return i(),x}));return e.displayName="MenuItemIndicator",e.defaultProps={as:"span",accessibility:ma},e.propTypes=Object.assign({},go(),{iconOnly:pe.bool,vertical:pe.bool,inSubmenu:pe.bool,active:pe.bool,primary:pe.bool,underlined:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.shorthandConfig={mappedProp:"content"},e}(),ya=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.className,s=r.children,c=r.design,d=r.styles,u=r.variables,f=r.content,g=r.active,p=r.disabled,b=r.iconOnly,m=r.isFromKeyboard,h=r.pills,v=r.pointing,y=r.secondary,C=r.underlined,k=r.vertical,w=r.primary,x=r.on,B=Lr(e.displayName,{className:"ui-menu__itemwrapper",mapPropsToStyles:function(){return {active:g,disabled:p,iconOnly:b,isFromKeyboard:m,pills:h,pointing:v,secondary:y,underlined:C,vertical:k,primary:w,on:x}},mapPropsToInlineStyles:function(){return {className:l,design:c,styles:d,variables:u}},rtl:t.rtl}).classes,E=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),O=or(r),F=Nr(e.handledProps,r),A=S.createElement(O,E("root",Object.assign({className:B.root,ref:o},F)),fo(s)?s:f);return i(),A}));return e.displayName="MenuItemWrapper",e.defaultProps={as:"li"},e.propTypes=Object.assign({},go(),{active:pe.bool,disabled:pe.bool,iconOnly:pe.bool,isFromKeyboard:pe.bool,pills:pe.bool,pointing:pe.oneOf(["start","end",!0,!1]),primary:Jr([qr(["secondary"]),pe.bool]),secondary:Jr([qr(["primary"]),pe.bool]),underlined:pe.bool,vertical:pe.bool,on:pe.oneOf(["hover"])}),e.handledProps=Object.keys(e.propTypes),e.shorthandConfig={mappedProp:"content"},e}(),Ca=function(){var e=function(e){var r="function"==typeof e.children,o=kn(e.align,e.position,e.rtl),t=S.useRef(o),n=S.useState(o),a=n[0],i=n[1],l=S.useRef(null),s=Sn(Object.assign({},e,{popperRef:Go(e.popperRef,l),onStateUpdate:function(e){e.placement!==t.current&&(t.current=e.placement,r&&i(e.placement));}})),c=s.targetRef,d=s.containerRef,u=s.arrowRef;Ar((function(){var r,o;c.current=null!==(o=e.targetRef)&&"object"==typeof o&&o.hasOwnProperty("current")?e.targetRef.current:e.targetRef,u.current=null==(r=e.pointerTargetRef)?void 0:r.current;}));var f=S.useCallback((function(){var e;null==(e=l.current)||e.updatePosition();}),[]),g=r?e.children({placement:a,scheduleUpdate:f}):e.children;return g?S.createElement(qo,{innerRef:d},S.Children.only(g)):null};return e.defaultProps={enabled:!0,modifiers:[],positionFixed:!1,positioningDependencies:[]},e}(),ka="ui-icon",wa=["bordered","className","circular","design","disabled","outline","size","rotate","styles","variables","xSpacing"],xa=function(e){var r=e.svg,o=e.displayName,t=e.handledProps,n=void 0===t?[]:t,a=function(e){var o=J(),t=e.alt,a=e["aria-label"],i=e.bordered,l=e.circular,s=e.className,c=e.design,d=e.disabled,u=e.outline,f=e.rotate,g=void 0===f?0:f,p=e.size,b=void 0===p?"medium":p,m=e.styles,h=e.variables,v=e.xSpacing,y=Lr("SvgIcon",{className:ka,mapPropsToStyles:function(){return {bordered:i,circular:l,disabled:d,outline:u,rotate:g,size:b,xSpacing:v}},mapPropsToInlineStyles:function(){return {className:s,design:c,styles:m,variables:h}},rtl:o.rtl}).classes,C=tr([].concat(wa,n),e);return S.createElement("span",Object.assign({role:"img","aria-hidden":t||a?void 0:"true","aria-label":a,className:y.root},C),r({classes:y,rtl:o.rtl,props:e}))};return a.displayName=o,a.handledProps=[].concat(wa,n),a},Sa="ui-icon__filled",Ba="ui-icon__outline",Ea=xa({svg:function(e){var r=e.classes;return S.createElement("svg",{role:"presentation",focusable:"false",viewBox:"2 2 16 16",className:r.svgFlippingInRtl},S.createElement("path",{className:ge()(Ba,r.outlinePart),d:"M7.64582 4.14708C7.84073 3.95147 8.15731 3.9509 8.35292 4.14582L13.8374 9.6108C14.0531 9.82574 14.0531 10.1751 13.8374 10.39L8.35292 15.855C8.15731 16.0499 7.84073 16.0493 7.64582 15.8537C7.4509 15.6581 7.45147 15.3415 7.64708 15.1466L12.8117 10.0004L7.64708 4.85418C7.45147 4.65927 7.4509 4.34269 7.64582 4.14708Z"}),S.createElement("path",{className:ge()(Sa,r.filledPart),d:"M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z"}))},displayName:"ChevronEndIcon"}),Oa="ui-menu__item",Fa={submenu:Oa+"__submenu"},Aa=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l,s,c,d=Eo(ga,{active:function(e){return e.activeIndex===r.index},onItemClick:function(e){return e.onItemClick},onItemSelect:function(e){return e.onItemSelect},variables:function(e){return e.variables},slotProps:function(e){return e.slotProps.item},accessibility:function(e){return e.behaviors.item}}),u=Object.assign({},d.slotProps,{active:d.active,variables:d.variables,accessibility:d.accessibility},r),f=u.accessibility,g=void 0===f?_n:f,p=u.children,b=u.content,m=u.icon,h=u.wrapper,v=u.primary,y=u.secondary,C=u.active,k=u.vertical,w=u.indicator,x=u.disabled,B=u.underlined,E=u.iconOnly,O=u.inSubmenu,F=u.pills,A=u.pointing,P=u.className,j=u.design,R=u.styles,I=u.variables,M=u.on,D=u.index,z=Qo(u.menu),_=z[0],H=z[1],T=Zo({defaultValue:u.defaultMenuOpen,value:u.menuOpen,initialValue:!1}),W=T[0],L=T[1];l=W,s=t.target,c=function(e){L((function(r){return ce()(u,"onMenuOpenChange",e,Object.assign({},u,{menuOpen:!1})),!1}));},function(e,r,o){void 0===o&&(o=1e3);var t=S.useRef();S.useEffect((function(){var n;return e&&(t.current=null==r||null==(n=r.defaultView)?void 0:n.setInterval((function(){var e=null==r?void 0:r.activeElement;if("IFRAME"===(null==e?void 0:e.tagName)){var o=new CustomEvent(Vn,{bubbles:!0});e.dispatchEvent(o);}}),o)),function(){var e;null==r||null==(e=r.defaultView)||e.clearTimeout(t.current);}}),[r,e,o]);}(l,s),function(e,r,o){var t=S.useCallback((function(e){r&&r(e);}),[r]);S.useEffect((function(){return e&&(null==o||o.addEventListener(Vn,t)),function(){null==o||o.removeEventListener(Vn,t);}}),[o,e,t]);}(l,c,s);var N=S.useState(!1),U=N[0],Z=N[1],V=or(u),G=Nr(e.handledProps,u),X=Pr(g,{debugName:Ra.displayName,actionHandlers:{performClick:function(e){return !e.defaultPrevented&&oe(e)},openMenu:function(e){function r(r){return e.apply(this,arguments)}return r.toString=function(){return e.toString()},r}((function(e){return le(e)})),closeAllMenusAndFocusNextParentItem:function(e){return ne(e)},closeMenu:function(e){function r(r){return e.apply(this,arguments)}return r.toString=function(){return e.toString()},r}((function(e){return ie(e)})),closeMenuAndFocusTrigger:function(e){return ie(e,!0)},doNotNavigateNextParentItem:function(e){e.stopPropagation();},closeAllMenus:function(e){function r(r){return e.apply(this,arguments)}return r.toString=function(){return e.toString()},r}((function(e){return ne(e)}))},mapPropsToBehavior:function(){return {menuOpen:W,hasMenu:!!_,disabled:x,vertical:k,active:C}},rtl:t.rtl}),Y=Lr(e.displayName,{className:Oa,mapPropsToStyles:function(){return {primary:v,underlined:B,active:C,vertical:k,pointing:A,secondary:y,disabled:x,iconOnly:E,pills:F,inSubmenu:O,isFromKeyboard:U}},mapPropsToInlineStyles:function(){return {className:P,design:j,styles:R,variables:Wn(d.variables,I)}},rtl:t.rtl}),$=Y.classes,K=Y.styles,q=S.useRef(),Q=S.useRef(),ee=function(e){te()&&(q.current.contains(e.target)||de(!1,e));},oe=function(e){x?e.preventDefault():(function(e){_&&(Kn(q.current,e,t.target)?de(!1,e,(function(){return br(Q.current)})):(de(!C||"hover"===M||!W,e),e.stopPropagation(),e.preventDefault()));}(e),ce()(u,"onClick",e,u),ce()(d,"onItemClick",e,u));},te=function(){return !(!_||!W)},ne=function(e){te()&&(de(!1,e,(function(){O||br(Q.current);})),O||e.preventDefault());},ie=function(e,r){if(te()){var o=O||u.vertical;de(!1,e,(function(){(r||o)&&br(Q.current);})),(r||o)&&e.stopPropagation();}},le=function(e){_&&!W&&(de(!0,e),ce()(d,"onItemSelect",e,D),ce()(u,"onActiveChanged",e,Object.assign({},u,{active:!0})),e.stopPropagation(),e.preventDefault());},se=Object.assign({},!h&&Object.assign({onClick:oe},"hover"===M&&{onMouseEnter:function(e){ua(t.target,"mouse"),de(!0,e),ce()(u,"onMouseEnter",e,u),ce()(d,"onItemSelect",e,D);},onMouseLeave:function(e){de(!1,e),ce()(u,"onMouseLeave",e,u);}})),de=function(e,r,o){L(e),o&&o(),ce()(u,"onMenuOpenChange",r,Object.assign({},u,{menuOpen:e}));},ue=S.createElement(qo,{innerRef:function(e){Q.current=e,mr(o,e);}},S.createElement(V,ae({},X("root",Object.assign({className:$.root,disabled:x,onBlur:function(e){Z(!1),ce()(u,"onBlur",e,u);},onFocus:function(e){Z("keyboard"===qn),ce()(u,"onFocus",e,u);},onClick:oe},G)),se),fo(p)?p:S.createElement(S.Fragment,null,wo(fa,m,{defaultProps:function(){return X("icon",{hasContent:!!b,iconOnly:E})}}),wo(ba,b,{defaultProps:function(){return X("content",{hasIcon:!!m,hasMenu:!!_,inSubmenu:O,vertical:k})}}),_&&wo(va,w,{defaultProps:function(){return X("indicator",{iconOnly:E,vertical:k,inSubmenu:O,active:C,primary:v,underlined:B})}})))),fe=_&&W?S.createElement(S.Fragment,null,S.createElement(qo,{innerRef:q},S.createElement(Ca,ae({align:k?"top":t.rtl?"end":"start",position:k?t.rtl?"before":"after":"below",targetRef:Q},H),wo(Ra,_,{defaultProps:function(){return {accessibility:Nn,className:Fa.submenu,vertical:!0,primary:u.primary,secondary:u.secondary,submenu:!0,styles:K.menu,indicator:u.indicator}},overrideProps:function(e){return {onClick:function(r){oe(r),ce()(e,"onClick",r,u);}}}}))),S.createElement(Zn,{listener:function(e){te()&&(Kn(Q.current,e,t.target)||Kn(q.current,e,t.target)||de(!1,e));},target:t.target,type:"click"}),S.createElement(Zn,{listener:ee,target:t.target,type:"wheel",capture:!0}),S.createElement(Zn,{listener:ee,target:t.target,type:"touchmove",capture:!0})):null;if(h){var ge=wo(ya,h,{defaultProps:function(){return X("wrapper",{active:C,disabled:x,iconOnly:E,isFromKeyboard:U,pills:F,pointing:A,secondary:y,underlined:B,vertical:k,primary:v,on:M,variables:I})},overrideProps:function(e){return Object.assign({children:S.createElement(S.Fragment,null,ue,fe)},function(e){return Object.assign({onBlur:function(r){!function(e){u.inSubmenu||e.currentTarget.contains(e.relatedTarget)||de(!1,e);}(r),ce()(e,"onBlur",r,u);}},"hover"===M&&{onMouseEnter:function(r){ua(t.target,"mouse"),de(!0,r),ce()(e,"onMouseEnter",r,u),ce()(d,"onItemSelect",r,D);},onMouseLeave:function(r){de(!1,r),ce()(e,"onMouseLeave",r,u);}})}(e))}});return i(),ge}return i(),ue}));return e.displayName="MenuItem",e.propTypes=Object.assign({},go({content:"shorthand"}),{active:pe.bool,disabled:pe.bool,icon:eo,on:pe.oneOf(["hover"]),iconOnly:pe.bool,index:pe.number,itemPosition:pe.number,itemsCount:pe.number,onClick:pe.func,onFocus:pe.func,onBlur:pe.func,pills:pe.bool,pointing:pe.oneOf(["start","end",!0,!1]),primary:Jr([qr(["secondary"]),pe.bool]),secondary:Jr([qr(["primary"]),pe.bool]),underlined:pe.bool,vertical:pe.bool,wrapper:pe.oneOfType([pe.node,pe.object]),menu:pe.oneOfType([oo,ao]),menuOpen:pe.bool,defaultMenuOpen:pe.bool,onActiveChanged:pe.func,inSubmenu:pe.bool,indicator:eo,onMenuOpenChange:pe.func}),e.handledProps=Object.keys(e.propTypes),e.shorthandConfig={mappedProp:"content"},e.defaultProps={as:"a",wrapper:{},indicator:S.createElement(Ea,{outline:!0})},e}(),Pa=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=Eo(ga,{variables:function(e){return e.variables},slotProps:function(e){return e.slotProps.divider},accessibility:function(e){return e.behaviors.divider}}),s=Object.assign({},l.slotProps,{accessibility:l.accessibility,variables:l.variables},r),c=s.accessibility,d=void 0===c?Hn:c,u=s.children,f=s.content,g=s.vertical,p=s.inSubmenu,b=s.pills,m=s.pointing,h=s.primary,v=s.className,y=s.design,C=s.styles,k=s.secondary,w=s.variables,x=Pr(d,{debugName:e.displayName,rtl:t.rtl}),B=Lr(e.displayName,{className:"ui-menu__divider",mapPropsToStyles:function(){return {hasContent:!!f||!!u,pills:b,pointing:m,vertical:g,inSubmenu:p,primary:h,secondary:k}},mapPropsToInlineStyles:function(){return {className:v,design:y,styles:C,variables:Wn(w,l.variables)}},rtl:t.rtl,unstable_props:s}).classes,E=or(s),O=Nr(e.handledProps,s),F=S.createElement(E,x("root",Object.assign({className:B.root},uo({forElements:[u,f]}),O,{ref:o})),fo(u)?u:f);return i(),F}));return e.defaultProps={as:"li"},e.displayName="MenuDivider",e.propTypes=Object.assign({},go(),{primary:pe.bool,secondary:pe.bool,vertical:pe.bool,inSubmenu:pe.bool,pointing:pe.oneOf(["start","end",!0,!1])}),e.handledProps=Object.keys(e.propTypes),e.shorthandConfig={mappedProp:"content"},e.create=Co({Component:e,mappedProp:"content"}),e}();function ja(e,r){var o=r[e];return S.useMemo((function(){return o}),zn()(o))}var Ra=function(){var e,r=S.forwardRef((function(e,o){var t=J(),n=re(r.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l,c,d=e.iconOnly,u=e.items,f=e.pills,g=e.pointing,p=e.primary,b=e.underlined,m=e.vertical,h=e.submenu,v=e.children,y=e.variables,C=e.styles,k=e.fluid,w=e.className,x=e.design,B=e.secondary,E=e.accessibility,O=or(e),F={divider:{inSubmenu:e.submenu,pills:e.pills,pointing:e.pointing,primary:e.primary,secondary:e.secondary,vertical:e.vertical},item:{iconOnly:e.iconOnly,indicator:e.indicator,inSubmenu:e.submenu,pills:e.pills,pointing:e.pointing,primary:e.primary,secondary:e.secondary,vertical:e.vertical,underlined:e.underlined}},A=ja("item",F),P=ja("divider",F),j=Nr(r.handledProps,e),R=Pr(e.accessibility,{debugName:r.displayName,mapPropsToBehavior:function(){return {vertical:m}},rtl:t.rtl}),I=function(e){var r=S.useRef(e);return S.useEffect((function(){r.current=e;})),r}(e),M=Lr(r.displayName,{className:"ui-menu",mapPropsToStyles:function(){return {iconOnly:d,fluid:k,pointing:g,pills:f,primary:p,underlined:b,vertical:m,secondary:B,submenu:h}},mapPropsToInlineStyles:function(){return {className:w,design:x,styles:C,variables:y}},rtl:t.rtl,unstable_props:e}).classes,D=Zo({defaultValue:e.defaultActiveIndex,value:e.activeIndex,initialValue:void 0}),z=D[0],_=D[1],H=S.useCallback((function(e,r){ce()(I.current,"onActiveIndexChange",e,Object.assign({},I.current,{activeIndex:r})),_(r);}),[I,_]),T=S.useCallback((function(e,r){var o=r.index;H(e,o),ce()(I.current,"onItemClick",e,r);}),[I,H]),W=S.useCallback((function(e,r){H(e,r);}),[H]),L=function(e){return {onActiveChanged:function(r,o){var t=o.index;o.active?H(r,t):z===t&&H(r,null),ce()(e,"onActiveChanged",r,o);},variables:Wn(y,e.variables)}},N=function(e){return {variables:Wn(y,e.variables)}},U=E&&E(e).childBehaviors,Z={activeIndex:+z,onItemClick:T,onItemSelect:W,vertical:m,variables:y,slotProps:{item:A,divider:P},behaviors:{item:null==U?void 0:U.item,divider:null==U?void 0:U.divider}},V=R.unstable_wrapWithFocusZone(S.createElement(O,R("root",Object.assign({className:M.root},uo({forElements:[v]}),j)),S.createElement(pa,{value:Z},fo(v)?v:(l=Rr()(u,(function(e){return "divider"!==Ln(e,"item")})).length,c=0,s()(u,(function(e,r){return "divider"===Ln(e,"item")?wo(Pa,e,{defaultProps:function(){return R("divider",{})},overrideProps:N}):(c++,wo(Aa,e,{defaultProps:function(){return R("item",{index:r,itemPosition:c,itemsCount:l})},overrideProps:L}))})))))),G=o?S.createElement(qo,{innerRef:o},V):V;return i(),G}));return r.displayName="Menu",r.propTypes=Object.assign({},go({content:!1}),{activeIndex:pe.oneOfType([pe.number,pe.string]),defaultActiveIndex:pe.oneOfType([pe.number,pe.string]),fluid:pe.bool,iconOnly:pe.bool,items:(e=["divider","item"],Jr([qr(["children"]),pe.arrayOf(to(e))])),onItemClick:pe.func,onActiveIndexChange:pe.func,pills:pe.bool,pointing:pe.oneOfType([pe.bool,pe.oneOf(["start","end"])]),primary:Jr([qr(["secondary"]),pe.bool]),secondary:Jr([qr(["primary"]),pe.bool]),underlined:pe.bool,vertical:pe.bool,submenu:pe.bool,indicator:eo}),r.handledProps=Object.keys(r.propTypes),r.defaultProps={as:"ul",accessibility:Tn},r.Item=Aa,r.ItemIcon=fa,r.ItemContent=ba,r.ItemWrapper=ya,r.ItemIndicator=va,r.Divider=Pa,r.create=Co({Component:r,mappedArrayProp:"items"}),r.shorthandConfig={mappedArrayProp:"items"},r}(),Ia=S.createContext(null),Ma=function(){var e=function(e){var r=S.useContext(Ia),o=e.children,t=e.mountNode,n=hn()?r||document.body:null,a=t||n;return Ar((function(){return ce()(e,"onMount",e),function(){return ce()(e,"onUnmount",e)}}),[]),a&&Xo.createPortal(o,a)};return e.propTypes=Object.assign({},go({accessibility:!1,as:!1,className:!1,content:!1,styled:!1}),{mountNode:Kr,onMount:pe.func,onUnmount:pe.func}),e}(),Da=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.children,c=r.items,d=r.content,u=r.className,f=r.design,g=r.styles,p=r.variables,b=or(r),m=Nr(e.handledProps,r),h=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),v=Lr(e.displayName,{className:"ui-reactions",mapPropsToInlineStyles:function(){return {className:u,design:f,styles:g,variables:p}},rtl:t.rtl}),y=v.classes,C=v.styles,k=Dr()(c)?S.createElement(b,ae({},h("root",Object.assign({className:y.root,ref:o},m)),uo({forElements:[l,d]})),fo(l)?l:d):S.createElement(b,ae({},m,{className:y.root}),s()(c,(function(e){return Ha.create(e,{defaultProps:function(){return {styles:C.reaction}}})})));return i(),k}));return e.displayName="ReactionGroup",e.propTypes=Object.assign({},go(),{items:ao}),e.handledProps=Object.keys(e.propTypes),e.create=Co({Component:e,mappedProp:"content",mappedArrayProp:"items"}),e}(),za="ui-reaction",_a={icon:za+"__icon",content:za+"__content"},Ha=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.children,s=r.icon,c=r.content,d=r.className,u=r.design,f=r.styles,g=r.variables,p=or(r),b=Nr(e.handledProps,r),m=Pr(r.accessibility,{debugName:e.displayName,rtl:t.rtl}),h=Lr(e.displayName,{className:za,mapPropsToStyles:function(){return {hasContent:!!c}},mapPropsToInlineStyles:function(){return {className:d,design:u,styles:f,variables:g}},rtl:t.rtl}),v=h.classes,y=h.styles,C=S.createElement(p,ae({},m("root",Object.assign({className:v.root,ref:o},b)),uo({forElements:[l]})),fo(l)?l:S.createElement(S.Fragment,null,Mo.create(s,{defaultProps:function(){return m("icon",{className:_a.icon,styles:y.icon})}}),Mo.create(c,{defaultProps:function(){return m("content",{className:_a.content,styles:y.content})}})));return i(),C}));return e.displayName="Reaction",e.propTypes=Object.assign({},go({content:"shorthand"}),{icon:eo}),e.defaultProps={as:"span"},e.handledProps=Object.keys(e.propTypes),e.Group=Da,e.create=Co({Component:e,mappedProp:"content"}),e}(),Ta=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.accessibility,s=r.align,c=r.atMention,d=r.children,u=r.className,f=r.color,g=r.content,p=r.design,b=r.disabled,m=r.error,h=r.important,v=r.size,y=r.styles,C=r.success,k=r.timestamp,w=r.truncated,x=r.temporary,B=r.variables,E=r.weight,O=Pr(l,{debugName:e.displayName,rtl:t.rtl}),F=Lr(e.displayName,{className:"ui-text",mapPropsToStyles:function(){return {atMention:c,color:f,important:h,timestamp:k,truncated:w,disabled:b,error:m,success:C,temporary:x,align:s,weight:E,size:v}},mapPropsToInlineStyles:function(){return {className:u,design:p,styles:y,variables:B}},rtl:t.rtl}).classes,A=Nr(e.handledProps,r),P=or(r),j=S.createElement(P,O("root",Object.assign({className:F.root,ref:o},uo({forElements:[d,g]}),A)),fo(d)?d:g);return i(),j}));return e.displayName="Text",e.defaultProps={as:"span"},e.propTypes=Object.assign({},go({color:!0}),{atMention:pe.oneOfType([pe.bool,pe.oneOf(["me"])]),disabled:pe.bool,error:pe.bool,important:pe.bool,size:lo,weight:pe.oneOf(["light","semilight","regular","semibold","bold"]),success:pe.bool,temporary:pe.bool,align:so,timestamp:pe.bool,truncated:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.create=Co({Component:e,mappedProp:"content"}),e}(),Wa=function(){var e=Io(Mo,{className:"ui-chat__messagedetails",displayName:"ChatMessageDetails",handledProps:["attached","density","hasHeaderReactionGroup","mine"],mapPropsToStylesProps:function(e){return {attached:e.attached,density:e.density,hasHeaderReactionGroup:e.hasHeaderReactionGroup,mine:e.mine}},overrideStyles:!0,shorthandConfig:{mappedProp:"content"}});return e.propTypes=Object.assign({},go(),{attached:pe.oneOfType([pe.bool,pe.oneOf(["top","bottom"])]),density:pe.oneOf(["comfy","compact"]),hasHeaderReactionGroup:pe.bool,mine:pe.bool}),e}(),La=function(){var e=Io(Mo,{className:"ui-chat__messageheader",displayName:"ChatMessageHeader",shorthandConfig:{mappedProp:"content"},overrideStyles:!0});return e.propTypes=go(),e}(),Na=function(){var e=Io(Mo,{className:"ui-chat__messagereadstatus",displayName:"ChatMessageReadStatus",handledProps:["density"],mapPropsToStylesProps:function(e){return {density:e.density,title:e.title}},overrideStyles:!0,shorthandConfig:{mappedProp:"content"}});return e.propTypes=Object.assign({},go(),{density:pe.oneOf(["comfy","compact"])}),e}(),Ua=["inline","showActionMenu"],Za="ui-chat__message",Va={actionMenu:Za+"__actions",author:Za+"__author",badge:Za+"__badge",bar:Za+"__bar",compactBody:Za+"__compact-body",content:Za+"__content",reactionGroup:Za+"__reactions",timestamp:Za+"__timestamp"},Ga=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=function(e,r){var o=S.useContext(e),t=o.value.current,n=o.version.current,a=o.listeners,i=r(t),l=S.useReducer((function(e,o){if(!o)return [t,i];if(o[0]<=n)return Object.is(e[1],i)?e:[t,i];try{if(Object.is(e[0],o[1]))return e;var a=r(o[1]);return Object.is(e[1],a)?e:[o[1],a]}catch(e){}return [].concat(e)}),[t,i]),s=l[0],c=l[1];return Object.is(s[1],i)||c(void 0),So((function(){return a.push(c),function(){var e=a.indexOf(c);a.splice(e,1);}}),[a]),s[1]}(Do,(function(e){return e.attached})),s=Po({density:function(e){return e.density},accessibility:function(e){return e.behaviors.message}}),c=Object.assign({},r,{density:void 0===r.density?s.density:r.density,accessibility:void 0===r.accessibility?s.accessibility||C:r.accessibility}),d=c.accessibility,u=c.attached,g=void 0===u?l:u,p=c.author,b=c.badge,m=c.badgePosition,h=c.children,v=c.className,k=c.compactBody,w=c.content,x=c.density,B=c.design,E=c.details,O=c.header,F=c.mine,A=c.positionActionMenu,P=c.reactionGroup,j=c.reactionGroupPosition,R=c.readStatus,I=c.styles,M=c.timestamp,D=c.unstable_overflow,z=c.variables,_=Qo(c.actionMenu),H=_[0],T=_[1],W=function(e){if("object"==typeof e&&null!==e&&!Array.isArray(e)){var r=e,o=r.inline,t=r.showActionMenu;return [Wo(r,Ua),null==o||o,t]}return [e,!0,!1]}(H),L=W[0],N=W[1],U=W[2],Z=Zo({defaultValue:!1,value:U}),V=Z[0],G=Z[1],X=!Dr()(L),Y=!!P&&"start"===j,$=S.useRef();$.current=function(e,r,o){var t;if(!Dr()(r))return S.isValidElement(r)?t=r.props.id:_r()(r)&&(t=r.id),t||o||ue()(e)}(Za+"-",L,$.current);var K=S.useCallback((function(e,r){return A&&[{name:"flip",options:{fallbackPlacements:["top"]}},D&&{name:"preventOverflow",options:{boundary:et(r)}}]}),[A,D]),q=S.useRef(),Q=Sn(Object.assign({align:"end",position:"above",positionFixed:D,enabled:X&&A,modifiers:K},T,{popperRef:Go(null==T?void 0:T.popperRef,q)})),ee=Q.targetRef,oe=Q.containerRef,te=S.useState(!1),ne=te[0],ae=te[1],ie=Pr(d,{actionHandlers:{preventDefault:function(e){e.currentTarget!==e.target&&e.preventDefault();},focus:function(e){ee.current&&(ee.current.focus(),e.stopPropagation());}},debugName:e.displayName,mapPropsToBehavior:function(){return {hasActionMenu:X,inlineActionMenu:N,actionMenuId:$.current}},rtl:t.rtl}),le=Lr(e.displayName,{className:Za,mapPropsToStyles:function(){return {attached:g,badgePosition:m,density:x,focused:ne,hasActionMenu:X,hasBadge:!!b,hasHeaderReactionGroup:Y,mine:F,showActionMenu:V}},mapPropsToInlineStyles:function(){return {className:v,design:B,styles:I,variables:z}},rtl:t.rtl}),se=le.classes,de=le.styles,fe=fo(h),pe=fe?ge()(se.root,se.content):se.root,be=or(c),me=Nr(e.handledProps,c),he=Mn.create(b,{defaultProps:function(){return {className:Va.badge,styles:de.badge}}}),ve=Ha.Group.create(P,{defaultProps:function(){return {className:Va.reactionGroup,styles:de.reactionGroup}}}),ye=function(){var e=Ra.create(L,{defaultProps:function(){var e;return (e={})[y]=!0,e.accessibility=No,e.className=Va.actionMenu,e.styles=de.actionMenu,e},overrideProps:{id:$.current}}),r=e?S.createElement(qo,{innerRef:oe},e):e;return N||!r?r:S.createElement(Ma,null,r)}(),Ce=Ta.create(p,{defaultProps:function(){return {size:"comfy"===x?"small":void 0,styles:de.author,className:Va.author}}}),ke=Ta.create(M,{defaultProps:function(){return {size:"small",styles:de.timestamp,timestamp:!0,className:Va.timestamp}}}),we=Mo.create(w,{defaultProps:function(){return {className:Va.content,styles:de.content}}}),xe=wo(Wa,E,{defaultProps:function(){return {attached:g,density:x,hasHeaderReactionGroup:Y,mine:F}}}),Se=wo(Na,R,{defaultProps:function(){return {density:x}}}),Be=S.createElement(S.Fragment,null);if("compact"===x){var Ee=wo(La,O),Oe=Mo.create(k||{},{defaultProps:function(){return ie("compactBody",{className:Va.compactBody,styles:de.compactBody})},overrideProps:function(){return {content:S.createElement(S.Fragment,null,S.createElement(An.Item,{grow:1},S.createElement("div",null,Ce,we)),ke,xe,he)}}});Be=S.createElement(S.Fragment,null,ye,S.createElement("div",{className:Va.bar}),Ee,Oe,ve,Se);}else {var Fe=wo(La,O||{},{overrideProps:function(){return {content:S.createElement(S.Fragment,null,Ce,ke,xe,"start"===j&&ve)}}});Be=S.createElement(S.Fragment,null,ye,S.createElement("div",{className:Va.bar}),"start"===m&&he,Fe,we,"end"===j&&ve,"end"===m&&he,Se);}var Ae=S.createElement(qo,{innerRef:ee},ie.unstable_wrapWithFocusZone(S.createElement(be,ie("root",Object.assign({className:pe,onBlur:function(e){var r=ce()(e,"currentTarget.contains",e.relatedTarget);ae(r),G(!1),ce()(c,"onBlur",e,c);},onFocus:function(e){var r;null==(r=q.current)||r.updatePosition(),ae(!0),ce()(c,"onFocus",e,c);},onMouseEnter:function(e){var r;null==(r=q.current)||r.updatePosition(),X&&!N&&G(!0),ce()(c,"onMouseEnter",e,c);},onMouseLeave:function(e){ne||!X||N||G(!1),ce()(c,"onMouseLeave",e,c);},onKeyDown:function(e){if(X&&!N){var r,o,t,n=null!=(r=null==(o=oe.current)?void 0:o.querySelector('[tabindex="0"]'))?r:null==(t=oe.current)?void 0:t.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])')[0];if(e.keyCode===f.Enter&&(null==n||n.focus(),e.stopPropagation(),e.preventDefault()),e.keyCode===f.Tab){var a=!!e.shiftKey,i=e.currentTarget.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])'),l=i[0],s=i[i.length-1];if(e.target===n)a?null==s||s.focus():null==l||l.focus(),e.stopPropagation(),e.preventDefault();else {var d=a?l:s;e.target===d&&(n.focus(),e.stopPropagation(),e.preventDefault());}}}ce()(c,"onKeyDown",e,c);},ref:o},uo({forElements:[h]}),me)),fe?h:Be)));return i(),Ae}));return e.displayName="ChatMessage",e.defaultProps={badgePosition:"end",positionActionMenu:!0,reactionGroupPosition:"start"},e.propTypes=Object.assign({},go({content:"shorthand"}),{actionMenu:pe.oneOfType([oo,ao]),attached:pe.oneOfType([pe.bool,pe.oneOf(["top","bottom"])]),author:oo,badge:oo,badgePosition:pe.oneOf(["start","end"]),compactBody:oo,density:pe.oneOf(["comfy","compact"]),details:oo,header:oo,mine:pe.bool,onBlur:pe.func,onFocus:pe.func,onKeyDown:pe.func,onMouseEnter:pe.func,onMouseLeave:pe.func,positionActionMenu:pe.bool,reactionGroup:pe.oneOfType([ao,oo]),reactionGroupPosition:pe.oneOf(["start","end"]),readStatus:oo,timestamp:oo,unstable_overflow:pe.bool}),e.handledProps=Object.keys(e.propTypes),e.create=Co({Component:e,mappedProp:"content"}),e}(),Xa="ui-chat",Ya={item:Xa+"__item"},$a=function(){var e=S.forwardRef((function(r,o){var t=J(),n=re(e.displayName,t.telemetry),a=n.setStart,i=n.setEnd;a();var l=r.accessibility,c=r.children,d=r.className,u=r.density,f=r.design,g=r.items,p=r.styles,b=r.variables,m=Pr(l,{debugName:e.displayName,rtl:t.rtl}),h=Lr(e.displayName,{className:Xa,mapPropsToStyles:function(){return {density:u}},mapPropsToInlineStyles:function(){return {className:d,design:f,styles:p,variables:b}},rtl:t.rtl}).classes,v=or(r),y=Nr(e.handledProps,r),C=l&&l(r).childBehaviors,k={density:u,behaviors:{item:null==C?void 0:C.item,message:null==C?void 0:C.message}},w=m.unstable_wrapWithFocusZone(S.createElement(v,m("root",Object.assign({className:h.root,ref:o},uo({forElements:[c]}),y)),S.createElement(Ao,{value:k},fo(c)?c:s()(g,(function(e){return To.create(e,{defaultProps:function(){return {className:Ya.item}}})})))));return i(),w}));return e.displayName="Chat",e.defaultProps={accessibility:w,as:"ul",density:Oo},e.propTypes=Object.assign({},go({content:!1}),{items:pe.arrayOf(oo),density:pe.oneOf(["comfy","compact"])}),e.handledProps=Object.keys(e.propTypes),e.Item=To,e.Message=Ga,e.MessageHeader=La,e.MessageDetails=Wa,e.MessageReadStatus=Na,e.create=Co({Component:e}),e}(),Ka=n(299),qa=n.n(Ka),Ja=n(2304),Qa=n.n(Ja),ei=function(){function e(){this.performance=void 0,this.enabled=void 0,this.performance={},this.enabled=!0;}return e.prototype.reset=function(){this.performance={};},e}(),ri=n(2787),oi=n(6368),ti=n(980),ni=n.n(ti),ai=n(4488);function ii(e,r,o){var t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return e.plugins.length>0?(0, ai.Z)(e.plugins,(function(r,n){return n(r,o,e,t)}),r):r}var li="RULE",si="KEYFRAME",ci="FONT",di="STATIC",ui="CLEAR",fi=/^(:|\[|>|&)/;function gi(e){return fi.test(e)}function pi(e){return "&"===e.charAt(0)?e.slice(1):e}function bi(e){return "@media"===e.substr(0,6)}function mi(e,r){return 0===e.length?r:e+" and "+r}function hi(e){return "@supports"===e.substr(0,9)}var vi=n(3140);function yi(e,r){return (arguments.length>4&&void 0!==arguments[4]?arguments[4]:"")+(arguments.length>3&&void 0!==arguments[3]?arguments[3]:"")+(arguments.length>2&&void 0!==arguments[2]?arguments[2]:"")+(0, vi.Z)(e)+r}function Ci(e){return null==e||"string"==typeof e&&null!==e.match(/(undefined|null)/)}function ki(e){return "."+e+(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"")}var wi=n(3235),xi=n(2370),Si="abcdefghijklmnopqrstuvwxyz",Bi=Si.length;function Ei(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return e<=Bi?Si[e-1]+r:Ei(e/Bi|0,Si[e%Bi]+r)}function Oi(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){return !0},o=Ei(e());return r(o)?o:Oi(e,r)}function Fi(e){return "data:"===e.substr(0,5)}function Ai(e){return Fi(e)?e:"'"+e+"'"}var Pi={".woff":"woff",".woff2":"woff2",".eot":"embedded-opentype",".ttf":"truetype",".otf":"opentype",".svg":"svg",".svgz":"svg"},ji={"image/svg+xml":"svg","application/x-font-woff":"woff","application/font-woff":"woff","application/x-font-woff2":"woff2","application/font-woff2":"woff2","font/woff2":"woff2","application/octet-stream":"truetype","application/x-font-ttf":"truetype","application/x-font-truetype":"truetype","application/x-font-opentype":"opentype","application/vnd.ms-fontobject":"embedded-opentype","application/font-sfnt":"sfnt"};function Ri(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=(0, ai.Z)(r,(function(e,r,o){return e+(o>0?",":"")+"local("+Ai(r)+")"}),""),t=(0, ai.Z)(e,(function(e,r,o){var t=o>0?",":"",n=function(e){if(Fi(e)){for(var r="",o=5;;o++){var t=e.charAt(o);if(";"===t||","===t)break;r+=t;}var n=ji[r];if(n)return n;console.warn("A invalid base64 font was used. Please use one of the following mime type: "+Object.keys(ji).join(", ")+".");}else {for(var a="",i=e.length-1;;i--){var l=e.charAt(i);if("."===l){a=l+a;break}a=l+a;}var s=Pi[a];if(s)return s;console.warn('A invalid font-format was used in "'+e+'". Use one of these: '+Object.keys(Pi).join(", ")+".");}return ""}(r);return ""+e+t+"url("+Ai(r)+") format('"+n+"')"}),"");return o+(o.length>0&&t.length>0?",":"")+t}function Ii(e){return -1===e.indexOf("ad")}var Mi=/^[a-z_][a-z0-9-_]*$/gi;function Di(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e.length>0&&null===e.match(Mi)&&console.error("An invalid selectorPrefix ("+e+") has been used to create a new Fela renderer.\nIt must only contain a-Z, 0-9, - and _ while it must start with either _ or a-Z.\nSee http://fela.js.org/docs/advanced/RendererConfiguration.html"),e}var zi=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var o=arguments[r];for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&(e[t]=o[t]);}return e};function _i(e,r){var o={};for(var t in e)r.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(e,t)&&(o[t]=e[t]);return o}var Hi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function Ti(e,r){var o=e.fontFamily,t=e.src,n=function(e,r){var o={};for(var t in e)r.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(e,t)&&(o[t]=e[t]);return o}(e,["fontFamily","src"]);if("string"==typeof o&&Array.isArray(t))return r.renderFont(o,t,n)}var Wi=n(9811);var Li=n(2700);function Ni(e,r){for(var o in e){var t=e[o];if(r.hasOwnProperty(o)){var n=r[o](t);(0, Li.Z)(e,n),n.hasOwnProperty(o)||delete e[o];}e.hasOwnProperty(o)&&ni()(t)&&(e[o]=Ni(t,r));}return e}var Ui=["::-webkit-input-placeholder","::-moz-placeholder",":-ms-input-placeholder",":-moz-placeholder","::placeholder"];function Zi(e){return e.reduce((function(e,r){var o=r[0],t=r[1];return e[o]=t,e[t]=o,e}),{})}function Vi(e){return "number"==typeof e}function Gi(e,r){return -1!==e.indexOf(r)}function Xi(e,r,o,t){return r+function(e){return 0===parseFloat(e)?e:"-"===e[0]?e.slice(1):"-"+e}(o)+t}function Yi(e){return e.replace(/ +/g," ").split(" ").map((function(e){return e.trim()})).filter(Boolean).reduce((function(e,r){var o=e.list,t=e.state,n=(r.match(/\(/g)||[]).length,a=(r.match(/\)/g)||[]).length;return t.parensDepth>0?o[o.length-1]=o[o.length-1]+" "+r:o.push(r),t.parensDepth+=n-a,{list:o,state:t}}),{list:[],state:{parensDepth:0}}).list}function $i(e){var r=Yi(e);if(r.length<=3||r.length>4)return e;var o=r[0],t=r[1],n=r[2];return [o,r[3],n,t].join(" ")}var Ki={padding:function(e){var r=e.value;return Vi(r)?r:$i(r)},textShadow:function(e){var r=function(e){for(var r=[],o=0,t=0,n=!1;t<e.length;)n||","!==e[t]?"("===e[t]?(n=!0,t++):")"===e[t]?(n=!1,t++):t++:(r.push(e.substring(o,t).trim()),o=++t);return o!=t&&r.push(e.substring(o,t+1)),r}(e.value).map((function(e){return e.replace(/(^|\s)(-*)([.|\d]+)/,(function(e,r,o,t){return "0"===t?e:r+(""===o?"-":"")+t}))}));return r.join(",")},borderColor:function(e){return $i(e.value)},borderRadius:function(e){var r=e.value;if(Vi(r))return r;if(Gi(r,"/")){var o=r.split("/"),t=o[0],n=o[1];return Ki.borderRadius({value:t.trim()})+" / "+Ki.borderRadius({value:n.trim()})}var a=Yi(r);switch(a.length){case 2:return a.reverse().join(" ");case 4:var i=a[0],l=a[1],s=a[2];return [l,i,a[3],s].join(" ");default:return r}},background:function(e){var r=e.value,o=e.valuesToConvert,t=e.isRtl,n=e.bgImgDirectionRegex,a=e.bgPosDirectionRegex;if(Vi(r))return r;var i=r.replace(/(url\(.*?\))|(rgba?\(.*?\))|(hsl\(.*?\))|(#[a-fA-F0-9]+)|((^| )(\D)+( |$))/g,"").trim();return r=r.replace(i,Ki.backgroundPosition({value:i,valuesToConvert:o,isRtl:t,bgPosDirectionRegex:a})),Ki.backgroundImage({value:r,valuesToConvert:o,bgImgDirectionRegex:n})},backgroundImage:function(e){var r=e.value,o=e.valuesToConvert,t=e.bgImgDirectionRegex;return Gi(r,"url(")||Gi(r,"linear-gradient(")?r.replace(t,(function(e,r,t){return e.replace(t,o[t])})):r},backgroundPosition:function(e){var r=e.value,o=e.valuesToConvert,t=e.isRtl,n=e.bgPosDirectionRegex;return r.replace(t?/^((-|\d|\.)+%)/:null,(function(e,r){return function(e){var r=e.indexOf(".");if(-1===r)e=100-parseFloat(e)+"%";else {var o=e.length-r-2;e=(e=100-parseFloat(e)).toFixed(o)+"%";}return e}(r)})).replace(n,(function(e){return o[e]}))},backgroundPositionX:function(e){var r=e.value,o=e.valuesToConvert,t=e.isRtl,n=e.bgPosDirectionRegex;return Vi(r)?r:Ki.backgroundPosition({value:r,valuesToConvert:o,isRtl:t,bgPosDirectionRegex:n})},transition:function(e){var r=e.value,o=e.propertiesToConvert;return r.split(/,\s*/g).map((function(e){var r=e.split(" ");return r[0]=o[r[0]]||r[0],r.join(" ")})).join(", ")},transitionProperty:function(e){var r=e.value,o=e.propertiesToConvert;return r.split(/,\s*/g).map((function(e){return o[e]||e})).join(", ")},transform:function(e){var r=e.value,o="[^\\u0020-\\u007e]",t="(?:(?:(?:\\[0-9a-f]{1,6})(?:\\r\\n|\\s)?)|\\\\[^\\r\\n\\f0-9a-f])",n="((?:-?(?:[0-9]*\\.[0-9]+|[0-9]+)(?:\\s*(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)|-?(?:[_a-z]|"+o+"|"+t+")(?:[_a-z0-9-]|"+o+"|"+t+")*)?)|(?:inherit|auto))",a=new RegExp("(translateX\\s*\\(\\s*)"+n+"(\\s*\\))","gi"),i=new RegExp("(translate\\s*\\(\\s*)"+n+"((?:\\s*,\\s*"+n+"){0,1}\\s*\\))","gi"),l=new RegExp("(translate3d\\s*\\(\\s*)"+n+"((?:\\s*,\\s*"+n+"){0,2}\\s*\\))","gi"),s=new RegExp("(rotate[ZY]?\\s*\\(\\s*)"+n+"(\\s*\\))","gi");return r.replace(a,Xi).replace(i,Xi).replace(l,Xi).replace(s,Xi)}};Ki.objectPosition=Ki.backgroundPosition,Ki.margin=Ki.padding,Ki.borderWidth=Ki.padding,Ki.boxShadow=Ki.textShadow,Ki.webkitBoxShadow=Ki.boxShadow,Ki.mozBoxShadow=Ki.boxShadow,Ki.WebkitBoxShadow=Ki.boxShadow,Ki.MozBoxShadow=Ki.boxShadow,Ki.borderStyle=Ki.borderColor,Ki.webkitTransform=Ki.transform,Ki.mozTransform=Ki.transform,Ki.WebkitTransform=Ki.transform,Ki.MozTransform=Ki.transform,Ki.transformOrigin=Ki.backgroundPosition,Ki.webkitTransformOrigin=Ki.transformOrigin,Ki.mozTransformOrigin=Ki.transformOrigin,Ki.WebkitTransformOrigin=Ki.transformOrigin,Ki.MozTransformOrigin=Ki.transformOrigin,Ki.webkitTransition=Ki.transition,Ki.mozTransition=Ki.transition,Ki.WebkitTransition=Ki.transition,Ki.MozTransition=Ki.transition,Ki.webkitTransitionProperty=Ki.transitionProperty,Ki.mozTransitionProperty=Ki.transitionProperty,Ki.WebkitTransitionProperty=Ki.transitionProperty,Ki.MozTransitionProperty=Ki.transitionProperty,Ki["text-shadow"]=Ki.textShadow,Ki["border-color"]=Ki.borderColor,Ki["border-radius"]=Ki.borderRadius,Ki["background-image"]=Ki.backgroundImage,Ki["background-position"]=Ki.backgroundPosition,Ki["background-position-x"]=Ki.backgroundPositionX,Ki["object-position"]=Ki.objectPosition,Ki["border-width"]=Ki.padding,Ki["box-shadow"]=Ki.textShadow,Ki["-webkit-box-shadow"]=Ki.textShadow,Ki["-moz-box-shadow"]=Ki.textShadow,Ki["border-style"]=Ki.borderColor,Ki["-webkit-transform"]=Ki.transform,Ki["-moz-transform"]=Ki.transform,Ki["transform-origin"]=Ki.transformOrigin,Ki["-webkit-transform-origin"]=Ki.transformOrigin,Ki["-moz-transform-origin"]=Ki.transformOrigin,Ki["-webkit-transition"]=Ki.transition,Ki["-moz-transition"]=Ki.transition,Ki["transition-property"]=Ki.transitionProperty,Ki["-webkit-transition-property"]=Ki.transitionProperty,Ki["-moz-transition-property"]=Ki.transitionProperty;var qi=Zi([["paddingLeft","paddingRight"],["marginLeft","marginRight"],["left","right"],["borderLeft","borderRight"],["borderLeftColor","borderRightColor"],["borderLeftStyle","borderRightStyle"],["borderLeftWidth","borderRightWidth"],["borderTopLeftRadius","borderTopRightRadius"],["borderBottomLeftRadius","borderBottomRightRadius"],["padding-left","padding-right"],["margin-left","margin-right"],["border-left","border-right"],["border-left-color","border-right-color"],["border-left-style","border-right-style"],["border-left-width","border-right-width"],["border-top-left-radius","border-top-right-radius"],["border-bottom-left-radius","border-bottom-right-radius"]]),Ji=["content"],Qi=Zi([["ltr","rtl"],["left","right"],["w-resize","e-resize"],["sw-resize","se-resize"],["nw-resize","ne-resize"]]),el=new RegExp("(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)","g"),rl=new RegExp("(left)|(right)");const ol=function e(r){return Object.keys(r).reduce((function(o,t){var n=r[t];if("string"==typeof n&&(n=n.trim()),Gi(Ji,t))return o[t]=n,o;var a=function(r,o){var t,n=/\/\*\s?@noflip\s?\*\//.test(o),a=n?r:qi[t=r]||t,i=n?o:function(r,o){if(!function(e){return !("boolean"==typeof e||function(e){return null==e}(e))}(o))return o;if((t=o)&&"object"==typeof t)return e(o);var t,n,a=Vi(o),i=function(e){return "function"==typeof e}(o),l=a||i?o:o.replace(/ !important.*?$/,""),s=!a&&l.length!==o.length,c=Ki[r];return n=c?c({value:l,valuesToConvert:Qi,propertiesToConvert:qi,isRtl:!0,bgImgDirectionRegex:el,bgPosDirectionRegex:rl}):Qi[l]||l,s?n+" !important":n}(a,o);return {key:a,value:i}}(t,n),i=a.key,l=a.value;return o[i]=l,o}),Array.isArray(r)?[]:{})};function tl(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return 0===e.length||0===r.length?0:e.indexOf(e.find((function(e){return null!==r.match(e)})))+1}function nl(e){return e.split("{")[0].slice(9).trim()}function al(e,r,o,t){var n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"",i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"";return {type:e,className:r,selector:ki(r,n),declaration:o+":"+t,pseudo:n,media:a,support:i}}var il=function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,r){var o=[],t=!0,n=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(t=(i=l.next()).done)&&(o.push(i.value),!r||o.length!==r);t=!0);}catch(e){n=!0,a=e;}finally{try{!t&&l.return&&l.return();}finally{if(n)throw a}}return o}(e,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")},ll=/[.]([0-9a-z_-]+)([^{]+)?{([^:]+):([^}]+)}/gi;function sl(e){for(var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=void 0;n=ll.exec(e);){var a=il(n,5),i=(a[0],a[1]),l=a[2],s=a[3],c=a[4];t[yi(s,c,l,r,o)]=al(li,i,s,c,l,r,o);}return t}var cl=function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,r){var o=[],t=!0,n=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(t=(i=l.next()).done)&&(o.push(i.value),!r||o.length!==r);t=!0);}catch(e){n=!0,a=e;}finally{try{!t&&l.return&&l.return();}finally{if(n)throw a}}return o}(e,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")},dl=/@supports[^{]+\{([\s\S]+?})\s*}/gi;function ul(e,r){var o=e.type,t=e.support,n=e.media;switch(o){case ci:return 0;case di:return 1;case si:return 2;case li:return function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];if(0===r.length)return e;var t=o.indexOf(r)+1;return t?e+2*t:9999}(t?4:3,n,r);default:return 9999}}var fl,gl=n(9332);function pl(e,r){return e+"{"+r+"}"}function bl(e,r){return "@supports "+e+"{"+r+"}"}function ml(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return (0, ai.Z)(e,(function(e,o){return e[o]=r,e}),{})}function hl(e){if(Array.isArray(e)){for(var r=0,o=Array(e.length);r<e.length;r++)o[r]=e[r];return o}return Array.from(e)}function vl(e,r,o){return r in e?Object.defineProperty(e,r,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[r]=o,e}var yl=(vl(fl={},li,(function(e,r){var o=r.selector,t=r.declaration,n=r.support,a=r.media,i=pl(o,t);n?a?(e.supportMediaRules[a]||(e.supportMediaRules[a]={}),e.supportMediaRules[a][n]||(e.supportMediaRules[a][n]=""),e.supportMediaRules[a][n]+=i):(e.supportRules[n]||(e.supportRules[n]=""),e.supportRules[n]+=i):a?(e.mediaRules[a]||(e.mediaRules[a]=""),e.mediaRules[a]+=i):e.rules+=i;})),vl(fl,ci,(function(e,r){var o=r.fontFace;e.fontFaces+=o;})),vl(fl,si,(function(e,r){var o=r.keyframe;e.keyframes+=o;})),vl(fl,di,(function(e,r){var o=r.css,t=r.selector;e.statics+=t?pl(t,o):o;})),fl);const Cl={fontFaces:ci,statics:di,keyframes:si,rules:li};function kl(e){return (0, xi.Z)(e,(function(e,r,o){return r.length>0&&(e+=bl(o,r)),e}),"")}var wl=/^[a-z0-9_-]*$/gi,xl=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var o=arguments[r];for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&(e[t]=o[t]);}return e};function Sl(e){var r=function(e){var r,o,t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],l=(r=e,o=function(e){return tl(i,e.pseudo)},t=(0, xi.Z)(r,(function(e,t,n){var a=e.findIndex((function(e){return o(r[e],e)>o(t,n)}));return -1!==a?function(e,r,o){return [].concat(hl(e.slice(0,o)),[r],hl(e.slice(o,e.length)))}(e,n,a):[].concat(function(e){if(Array.isArray(e)){for(var r=0,o=Array(e.length);r<e.length;r++)o[r]=e[r];return o}return Array.from(e)}(e),[n])}),[]),(0, ai.Z)(t,(function(e,o){return e[o]=r[o],e}),{})),s=ml(n),c=ml(a),d=(0, ai.Z)(n,(function(e,r){return e[r]=ml(a),e}),ml(n,{}));return (0, xi.Z)(l,(function(e,r){var o=yl[r.type];return o&&o(e,r),e}),{mediaRules:s,supportRules:c,supportMediaRules:d,fontFaces:"",statics:"",keyframes:"",rules:""})}(e.cache,e.mediaQueryOrder,e.supportQueryOrder,e.ruleOrder),o=function(e){return 0===e.selectorPrefix.length||null!==e.selectorPrefix.match(wl)?e.uniqueRuleIdentifier:-1}(e),t=(0, xi.Z)(Cl,(function(e,t,n){return r[n].length>0&&e.push({css:r[n],rehydration:o,type:t}),e}),[]),n=kl(r.supportRules);n&&t.push({css:n,type:li,rehydration:o,support:!0});var a=Object.keys(xl({},r.supportMediaRules,r.mediaRules));return (0, ai.Z)(a,(function(e,t){if(r.mediaRules[t]&&r.mediaRules[t].length>0&&e.push({css:r.mediaRules[t],type:li,rehydration:o,media:t}),r.supportMediaRules[t]){var n=kl(r.supportMediaRules[t]);n.length>0&&e.push({css:n,type:li,rehydration:o,support:!0,media:t});}return e}),t)}function Bl(e,r){e.updateSubscription||(e.scoreIndex={},e.nodes={},e.updateSubscription=function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document;return function(o){if(o.type===ui)return (0, gl.Z)(e.nodes,(function(e){var r=e.node;return r.parentNode.removeChild(r)})),e.nodes={},void(e.scoreIndex={});var t=function(e,r){var o,t,n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:document,i=(o=e).type+(void 0===(t=o.media)?"":t)+(void 0===(n=o.support)?"":n);if(!r.nodes[i]){var l=ul(e,r.mediaQueryOrder),s=function(e){var r=e.type,o=e.media,t=o?'[media="'+o+'"]':":not([media])",n=e.support?'[data-fela-support="true"]':':not([data-fela-support="true"])';return (arguments.length>1&&void 0!==arguments[1]?arguments[1]:document).querySelector('[data-fela-type="'+r+'"]'+n+t)}(e,a)||function(e,r,o){var t=o.type,n=o.media,a=o.support,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:document,l=i.head||{},s=i.createElement("style");s.setAttribute("data-fela-type",t),s.type="text/css",a&&s.setAttribute("data-fela-support","true"),n&&(s.media=n);var c=(0, xi.Z)(e,(function(o,t,n){return t.score>r&&(!o||e[o].score>t.score)?n:o}),void 0);return c?l.insertBefore(s,e[c].node):l.appendChild(s),s}(r.nodes,l,e,a);r.nodes[i]={node:s,score:l};}return r.nodes[i].node}(o,e,r);switch(o.type){case si:t.textContent+=o.keyframe;break;case ci:t.textContent+=o.fontFace;break;case di:t.textContent+=o.selector?pl(o.selector,o.css):o.css;break;case li:!function(e,r,o){var t=e.selector,n=e.declaration,a=e.support,i=e.media,l=e.pseudo,s=i+a;if(r.devMode)!function(e,r){var o=Sl(e),t=r.getAttribute("media")||void 0,n=r.getAttribute("data-fela-support")||void 0,a=o.find((function(e){return e.type===li&&e.media===t&&e.support===n}));a&&(r.textContent=a.css);}(r,o);else try{var c=tl(r.ruleOrder,l),d=o.sheet.cssRules,u=d.length;if(0===c)u=void 0===r.scoreIndex[s]?0:r.scoreIndex[s]+1;else for(var f=r.scoreIndex[s]||0,g=d.length;f<g;++f)if(d[f].score>c){u=f;break}var p=pl(t,n);if(a.length>0){var b=bl(a,p);o.sheet.insertRule(b,u);}else o.sheet.insertRule(p,u);0===c&&(r.scoreIndex[s]=u),d[u].score=c;}catch(e){}}(o,e,t);}}}(e,r),e.subscribe(e.updateSubscription),(0, gl.Z)(e.cache,e._emitChange));}var El=/[.][a-z0-9_-]*/gi;var Ol=function(){function e(e,r){for(var o=0;o<r.length;o++){var t=r[o];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t);}}return function(r,o,t){return o&&e(r.prototype,o),t&&e(r,t),r}}(),Fl=(0, S.createContext)();(0, S.createContext)();const Al=function(e,r,o,t,n){var a=function(e){function t(e,r){!function(e,r){if(!(e instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);var o=function(e,r){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !r||"object"!=typeof r&&"function"!=typeof r?e:r}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e,r));return o._renderStyle(),o}return function(e,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);e.prototype=Object.create(r&&r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(e,r):e.__proto__=r);}(t,e),Ol(t,[{key:"componentDidUpdate",value:function(e){this._renderStyle();}},{key:"_renderStyle",value:function(){var e=this.props,r=e.renderer,o=e.rehydrate,t=e.targetDocument;(function(e,r){if("undefined"==typeof document)return !1;var o=r||document;return e&&!e.isNativeRenderer&&o&&o.createElement})(r,t)&&(o&&function(){return (arguments.length>0&&void 0!==arguments[0]?arguments[0]:document).querySelectorAll("[data-fela-type]").length>0}(t)?function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document;Bl(e,r),(0, oi.Z)(r.querySelectorAll("[data-fela-type]"),(function(r){var o=r.getAttribute("data-fela-rehydration")||-1,t=e.uniqueRuleIdentifier||parseInt(o,10);if(-1!==t){var n=r.getAttribute("data-fela-type")||"",a=r.getAttribute("media")||"",i=r.getAttribute("data-fela-support")||"",l=r.textContent;e.uniqueRuleIdentifier=t;var s=n+a+i;if(e.nodes[s]={score:ul({type:n,media:a,support:i},e.mediaQueryOrder),node:r},n===li&&(i?function(e){for(var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},t=void 0;t=dl.exec(e);){var n=cl(t,2),a=n[0];sl(n[1],r,nl(a),o);}}(l,a,e.cache):sl(l,a,"",e.cache),r.sheet&&r.sheet.cssRules)){var c=a+i;(0, oi.Z)(r.sheet.cssRules,(function(r,o){var t=r.conditionText?r.cssRules[0].selectorText:r.selectorText,n=tl(e.ruleOrder,t.split(El)[1]);0===n&&(e.scoreIndex[c]=o),r.score=n;}));}}}));}(r,t):Bl(r,t));}},{key:"render",value:function(){return o(r.Provider,{value:this.props.renderer},(e=this.props.children,S.Children.only(e)));var e;}}]),t}(e);return n&&(0, gl.Z)(n,(function(e,r){a[r]=e;})),a}(S.Component,Fl,S.createElement,0,{propTypes:{renderer:be().object.isRequired,rehydrate:be().bool.isRequired},defaultProps:{rehydrate:!0}});var Pl=["animation","animationName","animationDuration","animationTimingFunction","animationDelay","animationIterationCount","animationDirection","animationFillMode","animationPlayState"];function jl(e,r,o){return r in e?Object.defineProperty(e,r,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[r]=o,e}function Rl(e,r){return function(e){if(Array.isArray(e))return e}(e)||function(e,r){var o=[],t=!0,n=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(t=(i=l.next()).done)&&(o.push(i.value),!r||o.length!==r);t=!0);}catch(e){n=!0,a=e;}finally{try{t||null==l.return||l.return();}finally{if(n)throw a}}return o}(e,r)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var Il=/(em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|q|in|pt|pc|px|dpi|dpcm|dppx|%|auto)$/i,Ml=/^(calc\()/i,Dl=/^(dashed|dotted|double|groove|hidden|inset|none|outset|ridge|solid)$/i,zl=/^(thick|medium|think)$/i,_l=/^\d+$/,Hl=["inherit","initial","unset","revert","revert-layer"];function Tl(e){for(var r=[""],o=0,t=e.trim(),n=0;n<t.length;n+=1)" "===t.charAt(n)&&0===o?r.push(""):r[r.length-1]=r[r.length-1]+t.charAt(n),"("===t.charAt(n)?o++:")"===t.charAt(n)&&o--;return r}function Wl(e,r){var o=Tl(e),t={};return o.forEach((function(e){null!==e.match(Dl)?t[r("Style")]=e:null!==e.match(zl)||null!==e.match(Il)||null!==e.match(Ml)||"0"===e?t[r("Width")]=e:t[r("Color")]=e;})),t}var Ll=new Set(Hl.concat(["none","underline","overline","line-through","blink"])),Nl=new Set(Hl.concat(["solid","double","dotted","dashed","wavy"])),Ul={borderWidth:function(e){return "border"+e+"Width"},borderColor:function(e){return "border"+e+"Color"},borderStyle:function(e){return "border"+e+"Style"},padding:function(e){return "padding"+e},margin:function(e){return "margin"+e},scrollPadding:function(e){return "scrollPadding"+e},scrollMargin:function(e){return "scrollMargin"+e}},Zl={borderLeft:function(e){return "borderLeft"+e},borderTop:function(e){return "borderTop"+e},borderRight:function(e){return "borderRight"+e},borderBottom:function(e){return "borderBottom"+e},outline:function(e){return "outline"+e}},Vl={paddingInline:function(e){return "paddingInline"+e},paddingBlock:function(e){return "paddingBlock"+e},marginInline:function(e){return "marginInline"+e},marginBlock:function(e){return "marginBlock"+e}},Gl=new Set(Hl.concat(["row","row-reverse","column","column-reverse"])),Xl=new Set(Hl.concat(["nowrap","wrap","reverse"])),Yl=function(e){var r=Tl(e);if(1===r.length){if(Hl.includes(r[0]))return {transitionProperty:r[0],transitionDuration:r[0],transitionDelay:r[0],transitionTimingFunction:r[0]};if("all"===r[0]||"none"===r[0])return {transitionProperty:r[0],transitionDuration:"0s",transitionDelay:"0s",transitionTimingFunction:"ease"}}var o=Rl(r,4),t=o[0],n=o[1],a=void 0===n?"0s":n,i=o[2],l=void 0===i?"0s":i,s=o[3];return {transitionProperty:t,transitionDuration:a,transitionDelay:l,transitionTimingFunction:void 0===s?"ease":s}};function $l(e,r){if("border"===e){var o=Wl(r.toString(),(function(e){return "border"+e})),t={};for(var n in o)Object.assign(t,$l(n,o[n]));return t}return "flex"===e?function(e){var r=[""];switch(e.trim()){case"initial":r=Tl("0 1 auto");break;case"auto":r=Tl("1 1 auto");break;case"none":r=Tl("0 0 auto");break;default:r=Tl(e);}if(1===r.length){var o=r[0];r=_l.test(o)?Tl(o+" 1 0"):Tl("1 1 "+o);}var t={};return 2===r.length?(t.flexGrow=r[0],null!==r[1].match(_l)?t.flexShrink=r[1]:t.flexBasis=r[1]):(t.flexGrow=r[0],t.flexShrink=r[1],t.flexBasis=r[2]),void 0===t.flexGrow&&(t.flexGrow="0"),void 0===t.flexShrink&&(t.flexShrink="1"),void 0===t.flexBasis&&(t.flexBasis="auto"),t}(r.toString()):"borderRadius"===e?function(e){var r=function(e,r){var o=[[]];return e.forEach((function(e){"/"===e?o.push([]):o[o.length-1].push(e);})),o}(Tl(e)),o=Rl(r,2),t=o[0],n=void 0===t?[]:t,a=o[1],i=void 0===a?[]:a,l=Rl(n,4),s=l[0],c=l[1],d=void 0===c?s:c,u=l[2],f=void 0===u?s:u,g=l[3],p=void 0===g?d:g,b=Rl(i,4),m=b[0],h=b[1],v=void 0===h?m:h,y=b[2],C=void 0===y?m:y,k=b[3],w=void 0===k?v:k;return {borderTopLeftRadius:[s,m].filter(Boolean).join(" "),borderTopRightRadius:[d,v].filter(Boolean).join(" "),borderBottomRightRadius:[f,C].filter(Boolean).join(" "),borderBottomLeftRadius:[p,w].filter(Boolean).join(" ")}}(r.toString()):"textDecoration"===e?function(e){var r=Tl(e);if(1===r.length)return "initial"===r[0]?{textDecorationLine:"none"}:{textDecorationLine:r[0]};var o=Rl(r,3),t=o[0],n=o[1],a=o[2],i=[],l="",s="",c=function(e){if(e)if(Ll.has(e)){if(0!==i.length&&i.includes(e))return !0;i.push(e);}else Nl.has(e)?s=e:l=e;return !1};return c(t)||c(n)||c(a)?{}:(i.sort(),{textDecorationLine:i.length?i.join(" "):"none",textDecorationStyle:s||"solid",textDecorationColor:l||"currentColor"})}(r.toString()):"overflow"===e?function(e){var r=Rl(Tl(e),2),o=r[0],t=r[1];return {overflowX:o,overflowY:void 0===t?o:t}}(r.toString()):"gap"===e?function(e){var r=Rl(Tl(e),2),o=r[0],t=r[1];return {rowGap:o,columnGap:void 0===t?o:t}}(r.toString()):"flexFlow"===e?function(e){var r="",o="",t=Rl(Tl(e),2),n=t[0],a=t[1],i=function(e){if(e)if(Gl.has(e)){if(""!==r)return !0;r=e;}else {if(!Xl.has(e))return !0;if(""!==o)return !0;o=e;}return !1};return i(n)||i(a)?{}:{flexDirection:r||"row",flexWrap:o||"nowrap"}}(r.toString()):"placeContent"===e?function(e){var r=Rl(Tl(e),2),o=r[0],t=r[1];if(!t&&o){if("left"===o||"right"===o||"first"===o||"last"===o)return {};t="baseline"===o?"start":o;}return {alignContent:o,justifyContent:t}}(r.toString()):"placeItems"===e?function(e){var r=Rl(Tl(e),2),o=r[0],t=r[1];return {alignItems:o,justifyItems:void 0===t?o:t}}(r.toString()):"placeSelf"===e?function(e){var r=Rl(Tl(e),2),o=r[0],t=r[1];return {alignSelf:o,justifySelf:void 0===t?o:t}}(r.toString()):"transition"===e?function(e){return e.includes(",")?e.split(",").map(Yl).reduce((function(e,r,o){var t=r.transitionProperty,n=r.transitionDuration,a=r.transitionDelay,i=r.transitionTimingFunction;return 0===o?(e.transitionProperty=t,e.transitionDuration=n,e.transitionDelay=a,e.transitionTimingFunction=i):(e.transitionProperty+=", ".concat(t),e.transitionDuration+=", ".concat(n),e.transitionDelay+=", ".concat(a),e.transitionTimingFunction+=", ".concat(i)),e}),{}):Yl(e)}(r.toString()):"inset"===e?function(e){var r=Rl(Tl(e),4),o=r[0],t=r[1],n=void 0===t?o:t,a=r[2],i=void 0===a?o:a,l=r[3];return {top:o,right:n,bottom:i,left:void 0===l?n:l}}(r.toString()):Ul[e]?function(e,r){var o,t=Rl(Tl(e),4),n=t[0],a=t[1],i=void 0===a?n:a,l=t[2],s=void 0===l?n:l,c=t[3],d=void 0===c?i:c;return jl(o={},r("Top"),n),jl(o,r("Right"),i),jl(o,r("Bottom"),s),jl(o,r("Left"),d),o}(r.toString(),Ul[e]):Zl[e]?Wl(r.toString(),Zl[e]):Vl[e]?function(e,r){var o,t=Rl(Tl(e),2),n=t[0],a=t[1],i=void 0===a?n:a;return jl(o={},r("Start"),n),jl(o,r("End"),i),o}(r.toString(),Vl[e]):void 0}var Kl={padding:!0,margin:!0,border:!0,borderWidth:!0,borderStyle:!0,borderColor:!0,borderTop:!0,borderRight:!0,borderBottom:!0,borderLeft:!0,borderRadius:!0,background:!0,outline:!0},ql=["_className"],Jl="abcdefghijklmnopqrstuvwxyz",Ql=Jl.length;function es(e,r){return void 0===r&&(r=""),e<=Ql?Jl[e-1]+r:es(e/Ql|0,Jl[e%Ql]+r)}function rs(e,r){void 0===r&&(r=function(){return !0});var o=es(e());return r(o)?o:rs(e,r)}function os(e,r,o,t,n){return void 0===o&&(o=""),void 0===t&&(t=""),void 0===n&&(n=""),n+t+o+e+r}var ts=["content","keyframe"],ns=n(1685),as=n.n(ns),is=new(as().default||as())({cascade:!1,compress:!1,global:!1,keyframe:!1,preserve:!1,semicolon:!1}),ls=!1;try{ls=!!window.localStorage.felaDevMode;}catch(e){}var ss,cs=["fa","fas","far","fal","fab","fc","ck","cke"],ds={devMode:ls,filterClassName:function(e){return -1===e.indexOf("ad")&&-1===cs.indexOf(e)},enhancers:[function(e){return e._renderStyleToClassNames=function(r,o,t,n){void 0===o&&(o=""),void 0===t&&(t=""),void 0===n&&(n="");var a,i=r._className,l=Wo(r,ql),s=i?" "+i:"";for(var c in l){var d=l[c];if(null!=(a=d)&&"object"==typeof a&&!1===Array.isArray(a))if(gi(c))s+=e._renderStyleToClassNames(d,o+pi(c),t,n);else if(bi(c)){var u=mi(t,c.slice(6).trim());s+=e._renderStyleToClassNames(d,o,u,n);}else if(hi(c)){var f=mi(n,c.slice(9).trim());s+=e._renderStyleToClassNames(d,o,t,f);}else console.warn('The object key "'+c+'" is not a valid nested key in Fela.\nMaybe you forgot to add a plugin to resolve it?\nCheck http://fela.js.org/docs/basics/Rules.html#styleobject for more information.');else {var g=os(c,d,o,t,n);if(!e.cache.hasOwnProperty(g)){if(Ci(d)){e.cache[g]={className:""};continue}var p=e.selectorPrefix+rs(e.getNextRuleIdentifier,e.filterClassName),b=(0, ri.default)(c,d),m=ki(p,o),h={type:li,className:p,selector:m,declaration:b,pseudo:o,media:t,support:n};e.cache[g]=h,e._emitChange(h);}var v=e.cache[g].className;v&&(s+=" "+v);}}return s},e},function(e){var r=e._emitChange.bind(e);return e._emitChange=function(e){e.type===li&&-1!==e.selector.indexOf(":focus-visible")&&(e.pseudo=e.pseudo?e.pseudo.replace(":focus-visible",":focus"):"",e.selector='html[data-whatinput="keyboard"] '+e.selector.replace(":focus-visible",":focus")),r(e);},e},function(e){var r=e._emitChange.bind(e);return e._emitChange=function(e){if(e.type===li){var o=is("",e.declaration);e.declaration=o.slice(1,-1);}r(e);},e}],plugins:[function e(r,o,t,n){return n&&n.disableAnimations&&"RULE"===o?Object.keys(r).reduce((function(a,i){var l,s,c,d=r[i];return -1!==Pl.indexOf(i)?a:null!=(c=d)&&"object"==typeof c&&!1===Array.isArray(c)?Object.assign({},a,((s={})[i]=e(d,o,t,n),s)):Object.assign({},a,((l={})[i]=r[i],l))}),{}):r},function e(r,o,t,n){if(!n.sanitizeCss)return r;var a=Array.isArray(r)?[]:{};return Object.keys(r).forEach((function(i){var l=r[i];"object"!=typeof l?(ts.some((function(e){return e===i}))||function(e){if("string"!=typeof e)return !0;for(var r=[],o=0;o<e.length;++o){var t=e[o];if("({[".includes(t))r.push(t);else if(")}]".includes(t)){var n=r.pop();if(n&&"({[".indexOf(n)!==")}]".indexOf(t))return !1}}return 0===r.length}(l))&&(a[i]=l):a[i]=e(l,o,t,n);})),a},(ss={"::placeholder":function(e){return (0, ai.Z)(Ui,(function(r,o){return r[o]=e,r}),{})}},function(e){return Ni(e,ss)}),function e(r){return Object.keys(r).reduce((function(o,t){var n=r[t];if(_r()(n)){if("animationName"===t){var a=n;return a.keyframe&&(r[t]=z(a.keyframe)(a.params||{})),o[t]=r[t],o}return o[t]=e(n),o}return o[t]=r[t],o}),{})},function e(r,o,t,n){var a=function(a){var i=r[a];"fontFace"===a&&"object"===(void 0===i?"undefined":Hi(i))?(Array.isArray(i)?r.fontFamily=(0, ai.Z)(i,(function(e,r){var o=Ti(r,t);return o&&-1===e.indexOf(o)&&e.push(o),e}),[]).join(","):r.fontFamily=Ti(i,t),delete r.fontFace):"animationName"===a&&"object"===(void 0===i?"undefined":Hi(i))?Array.isArray(i)?r[a]=i.map((function(e){return t.renderKeyframe((function(){return e}))}),n).join(","):r[a]=t.renderKeyframe((function(){return i}),n):ni()(i)&&e(i,o,t,n);};for(var i in r)a(i);return r},function e(r){return Object.keys(r).reduce((function(o,t){var n,a,i,l,s=r[t];if(null==s)return Object.assign({},o,((a={})[t]=s,a));if(Kl[t]){var c=function(e,r){if(Array.isArray(r)){var o={};return r.forEach((function(r){var t=$l(e,r);t&&Object.keys(t).forEach((function(e){o[e]=o[e]||[],o[e].push(t[e]);}));})),Object.keys(o).length?o:null}return $l(e,r)}(t,s);if(c)return Object.assign({},o,c)}return Array.isArray(s)?Object.assign({},o,((i={})[t]=s,i)):"object"==typeof s?Object.assign({},o,((l={})[t]=e(s),l)):Object.assign({},o,((n={})[t]=s,n))}),{})},function e(r){for(var o in r){var t=r[o];Array.isArray(t)?r[o]=(0, Wi.Z)(o,t):ni()(t)&&"fontFace"!==o&&(r[o]=e(t));}return r},function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"rtl";return function(r,o,t,n){return "rtl"===(n&&n.theme&&n.theme.direction||e)?ol(r):r}}()]},us=function(){var e=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r={listeners:[],keyframePrefixes:e.keyframePrefixes||["-webkit-","-moz-"],plugins:e.plugins||[],mediaQueryOrder:e.mediaQueryOrder||[],supportQueryOrder:e.supportQueryOrder||[],ruleOrder:[/^:link/,/^:visited/,/^:hover/,/^:focus-within/,/^:focus/,/^:active/],selectorPrefix:Di(e.selectorPrefix),filterClassName:e.filterClassName||Ii,devMode:e.devMode||!1,uniqueRuleIdentifier:0,uniqueKeyframeIdentifier:0,nodes:{},scoreIndex:{},cache:{},getNextRuleIdentifier:function(){return ++r.uniqueRuleIdentifier},renderRule:function(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return r._renderStyle(e(o,r),o)},renderKeyframe:function(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e(o,r),n=ii(r,t,si,o),a=JSON.stringify(n);if(!r.cache.hasOwnProperty(a)){var i=r.selectorPrefix+"k"+ ++r.uniqueKeyframeIdentifier,l=function(e,r){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[""],t=(0, xi.Z)(e,(function(e,r,o){return ""+e+o+"{"+(0, wi.Z)(r)+"}"}),"");return (0, ai.Z)(o,(function(e,o){return e+"@"+o+"keyframes "+r+"{"+t+"}"}),"")}(n,i,r.keyframePrefixes),s={type:si,keyframe:l,name:i};r.cache[a]=s,r._emitChange(s);}return r.cache[a].name},renderFont:function(e,o){var t,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=n.localAlias,i=_i(n,["localAlias"]),l=e+JSON.stringify(n),s=function(e){return "string"==typeof e?[e]:Array.isArray(e)?e.slice():[]}(a);if(!r.cache.hasOwnProperty(l)){var c=function(e){return '"'===e.charAt(0)?e:'"'+e+'"'}(e),d=(t=zi({},i,{src:Ri(o,s),fontFamily:c}),"@font-face{"+(0, wi.Z)(t)+"}"),u={type:ci,fontFace:d,fontFamily:c};r.cache[l]=u,r._emitChange(u);}return r.cache[l].fontFamily},renderStatic:function(e,o){var t=function(e,r){return "string"==typeof e?e:r?r+JSON.stringify(e):""}(e,o);if(!r.cache.hasOwnProperty(t)){var n=function(e,r){if("string"==typeof e)return e.replace(/\s{2,}/g,"");var o=ii(r,e,di);return (0, wi.Z)(o)}(e,r),a={type:di,css:n,selector:o};r.cache[t]=a,r._emitChange(a);}},subscribe:function(e){return r.listeners.push(e),{unsubscribe:function(){return r.listeners.splice(r.listeners.indexOf(e),1)}}},clear:function(){r.uniqueRuleIdentifier=0,r.uniqueKeyframeIdentifier=0,r.cache={},r._emitChange({type:ui});},_renderStyle:function(){var e=ii(r,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},li,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{});return r._renderStyleToClassNames(e).slice(1)},_renderStyleToClassNames:function(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",a=e._className,i=_i(e,["_className"]),l=a?" "+a:"";for(var s in i){var c=i[s];if(ni()(c))if(gi(s))l+=r._renderStyleToClassNames(c,o+pi(s),t,n);else if(bi(s)){var d=mi(t,s.slice(6).trim());l+=r._renderStyleToClassNames(c,o,d,n);}else if(hi(s)){var u=mi(n,s.slice(9).trim());l+=r._renderStyleToClassNames(c,o,t,u);}else console.warn('The object key "'+s+'" is not a valid nested key in Fela.\nMaybe you forgot to add a plugin to resolve it?\nCheck http://fela.js.org/docs/basics/Rules.html#styleobject for more information.');else {var f=yi(s,c,o,t,n);if(!r.cache.hasOwnProperty(f)){if(Ci(c)){r.cache[f]={className:""};continue}var g=r.selectorPrefix+Oi(r.getNextRuleIdentifier,r.filterClassName),p=(0, ri.default)(s,c),b=ki(g,o),m={type:li,className:g,selector:b,declaration:p,pseudo:o,media:t,support:n};r.cache[f]=m,r._emitChange(m);}var h=r.cache[f].className;h&&(l+=" "+h);}}return l},_emitChange:function(e){(0, oi.Z)(r.listeners,(function(r){return r(e)}));}};return r.keyframePrefixes.push(""),e.enhancers&&(0, oi.Z)(e.enhancers,(function(e){r=e(r);})),r}(ds),r=0;return {registerUsage:function(){r+=1;},unregisterUsage:function(){0==(r-=1)&&(e.listeners=[],e.nodes={},e.updateSubscription=void 0);},renderFont:function(r){e.renderFont(r.name,r.paths,r.props);},renderGlobal:e.renderStatic,renderRule:function(r,o){var t=Object.assign({},o,{theme:{direction:o.direction}});return e.renderRule((function(){return r}),t)},getOriginalRenderer:function(){throw new Error("This method implements private API and can be used only in tests")},Provider:function(r){return S.createElement(Al,{renderer:e,rehydrate:!1,targetDocument:r.target},r.children)}}},fs=S.createContext(us),gs={document:"document"},ps=new WeakMap,bs=function(e){for(var r=arguments.length,o=new Array(r>1?r-1:0),t=1;t<r;t++)o[t-1]=arguments[t];return o.reduce((function(e,r){return "boolean"==typeof r?r:e}),e)},ms=function(){var e=function(e){var r=e.render,o=J();return S.createElement(S.Fragment,null,r(o.theme))};return e.displayName="ProviderConsumer",e.propTypes={render:pe.func.isRequired},e}(),hs=function(){var e=function e(r){var o=r.children,t=r.className,n=r.design,a=r.overwrite,i=r.styles,l=r.variables,s=r.telemetryRef,c=or(r),d=Nr(e.handledProps,r),u=S.useMemo((function(){if(s)return s.current||(s.current=new ei),s.current}),[s]),f=J(),g=a?K:f,p=S.useContext(fs),b=S.useMemo((function(){return {disableAnimations:r.disableAnimations,performance:r.performance,rtl:r.rtl,target:r.target,telemetry:u,theme:r.theme}}),[r.disableAnimations,r.performance,r.rtl,r.target,u,r.theme]),m=S.useMemo((function(){return function(e){for(var r={theme:{siteVariables:{fontSizes:{}},componentVariables:{},componentStyles:{},fontFaces:[],staticStyles:[],animations:{}},rtl:!1,disableAnimations:!1,target:hn()?document:void 0,performance:{enableSanitizeCssPlugin:!1,enableStylesCaching:!0,enableVariablesCaching:!0,enableBooleanVariablesCaching:!1},telemetry:void 0,renderer:void 0},o=arguments.length,t=new Array(o>1?o-1:0),n=1;n<o;n++)t[n-1]=arguments[n];return t.reduce((function(r,o){if(!o)return r;r.theme=$(r.theme,o.theme);var t=bs(r.rtl,o.rtl);"boolean"==typeof t&&(r.rtl=t),r.target=o.target||r.target,r.renderer=function(e,r){var o=r||gs;if(hn()&&void 0!==r||(o=gs),hn()&&r===document&&(o=gs),ps.has(o))return ps.get(o);var t=e(o===gs?void 0:o);return ps.set(o,t),t}(e,r.target);var n=bs(r.disableAnimations,o.disableAnimations);return "boolean"==typeof n&&(r.disableAnimations=n),r.performance=function(e){for(var r=arguments.length,o=new Array(r>1?r-1:0),t=1;t<r;t++)o[t-1]=arguments[t];return Object.assign.apply(Object,[e].concat(o))}(r.performance,o.performance||{}),r.telemetry=o.telemetry||r.telemetry,r}),r)}(p,g,b)}),[p,g,b]),h={};f.rtl!==m.rtl&&Qa()(m.rtl)&&(h.dir=m.rtl?"rtl":"ltr");var v=Wr({allDisplayNames:[e.displayName],className:"ui-provider",primaryDisplayName:e.displayName,componentProps:{},inlineStylesProps:{className:t,design:n,styles:i,variables:l},disableAnimations:m.disableAnimations,performance:m.performance,renderer:m.renderer,rtl:m.rtl,theme:m.theme,saveDebug:qa(),telemetry:void 0}).classes,y=function(e){var r=e.className,o=e.rtl,t=e.target,n=S.useMemo((function(){var e=hn()?t.createElement("div"):null;return e&&t.body.appendChild(e),e}),[t]);return Ar((function(){n&&(n.setAttribute("class",r),o?n.setAttribute("dir","rtl"):n.removeAttribute("dir"));}),[r,n,o]),Ar((function(){return function(){n&&t.body.removeChild(n);}}),[n,t]),n}({className:v.root,target:m.target,rtl:m.rtl});Ar((function(){return e=m.renderer,(o=r.theme).fontFaces&&o.fontFaces.forEach((function(r){!function(r){if(!_r()(r))throw new Error("fontFaces must be objects, got: "+typeof r);e.renderFont(r);}(r);})),function(e,r,o){if(r.staticStyles){var t=function(r){A()(r,(function(r,o){e.renderGlobal(r,o);}));};r.staticStyles.forEach((function(r){if("string"==typeof r)e.renderGlobal(r);else if(_r()(r))t(r);else {if(!Zr()(r))throw new Error("staticStyles array must contain CSS strings, style objects, or style functions, got: "+typeof r);var n=Z(o);t(r(n));}}));}}(m.renderer,r.theme,m.theme.siteVariables),r.target&&function(e){var r=e.defaultView;if(hn()&&r&&"addEventListener"in r&&Array.prototype.indexOf){var o=e[ea];if("number"==typeof o&&o>0)return void(e[ea]=o+1);e[ea]=1,ia(r),sa(e);}}(r.target),m.renderer.registerUsage(),function(){var e,o,t,n;r.target&&(e=r.target,n=e.defaultView,hn()&&n&&"removeEventListener"in n&&(1===e[ea]?(delete e[ea],t=!na||{capture:!0},(o=n).PointerEvent?o.removeEventListener("pointerdown",la):window.MSPointerEvent?o.removeEventListener("MSPointerDown",la):(o.removeEventListener("mousedown",la,!0),"ontouchstart"in o&&(o.removeEventListener("touchstart",ca,t),o.removeEventListener("touchend",la,!0))),o.removeEventListener("keydown",ca,!0),o.removeEventListener("keyup",ca,!0)):e[ea]=e[ea]-1)),m.renderer.unregisterUsage();};var e,o;}),[]);var C=c===S.Fragment?{}:Object.assign({className:v.root},h,d),k=m.renderer.Provider;return S.createElement(k,{target:m.target},S.createElement(ee,{value:m},S.createElement(Ia.Provider,{value:y},S.createElement(c,C,o))))};return e.displayName="Provider",e.defaultProps={theme:{}},e.propTypes={as:pe.elementType,design:pe.object,variables:pe.oneOfType([pe.object,pe.func]),styles:pe.oneOfType([pe.object,pe.func]),theme:pe.shape({siteVariables:pe.object,componentVariables:pe.object,componentStyles:pe.objectOf(pe.any),fontFaces:pe.arrayOf(pe.exact({name:pe.string.isRequired,paths:pe.arrayOf(pe.string),props:pe.shape({fontStretch:pe.string,fontStyle:pe.string,fontVariant:pe.string,fontWeight:pe.number,localAlias:pe.oneOfType([pe.string,pe.arrayOf(pe.string)]),unicodeRange:pe.string})})),staticStyles:pe.array,animations:pe.objectOf(pe.any)}),rtl:pe.bool,disableAnimations:pe.bool,performance:pe.shape({enableSanitizeCssPlugin:pe.bool,enableStylesCaching:pe.bool,enableVariablesCaching:pe.bool}),children:pe.node.isRequired,overwrite:pe.bool,target:pe.object,telemetryRef:pe.object},e.handledProps=Object.keys(e.propTypes),e.Consumer=ms,e}(),vs="cubic-bezier(1,0,1,1)",ys="cubic-bezier(0,0,0,1)",Cs="cubic-bezier(0,0,1,1)",ks="50ms",ws="100ms",xs="150ms",Ss="200ms",Bs="300ms",Es="400ms",Os="500ms",Fs={scaleEnterUltraFast:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:ks,timingFunction:ys,fillMode:"forwards"},scaleEnterFaster:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:ws,timingFunction:ys,fillMode:"forwards"},scaleEnterFast:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:xs,timingFunction:ys,fillMode:"forwards"},scaleEnterNormal:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:Ss,timingFunction:ys,fillMode:"forwards"},scaleEnterSlow:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:Bs,timingFunction:ys,fillMode:"forwards"},scaleEnterSlower:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:Es,timingFunction:ys,fillMode:"forwards"},scaleEnterUltraSlow:{keyframe:function(e){return {"0%":{transform:"scale("+e.delta+")",opacity:0},"100%":{transform:"scale(1)",opacity:1}}},keyframeParams:{delta:.88},duration:Os,timingFunction:ys,fillMode:"forwards"},scaleExitUltraFast:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:ks,timingFunction:vs,fillMode:"forwards"},scaleExitFaster:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:ws,timingFunction:vs,fillMode:"forwards"},scaleExitFast:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:xs,timingFunction:vs,fillMode:"forwards"},scaleExitNormal:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:Ss,timingFunction:vs,fillMode:"forwards"},scaleExitSlow:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:Bs,timingFunction:vs,fillMode:"forwards"},scaleExitSlower:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:Es,timingFunction:vs,fillMode:"forwards"},scaleExitUltraSlow:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:Os,timingFunction:vs,fillMode:"forwards"},scaleDownSoft:{keyframe:function(e){return {"0%":{transform:"scale(1)",opacity:1},"100%":{transform:"scale("+e.delta+")",opacity:0}}},keyframeParams:{delta:.9},duration:"100ms",timingFunction:"cubic-bezier(.78, 0, .22, 1)",fillMode:"both"}},As={fadeEnterUltraFast:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:ks,timingFunction:Cs,fillMode:"forwards"},fadeEnterFaster:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:ws,timingFunction:Cs,fillMode:"forwards"},fadeEnterFast:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:xs,timingFunction:Cs,fillMode:"forwards"},fadeEnterNormal:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:Ss,timingFunction:Cs,fillMode:"forwards"},fadeEnterSlow:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:Bs,timingFunction:Cs,fillMode:"forwards"},fadeEnterSlower:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:Es,timingFunction:Cs,fillMode:"forwards"},fadeEnterUltraSlow:{keyframe:function(e){return {"0%":{opacity:e.delta},"100%":{opacity:1}}},keyframeParams:{delta:0},duration:Os,timingFunction:Cs,fillMode:"forwards"},fadeExitUltraFast:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:ks,timingFunction:Cs,fillMode:"forwards"},fadeExitFaster:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:ws,timingFunction:Cs,fillMode:"forwards"},fadeExitFast:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:xs,timingFunction:Cs,fillMode:"forwards"},fadeExitNormal:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:Ss,timingFunction:Cs,fillMode:"forwards"},fadeExitSlow:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:Bs,timingFunction:Cs,fillMode:"forwards"},fadeExitSlower:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:Es,timingFunction:Cs,fillMode:"forwards"},fadeExitUltraSlow:{keyframe:function(e){return {"0%":{opacity:1},"100%":{opacity:e.delta}}},keyframeParams:{delta:0},duration:Os,timingFunction:Cs,fillMode:"forwards"}},Ps={slideDownEnterUltraFast:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterFaster:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterFast:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterNormal:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterSlow:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterSlower:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownEnterUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateY(-"+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterUltraFast:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterFaster:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterFast:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterNormal:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterSlow:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterSlower:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideUpEnterUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateY("+e.delta+")",opacity:0},"100%":{transform:"translateY(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterUltraFast:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterFaster:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterFast:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterNormal:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"200px"},duration:Ss,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterSlow:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterSlower:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideLeftEnterUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateX("+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterUltraFast:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterFaster:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterFast:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterNormal:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"200px"},duration:Ss,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterSlow:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterSlower:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideRightEnterUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateX(-"+e.delta+")",opacity:0},"100%":{transform:"translateX(0px)",opacity:1}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:ys,direction:"forward",fillMode:"forwards"},slideDownExitUltraFast:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitFaster:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitFast:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitNormal:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitSlow:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitSlower:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideDownExitUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitUltraFast:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitFaster:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitFast:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitNormal:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitSlow:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitSlower:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideUpExitUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateY(0px)",opacity:1},"100%":{transform:"translateY(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitUltraFast:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitFaster:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitFast:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitNormal:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitSlow:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitSlower:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideRightExitUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX("+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitUltraFast:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ks,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitFaster:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:ws,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitFast:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:xs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitNormal:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Ss,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitSlow:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Bs,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitSlower:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Es,timingFunction:vs,direction:"forward",fillMode:"forwards"},slideLeftExitUltraSlow:{keyframe:function(e){return {"0%":{transform:"translateX(0px)",opacity:1},"100%":{transform:"translateX(-"+e.delta+")",opacity:0}}},keyframeParams:{delta:"20px"},duration:Os,timingFunction:vs,direction:"forward",fillMode:"forwards"}},js=Object.assign({},As,Fs,Ps,{"carousel-slide-to-next-enter":Ps.slideLeftEnterNormal,"carousel-slide-to-previous-enter":Ps.slideRightEnterNormal,"popup-show":As.fadeEnterUltraFast,"popup-hide":As.fadeExitUltraFast}),Rs=null,Is=function(e,r){var o;return r||Rs||(Rs=function(){if(hn())try{return function(e){return e&&parseFloat(e)||null}(getComputedStyle(document.documentElement).fontSize)||16}catch(e){return 16}return 16}()),(1e4*(o=e/(r||Rs||16))+(o>0?.5:-.5)<<0)/1e4+"rem"},Ms={brand:{50:"#e8ebfa",100:"#dcdffa",200:"#c5cbfa",300:"#acb3fa",400:"#9399f5",450:"#9499f5",500:"#7a80eb",600:"#5b5fc7",700:"#444691",800:"#3d3e78",900:"#383966",1e3:"#2f2f4a"}},Ds={grey:{0:"#FFFFFF",25:"#FCFCFB",50:"#FAF9F8",100:"#F3F2F1",150:"#EDEBE9",200:"#E1DFDD",250:"#C8C6C4",300:"#B3B0AD",340:"#999",350:"#979593",400:"#8A8886",430:"#707070",440:"#666666",450:"#605E5C",500:"#484644",550:"#3B3A39",600:"#323131",650:"#2D2C2C",700:"#292828",750:"#252423",800:"#201F1F",850:"#1B1A1A",900:"#11100F",1e3:"#000000"},orange:{50:"#F9ECEA",100:"#EFDBD3",200:"#EDC2A7",300:"#E97548",400:"#CC4A31",500:"#BD432C",600:"#A33D2A",700:"#833122",800:"#664134",900:"#51332C"},pink:{50:"#FCF2FA",100:"#F1DFEE",200:"#EC6FAE",300:"#DE569A",400:"#E959D9",500:"#B4009E",600:"#943670",700:void 0,800:"#3E2D3B",900:"#1F191D"},red:{50:"#FCF4F6",100:"#F3D6D8",200:"#F75E75",300:"#E73550",400:"#C4314B",500:"#A72037",600:"#8E192E",700:"#4F222B",800:"#3E1F25",900:"#1E040A"},green:{50:"#E7F2DA",100:"#BDDA9B",200:"#92C353",300:"#6BB700",400:"#13A40E",500:void 0,600:"#237B4B",700:void 0,800:"#0D2E0D",900:"#032003"},yellow:{50:void 0,100:"#FBF6D9",200:"#F2E384",300:"#F9EC02",400:"#F8D22A",500:"#FFB900",600:"#FFAA44",700:"#835C00",800:"#463100",900:"#261A00"}},zs=Object.assign({},Ms,Ds),_s={black:"#000",white:"#fff"},Hs={silver:{100:"rgba(255,255,255,0.85)",200:"rgba(255,255,255,0.75)",300:"rgba(255,255,255,0.65)",400:"rgba(255,255,255,0.5)",500:"rgba(255,255,255,0.4)",600:"rgba(255,255,255,0.3)",700:"rgba(255,255,255,0.2)",800:"rgba(255,255,255,0.1)",900:"rgba(255,255,255,0.05)"},ruby:{100:void 0,200:void 0,300:void 0,400:void 0,500:"rgba(196,49,75,0.9)",600:"rgba(167,32,55,0.9)",700:"rgba(142,25,46,0.9)",800:void 0,900:void 0},onyx:{100:"rgba(59,58,57,0.9)",200:"rgba(45,44,44,0.4)",300:"rgba(37,36,35,0.2)",400:"rgba(37,36,35,0.65)",500:"rgba(41,40,40,0.9)",600:"rgba(0,0,0,0.05)",700:"rgba(0,0,0,0.5)",800:"rgba(27,26,26,0.9)",900:"rgba(0,0,0,0.8)"},amethyst:{100:void 0,200:void 0,300:void 0,400:"rgba(98,100,167,0.75)",500:"rgba(51,52,74,0.5)",600:"rgba(70,71,117,0.4)",700:"rgba(98,100,167,0.15)",800:void 0,900:void 0}},Ts=Object.assign({},zs,_s,Hs),Ws=function(e){return void 0===e&&(e={}),Object.assign({foreground:void 0,background:void 0,border:void 0,shadow:void 0,foregroundHover:void 0,backgroundHover:void 0,borderHover:void 0,shadowHover:void 0,foregroundActive:void 0,backgroundActive:void 0,borderActive:void 0,shadowActive:void 0,foregroundFocus:void 0,backgroundFocus:void 0,borderFocus:void 0,shadowFocus:void 0,foregroundPressed:void 0,backgroundPressed:void 0,borderPressed:void 0,shadowPressed:void 0,foregroundDisabled:void 0,backgroundDisabled:void 0,borderDisabled:void 0,shadowDisabled:void 0},e)},Ls=function(){var e={default:Ws({foreground:Ts.grey[750],foreground1:Ts.grey[500],foreground2:Ts.grey[450],foreground3:Ts.white,foreground4:Ts.white,foreground5:Ts.grey[100],foreground6:Ts.grey[200],foreground7:Ts.grey[750],foreground8:Ts.grey[750],foreground9:Ts.grey[430],background:Ts.white,background1:Ts.grey[50],background2:Ts.grey[100],background3:Ts.grey[150],background4:Ts.grey[100],background5:Ts.grey[350],background6:Ts.grey[550],border:Ts.grey[200],border1:Ts.grey[150],border2:Ts.grey[200],border3:Ts.grey[150],borderTransparent:"transparent",borderTransparentActive:"transparent",shadow:Ts.black,shadowHover:Ts.black,foregroundHover:Ts.grey[750],foregroundHover1:Ts.white,foregroundHover2:Ts.white,backgroundHover:Ts.grey[100],backgroundHover1:Ts.grey[150],backgroundHover2:"transparent",backgroundHover3:Ts.grey[150],backgroundHover4:Ts.grey[50],borderHover:Ts.grey[250],foregroundPressed:Ts.grey[750],backgroundPressed:Ts.grey[200],backgroundPressed3:Ts.grey[150],borderPressed:Ts.grey[250],foregroundActive:Ts.grey[750],foregroundActive1:Ts.white,backgroundActive:Ts.grey[100],backgroundActive1:Ts.grey[150],backgroundActive2:Ts.grey[150],borderActive:Ts.grey[200],borderActive1:Ts.grey[150],borderActive2:Ts.grey[200],borderActive3:Ts.grey[150],borderActive4:Ts.grey[400],foregroundFocus:Ts.grey[750],foregroundFocus1:Ts.grey[500],foregroundFocus2:Ts.grey[450],foregroundFocus3:Ts.white,backgroundFocus:Ts.white,backgroundFocus1:Ts.grey[50],backgroundFocus2:Ts.grey[100],backgroundFocus3:Ts.grey[150],borderFocusWithin:Ts.white,borderFocus:Ts.black,foregroundDisabled1:Ts.grey[250],foregroundDisabled:Ts.grey[250],backgroundDisabled:Ts.grey[150],backgroundDisabled1:Ts.grey[150],backgroundDisabled2:Ts.grey[50],backgroundDisabled3:Ts.grey[50],borderDisabled:Ts.grey[150]}),brand:Ws({foreground:Ts.brand[600],foreground1:Ts.brand[600],foreground2:Ts.brand[700],foreground3:Ts.brand[200],foreground4:Ts.white,foreground5:Ts.white,background:Ts.brand[600],background1:Ts.brand[100],background2:Ts.brand[900],background3:Ts.brand[1e3],background4:Ts.brand[800],background5:Ts.brand[100],background6:Ts.brand[600],border:Ts.grey[200],border1:Ts.brand[200],border2:Ts.brand[300],shadow:Ts.black,shadowHover:Ts.black,foregroundHover:Ts.brand[600],foregroundHover1:Ts.white,foregroundHover2:Ts.brand[200],borderHover:Ts.brand[300],backgroundHover:Ts.brand[700],backgroundHover1:Ts.brand[50],backgroundHover2:Ts.brand[100],backgroundHover3:Ts.brand[100],foregroundPressed:Ts.brand[800],foregroundPressed1:Ts.white,backgroundPressed:Ts.brand[800],backgroundPressed1:Ts.brand[100],backgroundPressed2:Ts.brand[100],borderPressed:Ts.brand[300],foregroundActive:Ts.brand[600],foregroundActive1:Ts.brand[600],foregroundActive2:Ts.brand[200],backgroundActive:Ts.brand[600],backgroundActive1:Ts.brand[600],borderActive:Ts.grey[200],borderActive1:Ts.brand[200],borderActive2:Ts.brand[300],foregroundFocus:Ts.brand[600],foregroundFocus1:Ts.brand[600],foregroundFocus2:Ts.brand[700],foregroundFocus3:Ts.brand[200],foregroundFocus4:Ts.white,backgroundFocus:Ts.brand[600],backgroundFocus1:Ts.brand[100],backgroundFocus2:Ts.brand[900],backgroundFocus3:Ts.brand[1e3],borderFocus:Ts.black,borderFocusWithin:Ts.white,borderFocus1:Ts.brand[600],foregroundDisabled:Ts.grey[250],foregroundDisabled1:Ts.grey[250],backgroundDisabled:Ts.grey[150],backgroundDisabled1:Ts.grey[150],borderDisabled:Ts.grey[150]}),black:{foreground:Ts.black,foreground1:Ts.white,background:Ts.white,background1:Ts.grey[750],border:Ts.black,shadow:Ts.black,foregroundHover:Ts.white,backgroundHover:Ts.black,borderHover:Ts.black,shadowHover:Ts.black,foregroundActive:Ts.white,backgroundActive:Ts.black,borderActive:Ts.black,shadowActive:Ts.black,foregroundFocus:Ts.white,backgroundFocus:Ts.black,borderFocus:Ts.black,shadowFocus:Ts.black,foregroundPressed:Ts.white,backgroundPressed:Ts.black,borderPressed:Ts.black,shadowPressed:Ts.black,foregroundDisabled:Ts.white,backgroundDisabled:Ts.black,borderDisabled:Ts.black,shadowDisabled:Ts.black},white:{foreground:Ts.white,foreground1:Ts.grey[750],background:Ts.black,background1:Ts.white,border:Ts.white,shadow:Ts.white,foregroundHover:Ts.black,backgroundHover:Ts.white,borderHover:Ts.white,shadowHover:Ts.white,foregroundActive:Ts.black,backgroundActive:Ts.white,borderActive:Ts.white,shadowActive:Ts.white,foregroundFocus:Ts.black,backgroundFocus:Ts.white,borderFocus:Ts.white,shadowFocus:Ts.white,foregroundPressed:Ts.black,backgroundPressed:Ts.white,borderPressed:Ts.white,shadowPressed:Ts.white,foregroundDisabled:Ts.black,backgroundDisabled:Ts.white,borderDisabled:Ts.white,shadowDisabled:Ts.white},green:Ws({foreground:Ts.green[600],foreground1:Ts.white,foreground2:Ts.green[400],foreground3:Ts.white,background:Ts.green[300],background1:Ts.green[600],background2:Ts.green[50],border:Ts.green[100],border1:Ts.green[600]}),orange:Ws({foreground:Ts.orange[400],foreground1:Ts.orange[300],foreground2:Ts.white,background:Ts.orange[400],background1:Ts.orange[400],border:Ts.orange[200]}),pink:Ws({foreground:Ts.pink[600],foreground1:Ts.pink[500],background:Ts.pink[50],border:Ts.pink[100]}),red:Ws({foreground:Ts.red[400],foreground1:Ts.white,foreground2:Ts.white,background:Ts.red[400],background1:Ts.red[50],background2:Ts.ruby[500],background3:Ts.red[400],border:Ts.red[100],border1:Ts.red[300],foregroundHover:Ts.white,backgroundHover:Ts.ruby[600],backgroundHover1:Ts.red[400],foregroundPressed:Ts.white,backgroundPressed:Ts.ruby[700]}),yellow:Ws({foreground:Ts.yellow[300],foreground1:Ts.grey[800],foreground2:Ts.white,foreground3:Ts.grey[750],foreground4:Ts.yellow[700],background:Ts.yellow[600],background1:Ts.yellow[100],background2:Ts.yellow[500],background3:Ts.yellow[100],border:Ts.yellow[200],border1:Ts.yellow[700]}),silver:Ws({foreground:Ts.white,foreground1:Ts.silver[200],foregroundHover:Ts.white,foregroundPressed:Ts.white,border:Ts.silver[600],background:"transparent",backgroundHover:Ts.silver[800],borderHover:Ts.silver[600],backgroundPressed:Ts.silver[700],borderPressed:Ts.silver[600],foregroundDisabled:Ts.silver[600],backgroundDisabled:Ts.silver[900]}),onyx:Ws({background:Ts.onyx[500],background1:Ts.onyx[100],background2:Ts.onyx[500],background3:Ts.onyx[400],backgroundHover:Ts.onyx[500],backgroundPressed:Ts.onyx[800],border:Ts.onyx[800],border1:"transparent",border2:Ts.onyx[300]}),amethyst:Ws({background:Ts.amethyst[600],backgroundHover:Ts.amethyst[700],backgroundHover1:Ts.amethyst[500],backgroundActive:Ts.amethyst[700]})};return e.grey=e.default,e}(),Ns=["default","black","white","brand","grey","red","yellow","green","pink","orange"],Us=function(e,r){return e&&function(e){return e&&Ns.indexOf(e)>=0}(e)?e:r?"brand":"default"},Zs=function(e,r,o){return e[Us(r,o)]},Vs={redDark:{100:"#FAF6F6",150:"#F2E4E5",200:"#E7CED1",250:"#CF9BA1",300:"#C07B82",350:"#C98289",400:"#A23D48",450:"#A03843",500:"#96232F",550:"#88232E",600:"#861F2A",650:"#721A23",700:"#69232A",750:"#521319",800:"#4D2327",850:"#3D2326",900:"#292424"},red:{100:"#FCF7F8",150:"#F8E8EA",200:"#F3D7D9",250:"#E7ADB2",300:"#DF9299",350:"#DC8990",400:"#D06069",450:"#CF5B65",500:"#CA4A55",550:"#B6454F",600:"#B6424C",650:"#993840",700:"#883B42",750:"#6E282E",800:"#603135",850:"#492C2E",900:"#2A2425"},orangeDark:{100:"#FCF7F6",150:"#F8E8E4",200:"#F2D5CD",250:"#E5AA99",300:"#DD8E77",350:"#DA846B",400:"#CD5937",450:"#CC5634",500:"#C7431D",550:"#B33F1E",600:"#B23C1A",650:"#973216",700:"#85361F",750:"#6D240F",800:"#5E2F21",850:"#482A22",900:"#2B2423"},orange:{100:"#FEF9F7",150:"#FCECE9",200:"#FBDED7",250:"#F7BBAD",300:"#F4A593",350:"#F39D89",400:"#F07A60",450:"#EF785D",500:"#EE694B",550:"#D66046",600:"#D65E43",650:"#B24932",700:"#9C4D3B",750:"#823929",800:"#6D3C32",850:"#51332C",900:"#2D2725"},orangeLight:{100:"#FEFBF7",150:"#FEF3E8",200:"#FDEAD4",250:"#FCD4A8",300:"#FCC68B",350:"#FBC181",400:"#FAAB54",450:"#FAA950",500:"#FAA03E",550:"#E0903A",600:"#E08F37",650:"#A45D11",700:"#A56F34",750:"#895722",800:"#72502D",850:"#533F29",900:"#2D2925"},yellowDark:{100:"#FDFBF6",150:"#FBF3E4",200:"#F8EACD",250:"#F1D499",300:"#EDC678",350:"#ECC26E",400:"#E5AC39",450:"#E4AA35",500:"#E2A11F",550:"#CA911F",600:"#CA901B",650:"#92660D",700:"#966E20",750:"#7C5811",800:"#685022",850:"#4E3F22",900:"#2C2924"},yellow:{100:"#FEFCF5",150:"#FEF6E2",200:"#FEEFCB",250:"#FEDF95",300:"#FDD472",350:"#FDD066",400:"#FDC030",450:"#FDBF2B",500:"#FDB814",550:"#E3A615",600:"#E4A512",650:"#8F680D",700:"#A67D1B",750:"#805E0B",800:"#72581E",850:"#544420",900:"#2D2922"},brown:{100:"#FBF9F8",150:"#F3EDEA",200:"#E9DDD8",250:"#D3BBAF",300:"#C4A494",350:"#BF9D8C",400:"#A87A63",450:"#A67760",500:"#9D684E",550:"#8E6049",600:"#8C5D46",650:"#764E3B",700:"#6D4C3C",750:"#56392B",800:"#503C33",850:"#3F322D",900:"#292625"},oliveDark:{100:"#F8F9F7",150:"#EBEEE7",200:"#DBE1D5",250:"#B7C2AA",300:"#9EAD8D",350:"#96A683",400:"#708757",450:"#6D8453",500:"#5E7741",550:"#566C3D",600:"#546B3A",650:"#475A31",700:"#465535",750:"#334123",800:"#38412E",850:"#31362A",900:"#272724"},olive:{100:"#FAFBF8",150:"#F1F5EC",200:"#E6EDDC",250:"#CCDBB8",300:"#BBD0A1",350:"#B5CC99",400:"#9BBA75",450:"#99B872",500:"#8EB163",550:"#809F5A",600:"#7F9E58",650:"#56742F",700:"#637849",750:"#4E6136",800:"#4B563A",850:"#3C4231",900:"#292926"},greenDark:{100:"#F5F9F7",150:"#E5EFE9",200:"#CFE1D7",250:"#9EC3AE",300:"#7DAE93",350:"#72A78A",400:"#408861",450:"#3C865D",500:"#27794C",550:"#266E46",600:"#236D44",650:"#1D5C39",700:"#26563B",750:"#154229",800:"#254232",850:"#25362C",900:"#252725"},green:{100:"#F6FBF9",150:"#E5F5ED",200:"#D1ECDF",250:"#A1DABD",300:"#82CDA8",350:"#78C9A0",400:"#48B67F",450:"#45B57C",500:"#30AD6E",550:"#2F9B64",600:"#2B9B62",650:"#248353",700:"#2B7550",750:"#1A5E3C",800:"#29553E",850:"#274134",900:"#242826"},tealDark:{100:"#F6F8F9",150:"#E5EBED",200:"#CEDADD",250:"#9BB4BA",300:"#7B9CA3",350:"#7FA3AB",400:"#3D6E79",450:"#386A75",500:"#235A67",550:"#23535E",600:"#1F515C",650:"#1A444E",700:"#24454C",750:"#133138",800:"#23373C",850:"#243033",900:"#252627"},teal:{100:"#F6F9FA",150:"#E9F0F2",200:"#D6E3E7",250:"#ABC6CE",300:"#8FB3BE",350:"#85ACB8",400:"#5A8F9F",450:"#578D9E",500:"#458193",550:"#417686",600:"#3E7484",650:"#34626F",700:"#375B66",750:"#254650",800:"#2F454C",850:"#2C383C",900:"#262828"},tealLight:{100:"#F8FCFC",150:"#EBF7F7",200:"#DBF1F1",250:"#B5E3E3",300:"#9DD9DB",350:"#96D6D8",400:"#70C8CA",450:"#6DC7C9",500:"#5DC1C3",550:"#55ADAF",600:"#53AEAF",650:"#37797B",700:"#468183",750:"#33696B",800:"#395B5C",850:"#314646",900:"#272A2A"},blueDark:{100:"#F5F7FA",150:"#E0E7F2",200:"#C7D4E8",250:"#8CA7D0",300:"#668AC0",350:"#6991CC",400:"#1E53A3",450:"#1A50A1",500:"#003D97",550:"#053988",600:"#003788",650:"#002E72",700:"#0F3268",750:"#002152",800:"#182D4D",850:"#1D293D",900:"#242528"},blue:{100:"#F6F8FB",150:"#E3EAF3",200:"#CDDAEA",250:"#99B3D4",300:"#779AC6",350:"#7FA3D0",400:"#376BAB",450:"#3469A9",500:"#1D58A0",550:"#1D5190",600:"#1A4F90",650:"#164279",700:"#20426E",750:"#0F3057",800:"#213650",850:"#232F3F",900:"#252629"},purpleDark:{100:"#F7F6FA",150:"#E8E7F2",200:"#D6D4E8",250:"#ADA8D1",300:"#918AC2",350:"#928BC5",400:"#5D53A5",450:"#5A50A4",500:"#483D9A",550:"#443A8C",600:"#40368A",650:"#362E75",700:"#3A336B",750:"#272154",800:"#312D4E",850:"#2C293D",900:"#262529"},purple:{100:"#F9F9FB",150:"#EFEDF5",200:"#E2DEED",250:"#C3BDDC",300:"#AFA6D0",350:"#A99FCC",400:"#8B7DBA",450:"#877AB8",500:"#7B6CB1",550:"#70629F",600:"#6E609E",650:"#5D5286",700:"#584E78",750:"#443B61",800:"#443D56",850:"#383342",900:"#282729"},maroon:{100:"#FBF7F9",150:"#F4E6EE",200:"#EBD3E1",250:"#D6A5C3",300:"#C988AF",350:"#CC87B1",400:"#AF5089",450:"#AD4C87",500:"#A5397A",550:"#953770",600:"#94336D",650:"#7D2B5C",700:"#723057",750:"#5A1F42",800:"#522B42",850:"#412836",900:"#2A2527"},pink:{100:"#FDF7F9",150:"#FAE7EE",200:"#F5D3DF",250:"#ECA4BE",300:"#E687A8",350:"#E47CA1",400:"#DA4E7F",450:"#DA4A7D",500:"#D6376F",550:"#C03465",600:"#C13164",650:"#A22954",700:"#8F2F50",750:"#751E3C",800:"#642A3E",850:"#4B2834",900:"#2B2426"},smokeDark:{100:"#F6F6F6",150:"#E8E8E8",200:"#D5D5D5",250:"#AAAAAA",300:"#8E8E8E",350:"#939393",400:"#5A5A5A",450:"#565656",500:"#444444",550:"#404040",600:"#3D3D3D",650:"#333333",700:"#373737",750:"#252525",800:"#2B2A2A",850:"#282828",900:"#262525"},smokeLight:{100:"#F9F9F9",150:"#EDEDED",200:"#DFDFDF",250:"#BEBEBE",300:"#A9A9A9",350:"#A1A1A1",400:"#818181",450:"#7E7E7E",500:"#707070",550:"#676767",600:"#646464",650:"#555555",700:"#525151",750:"#3D3D3D",800:"#353434",850:"#2E2D2D",900:"#272626"},steelDark:{100:"#F8F9F9",150:"#ECEEEF",200:"#DDE1E2",250:"#BBC2C4",300:"#A5AEB1",350:"#9DA7AB",400:"#7B898D",450:"#78868B",500:"#69797E",550:"#606E73",600:"#5E6D71",650:"#4F5B5F",700:"#4E5659",750:"#394245",800:"#3D4244",850:"#343637",900:"#272727"},steelLight:{100:"#FBFBFB",150:"#F3F3F5",200:"#EAEDEE",250:"#D4DADC",300:"#C7C6D0",350:"#C1CACC",400:"#ACABBB",450:"#A9B5B9",500:"#A0AEB2",550:"#919DA1",600:"#8F9C9F",650:"#637074",700:"#6F7678",750:"#585761",800:"#515556",850:"#404243",900:"#292828"},neon:{100:"#FAFEDF",150:"#F4FBC4",200:"#E9F1AC",250:"#E5F18F",300:"#D9E388",350:"#C8D464",400:"#BDCB4C",450:"#B7C640",500:"#A8B63A",550:"#99A43B",600:"#909A45",650:"#899338",700:"#7A8337",750:"#656C2B",800:"#50571E",850:"#3C4212",900:"#272B0E"}},Gs=function(e,r){return void 0===r&&(r={}),Object.assign({foreground:Vs[e][750],foreground1:Vs[e][400],background:Vs[e][200],borderActive:Vs[e][650]},r)},Xs={redDark:Gs("redDark"),red:Gs("red"),orangeDark:Gs("orangeDark"),orange:Gs("orange"),orangeLight:Gs("orangeLight"),yellowDark:Gs("yellowDark"),yellow:Gs("yellow"),brown:Gs("brown"),oliveDark:Gs("oliveDark"),olive:Gs("olive"),greenDark:Gs("greenDark"),green:Gs("green"),tealDark:Gs("tealDark"),teal:Gs("teal"),tealLight:Gs("tealLight"),blueDark:Gs("blueDark"),blue:Gs("blue"),purpleDark:Gs("purpleDark"),purple:Gs("purple"),maroon:Gs("maroon"),pink:Gs("pink"),smokeDark:Gs("smokeDark"),smokeLight:Gs("smokeLight"),steelDark:Gs("steelDark"),steelLight:Gs("steelLight"),neon:Gs("neon"),formatting:{foreground1:Vs.red[600],background1:Vs.red[300],foreground2:Vs.orangeDark[400],background2:Vs.orange[300],foreground3:Vs.yellow[400],background3:Vs.yellow[300],foreground4:Vs.neon[450],background4:Vs.neon[200],foreground5:Vs.green[600],background5:Vs.green[300],foreground6:Vs.tealLight[650],background6:Vs.tealLight[300],foreground7:Vs.blueDark[400],background7:Vs.blueDark[200],foreground8:Vs.maroon[500],background8:Vs.maroon[200]}},Ys="1px",$s="2px",Ks="4px",qs="8px",Js=Ts.white,Qs=Ts.black,ec="0 .2rem .4rem -.075rem rgba(0, 0, 0, .1)",rc="0 .4rem .7rem -.1rem rgba(0, 0, 0, .1)",oc="0 .8rem 1rem -.2rem rgba(0, 0, 0, .1)",tc="0 1.6rem 1.8rem -.4rem rgba(0, 0, 0, .1)",nc="0 .2rem .4rem -.075rem rgba(0, 0, 0, .25)",ac="0 0 2px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .14)",ic="0 0 2px rgba(0, 0, 0, .12), 0 2px 4px rgba(0, 0, 0, .14)",lc="0 0 2px rgba(0, 0, 0, .12), 0 4px 8px rgba(0, 0, 0, .14)",sc="0 0 2px rgba(0, 0, 0, .12), 0 8px 16px rgba(0, 0, 0, .14)",cc="0 0 8px rgba(0, 0, 0, .20), 0 14px 28px rgba(0, 0, 0, .24)",dc="0 0 8px rgba(0, 0, 0, .20), 0 32px 64px rgba(0, 0, 0, .24)",uc={smaller:Is(10),small:Is(12),medium:Is(14),large:Is(18),larger:Is(24),largest:Is(28)},fc=200,gc=300,pc=400,bc=600,mc=700,hc=1,vc=1.2,yc=1.3333,Cc=1.4286,kc=1.3333,wc=1.3333,xc=1.3333,Sc={background:0,foreground:1,menuItem:2,overlay:1e3,overlayPriority:1001,debug:999999999},Bc=0,Ec=0,Oc='"Segoe UI", system-ui, "Apple Color Emoji", "Segoe UI Emoji", sans-serif',Fc=uc.medium,Ac=Ts.white,Pc=Ts.grey[750],jc=Cc,Rc=function(e){return {color:e.bodyColor,focusBorderColor:e.focusOuterBorderColor,focusBorderRadius:e.borderRadiusMedium,focusBorderWidth:e.borderWidth}},Ic=function(e){return {padding:Is(7)+" "+Is(3)+" "+Is(7)+" "+Is(11),iconSpace:Is(12),iconSize:Is(32),borderColor:e.colorScheme.default.border3,borderRadius:e.borderRadiusMedium,backgroundColor:e.colorScheme.default.background4,backgroundColorHover:e.colorScheme.default.backgroundHover1,textColor:e.colorScheme.default.foreground,textColorHover:e.colorScheme.default.foregroundHover,boxShadow:e.shadowLevel1,focusBackgroundColor:void 0,focusColor:void 0,progressColor:e.colorScheme.green.background,progressHeight:Is(4),headerFontSize:e.fontSizes.medium,headerFontWeight:e.fontWeightSemibold,headerLineHeight:e.lineHeightMedium,descriptionFontSize:e.fontSizes.small,descriptionFontWeight:e.fontWeightRegular,descriptionLineHeight:e.lineHeightDefault,actionHeight:Is(32),actionMaxWidth:Is(280),actionColor:e.colorScheme.default.foreground,actionPrimaryColor:e.colorScheme.brand.foreground,actionColorDisabled:e.colorScheme.brand.foregroundDisabled1,actionIconSize:Is(16),actionLoaderBorderSize:Is(2),actionLoaderSize:Is(20),actionLoaderSvgHeight:Is(1220),actionLoaderSvgAnimationHeight:Is(-1200),actionFocusBorderRadius:e.borderRadiusMedium}},Mc=function(e){var r=Is(28);return {borderStyle:"solid",borderWidth:"1px",borderRadius:e.borderRadiusMedium,backgroundColor:e.colorScheme.default.background4,borderColor:e.colorScheme.default.border2,color:e.colorScheme.default.foreground1,fontWeight:e.fontWeightRegular,minHeight:r,padding:"0 "+Is(16),actionsMargin:Is(5),hoverBorderColor:void 0,hoverBackgroundColor:void 0,focusBackgroundColor:void 0,dismissActionHoverBorderRadius:void 0,dismissActionHoverBorderWidth:void 0,dismissActionHoverInnerBorderColor:void 0,dismissActionHoverOuterBorderColor:void 0,dismissActionHoverZIndex:void 0,dismissActionSize:r,dismissActionColor:void 0,dismissiblePadding:"0 0 0 "+Is(16),dangerColor:e.colorScheme.red.foreground,dangerBackgroundColor:e.colorScheme.red.background1,dangerBorderColor:e.colorScheme.red.border,oof:!1,oofColor:e.colorScheme.pink.foreground,oofBackgroundColor:e.colorScheme.pink.background,oofBorderColor:e.colorScheme.pink.border,successColor:e.colorScheme.green.foreground,successBackgroundColor:e.colorScheme.green.background2,successBorderColor:e.colorScheme.green.border,urgent:!1,urgentColor:e.colorScheme.red.foreground1,urgentBackgroundColor:e.colorScheme.red.background3,urgentBorderColor:e.colorScheme.red.background3,warningColor:e.colorScheme.yellow.foreground4,warningBackgroundColor:e.colorScheme.yellow.background3,warningBorderColor:e.colorScheme.yellow.border,headerFontWeight:e.fontWeightSemibold,headerMargin:"0 "+Is(10)+" 0 0",iconMargin:"0 "+Is(10)+" 0 0",iconSize:Is(16),dismissActionBackgroundColor:"transparent",dismissActionBorderRadius:e.borderRadiusMedium,dismissActionBorderColor:"transparent",dismissActionColorHover:e.colorScheme.brand.foregroundHover,dismissActionBackgroundColorHover:e.colorScheme.default.backgroundHover2,dismissActionBorderColorHover:e.colorScheme.default.borderHover,dismissActionContentFontWeight:e.fontWeightSemibold,dismissActionBackgroundColorFocus:void 0,dismissActionBorderColorFocus:void 0,dismissActionColorFocus:void 0,dismissActionColorDisabled:e.colorScheme.brand.foregroundDisabled,dismissActionBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled,dismissActionBorderColorDisabled:"transparent",dismissActionIndicatorSize:Is(16),focusBorderRadius:e.borderRadiusMedium,focusBorderWidth:e.borderWidth,focusInnerBorderColor:e.focusInnerBorderColor,focusOuterBorderColor:e.focusOuterBorderColor,focusBorderZIndex:e.zIndexes.foreground}},Dc=function(){return function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return r}.apply(void 0,arguments)},zc=(Dc("foreground","background"),function(e){return {avatarBorderColor:"",avatarBorderWidth:"0",squareAvatarBorderRadius:e.borderRadiusMedium,iconColor:e.colors.white,iconBackgroundColor:e.colors.brand[600],statusBorderWidth:"2px",statusIconSize:Is(7),statusBorderColor:e.bodyBackground,statusSuccessBackgroundColor:e.colorScheme.green.background,statusSuccessColor:e.colorScheme.green.foreground1,statusInfoBackgroundColor:e.colorScheme.brand.background,statusInfoColor:e.colorScheme.default.foreground2,statusWarningBackgroundColor:e.colorScheme.yellow.background,statusWarningColor:e.colorScheme.yellow.foreground2,statusErrorBackgroundColor:e.colorScheme.red.background,statusErrorColor:e.colorScheme.red.foreground2,statusBackgroundColor:e.colorScheme.default.background5,statusColor:e.colorScheme.default.foreground4,imageWidth:void 0,imageHeight:void 0,imageAvatarRadius:Is(9999),imageAvatarSize:Is(32),imageCircularRadius:Is(9999),labelCircularRadius:Is(9999),labelColor:"rgba(0, 0, 0, 0.6)",labelBackground:"rgb(232, 232, 232)"}}),_c=function(e){return {padding:"0 "+Is(20),height:Is(32),minWidth:Is(96),loadingMinWidth:Is(118),maxWidth:Is(280),borderRadius:e.borderRadiusMedium,contentFontSize:e.fontSizes.medium,contentFontWeight:e.fontWeightSemibold,contentLineHeight:e.lineHeightMedium,color:e.colorScheme.default.foreground,colorHover:e.colorScheme.default.foregroundHover,colorActive:e.colorScheme.default.foregroundPressed,colorDisabled:e.colorScheme.brand.foregroundDisabled,colorFocus:void 0,iconSize:Is(16),backgroundColor:e.colorScheme.default.background,backgroundColorActive:e.colorScheme.default.backgroundPressed,backgroundColorHover:e.colorScheme.default.backgroundHover1,backgroundColorFocus:void 0,backgroundColorDisabled:e.colorScheme.default.backgroundDisabled,borderColor:e.colorScheme.default.border,borderColorHover:e.colorScheme.default.borderHover,borderColorFocus:void 0,borderColorActive:e.colorScheme.default.borderPressed,borderColorDisabled:"transparent",backgroundColorIconOnlyHover:e.colorScheme.default.backgroundHover2,primaryColor:e.colorScheme.brand.foreground4,primaryColorHover:e.colorScheme.brand.foreground4,primaryBackgroundColor:e.colorScheme.brand.background,primaryBackgroundColorActive:e.colorScheme.brand.backgroundPressed,primaryBackgroundColorHover:e.colorScheme.brand.backgroundHover,primaryBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled,primaryBackgroundColorFocus:void 0,primaryBorderColor:"transparent",tintedColor:e.colorScheme.brand.foreground,tintedColorHover:e.colorScheme.brand.foregroundHover,tintedBackgroundColor:e.colorScheme.default.background,tintedBackgroundColorActive:e.colorScheme.brand.backgroundHover1,tintedBackgroundColorHover:e.colorScheme.brand.backgroundHover1,tintedBorderColor:e.colorScheme.brand.border1,tintedBorderColorHover:e.colorScheme.brand.borderHover,circularBorderRadius:Is(999),textColor:e.colorScheme.default.foreground1,textColorHover:e.colorScheme.brand.foreground1,textPrimaryColor:e.colorScheme.brand.foreground,textPrimaryColorHover:e.colorScheme.brand.foreground1,textColorDisabled:e.colorScheme.brand.foregroundDisabled1,textColorIconOnlyHover:e.colorScheme.brand.foregroundHover,primaryBoxShadow:e.shadowLevel1Dark,boxShadow:e.shadowLevel1,loaderBorderSize:Is(2),loaderSize:Is(20),loaderSvgHeight:Is(1220),loaderSvgAnimationHeight:Is(-1200),sizeSmallContentFontSize:e.fontSizes.small,sizeSmallContentLineHeight:e.lineHeightSmall,sizeSmallHeight:Is(24),sizeSmallMinWidth:Is(72),sizeSmallPadding:"0 "+Is(8),sizeSmallLoaderBorderSize:Is(2),sizeSmallLoaderSize:Is(15),sizeSmallLoaderSvgHeight:Is(895),sizeSmallLoaderSvgAnimationHeight:Is(-880)}},Hc=function(e){return {dividerMargin:"0 "+Is(8),fontSizeSmaller:Is(12),fontSizeSmall:Is(12),fontSizeMedium:Is(14),fontSizeLarge:Is(18),itemCurrentFontWeight:e.fontWeightBold,linkPaddingTop:Is(6),linkPaddingBottom:Is(6),linkPaddingLeftSmaller:Is(4),linkPaddingRightSmaller:Is(4),linkPaddingLeftSmall:Is(8),linkPaddingRightSmall:Is(8),linkPaddingLeftMedium:Is(12),linkPaddingRightMedium:Is(12),linkPaddingLeftLarge:Is(12),linkPaddingRightLarge:Is(12),linkSmallerGap:Is(2),linkSmallGap:Is(8),linkMediumGap:Is(8),linkLargeGap:Is(8),disabledColor:e.colorScheme.default.foregroundDisabled}},Tc=function(e){return {backgroundColor:e.colorScheme.default.background2}},Wc=function(){return {gutterMargin:Is(10),gutterMarginCompact:Is(2),margin:Is(8),messageMargin:Is(40),messageMarginCompact:Is(56),messageMarginEndCompact:Is(16)}},Lc=function(e){return {actionMenuBoxShadow:e.shadowLevel1,actionMenuPositionRight:Is(5),actionMenuPositionTop:Is(-30),authorColor:e.colorScheme.default.foreground,authorColorMineCompact:e.colorScheme.brand.foreground,authorFontWeight:e.fontWeightSemibold,authorFontWeightCompact:e.fontWeightSemibold,authorMarginRight:Is(12),authorMarginRightCompact:Is(8),backgroundColor:e.colorScheme.default.background,backgroundColorMine:e.colorScheme.brand.background1,badgeShadow:e.shadowLevel1Dark,badgeTextColor:e.colorScheme.brand.foreground4,border:"none",borderRadius:e.borderRadiusMedium,compactBorder:"solid "+e.borderWidth+" transparent",compactHoverBackground:e.colorScheme.default.backgroundHover3,compactHoverBorder:"solid "+e.borderWidth+" "+e.colorScheme.default.backgroundHover3,compactSpacing:Is(12),contentColor:e.colorScheme.default.foreground,hasMention:!1,hasMentionColor:e.colors.orange[300],hasMentionNubbinColor:e.colorScheme.orange.background,headerMarginBottom:Is(2),isImportant:!1,isImportantColor:e.colorScheme.red.background,linkColor:e.colorScheme.brand.foreground1,linkColorMine:e.colorScheme.brand.foreground2,offset:Is(100),overlayZIndex:e.zIndexes.overlay,padding:Is(16),paddingCompact:Is(3),reactionGroupBorderColor:"transparent",reactionGroupMarginLeft:Is(12),showActionMenu:void 0,zIndex:e.zIndexes.foreground}},Nc=function(e){return {detailsColor:e.colorScheme.default.foreground1,detailsFontSize:e.fontSizes.small,detailsMargin:Is(12)}},Uc=function(e){return {bottomPosition:Is(0),bottomPositionCompact:Is(2),color:e.colorScheme.brand.foreground1,rightPosition:Is(-24),rightPositionCompact:Is(-16)}},Zc=Is(20),Vc=Is(2),Gc="red",Xc=function(e){return {checkboxColor:"transparent",toggleBackground:"transparent",toggleBorderColor:e.colors.grey[300],toggleBorderStyle:"solid",toggleBorderWidth:Is(1),toggleIndicatorColor:"inherit",checkboxCheckedColor:e.colors.grey[500],checkboxToggleCheckedBackground:"transparent",checkboxToggleCheckedBorderColor:e.colors.grey[500],checkboxToggleCheckedColor:"inherit",disabledColor:e.colors.grey[300],disabledCheckboxColor:e.colors.grey[300],disabledToggleBackground:"transparent",disabledToggleBorderColor:e.colors.grey[200],textColor:En()(e,"colorScheme.default.foreground1",Gc),background:"transparent",borderColor:En()(e,"colorScheme.default.foreground1",Gc),borderStyle:"solid",borderRadius:e.borderRadiusSmall,borderWidth:Is(1),indicatorColor:"transparent",gap:Is(12),margin:Is(2.8)+" 0 0 0",padding:Vc,rootPadding:"3px 5px",textColorHover:En()(e,"colorScheme.default.foreground",Gc),borderColorHover:En()(e,"colorScheme.default.foreground",Gc),checkedBackgroundHover:En()(e,"colorScheme.brand.backgroundHover",Gc),toggleBorderRadius:Is(999),toggleIndicatorSize:Is(14),toggleMargin:"0",togglePadding:Vc+" "+Zc+" "+Vc+" "+Vc,toggleWidth:Is(38),toggleHeight:Is(20),checkedTextColor:En()(e,"colorScheme.default.foreground",Gc),checkedBackground:En()(e,"colorScheme.brand.backgroundActive1",Gc),checkedBorderColor:En()(e,"colorScheme.brand.backgroundActive1",Gc),checkedIndicatorColor:En()(e,"colorScheme.default.background",Gc),toggleCheckedPadding:Vc+" "+Vc+" "+Vc+" "+Zc,disabledBackground:En()(e,"colorScheme.default.background",Gc),disabledBackgroundChecked:En()(e,"colorScheme.default.backgroundDisabled",Gc),disabledBorderColor:En()(e,"colorScheme.default.foregroundDisabled1",Gc),disabledCheckedIndicatorColor:En()(e,"colorScheme.default.foregroundDisabled",Gc),disabledToggleIndicatorColor:En()(e,"colorScheme.default.foregroundDisabled",Gc)}},Yc=function(e){return {border:"none",rootBackground:e.colors.white,rootBorderRadius:e.borderRadiusXLarge,rootWidth:"600px",rootPadding:Is(27)+" "+Is(32)+" "+Is(32)+" "+Is(32),rootPaddingZoom:""+Is(12),contentMargin:"0 0 "+Is(20)+" 0",boxShadow:e.shadowLevel4,foregroundColor:e.colors.grey[900],headerFontSize:e.fontSizes.large,headerFontWeight:e.fontWeightBold,headerMargin:"0 0 "+Is(8)+" 0",overlayBackground:"rgba(37, 36, 36, .75)",overlayZIndex:e.zIndexes.overlay,headerActionMargin:Is(-3)+" "+Is(-8)+" 0 0",footerActionsBreakpoint:"400px"}},$c=function(e,r){var o=e;return Object.keys(r).forEach((function(t){var n;o=Object.assign({},o,((n={})[t]=Object.assign({},e[t],r[t]),n));})),o};function Kc(e,r){var o={};return Object.keys(e).forEach((function(t){var n,a=r.reduce((function(r,o){var n;return Object.assign({},r,((n={})[o]=e[t][o],n))}),{});o=Object.assign({},o,((n={})[t]=a,n));})),o}var qc,Jc,Qc,ed,rd=Dc("foreground"),od=function(e){return {colorScheme:Kc(e.colorScheme,rd),dividerColor:e.colors.grey[150],textColor:e.colors.grey[450],textFontSize:e.fontSizeSmall,textLineHeight:e.lineHeightSmall,importantFontWeight:e.fontWeightBold,dividerPadding:Is(4)}},td=function(e){return {backgroundColor:e.colorScheme.default.background2,backgroundColorHover:e.colorScheme.default.backgroundHover3,invertedBackgroundColor:e.colorScheme.default.background,invertedBackgroundColorHover:e.colorScheme.default.backgroundHover4,borderColor:"transparent",borderColorHover:"transparent",borderColorFocus:e.colorScheme.brand.borderFocus1,borderError:e.colorScheme.red.background,borderWidth:"0px",openBorderColorHover:void 0,containerBorderRadius:e.borderRadiusMedium,disabledColor:e.colorScheme.default.foregroundDisabled,openAboveContainerBorderRadius:"0 0 "+e.borderRadiusMedium+" "+e.borderRadiusMedium,openBelowContainerBorderRadius:e.borderRadiusMedium+" "+e.borderRadiusMedium+" 0 0",searchBorderBottomWidth:Is(2),color:e.colorScheme.default.foreground1,comboboxPaddingButton:"0 "+Is(12),comboboxFlexBasis:Is(50),aboveListBorderRadius:e.borderRadiusMedium+" "+e.borderRadiusMedium+" 0 0",belowListBorderRadius:"0 0 "+e.borderRadiusMedium+" "+e.borderRadiusMedium,listBackgroundColor:e.colorScheme.default.background,listBorderColor:"transparent",listBorderWidth:"0px",listPadding:Is(8)+" 0 "+Is(6),listBoxShadow:e.shadowLevel3,listMaxHeight:Is(296),listItemFocusBorderWidth:Is(1),listItemBackgroundColor:"transparent",listItemBackgroundColorActive:e.colorScheme.default.backgroundActive,listItemBackgroundColorHover:e.colorScheme.default.backgroundHover,listItemColorActive:e.colorScheme.default.backgroundFocus3,listItemColorHover:e.colorScheme.default.foregroundHover,listItemSelectedColor:e.colorScheme.default.foreground,listItemSelectedFontWeight:e.fontWeightSemibold,listItemHeaderLineHeight:e.lineHeightSmall,listItemContentLineHeight:e.lineHeightSmall,selectedItemBackgroundColor:e.colorScheme.default.background,selectedItemBackgroundColorHover:e.colorScheme.brand.backgroundHover2,selectedItemBorder:"none",selectedItemColor:e.colorScheme.default.foreground,selectedItemColorHover:e.colorScheme.default.foregroundHover,selectedItemIconColor:e.colorScheme.default.foreground1,selectedItemIconColorHover:e.colorScheme.brand.foregroundHover,selectedItemsMaxWidth:Is(140),selectedItemColorFocus:e.bodyColor,selectedItemsMaxHeight:Is(82),toggleIndicatorSize:Is(32),triggerButtonColorFocusActive:void 0,triggerButtonColorHover:e.bodyColor,width:Is(356),overlayZIndex:e.zIndexes.overlay,disabledBorderColorHover:"transparent",disabledTriggerColorHover:e.colorScheme.brand.foregroundDisabled,disabledBackgroundColorHover:e.colorScheme.brand.backgroundDisabled,listItemHeaderFontSize:e.fontSizes.medium,listItemHeaderColor:e.colorScheme.default.foreground1,listItemContentFontSize:e.fontSizes.small,listItemContentColor:e.colorScheme.default.foreground2,headerMessageBackgroundColor:e.colors.white,noResultsMessageBackgroundColor:"transparent",loadingMessageBackgroundColor:"transparent"}},nd=function(e){return {controlColor:e.colors.white,controlBackgroundColor:e.colors.onyx[900],controlBackgroundSize:Is(24)+" "+Is(24),width:void 0,height:void 0,focusBorderColor:e.colors.brand[500],zIndex:e.zIndexes.foreground}},ad=function(){return {"gap.smaller":Is(8),"gap.small":Is(10),"gap.medium":Is(15),"gap.large":Is(30),"padding.medium":Is(10)}},id=function(){return {"size.half":"50%","size.quarter":"25%","size.small":Is(150),"size.medium":Is(200),"size.large":Is(300)}},ld=function(e){return {lastChildMarginTop:Is(12),fieldsMarginBottom:Is(20)}},sd=Dc("foreground","background"),cd=function(e){return {colorScheme:Kc(e.colorScheme,sd),messagePaddingLeft:Is(12)}},dd=Dc("foreground"),ud=function(e){return {colorScheme:Kc(e.colorScheme,dd),paddingLeft:Is(12)}},fd=function(e){return {lineHeight:Is(16),marginBottom:Is(4)}},gd=function(){return {defaultColumnCount:5,gridGap:void 0,padding:void 0}},pd=Dc("foreground"),bd=function(e){return {colorScheme:Kc(e.colorScheme,pd),color:e.colors.grey[750],descriptionColor:void 0}},md=Dc("foreground"),hd=function(e){return {colorScheme:Kc(e.colorScheme,md),color:e.colors.grey[350]}},vd=Dc("foreground"),yd=function(e){return {colorScheme:Kc(e.colorScheme,vd),color:void 0,borderColor:void 0,backgroundColor:void 0,brandColor:e.brandColor,secondaryColor:e.colors.white,redColor:e.colors.red[400],disabledColor:e.colors.grey[250],smallestSize:Is(7),smallerSize:Is(10),smallSize:Is(12),mediumSize:Is(16),largeSize:Is(20),largerSize:Is(32),largestSize:Is(40),horizontalSpace:Is(10)}},Cd=function(){return {width:void 0,height:void 0,avatarRadius:Is(9999),avatarSize:Is(32),circularRadius:Is(9999)}},kd=function(e){return {colorDisabled:e.colorScheme.brand.foregroundDisabled,colorError:e.colorScheme.red.foreground,borderColorError:e.colorScheme.red.background,iconPosition:"absolute",iconRight:Is(10),iconLeft:Is(9),inputPaddingWithIconAtStart:Is(5)+" "+Is(12)+" "+Is(5)+" "+Is(34),inputPaddingWithIconAtEnd:Is(5)+" "+Is(35)+" "+Is(5)+" "+Is(12),inputPadding:Is(5)+" "+Is(12),inputInsideLabelPaddingTop:Is(14),borderColor:"transparent",borderRadius:e.borderRadiusMedium,borderWidth:"0 0 "+Is(2)+" 0",backgroundColor:e.colorScheme.default.background2,backgroundColorInverted:e.colorScheme.default.background,fontColor:e.colorScheme.default.foreground,fontSize:e.fontSizes.medium,iconColor:e.colorScheme.default.foreground,successfulColor:e.colorScheme.green.foreground,inputFocusBorderColor:"transparent transparent "+e.colorScheme.brand.borderFocus1+" transparent",inputFocusBorderRadius:e.borderRadiusMedium+" "+e.borderRadiusMedium+" "+e.borderRadiusSmall+" "+e.borderRadiusSmall,placeholderColor:e.colorScheme.default.foreground1}},wd=function(e){return {insideLabelBottom:Is(-8),insideLabelPaddingLeft:Is(12),insideLabelActiveFontSize:Is(12),inlineLabelPaddingRight:Is(10),lineHeight:Is(16),marginBottom:Is(4)}},xd=function(e){return {circularRadius:Is(9999),iconSize:Is(16),padding:"0 "+Is(4)+" 0 "+Is(4),startPaddingLeft:"0px",endPaddingRight:"0px",height:Is(20),foreground:"rgba(0, 0, 0, 0.6)",background:"rgb(232, 232, 232)",blackForeground:e.colorScheme.black.foreground1,blackBackground:e.colorScheme.black.background1,whiteForeground:e.colorScheme.white.foreground1,whiteBackground:e.colorScheme.white.background1,brandForeground:e.colorScheme.brand.foreground5,brandBackground:e.colorScheme.brand.background6,greyForeground:e.colorScheme.grey.foreground2,greyBackground:e.colorScheme.grey.background3,orangeForeground:e.colorScheme.orange.foreground2,orangeBackground:e.colorScheme.orange.background1,redForeground:e.colorScheme.red.foreground1,redBackground:e.colorScheme.red.background,greenForeground:e.colorScheme.green.foreground3,greenBackground:e.colorScheme.green.background1,yellowForeground:e.colorScheme.yellow.foreground3,yellowBackground:e.colorScheme.yellow.background}},Sd=function(){return {}},Bd=function(){return {containerHeights:{smallest:Is(24),smaller:Is(24),small:Is(24),medium:Is(36),large:Is(72),larger:Is(72),largest:Is(72)},containerWidths:{smallest:Is(24),smaller:Is(24),small:Is(24),medium:Is(36),large:Is(72),larger:Is(72),largest:Is(72)},svgContent:"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 4880'%3E%3Cg role='presentation'%3E%3Cpath fill='%236264a7' d='M67.4 26.4c5.8-2 12.4 3.3 11.4 9.4-.4 6.5-8.8 10-13.8 6-5.6-3.6-4.2-13.5 2.4-15.3zM66.5 113.7c5.7-3.3 13.6 1.8 12.7 8.4 0 6.4-8 10.4-13.2 7-5.6-3.2-5.4-12.5.5-15.3z'%3E%3C/path%3E%3Cpath fill='%235659b0' d='M65.5 200.4c5.7-3.4 13.6 2 12.6 8.5 0 6-7 10.7-12.7 7.7-6.4-3-6-13.2.2-16.3z'%3E%3C/path%3E%3Cpath fill='%23575ab1' d='M64.3 286.2c5-2 11.3 2.3 11.2 7.8 0 5.4-4.5 11.7-10.5 11-5.4-.3-9.2-6.3-7.3-11.2 1.2-3.2 3.2-6.5 6.6-7.6z'%3E%3C/path%3E%3Cpath fill='%23585bb2' d='M59.4 372.5c5-2.6 11.6 1 12 6.5.8 5-3.4 8.6-7 11.3-4.5 3.2-11.7.2-12.6-5.3-1.4-5.5 3.6-9.7 7.6-12.5z'%3E%3C/path%3E%3Cpath fill='%235a5db4' d='M54.3 457.4c4-2.2 9.6 0 11.2 4.2 1.7 3.7 0 8.4-3.5 10.5-3.7 2.5-8.2 5.6-12.8 4-4.3-1.6-6.5-6.8-4.8-11 1.5-4.2 6.4-5.4 10-7.6z'%3E%3C/path%3E%3Cpath fill='%235b5fb6' d='M48.6 540.7c4.4-2 10 1 11 5.7 1 4-1.4 8.4-5.4 9.7-4 1.6-8.5 3-13 2.5-5.6-.8-8.6-8-5.3-12.6 2.7-4.4 8.4-3.5 12.6-5.3z'%3E%3C/path%3E%3Cpath fill='%235d60b8' d='M29.4 622.4c3-1.5 6.4 0 9.6 0 3.4.3 7.3-1 10.3 1.3 4.6 3 4.4 10.4-.2 13.3-3.7 2-8.2 1.7-12.4 1.5-3.6-.5-7.8-.7-10.2-4-3.2-3.7-1.6-10.2 3-12z'%3E%3C/path%3E%3Cpath fill='%235f63ba' d='M20.3 698.3c4-2 7.8 1.3 11.4 2.8 4 2 9.6 1 12.2 5 3.3 4.7-.2 12-6 12.3-7 0-14-2.6-19.7-6.6-4.7-3.4-3.5-11.6 2-13.4z'%3E%3C/path%3E%3Cpath fill='%236165bc' d='M12.3 771.3c3-1.5 7-.6 9 2 3 3.8 6.7 6.7 11 8.3 3.3 1 5.7 4 5.5 7.4.2 4.8-4.8 8.7-9.3 7.4-7.7-2.2-14.5-7.2-19.3-13.6-2.8-3.7-1.2-9.8 3-11.5z'%3E%3C/path%3E%3Cpath fill='%236467bf' d='M7.5 841.7c4-2 9.2.3 10.3 4.6 1.7 5.4 5 10 9.7 13 4 2.5 4.6 8.4 1.4 11.6-2.5 2.6-7 3-10 1-7.4-5-13-12.6-15.5-21-1.2-3.6.5-8 4-9.3z'%3E%3C/path%3E%3Cpath fill='%23666ac1' d='M6.5 910.8c3-1.6 7.3-.4 9 2.6 1.7 2.2 1 5 1.4 7.6 0 5.6 2.5 11 6 15 2.5 2.5 2.7 6.7.5 9.5-2.4 3.3-7.8 3.8-10.7 1-7.6-7.8-11.5-19-10.6-29.6.2-2.7 1.8-5.2 4.3-6.2z'%3E%3C/path%3E%3Cpath fill='%23696cc4' d='M9.3 980c3.7-2 9 .3 10 4.4 1 2.4-.2 4.8-1 7-2.4 5.7-2.3 12.4.3 18 1 2.3 2.4 5 1.5 7.6-1 4-5.7 6.2-9.5 4.5-2.6-1-3.8-3.7-5-6-4.4-10-4.3-21.8.4-31.6.6-1.7 1.7-3 3.3-4z'%3E%3C/path%3E%3Cpath fill='%236b6fc7' d='M16.3 1051.2c4-2.6 10 1 10 5.8.5 3-2 5.3-4 7.4-5.3 5.7-7 14-5.2 21.6 1 3.5-1 7.4-4.4 8.5-3.4 1.2-7.6-.8-8.7-4.3-4.2-13.8.7-30.2 12.3-39z'%3E%3C/path%3E%3Cpath fill='%236e72ca' d='M26.4 1125.3c4.5-2.6 10.7 1.5 10 6.7-.4 3.3-3.3 5.2-6 6.3-8.2 3.4-14 11.8-14.2 20.6 0 2.6-.6 5.6-3.2 7-4 2.8-10 0-10.2-5-.8-15.3 9.2-30.3 23.6-35.7z'%3E%3C/path%3E%3Cpath fill='%237175cd' d='M35.3 1203.2c3.7-.3 8.6-1.2 11.2 2.3 2.7 3.2 1 8.8-3 10-3.7.8-7.7.3-11.3 1.7-8 2.6-13.8 9.5-15.8 17.5-1 4.7-7.6 6.2-10.8 2.7-2.8-2.7-1.7-7-.4-10 4.5-13 16.6-22.6 30-24.2z'%3E%3C/path%3E%3Cpath fill='%237478d0' d='M36.4 1283.3c7-.6 14.2.5 20.3 4 3.8 2.4 3.3 8.7-.8 10.6-3 1.5-6-.2-8.6-1-9.8-3.5-21.6.5-27.3 9-1.5 2.4-3 5.6-6 6-4.6 1-9-4.4-6.8-8.7 5.4-11 17-18.8 29.2-20z'%3E%3C/path%3E%3Cpath fill='%23777bd3' d='M36.5 1363.5c11.6-1 23.8 3.6 31.3 12.7 2.7 3.6-.3 9.5-4.8 9.4-3.2.3-5-2.6-7.3-4.4-8.4-7.4-22.2-7.6-31-.4-2.3 1.8-4.3 5-7.7 4.7-4.7 0-7.5-6.3-4.4-9.8 6-7 14.8-11.3 24-12.2z'%3E%3C/path%3E%3Cpath fill='%237a7ed6' d='M31.4 1444.6c18-4.8 38.3 6.6 43.3 24.6 1 4-3.5 8-7.4 6.6-3.5-1-4-4.8-5.5-7.5-5.5-10.8-19.6-16-30.8-11.4-3.2 1-6.2 4.3-10 3-3.8-1.4-5-7.2-1.7-9.8 3.5-2.8 7.8-4.4 12-5.6z'%3E%3C/path%3E%3Cpath fill='%237d81da' d='M32.4 1524.6c15-3.4 31.8 4 39.2 17.8 3.5 6.5 5.3 14 4.3 21.5-1 4-6.7 5.5-9.5 2.4-2-2-1.4-5-1.6-7.4-.2-11.6-9.6-22-21-23.7-4.4-.8-8.8 0-13 1-4 1.2-7.7-3.5-6-7.2 1-3 4.6-3.7 7.4-4.4z'%3E%3C/path%3E%3Cpath fill='%238084dd' d='M36.3 1604.4c14-2 28.5 6 35 18.2 6 10.6 6 24.3 0 34.8-2 3.5-7.6 3-9-.6-1.8-3.5 1.4-6.8 2-10.2 3.8-12.4-4-26.7-16.3-30.5-4-1.6-8.3-.8-12.4-1.6-4.6-1.7-4-9 .7-10z'%3E%3C/path%3E%3Cpath fill='%238387e0' d='M43.3 1685.3c4-1.2 8.2 1 12 2.5 14.7 6.6 23.3 24.2 19.5 40-1.8 8-6.5 15.7-13.4 20.6-3 2.2-8-.6-7.7-4.4 0-2.3 1.8-3.7 3.3-5 7-6 10-16 7.8-24.7-1.8-8-7.6-15-15.3-18-2.2-.8-4.6-1-6.8-2-3.4-2-3-7.5.6-9z'%3E%3C/path%3E%3Cpath fill='%23868be4' d='M50.2 1768c1.4-.8 3.2-.8 4.7 0 13.2 5.7 21.7 20.5 20.3 35-1 15-12.6 28.5-27.3 31.4-3.4.6-6.4-3-5-6.3.6-2.6 3.7-3 6-4 8.2-2.8 14.5-10.4 16.2-19 2-9-1.5-18.8-8.6-24.6-2.2-2-5-3-7.2-4.8-2.2-2-1.7-6 .8-7.5z'%3E%3C/path%3E%3Cpath fill='%238a8ee7' d='M57.4 1852.2c3.7-1.8 6.6 2 9 4.5 11 12 11.7 31.6 1.7 44.5-6.8 9.3-18.5 14.6-30 14-2.4-.3-5.3-.2-7-2.2-1.6-2-1-5.4 1.3-6.8 1.7-1 3.8-.3 5.6-.4 9.8 1 20-4.5 24.7-13.2 4.6-8 4.3-18.7-.8-26.5-1.8-3-4.5-5-6.6-7.4-1.4-2.2-.4-5.4 2-6.4z'%3E%3C/path%3E%3Cpath fill='%238d91ea' d='M62.3 1938.3c1.7-1 4.3-1 5.6.8 9 11.5 9.2 28.8.8 40.8-7 10.4-20 16.4-32.6 15-5.7-.7-11.3-2.7-16-6-2.6-1.8-2-6.4 1-7.5 2.2-1 4.2.6 6 1.5 8.6 5 20 4.4 28-1.5 7.7-5.4 12-15 10.8-24.3-.3-4.5-2.3-8.6-4.7-12.4-1.6-2-1-5 1-6.3z'%3E%3C/path%3E%3Cpath fill='%239095ee' d='M66.3 2025.2c2-1.2 4.8-.5 5.7 1.6 5.6 12.8 2.2 28.7-8 38.2-9.4 9.2-24.2 12.2-36.5 7.4-7-2.8-13.5-8-17.3-14.7-1.2-2.6 1-5.8 3.8-5.7 2.5 0 3.7 2.4 5 4 7 9.5 20.5 13 31.2 8.4 12-4.7 19-18.8 15.3-31-.8-2.7-2.3-6.5.8-8.2z'%3E%3C/path%3E%3Cpath fill='%239398f1' d='M68.6 2112.7c2-1 5 0 5.4 2.4 2.4 14.5-5.8 30-19.2 36-12.5 6.2-28.7 3.6-38.7-6.2-5.6-5.5-9.4-13-10-21-.4-4 6-5 7.2-1.2 1 5.5 3 11 7 15.3 7 7.8 19 11 28.8 7 10.7-3.6 18.4-14.7 17.7-26-.2-2.2-.6-5.3 2-6.3z'%3E%3C/path%3E%3Cpath fill='%23969bf5' d='M8.4 2188.4c2-2 6-.3 6 2.6-.4 2-1 4-1.2 5.8-1 8.8 2.5 18 9.3 23.7 7 6 17.2 8 26 5 10-3 17-12.3 18.4-22.5.3-4 6.7-3.6 7 .3-1 15-13.3 28-28 30.3-13 2.5-27.4-3.6-34.6-15-5.2-7.8-6.8-17.8-4.6-27 .4-1 .6-2.4 1.6-3.2z'%3E%3C/path%3E%3Cpath fill='%23999ef8' d='M15.3 2257c2-1 4.4 0 5 2.2.3 2-1.3 3.3-2.3 4.8-5.7 7.6-6.8 18.2-3 27 4.3 10 15 16.7 26 16.2 10-.3 19.4-6.6 23.7-15.6 1.2-3.4 6.7-2.2 6.4 1.4-.7 3.4-3 6.3-5 9-9.3 11-26 15-39.3 9.2C13.8 2306 5 2292 6 2278c.7-7.8 3.7-15.7 9.3-21z'%3E%3C/path%3E%3Cpath fill='%239ca1fb' d='M25.6 2329.6c1.8-1.2 4.5.2 4.6 2.5.2 2.7-2.8 3.4-4.6 4.7-12 7-16.6 23.5-10 35.7 5.8 12.2 21.6 18.4 34.2 13.2 3.6-1.2 6.4-3.6 9.5-5.7 2.8-2 6 2.5 3.6 4.7-11.4 11-30.5 12-43 2.4-12.8-9-17.4-27.3-10.5-41.3 3.3-7 9-13 16-16z'%3E%3C/path%3E%3Cpath fill='%236264a7' d='M33.2 2407.2c2.3-.4 4.6-.8 7-.6 2.4.5 3 4.2.6 5.4-4 .7-8.3 1-12 2.8-12.6 5.3-19.5 20.5-15.2 33.4 4 13.3 18.8 22 32.3 18.8 2-.6 6-2 6.7 1.3.7 3.7-4 4-6.6 4.6-15.4 3-32.3-6.4-37.4-21.4-5.3-13.8 0-30.6 12-39 3.8-2.6 8-4.4 12.6-5.4z'%3E%3C/path%3E%3Cpath fill='%239ca1fb' d='M37.4 2486.4c5.5-.4 11.3.4 16.3 3 2 1.6.8 5.3-2 5.4-3.5-.8-7-2.3-10.8-2.2-13-.7-25.2 9-27.8 21.4-3 12 3.4 25 14.4 30.5 3.4 2 7.3 2.3 11 3 2.7 1 2.3 5.6-.6 6-17.3-.3-32-16.3-31.7-33.5-.4-17 14-32.7 31-33.6z'%3E%3C/path%3E%3Cpath fill='%23999ef8' d='M33.5 2566.7c10.8-2.2 22.7 1.3 30.5 9.3 1.8 1.6 1 5-1.3 5.6-2.3 1-4-1.5-5.6-2.7-9.6-8.4-25-8-34.6.3-8.6 7-12 19.7-8 30 2.3 6.4 7 11.4 12.7 14.8 3.2 2 .6 7.3-2.8 6-13.8-6.8-21.2-24-17-38.7 3-12.3 13.8-22.3 26.3-24.6z'%3E%3C/path%3E%3Cpath fill='%23969bf5' d='M32.4 2646.7c15-3.7 32 4.3 38.3 18.5.8 2.3-1.4 4.8-3.8 4.5-2.2 0-3-2.2-4-3.7-5.6-9.7-17.8-14.8-28.6-12.4-9.8 2-18 10-20.5 19.6-2 7.2-.8 15.2 3.4 21.4 1 1.5 2.4 3.3 1.4 5.2-1 2.4-4.7 2.8-6 .7-9.2-11.7-9.2-29.2-.2-41 4.8-6.4 12-11 19.8-12.8z'%3E%3C/path%3E%3Cpath fill='%239398f1' d='M31.4 2726.7c14.6-4 31.3 3 38.5 16.3 1.7 3.3 3.4 7 3.7 10.8-.3 2.8-4 4.3-6 2.6-1.6-1-1.7-3-2.3-4.6-2.5-8.4-9.6-15-18-17.5-8.6-2.6-18.6-.3-25.2 5.8-6.5 6-10 15-8.6 23.5 0 1.8 1 4-.5 5.6-1.5 2.2-5.2 1.8-6.3-.7-5.2-17.5 7-37.5 24.7-41.6z'%3E%3C/path%3E%3Cpath fill='%239095ee' d='M36.4 2805.5c14.7-1.7 29.7 7 35.4 20.6 2 5 3.2 10.4 2.8 15.7-.5 4-6.7 4.5-7.8.7-.6-3.3-.3-6.8-1.5-10-3-10.4-12.7-18.2-23.4-18.8-11.8-1-23.7 6.8-27 18-1 2.2-1 5-3.4 6-2.7 1.2-6-1.4-5.6-4.3 2.6-14.6 15.7-26.5 30.4-27.8z'%3E%3C/path%3E%3Cpath fill='%238d91ea' d='M33.5 2885.7c14-2.8 29.3 4 36.5 16.3 5 8.4 6.4 19 3.3 28.2-1 3-5.7 3.6-7.5 1-1.5-2.2 0-4.8 0-7 2.3-12-5-24.4-16.3-28.6-9.8-4-22-1.2-29 7-1.5 1.5-2.8 4-5.4 3.8-3.2 0-5.3-4-3.3-6.8 5-7.2 13-12.3 21.8-14z'%3E%3C/path%3E%3Cpath fill='%238a8ee7' d='M32.4 2965.7c15-3.5 31.4 4 38.5 17.4 5.8 10.8 5.6 24.7-1 35.2-1.6 3-6.4 2.6-7.8-.5-1.4-2.3.4-4.7 1.3-7 4.2-8.3 3-19-2.8-26.4-6-8-17-12-27-9.5-3 .6-5.7 2.6-8.8 3.3-4 .4-6.4-5-3.6-7.6 3.2-2.5 7.2-3.8 11-4.8z'%3E%3C/path%3E%3Cpath fill='%23868be4' d='M34.4 3045.4c14.2-3.4 29.8 4.8 36.7 17.5 7.7 13.5 5 32-6.5 42.5-2.5 2.2-7 .7-7.6-2.5-1-3.2 2-5.3 3.5-7.6 6-7.6 7-18.6 2.4-27-4.4-8.5-13.5-14.3-23-14-2-.2-4.6.4-6.3-1.2-2.5-2-2-6.3.7-7.8z'%3E%3C/path%3E%3Cpath fill='%238387e0' d='M48.2 3126c4.2-.4 8 2.2 11.5 4.2 13 8.3 19 25.5 14.5 40-2.6 8.7-8.6 16.4-16.5 20.7-3.2 2-7.7-1-7.4-4.8 0-2.7 2.5-4 4.5-5.5 7.5-5 11.6-14.7 10.5-23.6-1-9-7.2-17.2-15.7-20.5-1.8-1-4-1.5-4.8-3.6-1.3-2.8.5-6.3 3.4-7z'%3E%3C/path%3E%3Cpath fill='%238084dd' d='M58.3 3212.3c3.8-1.7 6.8 1.8 9 4.4 9.5 10.8 11.3 27.5 4.5 40-4.6 8.7-12.8 15.4-22.2 18-3.7 1-7.6-2.8-6.5-6.5 1-3.7 5-4 7.8-5.4 11.3-5 17.4-19.2 13-30.8-1.3-4.5-4.2-8.2-7.5-11.4-2.4-2.5-1.2-7 2-8.3z'%3E%3C/path%3E%3Cpath fill='%237d81da' d='M65.2 3302.3c2.8-1.5 6.5-.2 7.7 2.7 2.6 6 3.6 12.6 3 19-1.7 17.8-18.2 32.7-36 32-4.5 0-6.6-6.3-3.4-9.3 2.6-2.5 6.6-1.5 9.7-2.5 10.8-2.6 19-13 18.7-24.2 0-4-1.2-7.6-2.5-11.3-1-2.4.5-5.3 2.7-6.4z'%3E%3C/path%3E%3Cpath fill='%237a7ed6' d='M67.4 3394.4c3-2.2 8-.2 8.8 3.6 1.3 15-8.5 30.3-22.6 35.8-7.2 2.8-15.4 3.5-23 1.3-3.8-1.3-4.7-7.2-1.3-9.7 2.8-2.4 6.5-.6 9.7-.6 12 .8 23.8-8.7 25.4-20.7.6-3.3-.3-7.6 3-9.5z'%3E%3C/path%3E%3Cpath fill='%23777bd3' d='M66.5 3485.7c4.3-1.7 9.2 2.8 7.7 7.2-5 14.3-20 24.2-35.2 23.6-6-.2-12-1.6-17-4.8-3.5-2.5-2.8-8.7 1.3-10.2 3-1.5 6 .6 8.7 1.5 10.6 4.2 23.8-.8 29.2-10.8 1.4-2.4 2.3-5.7 5.3-6.5z'%3E%3C/path%3E%3Cpath fill='%237478d0' d='M59.5 3575.7c3.7-1.5 8.3 1.4 8.4 5.4.3 4.4-4 7-6.8 9.2-13.7 10-34.2 8.6-46.3-3.2-3.4-3.2-1.5-9.6 3-10.4 3-1 5.4 1.3 7.6 3 7.4 5.7 18.3 6.3 26.4 1.5 2.8-1.3 4.8-4 7.5-5.3z'%3E%3C/path%3E%3Cpath fill='%237175cd' d='M11.4 3651.2c2.5-1.4 6-1 8 1.4 2 2.5 4 5.3 6.8 7 6.6 5 15.5 5.6 23 2.7 4.7-2.3 10.3 2.6 8.8 7.6-1 4-5.6 5-9 6-15 4-32-2.8-40-16-2-3-.7-7.2 2.4-8.8z'%3E%3C/path%3E%3Cpath fill='%236e72ca' d='M9.5 3723.6c3.4-1 7 1.2 8 4.6 3 8.3 11 14.7 19.8 15.4 2.4.4 5.3 0 7.2 2 3 2.4 3 7.4 0 10-2.5 2.4-6.4 1.7-9.6 1.3C21 3755 9 3745 4.6 3732c-1.2-3.5 1-7.6 4.8-8.4z'%3E%3C/path%3E%3Cpath fill='%236b6fc7' d='M6.4 3796.4c3.3-1.6 7.6-.2 9.3 3 1 2.7 1 5.5 2 8.2 2 6 6.3 11 12 13.6 2.5 1.2 5.2 2.8 5.6 5.8 1.2 4.7-3.6 9.4-8.3 8-13.5-4.5-23.5-17.8-24.4-32-.2-2.8 1.5-5.4 3.8-6.6z'%3E%3C/path%3E%3Cpath fill='%23696cc4' d='M7.3 3868.4c3.3-1.3 7.3.3 9 3.5 1 1.8.4 4 .4 6-.7 7 2 13.7 6.7 18.6 2.4 2 3.4 5.8 1.8 8.7-1.8 4-7.5 5.2-10.8 2.3C5 3899.4.7 3886 2.8 3874c.4-2.6 2.2-4.7 4.5-5.6z'%3E%3C/path%3E%3Cpath fill='%23666ac1' d='M8.5 3941.4c4.6-2.7 11 1.3 10.7 6.7-.7 4-2.7 7.8-2.4 12-.2 4 1.3 7.5 2.5 11 1.2 4-1.6 8.3-5.5 9-3.4.8-7-1-8.3-4.4-4.3-9.3-4.5-20.3-.7-29.8.7-1.8 2-3.5 3.7-4.4z'%3E%3C/path%3E%3Cpath fill='%236467bf' d='M12.5 4014.7c4.2-2.2 9.8.6 10.5 5.3 1 5-4 8.3-5 13-2 4.6.7 10.7-3.4 14.6-3.8 4-11.3 1.7-12.4-3.7-1.2-8.7 1.2-17.6 6-25 1-1.6 2.3-3.5 4.3-4.3z'%3E%3C/path%3E%3Cpath fill='%236165bc' d='M17.4 4089.3c4.7-2.6 11.3 1.2 11 6.7.5 5-5 7.3-7.3 11-2.7 3.7-2.6 9.7-7.5 11.4-5.3 2.3-11.6-2.8-10.4-8.4 2.2-8.2 7.3-16 14.4-20.7z'%3E%3C/path%3E%3Cpath fill='%235f63ba' d='M25.4 4164.6c5.4-1.4 11 4 9.3 9.5-.7 4.2-5 5.6-8 7.7-4 2.3-5.7 7.7-10.7 7.8-6 .8-10.6-6.7-7.3-11.8 4-6 10-10.7 16.7-13z'%3E%3C/path%3E%3Cpath fill='%235d60b8' d='M30.3 4242.6c4.3-1.7 10 0 11.3 4.8 1.8 4.7-1.7 10-6.6 10.6-5 .8-9 6-14.3 4.2-5.6-1.3-7.6-9-3.6-13 3.8-3.4 8.6-5.2 13.3-6.6z'%3E%3C/path%3E%3Cpath fill='%235b5fb6' d='M35.4 4321.5c4.2-.4 9.4-1 12.3 2.8 3.6 4.3 1.3 12-4.3 13l-11.4 1.2c-6 .3-10-6.8-7-11.8 1.7-4 6.5-4.7 10.4-5.2z'%3E%3C/path%3E%3Cpath fill='%235a5db4' d='M39.3 4401.5c4.3-.8 8.7.2 12.7 1.6 5.2 2.3 6.2 10.2 2 13.8-4.4 3.8-10.4 1.2-15.3.4-7.2-2.4-6.6-14 .6-15.7z'%3E%3C/path%3E%3Cpath fill='%23585bb2' d='M49.3 4483c4-.5 7.7 1.7 11 3.8 4.5 3.5 3.7 11.5-1.6 14-4.6 2.4-9.5-.6-13.4-3-5.3-4.2-2.7-13.8 4-14.7z'%3E%3C/path%3E%3Cpath fill='%23575ab1' d='M56.3 4567.4c7-1.7 15 6.2 12 13.2-1.6 4.6-7.8 6.7-12 4-2.8-1.6-5.7-4-6.2-7.7-.6-4.2 2.2-8.6 6.3-9.6z'%3E%3C/path%3E%3Cpath fill='%235659b0' d='M61.4 4653.5c7-3 14.7 5.6 11.5 12.3-2.3 6-11 7-14.8 2-4.2-4.3-2.7-12.4 3-14.3z'%3E%3C/path%3E%3Cpath fill='%236264a7' d='M64.5 4740.3c5.7-3 13.2 2.2 12.4 8.6-.3 6.3-8.4 10.2-13.6 6.5-5.5-3.4-5-12.7 1-15.2zM67.3 4826.3c6.2-2.4 13 4 11.3 10.3-1 6-9.3 9-14 4.8-5.2-4-3.7-13.4 2.7-15z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\")",secondarySvgContent:"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 4880'%3E%3Cg role='presentation'%3E%3Cpath fill='rgba(255,255,255,1)' d='M67.4 26.4c5.8-2 12.4 3.3 11.4 9.4-.4 6.5-8.8 10-13.8 6-5.6-3.6-4.2-13.5 2.4-15.3zM66.5 113.7c5.7-3.3 13.6 1.8 12.7 8.4 0 6.4-8 10.4-13.2 7-5.6-3.2-5.4-12.5.5-15.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M65.5 200.4c5.7-3.4 13.6 2 12.6 8.5 0 6-7 10.7-12.7 7.7-6.4-3-6-13.2.2-16.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M64.3 286.2c5-2 11.3 2.3 11.2 7.8 0 5.4-4.5 11.7-10.5 11-5.4-.3-9.2-6.3-7.3-11.2 1.2-3.2 3.2-6.5 6.6-7.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M59.4 372.5c5-2.6 11.6 1 12 6.5.8 5-3.4 8.6-7 11.3-4.5 3.2-11.7.2-12.6-5.3-1.4-5.5 3.6-9.7 7.6-12.5z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M54.3 457.4c4-2.2 9.6 0 11.2 4.2 1.7 3.7 0 8.4-3.5 10.5-3.7 2.5-8.2 5.6-12.8 4-4.3-1.6-6.5-6.8-4.8-11 1.5-4.2 6.4-5.4 10-7.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M48.6 540.7c4.4-2 10 1 11 5.7 1 4-1.4 8.4-5.4 9.7-4 1.6-8.5 3-13 2.5-5.6-.8-8.6-8-5.3-12.6 2.7-4.4 8.4-3.5 12.6-5.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M29.4 622.4c3-1.5 6.4 0 9.6 0 3.4.3 7.3-1 10.3 1.3 4.6 3 4.4 10.4-.2 13.3-3.7 2-8.2 1.7-12.4 1.5-3.6-.5-7.8-.7-10.2-4-3.2-3.7-1.6-10.2 3-12z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M20.3 698.3c4-2 7.8 1.3 11.4 2.8 4 2 9.6 1 12.2 5 3.3 4.7-.2 12-6 12.3-7 0-14-2.6-19.7-6.6-4.7-3.4-3.5-11.6 2-13.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M12.3 771.3c3-1.5 7-.6 9 2 3 3.8 6.7 6.7 11 8.3 3.3 1 5.7 4 5.5 7.4.2 4.8-4.8 8.7-9.3 7.4-7.7-2.2-14.5-7.2-19.3-13.6-2.8-3.7-1.2-9.8 3-11.5z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M7.5 841.7c4-2 9.2.3 10.3 4.6 1.7 5.4 5 10 9.7 13 4 2.5 4.6 8.4 1.4 11.6-2.5 2.6-7 3-10 1-7.4-5-13-12.6-15.5-21-1.2-3.6.5-8 4-9.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M6.5 910.8c3-1.6 7.3-.4 9 2.6 1.7 2.2 1 5 1.4 7.6 0 5.6 2.5 11 6 15 2.5 2.5 2.7 6.7.5 9.5-2.4 3.3-7.8 3.8-10.7 1-7.6-7.8-11.5-19-10.6-29.6.2-2.7 1.8-5.2 4.3-6.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M9.3 980c3.7-2 9 .3 10 4.4 1 2.4-.2 4.8-1 7-2.4 5.7-2.3 12.4.3 18 1 2.3 2.4 5 1.5 7.6-1 4-5.7 6.2-9.5 4.5-2.6-1-3.8-3.7-5-6-4.4-10-4.3-21.8.4-31.6.6-1.7 1.7-3 3.3-4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M16.3 1051.2c4-2.6 10 1 10 5.8.5 3-2 5.3-4 7.4-5.3 5.7-7 14-5.2 21.6 1 3.5-1 7.4-4.4 8.5-3.4 1.2-7.6-.8-8.7-4.3-4.2-13.8.7-30.2 12.3-39z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M26.4 1125.3c4.5-2.6 10.7 1.5 10 6.7-.4 3.3-3.3 5.2-6 6.3-8.2 3.4-14 11.8-14.2 20.6 0 2.6-.6 5.6-3.2 7-4 2.8-10 0-10.2-5-.8-15.3 9.2-30.3 23.6-35.7z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M35.3 1203.2c3.7-.3 8.6-1.2 11.2 2.3 2.7 3.2 1 8.8-3 10-3.7.8-7.7.3-11.3 1.7-8 2.6-13.8 9.5-15.8 17.5-1 4.7-7.6 6.2-10.8 2.7-2.8-2.7-1.7-7-.4-10 4.5-13 16.6-22.6 30-24.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M36.4 1283.3c7-.6 14.2.5 20.3 4 3.8 2.4 3.3 8.7-.8 10.6-3 1.5-6-.2-8.6-1-9.8-3.5-21.6.5-27.3 9-1.5 2.4-3 5.6-6 6-4.6 1-9-4.4-6.8-8.7 5.4-11 17-18.8 29.2-20z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M36.5 1363.5c11.6-1 23.8 3.6 31.3 12.7 2.7 3.6-.3 9.5-4.8 9.4-3.2.3-5-2.6-7.3-4.4-8.4-7.4-22.2-7.6-31-.4-2.3 1.8-4.3 5-7.7 4.7-4.7 0-7.5-6.3-4.4-9.8 6-7 14.8-11.3 24-12.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M31.4 1444.6c18-4.8 38.3 6.6 43.3 24.6 1 4-3.5 8-7.4 6.6-3.5-1-4-4.8-5.5-7.5-5.5-10.8-19.6-16-30.8-11.4-3.2 1-6.2 4.3-10 3-3.8-1.4-5-7.2-1.7-9.8 3.5-2.8 7.8-4.4 12-5.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M32.4 1524.6c15-3.4 31.8 4 39.2 17.8 3.5 6.5 5.3 14 4.3 21.5-1 4-6.7 5.5-9.5 2.4-2-2-1.4-5-1.6-7.4-.2-11.6-9.6-22-21-23.7-4.4-.8-8.8 0-13 1-4 1.2-7.7-3.5-6-7.2 1-3 4.6-3.7 7.4-4.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M36.3 1604.4c14-2 28.5 6 35 18.2 6 10.6 6 24.3 0 34.8-2 3.5-7.6 3-9-.6-1.8-3.5 1.4-6.8 2-10.2 3.8-12.4-4-26.7-16.3-30.5-4-1.6-8.3-.8-12.4-1.6-4.6-1.7-4-9 .7-10z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M43.3 1685.3c4-1.2 8.2 1 12 2.5 14.7 6.6 23.3 24.2 19.5 40-1.8 8-6.5 15.7-13.4 20.6-3 2.2-8-.6-7.7-4.4 0-2.3 1.8-3.7 3.3-5 7-6 10-16 7.8-24.7-1.8-8-7.6-15-15.3-18-2.2-.8-4.6-1-6.8-2-3.4-2-3-7.5.6-9z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M50.2 1768c1.4-.8 3.2-.8 4.7 0 13.2 5.7 21.7 20.5 20.3 35-1 15-12.6 28.5-27.3 31.4-3.4.6-6.4-3-5-6.3.6-2.6 3.7-3 6-4 8.2-2.8 14.5-10.4 16.2-19 2-9-1.5-18.8-8.6-24.6-2.2-2-5-3-7.2-4.8-2.2-2-1.7-6 .8-7.5z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M57.4 1852.2c3.7-1.8 6.6 2 9 4.5 11 12 11.7 31.6 1.7 44.5-6.8 9.3-18.5 14.6-30 14-2.4-.3-5.3-.2-7-2.2-1.6-2-1-5.4 1.3-6.8 1.7-1 3.8-.3 5.6-.4 9.8 1 20-4.5 24.7-13.2 4.6-8 4.3-18.7-.8-26.5-1.8-3-4.5-5-6.6-7.4-1.4-2.2-.4-5.4 2-6.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M62.3 1938.3c1.7-1 4.3-1 5.6.8 9 11.5 9.2 28.8.8 40.8-7 10.4-20 16.4-32.6 15-5.7-.7-11.3-2.7-16-6-2.6-1.8-2-6.4 1-7.5 2.2-1 4.2.6 6 1.5 8.6 5 20 4.4 28-1.5 7.7-5.4 12-15 10.8-24.3-.3-4.5-2.3-8.6-4.7-12.4-1.6-2-1-5 1-6.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M66.3 2025.2c2-1.2 4.8-.5 5.7 1.6 5.6 12.8 2.2 28.7-8 38.2-9.4 9.2-24.2 12.2-36.5 7.4-7-2.8-13.5-8-17.3-14.7-1.2-2.6 1-5.8 3.8-5.7 2.5 0 3.7 2.4 5 4 7 9.5 20.5 13 31.2 8.4 12-4.7 19-18.8 15.3-31-.8-2.7-2.3-6.5.8-8.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M68.6 2112.7c2-1 5 0 5.4 2.4 2.4 14.5-5.8 30-19.2 36-12.5 6.2-28.7 3.6-38.7-6.2-5.6-5.5-9.4-13-10-21-.4-4 6-5 7.2-1.2 1 5.5 3 11 7 15.3 7 7.8 19 11 28.8 7 10.7-3.6 18.4-14.7 17.7-26-.2-2.2-.6-5.3 2-6.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M8.4 2188.4c2-2 6-.3 6 2.6-.4 2-1 4-1.2 5.8-1 8.8 2.5 18 9.3 23.7 7 6 17.2 8 26 5 10-3 17-12.3 18.4-22.5.3-4 6.7-3.6 7 .3-1 15-13.3 28-28 30.3-13 2.5-27.4-3.6-34.6-15-5.2-7.8-6.8-17.8-4.6-27 .4-1 .6-2.4 1.6-3.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M15.3 2257c2-1 4.4 0 5 2.2.3 2-1.3 3.3-2.3 4.8-5.7 7.6-6.8 18.2-3 27 4.3 10 15 16.7 26 16.2 10-.3 19.4-6.6 23.7-15.6 1.2-3.4 6.7-2.2 6.4 1.4-.7 3.4-3 6.3-5 9-9.3 11-26 15-39.3 9.2C13.8 2306 5 2292 6 2278c.7-7.8 3.7-15.7 9.3-21z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M25.6 2329.6c1.8-1.2 4.5.2 4.6 2.5.2 2.7-2.8 3.4-4.6 4.7-12 7-16.6 23.5-10 35.7 5.8 12.2 21.6 18.4 34.2 13.2 3.6-1.2 6.4-3.6 9.5-5.7 2.8-2 6 2.5 3.6 4.7-11.4 11-30.5 12-43 2.4-12.8-9-17.4-27.3-10.5-41.3 3.3-7 9-13 16-16z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M33.2 2407.2c2.3-.4 4.6-.8 7-.6 2.4.5 3 4.2.6 5.4-4 .7-8.3 1-12 2.8-12.6 5.3-19.5 20.5-15.2 33.4 4 13.3 18.8 22 32.3 18.8 2-.6 6-2 6.7 1.3.7 3.7-4 4-6.6 4.6-15.4 3-32.3-6.4-37.4-21.4-5.3-13.8 0-30.6 12-39 3.8-2.6 8-4.4 12.6-5.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M37.4 2486.4c5.5-.4 11.3.4 16.3 3 2 1.6.8 5.3-2 5.4-3.5-.8-7-2.3-10.8-2.2-13-.7-25.2 9-27.8 21.4-3 12 3.4 25 14.4 30.5 3.4 2 7.3 2.3 11 3 2.7 1 2.3 5.6-.6 6-17.3-.3-32-16.3-31.7-33.5-.4-17 14-32.7 31-33.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M33.5 2566.7c10.8-2.2 22.7 1.3 30.5 9.3 1.8 1.6 1 5-1.3 5.6-2.3 1-4-1.5-5.6-2.7-9.6-8.4-25-8-34.6.3-8.6 7-12 19.7-8 30 2.3 6.4 7 11.4 12.7 14.8 3.2 2 .6 7.3-2.8 6-13.8-6.8-21.2-24-17-38.7 3-12.3 13.8-22.3 26.3-24.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M32.4 2646.7c15-3.7 32 4.3 38.3 18.5.8 2.3-1.4 4.8-3.8 4.5-2.2 0-3-2.2-4-3.7-5.6-9.7-17.8-14.8-28.6-12.4-9.8 2-18 10-20.5 19.6-2 7.2-.8 15.2 3.4 21.4 1 1.5 2.4 3.3 1.4 5.2-1 2.4-4.7 2.8-6 .7-9.2-11.7-9.2-29.2-.2-41 4.8-6.4 12-11 19.8-12.8z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M31.4 2726.7c14.6-4 31.3 3 38.5 16.3 1.7 3.3 3.4 7 3.7 10.8-.3 2.8-4 4.3-6 2.6-1.6-1-1.7-3-2.3-4.6-2.5-8.4-9.6-15-18-17.5-8.6-2.6-18.6-.3-25.2 5.8-6.5 6-10 15-8.6 23.5 0 1.8 1 4-.5 5.6-1.5 2.2-5.2 1.8-6.3-.7-5.2-17.5 7-37.5 24.7-41.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M36.4 2805.5c14.7-1.7 29.7 7 35.4 20.6 2 5 3.2 10.4 2.8 15.7-.5 4-6.7 4.5-7.8.7-.6-3.3-.3-6.8-1.5-10-3-10.4-12.7-18.2-23.4-18.8-11.8-1-23.7 6.8-27 18-1 2.2-1 5-3.4 6-2.7 1.2-6-1.4-5.6-4.3 2.6-14.6 15.7-26.5 30.4-27.8z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M33.5 2885.7c14-2.8 29.3 4 36.5 16.3 5 8.4 6.4 19 3.3 28.2-1 3-5.7 3.6-7.5 1-1.5-2.2 0-4.8 0-7 2.3-12-5-24.4-16.3-28.6-9.8-4-22-1.2-29 7-1.5 1.5-2.8 4-5.4 3.8-3.2 0-5.3-4-3.3-6.8 5-7.2 13-12.3 21.8-14z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M32.4 2965.7c15-3.5 31.4 4 38.5 17.4 5.8 10.8 5.6 24.7-1 35.2-1.6 3-6.4 2.6-7.8-.5-1.4-2.3.4-4.7 1.3-7 4.2-8.3 3-19-2.8-26.4-6-8-17-12-27-9.5-3 .6-5.7 2.6-8.8 3.3-4 .4-6.4-5-3.6-7.6 3.2-2.5 7.2-3.8 11-4.8z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M34.4 3045.4c14.2-3.4 29.8 4.8 36.7 17.5 7.7 13.5 5 32-6.5 42.5-2.5 2.2-7 .7-7.6-2.5-1-3.2 2-5.3 3.5-7.6 6-7.6 7-18.6 2.4-27-4.4-8.5-13.5-14.3-23-14-2-.2-4.6.4-6.3-1.2-2.5-2-2-6.3.7-7.8z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M48.2 3126c4.2-.4 8 2.2 11.5 4.2 13 8.3 19 25.5 14.5 40-2.6 8.7-8.6 16.4-16.5 20.7-3.2 2-7.7-1-7.4-4.8 0-2.7 2.5-4 4.5-5.5 7.5-5 11.6-14.7 10.5-23.6-1-9-7.2-17.2-15.7-20.5-1.8-1-4-1.5-4.8-3.6-1.3-2.8.5-6.3 3.4-7z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M58.3 3212.3c3.8-1.7 6.8 1.8 9 4.4 9.5 10.8 11.3 27.5 4.5 40-4.6 8.7-12.8 15.4-22.2 18-3.7 1-7.6-2.8-6.5-6.5 1-3.7 5-4 7.8-5.4 11.3-5 17.4-19.2 13-30.8-1.3-4.5-4.2-8.2-7.5-11.4-2.4-2.5-1.2-7 2-8.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M65.2 3302.3c2.8-1.5 6.5-.2 7.7 2.7 2.6 6 3.6 12.6 3 19-1.7 17.8-18.2 32.7-36 32-4.5 0-6.6-6.3-3.4-9.3 2.6-2.5 6.6-1.5 9.7-2.5 10.8-2.6 19-13 18.7-24.2 0-4-1.2-7.6-2.5-11.3-1-2.4.5-5.3 2.7-6.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M67.4 3394.4c3-2.2 8-.2 8.8 3.6 1.3 15-8.5 30.3-22.6 35.8-7.2 2.8-15.4 3.5-23 1.3-3.8-1.3-4.7-7.2-1.3-9.7 2.8-2.4 6.5-.6 9.7-.6 12 .8 23.8-8.7 25.4-20.7.6-3.3-.3-7.6 3-9.5z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M66.5 3485.7c4.3-1.7 9.2 2.8 7.7 7.2-5 14.3-20 24.2-35.2 23.6-6-.2-12-1.6-17-4.8-3.5-2.5-2.8-8.7 1.3-10.2 3-1.5 6 .6 8.7 1.5 10.6 4.2 23.8-.8 29.2-10.8 1.4-2.4 2.3-5.7 5.3-6.5z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M59.5 3575.7c3.7-1.5 8.3 1.4 8.4 5.4.3 4.4-4 7-6.8 9.2-13.7 10-34.2 8.6-46.3-3.2-3.4-3.2-1.5-9.6 3-10.4 3-1 5.4 1.3 7.6 3 7.4 5.7 18.3 6.3 26.4 1.5 2.8-1.3 4.8-4 7.5-5.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M11.4 3651.2c2.5-1.4 6-1 8 1.4 2 2.5 4 5.3 6.8 7 6.6 5 15.5 5.6 23 2.7 4.7-2.3 10.3 2.6 8.8 7.6-1 4-5.6 5-9 6-15 4-32-2.8-40-16-2-3-.7-7.2 2.4-8.8z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M9.5 3723.6c3.4-1 7 1.2 8 4.6 3 8.3 11 14.7 19.8 15.4 2.4.4 5.3 0 7.2 2 3 2.4 3 7.4 0 10-2.5 2.4-6.4 1.7-9.6 1.3C21 3755 9 3745 4.6 3732c-1.2-3.5 1-7.6 4.8-8.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M6.4 3796.4c3.3-1.6 7.6-.2 9.3 3 1 2.7 1 5.5 2 8.2 2 6 6.3 11 12 13.6 2.5 1.2 5.2 2.8 5.6 5.8 1.2 4.7-3.6 9.4-8.3 8-13.5-4.5-23.5-17.8-24.4-32-.2-2.8 1.5-5.4 3.8-6.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M7.3 3868.4c3.3-1.3 7.3.3 9 3.5 1 1.8.4 4 .4 6-.7 7 2 13.7 6.7 18.6 2.4 2 3.4 5.8 1.8 8.7-1.8 4-7.5 5.2-10.8 2.3C5 3899.4.7 3886 2.8 3874c.4-2.6 2.2-4.7 4.5-5.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M8.5 3941.4c4.6-2.7 11 1.3 10.7 6.7-.7 4-2.7 7.8-2.4 12-.2 4 1.3 7.5 2.5 11 1.2 4-1.6 8.3-5.5 9-3.4.8-7-1-8.3-4.4-4.3-9.3-4.5-20.3-.7-29.8.7-1.8 2-3.5 3.7-4.4z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M12.5 4014.7c4.2-2.2 9.8.6 10.5 5.3 1 5-4 8.3-5 13-2 4.6.7 10.7-3.4 14.6-3.8 4-11.3 1.7-12.4-3.7-1.2-8.7 1.2-17.6 6-25 1-1.6 2.3-3.5 4.3-4.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M17.4 4089.3c4.7-2.6 11.3 1.2 11 6.7.5 5-5 7.3-7.3 11-2.7 3.7-2.6 9.7-7.5 11.4-5.3 2.3-11.6-2.8-10.4-8.4 2.2-8.2 7.3-16 14.4-20.7z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M25.4 4164.6c5.4-1.4 11 4 9.3 9.5-.7 4.2-5 5.6-8 7.7-4 2.3-5.7 7.7-10.7 7.8-6 .8-10.6-6.7-7.3-11.8 4-6 10-10.7 16.7-13z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M30.3 4242.6c4.3-1.7 10 0 11.3 4.8 1.8 4.7-1.7 10-6.6 10.6-5 .8-9 6-14.3 4.2-5.6-1.3-7.6-9-3.6-13 3.8-3.4 8.6-5.2 13.3-6.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M35.4 4321.5c4.2-.4 9.4-1 12.3 2.8 3.6 4.3 1.3 12-4.3 13l-11.4 1.2c-6 .3-10-6.8-7-11.8 1.7-4 6.5-4.7 10.4-5.2z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M39.3 4401.5c4.3-.8 8.7.2 12.7 1.6 5.2 2.3 6.2 10.2 2 13.8-4.4 3.8-10.4 1.2-15.3.4-7.2-2.4-6.6-14 .6-15.7z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M49.3 4483c4-.5 7.7 1.7 11 3.8 4.5 3.5 3.7 11.5-1.6 14-4.6 2.4-9.5-.6-13.4-3-5.3-4.2-2.7-13.8 4-14.7z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M56.3 4567.4c7-1.7 15 6.2 12 13.2-1.6 4.6-7.8 6.7-12 4-2.8-1.6-5.7-4-6.2-7.7-.6-4.2 2.2-8.6 6.3-9.6z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M61.4 4653.5c7-3 14.7 5.6 11.5 12.3-2.3 6-11 7-14.8 2-4.2-4.3-2.7-12.4 3-14.3z'/%3E%3Cpath fill='rgba(255,255,255,1)' d='M64.5 4740.3c5.7-3 13.2 2.2 12.4 8.6-.3 6.3-8.4 10.2-13.6 6.5-5.5-3.4-5-12.7 1-15.2zM67.3 4826.3c6.2-2.4 13 4 11.3 10.3-1 6-9.3 9-14 4.8-5.2-4-3.7-13.4 2.7-15z'/%3E%3C/g%3E%3C/svg%3E\")",svgHeights:{smaller:Is(1464),smallest:Is(1464),small:Is(1464),medium:Is(2196),large:Is(4392),larger:Is(4392),largest:Is(4392)},svgTranslatePosition:{smallest:Is(-1440),smaller:Is(-1440),small:Is(-1440),medium:Is(-2160),large:Is(-4320),larger:Is(-4320),largest:Is(-4320)},svgWidths:{smallest:Is(24),smaller:Is(24),small:Is(24),medium:Is(36),large:Is(72),larger:Is(72),largest:Is(72)}}},Ed=function(){return {paddingLeft:Is(20),paddingRight:Is(18),columnGap:Is(8),height:Is(48)}},Od=function(e){return {minHeight:Is(48),rootPadding:"0 "+Is(18)+" 0 "+Is(20),gap:Is(8),zIndex:e.zIndexes.foreground,headerLineHeight:e.lineHeightSmall,headerFontSize:e.fontSizes.medium,headerMediaFontSize:e.fontSizes.small,headerMediaLineHeight:e.lineHeightSmall,importantFontWeight:e.fontWeightBold,contentFontSize:e.fontSizes.small,contentLineHeight:e.lineHeightSmall,contentMediaFontSize:e.fontSizes.small,contentMediaLineHeight:e.lineHeightSmall,selectableFocusHoverColor:e.colorScheme.default.foregroundHover,selectableFocusHoverBackgroundColor:e.colorScheme.default.backgroundHover,selectedColor:e.colorScheme.default.foregroundPressed,selectedBackgroundColor:e.colorScheme.default.backgroundActive1}},Fd=Dc("border","borderActive","foregroundActive","foregroundFocus","foregroundHover","backgroundHover","backgroundActive","backgroundFocus","foregroundDisabled"),Ad=function(e){return {colorScheme:Kc($c(e.colorScheme,{default:{borderActive:e.colorScheme.default.border2,backgroundActive:e.colorScheme.default.backgroundActive2,backgroundFocus:e.colorScheme.default.backgroundFocus1,foregroundDisabled:e.colorScheme.default.foregroundDisabled1},brand:{foregroundHover:e.colors.white,backgroundHover:e.colors.brand[300],foregroundActive:e.colors.white,borderActive:e.colors.brand[600],backgroundActive:e.colors.brand[500],foregroundFocus:e.colors.white,backgroundFocus:e.colors.brand[300],foregroundDisabled:e.colorScheme.brand.foregroundDisabled1}}),Fd),color:e.colors.grey[500],colorActive:e.colors.black,colorFocus:void 0,colorHover:"inherit",colorDisabled:void 0,borderColor:void 0,borderColorHover:void 0,borderColorActive:void 0,borderColorFocus:e.colors.white,outlineColorFocus:e.colors.black,backgroundColor:void 0,backgroundColorFocus:void 0,backgroundColorHover:void 0,backgroundColorActive:void 0,iconSize:Is(16),iconOnlyBorderRadius:e.borderRadiusMedium,iconOnlyColorActive:e.colors.brand[600],iconOnlyColorFocus:e.colors.brand[600],iconOnlyWrapperBackgroundColorFocus:void 0,activeIconOnlyWrapperBackgroundColor:void 0,iconOnlyBackgroundColorHover:void 0,iconOnlyColorHover:e.colors.brand[600],underlinedBorderColor:e.colors.grey[200],lineHeightBase:e.lineHeightMedium,horizontalPadding:Is(14)+" "+Is(18),verticalBackgroundColor:e.colorScheme.default.background,verticalItemPadding:Is(7)+" "+Is(12),verticalBoxShadow:e.shadow16,verticalDividerMargin:Is(8)+" 0",verticalItemBorderWidth:Is(2),verticalItemBorderColor:"transparent",verticalPointingBorderColor:e.colorScheme.brand.borderActive,verticalBackgroundColorFocus:void 0,verticalBorderColor:e.colorScheme.default.borderTransparent,activeUnderlinedColor:void 0,activeUnderlinedPrimaryColor:e.colors.brand[600],activeUnderlinedBorderBottomColor:e.colors.black,activeUnderlinedWrapperColor:void 0,pointingIndicatorBackgroundColor:e.colors.brand[600],underlinedBottomBorderWidth:Is(2),underlinedColorHover:"inherit",primaryBorderColor:e.colorScheme.default.border2,primaryWrapperColorFocus:e.colors.white,primaryWrapperBackgroundColorFocus:e.colors.brand[500],underlinedWrapperColorHover:e.colors.black,underlinedWrapperBackgroundHover:"transparent",dividerHeight:Is(1),borderWidth:Is(1),menuZIndex:e.zIndexes.overlay,beakZIndex:e.zIndexes.menuItem,wrapperColorActive:e.colors.grey[500],wrapperColorFocus:e.colors.grey[500],wrapperColorHover:void 0,primaryWrapperColorHover:e.colors.white,wrapperBackgroundColorFocus:e.colors.grey[150],activeWrapperBackgroundColorHover:void 0,indicatorColor:e.colors.grey[500],activeIndicatorColor:e.colors.grey[750],activePrimaryIndicatorColor:e.colors.grey[750],activePrimaryVerticalIndicatorColor:e.colors.white,primaryIndicatorColorHover:e.colors.white,indicatorColorHover:e.colors.grey[500]}},Pd=function(e){return {background:e.colorScheme.default.background3,backgroundHover:e.colorScheme.default.background1,borderRadius:"9999px",smallerRoundedBorderRadius:Is(2),disabledBackground:e.colorScheme.default.backgroundDisabled,disabledColor:e.colorScheme.default.foregroundDisabled,invertedBackground:e.colorScheme.default.background,outlineBackground:"transparent",outlineBorderColor:e.colorScheme.default.borderActive4,outlineDisabledborder:e.colorScheme.default.borderDisabled,smallerHeight:Is(20),smallerMinWidth:Is(80),smallerMargin:Is(6)+" "+Is(2),smallHeight:Is(24),smallMinWidth:Is(80),smallMargin:Is(4),height:Is(32),minWidth:Is(90),margin:Is(6)+" "+Is(4),roundedBorderRadius:e.borderRadiusMedium,contentPaddingSmaller:Is(2)+" "+Is(8),contentFontSizeSmaller:Is(12),contentFontSizeSmall:Is(12),contentPaddingSmall:Is(4)+" "+Is(8),contentFontSize:Is(14),contentPadding:Is(6)+" "+Is(8),actionMargin:"0 "+Is(8),actionWidth:Is(16),smallOrSmallerActionWidth:Is(12),iconMargin:"0 0 0 "+Is(8),iconWidth:Is(20),smallOrSmallerIconWidth:Is(16),selectedIconColor:e.colorScheme.default.border,selectedIconCheckColor:e.colorScheme.brand.background2,selectedImageIconWidth:Is(32),smallSelectedImageIconWidth:Is(24),smallerSelectedImageIconWidth:Is(20),imageWidth:Is(32),imageHeight:Is(32),smallImageWidth:Is(24),smallImageHeight:Is(24),smallerImageWidth:Is(20),smallerImageHeight:Is(20)}},jd=function(e){return {borderColor:e.colorScheme.default.borderTransparent,borderRadius:e.borderRadiusMedium,borderSize:"1px",backgroundColor:e.colorScheme.default.background,color:e.colorScheme.default.foreground,boxShadow:e.shadow16,padding:""+Is(16),pointerGap:Is(5),pointerMargin:Is(10),pointerHeight:Is(7),pointerWidth:Is(14),zIndex:e.zIndexes.overlay}},Rd=function(e){return {background:e.bodyBackground,color:e.bodyColor,scrollbarHeight:Is(16),scrollbarWidth:Is(16),scrollbarThumbBackgroundColor:e.colors.onyx[700],scrollbarThumbBorderRadius:Is(9),scrollbarThumbBorderSize:Is(4),scrollbarThumbHoverBackgroundColor:e.colors.onyx[700],scrollbarThumbHoverBorderSize:Is(2)}},Id=function(e){return {colorDisabled:e.colors.grey[250],textFontSize:e.fontSizes.medium,textColorDefault:e.colors.grey[500],textColorDefaultHoverFocus:e.colors.grey[750],textColorChecked:e.colors.grey[750],indicatorColorDefault:e.colors.grey[500],indicatorBorderColorDefaultHover:e.colors.grey[750],indicatorBorderColorChecked:e.colors.brand[600],indicatorBackgroundColorChecked:e.colors.brand[600],padding:"0 "+Is(2),margin:Is(5)+" "+Is(8)+" "+Is(5)+" "+Is(2)}},Md=function(e){return {meReactingColor:e.colors.brand[600],meReactingColorHover:e.colors.brand[800],otherReactingColor:e.colors.grey[450],otherReactingColorHover:e.colors.grey[750],contentFontSize:e.fontSizes.small,fontWeightHover:e.fontWeightBold,outlineColorFocus:e.colors.brand[600],outlineWidthFocus:Is(2),outlineOffsetFocus:Is(-2),meReacting:!1,boxShadowColor:e.colors.white,borderColorFocus:e.colors.grey[750]}},Dd=function(){return {reactionSpacing:Is(8)}},zd=Dc("foreground"),_d=function(e){return {colorScheme:Kc(e.colorScheme,zd),color:e.bodyColor,disabledColor:e.colors.grey[250],backgroundColor:e.bodyBackground,disabledBackgroundColor:e.colors.grey[150],disabledBorderColor:"transparent",borderRadius:0,borderStyle:"solid",borderWidth:"2px 0 0 0",boxShadow:"0 1px 1px 1px rgba(34,36,38,.15)",padding:"1em"}},Hd=function(e){return {lineBackground:e.colorScheme.default.foreground6,shapeBackground:e.colorScheme.default.foreground6,animationBackground:e.colorScheme.default.foreground6,animationBackgroundSecondary:e.colorScheme.default.foreground6,lineMargin:"0 0 "+Is(2)+" 0",shapeMargin:"0 0 "+Is(2)+" 0",buttonHeight:Is(32),buttonWidth:Is(96),buttonSmallHeight:Is(24),buttonSmallWidth:Is(72),buttonBackground:e.colorScheme.default.foreground6,buttonCircularBorderRadius:Is(999),textBackground:e.colorScheme.default.foreground6,textWidth:"100%",textSmallerHeight:Is(14),textSmallHeight:Is(16),textMediumHeight:Is(19),textLargeHeight:Is(24),textLargerHeight:Is(32),inputHeight:Is(32),inputWidth:Is(154),inputBackground:e.colorScheme.default.foreground6,avatarBackground:e.colorScheme.default.foreground6,avatarSmallest:Is(20),avatarSmaller:Is(24),avatarSmall:Is(28),avatarMedium:Is(32),avatarLarge:Is(44),avatarLarger:Is(64),avatarLargest:Is(96)}},Td=function(e){var r=e.colorScheme;return {height:Is(16),length:Is(320),railColor:r.default.border,disabledRailColor:r.default.backgroundDisabled1,railHeight:Is(2),thumbColor:r.default.foreground2,activeThumbColor:r.default.foreground1,disabledThumbColor:r.default.foregroundDisabled1,thumbHeight:Is(10),activeThumbHeight:Is(14),thumbBorderPadding:Is(4),thumbWidth:Is(10),activeThumbWidth:Is(14),trackColor:r.brand.foregroundActive,disabledTrackColor:r.default.foregroundDisabled1}},Wd=function(e){return {borderColor:void 0,borderWidth:2,iconSize:Is(7),successBackgroundColor:e.colorScheme.green.background,successTextColor:e.colorScheme.green.foreground1,infoBackgroundColor:e.colorScheme.brand.background,infoTextColor:e.colorScheme.default.foreground2,warningBackgroundColor:e.colorScheme.yellow.background,warningTextColor:e.colorScheme.yellow.foreground2,errorBackgroundColor:e.colorScheme.red.background,errorTextColor:e.colorScheme.red.foreground2,defaultBackgroundColor:e.colorScheme.default.background5,defaultTextColor:e.colorScheme.default.foreground4}},Ld=Dc("foreground"),Nd=function(e){return {colorScheme:Kc(e.colorScheme,Ld),fontSizeSmallest:e.fontSizes.smallest,fontLineHeightSmallest:e.lineHeightSmallest,fontSizeSmaller:e.fontSizes.smaller,fontLineHeightSmaller:e.lineHeightSmaller,fontSizeSmall:e.fontSizes.small,fontLineHeightSmall:e.lineHeightSmall,fontSizeMedium:e.fontSizes.medium,fontLineHeightMedium:e.lineHeightMedium,fontSizeLarge:e.fontSizes.large,fontLineHeightLarge:e.lineHeightLarge,fontSizeLarger:e.fontSizes.larger,fontLineHeightLarger:e.lineHeightLarger,fontSizeLargest:e.fontSizes.largest,fontLineHeightLargest:e.lineHeightLargest,fontWeightLight:e.fontWeightLight,fontWeightSemilight:e.fontWeightSemilight,fontWeightRegular:e.fontWeightRegular,fontWeightSemibold:e.fontWeightSemibold,fontWeightBold:e.fontWeightBold,atMentionOtherColor:e.colors.brand[600],atMentionMeColor:e.colors.orange[400],atMentionMeFontWeight:e.fontWeightBold,disabledColor:e.colors.grey[250],errorColor:e.colorScheme.red.foreground,importantWeight:e.fontWeightBold,importantColor:e.colors.red[400],successColor:e.colors.green[600],timestampColor:e.colorScheme.default.foreground1}},Ud=function(e){return {margin:"0",padding:Is(7)+" "+Is(12),borderColor:"transparent",borderRadius:e.borderRadiusMedium+" "+e.borderRadiusMedium+" "+e.borderRadiusSmall+" "+e.borderRadiusSmall,borderWidth:"0 0 "+Is(2)+" 0",backgroundColor:e.colorScheme.default.background2,invertedBackgroundColor:e.colorScheme.default.background,placeholderColor:e.colorScheme.default.foreground1,disabledColor:e.colorScheme.brand.foregroundDisabled,fontColor:e.colorScheme.default.foreground,fontSize:e.fontSizes.medium,borderColorFocus:"transparent transparent "+e.colorScheme.brand.borderFocus1+" transparent",height:"auto",borderColorError:e.colorScheme.red.background}},Zd=Dc("foreground1","background","border","foregroundActive","foregroundHover","backgroundHover","foregroundDisabled1","menuItemForegroundHover","menuItemBackgroundHover"),Vd=function(e){return {colorScheme:Kc($c(e.colorScheme,{default:{foregroundHover:e.colorScheme.brand.foregroundHover,backgroundHover:"transparent",foregroundActive:e.colorScheme.brand.foregroundActive,menuItemForegroundHover:e.colorScheme.default.foregroundHover,menuItemBackgroundHover:e.colorScheme.default.backgroundHover}}),Zd),foreground:void 0,background:"transparent",dividerBorder:void 0,foregroundHover:void 0,backgroundHover:void 0,foregroundActive:void 0,backgroundActive:"transparent",foregroundDisabled:void 0,backgroundDisabled:"transparent",itemHeight:Is(32),itemPadding:"0",borderWidth:"2px",borderRadius:e.borderRadiusMedium,dividerMargin:Is(10)+" "+Is(4),menuMaxWidth:Is(312),menuPadding:Is(8)+" 0",menuBackground:void 0,menuBorder:void 0,menuBorderWidth:"1px",menuBorderRadius:e.borderRadiusMedium,menuBoxShadow:e.shadowLevel3,menuItemForeground:void 0,menuItemForegroundHover:void 0,menuItemBackgroundHover:void 0,menuItemForegroundDisabled:void 0,menuItemBackgroundDisabled:"transparent",menuItemPadding:Is(5)+" "+Is(15),menuDividerBorder:void 0,menuDividerMargin:Is(8)+" 0",customItemHorizontalPadding:Is(16),customItemVerticalPadding:Is(4),overlayZIndex:e.zIndexes.overlay,lineHeightBase:e.lineHeightMedium}},Gd=function(e){return {color:e.colorScheme.default.foreground,padding:Is(1)+" 0",paddingRight:Is(20),paddingLeft:Is(20),borderColor:e.colorScheme.default.foreground1,borderStyle:"solid",borderRadius:e.borderRadiusMedium,borderWidth:Is(1),indicatorColor:"transparent",selectionIndicatorMargin:"0 0 0 0",background:"transparent",hoverBackground:e.colorScheme.default.background1,checkedBackground:e.colorScheme.brand.backgroundActive1,checkedBorderColor:e.colorScheme.brand.backgroundActive1,checkedIndicatorColor:e.colorScheme.default.background,disabledBackground:e.colorScheme.default.background,disabledBackgroundChecked:e.colorScheme.default.backgroundDisabled,disabledBorderColor:e.colorScheme.default.foregroundDisabled1,disabledCheckedIndicatorColor:e.colorScheme.default.foregroundDisabled}},Xd=function(){return {width:void 0,height:void 0}},Yd=function(e){return {boxShadow:e.shadow8,borderRadius:e.borderRadiusMedium,borderSize:"1px",padding:Is(5)+" "+Is(12)+" "+Is(7)+" "+Is(12),maxWidth:Is(246),pointerMargin:Is(6),pointerGap:Is(5),pointerWidth:Is(16),pointerHeight:Is(6),color:e.colorScheme.default.foreground3,backgroundColor:e.colors.grey[500],subtleBackgroundColor:e.colorScheme.default.background,subtleForegroundColor:e.colorScheme.default.foreground,subtleBorderColor:e.colorScheme.onyx.border1,zIndex:e.zIndexes.overlayPriority}},$d=function(e){return {borderRadius:e.borderRadiusMedium,borderColor:e.colorScheme.default.border,borderColorPrimary:e.colors.brand[500],borderColorDisabled:e.colorScheme.brand.foregroundDisabled,smallDimension:Is(24),smallPadding:"0 "+Is(8),smallMinWidth:"0",smallBoxShadow:"none",padding:"0 "+Is(12),minWidth:"0",boxShadow:e.shadowLevel1,toggleButtonHeight:Is(32),dividerColor:e.colorScheme.default.border,dividerPrimaryColor:e.colors.white,toggleButtonColor:e.colorScheme.default.foreground,toggleButtonBackgroundColor:e.colorScheme.default.background,toggleButtonBorderRadius:e.borderRadiusMedium,toggleButtonBorderColor:e.colorScheme.default.border,toggleButtonBoxShadow:e.shadowLevel1,toggleButtonColorHover:e.colorScheme.default.foregroundHover,toggleButtonBackgroundColorHover:e.colorScheme.default.backgroundHover1,toggleButtonBorderColorHover:e.colorScheme.default.borderHover,toggleButtonColorActive:e.colorScheme.default.foregroundPressed,toggleButtonBackgroundColorActive:e.colorScheme.default.backgroundPressed,toggleButtonBorderColorActive:e.colorScheme.default.borderPressed,toggleButtonBackgroundColorFocus:void 0,toggleButtonBorderColorFocus:void 0,toggleButtonColorFocus:void 0,toggleButtonPrimaryHoverBackgroundColor:e.colorScheme.brand.backgroundHover,toggleButtonPrimaryHoverColor:e.colorScheme.brand.foregroundHover1,toggleButtonPrimaryColor:e.colorScheme.brand.foreground4,toggleButtonPrimaryBackgroundColor:e.colorScheme.brand.background,toggleButtonPrimaryBorderColor:"transparent",toggleButtonPrimaryBoxShadow:e.shadowLevel1Dark,toggleButtonPrimaryBackgroundColorActive:e.colorScheme.brand.backgroundPressed,toggleButtonPrimaryBackgroundColorFocus:void 0,toggleButtonColorDisabled:e.colorScheme.brand.foregroundDisabled,toggleButtonBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled,toggleButtonIndicatorSize:Is(16),focusBorderRadius:e.borderRadiusMedium,focusBorderWidth:e.borderWidth,focusInnerBorderColor:e.focusInnerBorderColor,focusOuterBorderColor:e.focusOuterBorderColor,focusBorderZIndex:e.zIndexes.foreground}},Kd=function(e){return {width:300,height:300,focusOuterBorderColor:e.focusOuterBorderColor,focusOuterBorderRadius:e.borderRadiusMedium,paddleColor:e.colorScheme.default.foreground4,paddleColorDisabled:e.colorScheme.brand.foregroundDisabled,paddleBackgroundColor:e.colorScheme.onyx.background3,paddleBackgroundColorActive:e.colorScheme.onyx.backgroundPressed,paddleBackgroundColorHover:e.colorScheme.onyx.backgroundHover,paddleBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled,paddleBorderColor:"transparent",paddleBorderRadius:e.borderRadiusMedium,paddleHeight:Is(32),paddleIndicatorSize:Is(16),focusBorderRadius:e.borderRadiusMedium,focusBorderWidth:e.borderWidth,focusInnerBorderColor:e.focusInnerBorderColor,focusBorderZIndex:e.zIndexes.foreground}},qd=Dc("border","borderActive","foregroundActive","foregroundFocus","foregroundHover","backgroundHover","backgroundActive","backgroundFocus","foregroundDisabled"),Jd=function(e){return {width:300,colorScheme:Kc($c(e.colorScheme,{default:{borderActive:e.colorScheme.default.border2,backgroundActive:e.colorScheme.default.backgroundActive1,backgroundFocus:e.colorScheme.default.backgroundFocus1,foregroundDisabled:e.colorScheme.default.foregroundDisabled1},brand:{foregroundHover:e.colors.white,backgroundHover:e.colors.brand[300],foregroundActive:e.colors.white,borderActive:e.colors.brand[600],backgroundActive:e.colors.brand[500],foregroundFocus:e.colors.white,backgroundFocus:e.colors.brand[300],foregroundDisabled:e.colorScheme.brand.foregroundDisabled1}}),qd),color:e.colors.grey[500],colorActive:e.colors.black,borderColor:void 0,borderColorActive:void 0,borderColorFocus:e.colors.white,outlineColorFocus:e.colors.black,backgroundColor:void 0,backgroundColorFocus:void 0,backgroundColorHover:void 0,backgroundColorActive:void 0,iconOnlyColorActive:e.colors.brand[600],lineHeightBase:e.lineHeightMedium,horizontalPadding:Is(14)+" "+Is(18),verticalBackgroundColor:e.colors.white,verticalItemPadding:Is(7)+" "+Is(14),verticalItemBorderWidth:Is(2),verticalItemBorderColor:"transparent",verticalBackgroundColorFocus:e.colors.grey[150],primaryBorderColor:e.colorScheme.default.border2,indicatorBackgroundColor:e.colors.grey[500],indicatorActiveBackgroundColor:e.colors.brand[600],borderWidth:Is(1),thumbnailWidth:75}},Qd=function(e){return {color:e.colorScheme.default.foreground,hoverColor:e.colorScheme.default.foregroundHover,backgroundColor:e.colorScheme.default.background,backgroundHoverColor:e.colorScheme.default.backgroundHover1,defaultRowHeight:Is(48),compactRowHeight:Is(36),minCellWidth:"0",cellPadding:"0 "+Is(8),rowPadding:"0",headerFontSize:Is(12),bodyFontSize:Is(13),borderWidth:Is(1),headerBorderColor:e.colorScheme.default.backgroundHover1,headerBorderHoverColor:"transparent",headerBorderFocusColor:"transparent",rowBorderColor:e.colorScheme.default.backgroundHover1,rowBorderHoverColor:e.colorScheme.default.backgroundHover1,rowBorderFocusColor:e.colorScheme.default.borderFocus,cellBorderColor:"transparent",cellBorderHoverColor:"transparent",cellBorderFocusColor:e.colorScheme.default.borderFocus}},eu=function(e){return {backgroundColor:e.colorScheme.default.background1,backgroundColorDisabled:e.colorScheme.default.backgroundDisabled1,backgroundColorFocus:e.colorScheme.default.backgroundFocus1,backgroundColorHover:e.colorScheme.default.backgroundHover1,backgroundColorPressed:e.colorScheme.default.backgroundPressed,ghostBackgroundColor:"none",ghostBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled,ghostBackgroundColorFocus:"none",ghostBackgroundColorHover:e.colorScheme.default.backgroundHover,ghostBackgroundColorPressed:e.colorScheme.default.backgroundPressed,invertedBackgroundColor:e.colorScheme.default.background2,invertedBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled2,invertedBackgroundColorFocus:e.colorScheme.default.background2,invertedBackgroundColorHover:e.colorScheme.default.backgroundHover2,invertedBackgroundColorPressed:e.colorScheme.default.backgroundPressed,borderStyle:"solid",borderColor:"transparent",borderColorDisabled:"transparent",borderColorHover:"transparent",borderColorPressed:"transparent",borderWidth:e.borderWidth,borderRadius:e.borderRadiusMedium,boxShadow:"none",boxShadowDisabled:"none",boxShadowHover:"none",boxShadowFocus:"none",boxShadowPressed:"none",elevatedBoxShadow:e.shadowLevel1,elevatedBoxShadowDisabled:e.shadowLevel1,elevatedBoxShadowHover:e.shadowLevel3,elevatedBoxShadowFocus:e.shadowLevel1,elevatedBoxShadowPressed:e.shadowLevel1,padding:Is(16),margin:Is(0),colorDisabled:e.colorScheme.default.foregroundDisabled,compactPadding:Is(0),previewMargin:"0 0 "+Is(10)+" 0",headerMargin:"0 0 "+Is(10)+" 0",bodyMargin:"0 0 "+Is(10)+" 0",footerMargin:"0 0 "+Is(10)+" 0",fittedPreviewMargin:Is(0),fittedHeaderMargin:Is(0),fittedBodyMargin:Is(0),fittedFooterMargin:Is(0),previewMarginHorizontal:"0 "+Is(10)+" 0 0",topControlsTop:Is(10),topControlsRight:Is(0),width:Is(300),height:"100%",sizeSmallWidth:Is(200),sizeSmallHeight:"100%",sizeSmallPadding:Is(0),sizeLargeWidth:Is(500),sizeLargeHeight:"100%",sizeLargePadding:Is(16),fluidWidth:"100%",fluidHeight:"100%",expandableBoxStartMaxHeight:Is(20),expandableBoxEndMaxHeight:Is(500),expandableBoxShrinkTransition:"max-height 0.5s ease-in",expandableBoxExpandTransition:"max-height 1s ease-in",selectedBackgroundColor:e.colorScheme.default.backgroundFocus3,selectedBorderColor:e.colorScheme.default.borderActive,selectedBoxShadow:e.shadowLevel4,selectedBackgroundColorDisabled:e.colorScheme.default.backgroundDisabled3,selectedBackgroundColorFocus:e.colorScheme.default.backgroundFocus3,selectedBackgroundColorHover:e.colorScheme.default.backgroundHover3,selectedBackgroundColorPressed:e.colorScheme.default.backgroundPressed3}};!function(e){e[e.Sunday=0]="Sunday",e[e.Monday=1]="Monday",e[e.Tuesday=2]="Tuesday",e[e.Wednesday=3]="Wednesday",e[e.Thursday=4]="Thursday",e[e.Friday=5]="Friday",e[e.Saturday=6]="Saturday";}(qc||(qc={})),function(e){e[e.January=0]="January",e[e.February=1]="February",e[e.March=2]="March",e[e.April=3]="April",e[e.May=4]="May",e[e.June=5]="June",e[e.July=6]="July",e[e.August=7]="August",e[e.September=8]="September",e[e.October=9]="October",e[e.November=10]="November",e[e.December=11]="December";}(Jc||(Jc={})),function(e){e[e.FirstDay=0]="FirstDay",e[e.FirstFullWeek=1]="FirstFullWeek",e[e.FirstFourDayWeek=2]="FirstFourDayWeek";}(Qc||(Qc={})),function(e){e[e.Day=0]="Day",e[e.Week=1]="Week",e[e.Month=2]="Month",e[e.WorkWeek=3]="WorkWeek";}(ed||(ed={}));var ru=function(e){return {calendarCellBorder:"none",calendarCellHeight:Is(34),calendarCellWidth:Is(34),calendarCellPadding:Is(0),calendarCellMargin:Is(0),calendarCellBackgroundColor:e.colorScheme.default.background,calendarCellColor:"inherit",calendarCellQuietColor:e.colorScheme.default.foreground2,calendarCellSelectedColor:e.colorScheme.brand.background4,calendarCellSelectedBackgroundColor:e.colorScheme.brand.borderActive1,calendarCellTodayBackgroundColor:e.colorScheme.brand.backgroundFocus,calendarCellTodayColor:e.colorScheme.white.foreground,calendarCellTodayBorderRadius:"50%",calendarCellHoverBackgroundColor:e.colorScheme.brand.backgroundHover2,calendarCellHoverColor:"inherit",calendarCellDisabledColor:e.colorScheme.brand.foregroundDisabled,calendarCellDisabledBackgroundColor:e.colorScheme.default.background,calendarHeaderCellFontWeight:e.fontWeightRegular,calendarHeaderCellHeight:Is(32),calendarHeaderCellPadding:Is(2)+" "+Is(0)+" "+Is(2)+" "+Is(0),calendarHeaderCellWidth:"calc(100%/7)",calendarHeaderPaddingTop:Is(5),calendarHeaderPaddingBottom:Is(5),calendarHeaderLabelPaddingLeft:Is(10),calendarHeaderLabelFontWeight:e.fontWeightBold,calendarMinHeight:Is(282)}},ou={root:function(){return {verticalAlign:"middle",display:"flex",flexDirection:"column",marginBlockEnd:0,marginBlockStart:0}}},tu={root:function(e){var r=e.props;return Object.assign({display:"none",verticalAlign:"middle"},r.active&&{display:"block"},{marginInlineStart:""+Is(20)})}},nu={root:function(e){return {display:"inline-block",verticalAlign:"middle",padding:".5rem 0",cursor:e.props.disabled?"default":"pointer"}},contentWrapper:function(e){var r=e.props,o=e.variables;return Object.assign({display:"grid",gridTemplateColumns:"auto",msGridColumns:"auto",userSelect:"none"},r.content&&{gridTemplateColumns:"auto 1fr",msGridColumns:"auto 1fr"},{":focus-visible":{borderRadius:o.focusBorderRadius,outline:o.focusBorderWidth+" solid "+o.focusBorderColor}})},indicator:function(e){var r,o,t=e.props,n=e.variables,a=e.rtl;return Object.assign({alignItems:"center",display:"inline-flex",backgroundImage:(r=n.color,o=t.active,o?"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' fill='"+encodeURIComponent(r)+"' viewBox='8 8 16 16'%3E%3Cpath d='M16 19l3.5-4h-7z' /%3E%3C/svg%3E\")":"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' fill='"+encodeURIComponent(r)+"' viewBox='8 8 16 16'%3E%3Cpath d='M19 16l-4-3.5v7z' /%3E%3C/svg%3E\")"),backgroundPosition:"center"},a&&{transform:"scaleX(-1)"},{content:'" "',overflow:"hidden",height:"100%",width:Is(16),msGridColumn:"1",marginRight:""+Is(4)})},content:function(){return {alignItems:"center",display:"grid",msGridColumn:"2"}}},au=function(e,r){return e.danger?{color:r.dangerColor,backgroundColor:r.dangerBackgroundColor,borderColor:r.dangerBorderColor}:e.info?{color:r.color,backgroundColor:r.backgroundColor,borderColor:r.borderColor}:r.oof?{color:r.oofColor,backgroundColor:r.oofBackgroundColor,borderColor:r.oofBorderColor}:r.urgent?{color:r.urgentColor,backgroundColor:r.urgentBackgroundColor,borderColor:r.urgentBorderColor}:e.success?{color:r.successColor,backgroundColor:r.successBackgroundColor,borderColor:r.successBorderColor}:e.warning?{color:r.warningColor,backgroundColor:r.warningBackgroundColor,borderColor:r.warningBorderColor}:{color:r.color,backgroundColor:r.backgroundColor,borderColor:r.borderColor}},iu={root:function(e){var r=e.props,o=e.variables;return e.theme.siteVariables,Object.assign({display:"flex",alignItems:"center",position:"relative",borderStyle:o.borderStyle,borderWidth:o.borderWidth,borderRadius:o.borderRadius,minHeight:o.minHeight,padding:o.padding,fontWeight:o.fontWeight,visibility:"visible",boxSizing:"border-box"},au(r,o),("top"===r.attached||!0===r.attached)&&{borderRadius:o.borderRadius+" "+o.borderRadius+" 0 0"},"bottom"===r.attached&&{borderRadius:"0 0 "+o.borderRadius+" "+o.borderRadius},r.fitted&&{display:"inline-flex"},r.dismissible&&{padding:o.dismissiblePadding},!r.visible&&{visibility:"hidden"})},actions:function(e){return {margin:e.variables.actionsMargin}},header:function(e){var r=e.variables;return {fontWeight:r.headerFontWeight,margin:r.headerMargin}},body:function(){return {display:"flex",flexGrow:1}},content:function(){return {flexGrow:1}},icon:function(e){var r=e.variables;return {display:"inline-flex",alignItems:"center",justifyContent:"center",width:r.iconSize,height:r.iconSize,"& > :first-child":{height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}},margin:r.iconMargin}}},lu="ui-alert__dismissaction__content",su="transparent",cu=function(e){var r=e.variables,o=e.borderRadius,t=void 0===o?r.focusBorderRadius||r.borderRadius:o,n=e.focusInnerBorderColor,a=void 0===n?r.focusInnerBorderColor||su:n,i=e.focusOuterBorderColor,l=void 0===i?r.focusOuterBorderColor||su:i,s=e.borderPadding,c=e.focusInnerBorderWidth,d=void 0===c?r.focusInnerBorderWidth||r.borderWidth:c,u=e.focusOuterBorderWidth,f=void 0===u?r.focusOuterBorderWidth||r.borderWidth:u,g={content:'""',position:"absolute",borderStyle:"solid",pointerEvents:"none",borderRadius:t},p=(null==s?void 0:s.top)||s,b=(null==s?void 0:s.bottom)||s,m=(null==s?void 0:s.left)||s,h=(null==s?void 0:s.right)||s;return {":focus":{outline:"none"},":focus-visible":{borderColor:"transparent",":before":Object.assign({},g,{borderWidth:d,zIndex:r.zIndexes.foreground,borderColor:a,top:null==s?"0":"-"+p,bottom:null==s?"0":"-"+b,left:null==s?"0":"-"+m,right:null==s?"0":"-"+h}),":after":Object.assign({},g,{borderWidth:f,zIndex:r.zIndexes.foreground,borderColor:l,top:null==s?"-"+d:"calc(0px - "+p+" - "+d+")",bottom:null==s?"-"+d:"calc(0px - "+b+" - "+d+")",left:null==s?"-"+d:"calc(0px - "+m+" - "+d+")",right:null==s?"-"+d:"calc(0px - "+h+" - "+d+")"})}}},du=function(e){var r,o=e.outline;return (r={})["& ."+Sa]={display:o?"none":"block"},r["& ."+Ba]={display:o?"block":"none"},r},uu=function(e,r){return r?"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M16.707 16l4.243-4.243a.5.5 0 1 0-.707-.707L16 15.293l-4.243-4.243a.5.5 0 1 0-.707.707L15.293 16l-4.243 4.243a.5.5 0 1 0 .707.707L16 16.707l4.243 4.243a.498.498 0 0 0 .707 0 .5.5 0 0 0 0-.707L16.707 16z' /%3E%3C/g%3E%3C/svg%3E\")":"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M17.414 16l3.89-3.89a1 1 0 1 0-1.415-1.413L16 14.586l-3.89-3.89a1 1 0 1 0-1.413 1.415L14.586 16l-3.89 3.89a1 1 0 1 0 1.415 1.413L16 17.414l3.89 3.89a.997.997 0 0 0 1.413 0 1 1 0 0 0 0-1.415L17.414 16z' /%3E%3C/g%3E%3C/svg%3E\")"},fu=function(e,r,o){return {width:o,height:o,backgroundImage:uu(e,r),backgroundRepeat:"no-repeat"}},gu={root:function(e){var r,o,t,n=e.props,a=e.variables,i=e.theme.siteVariables.borderWidth,l=au(n,a).color,s=cu({variables:{borderRadius:a.focusBorderRadius,borderWidth:a.focusBorderWidth,focusInnerBorderColor:a.focusInnerBorderColor,focusOuterBorderColor:a.focusOuterBorderColor,zIndexes:{foreground:a.focusBorderZIndex}},borderPadding:i});return Object.assign({height:a.dismissActionSize,minWidth:a.dismissActionSize,color:a.dismissActionColor||"currentColor",outline:0,padding:0,borderWidth:0,backgroundColor:a.dismissActionBackgroundColor,borderRadius:a.borderRadius,display:"inline-flex",justifyContent:"center",alignItems:"center",position:"relative",verticalAlign:"middle",cursor:"pointer",transition:ws},du({outline:!0}),!n.hasContent&&((r={})["& ."+lu]=Object.assign({},fu(l,!0,a.dismissActionIndicatorSize)),r),{":hover":Object.assign({backgroundColor:a.hoverBackgroundColor,color:"currentColor"},du({outline:!1}),!n.hasContent&&(o={},o["& ."+lu]=Object.assign({},fu(l,!1,a.dismissActionIndicatorSize)),o),cu({variables:{borderRadius:a.dismissActionHoverBorderRadius,borderWidth:a.dismissActionHoverBorderWidth,focusInnerBorderColor:a.dismissActionHoverInnerBorderColor,focusOuterBorderColor:a.dismissActionHoverOuterBorderColor,zIndexes:{foreground:a.dismissActionHoverZIndex}}})[":focus-visible"]),":focus":s[":focus"],":focus-visible":Object.assign({backgroundColor:a.focusBackgroundColor,borderColor:a.dismissActionBorderColorFocus,color:a.dismissActionColorFocus,borderWidth:i},s[":focus-visible"],du({outline:!1}),!n.hasContent&&(t={},t["& ."+lu]=Object.assign({},fu(l,!1,a.dismissActionIndicatorSize)),t),{":hover":{borderColor:a.dismissActionBorderColorHover}})},n.disabled&&{cursor:"default",color:a.dismissActionColorDisabled,boxShadow:"none",pointerEvents:"none",":hover":{color:a.dismissActionColorDisabled},backgroundColor:a.dismissActionBackgroundColorDisabled,borderColor:a.dismissActionBorderColorDisabled})},content:function(e){var r=e.props,o=e.variables,t=au(r,o).color;return Object.assign({fontWeight:o.dismissActionContentFontWeight},!r.hasContent&&Object.assign({},fu(t,!1,o.dismissActionIndicatorSize)))}},pu="ui-attachment__action",bu={root:function(e){var r,o,t=e.props,n=e.variables,a=e.theme.siteVariables,i=cu({variables:a,borderRadius:n.borderRadius});return Object.assign({position:"relative",display:"inline-flex",alignItems:"center",width:"100%",maxWidth:Is(440),minHeight:Is(48),padding:n.padding,marginBottom:Is(2),marginRight:Is(2),background:n.backgroundColor,color:n.textColor,boxShadow:n.boxShadow,border:a.borderWidth+" solid "+n.borderColor,borderRadius:n.borderRadius},i,{"& .ui-attachment__progress":{transition:"width 0.2s",position:"absolute",display:"block",bottom:0,left:0,maxWidth:"100%",height:n.progressHeight,background:n.progressColor}},t.actionable&&{cursor:"pointer",":focus-visible":Object.assign({},i[":focus-visible"],(r={backgroundColor:n.focusBackgroundColor,color:n.focusColor},r["& ."+pu]={color:n.focusColor},r["& ."+ka]={color:n.focusColor},r)),":hover":(o={backgroundColor:n.backgroundColorHover,color:n.textColorHover},o["& ."+pu]={color:n.textColorHover},o["& ."+ka]={color:n.textColorHover},o)})}},mu="ui-loader",hu=mu+"__indicator",vu=mu+"__svg",yu={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=du({outline:!1}),a=cu({variables:t,borderRadius:o.actionFocusBorderRadius});return Object.assign({height:o.actionHeight,maxWidth:o.actionMaxWidth,display:"inline-flex",justifyContent:"center",alignItems:"center",position:"relative",verticalAlign:"middle",cursor:"pointer",color:o.actionColor,backgroundColor:"transparent",borderColor:"transparent",padding:0},du({outline:!0}),{":focus":Object.assign({boxShadow:"none"},a[":focus"]),":focus-visible":Object.assign({},n,a[":focus-visible"])},r.primary&&{color:o.actionPrimaryColor},r.disabled&&{cursor:"default",boxShadow:"none",pointerEvents:"none",color:o.actionColorDisabled,backgroundColor:"transparent",":hover":{color:o.actionColorDisabled}},{minWidth:o.actionHeight,":hover":Object.assign({},du({outline:!1}))})},icon:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.actionIconSize,height:o.actionIconSize},r.loading&&{margin:0,opacity:0,width:0},r.hasContent&&Object.assign({margin:"0 "+Is(10)+" 0 0"},"after"===r.iconPosition&&{margin:"0 0 0 "+Is(10)}))},loader:function(e){var r,o=e.props,t=e.variables;return Object.assign(((r={})["& ."+hu]={width:t.actionLoaderSize,height:t.actionLoaderSize},r["& ."+vu]={":before":{animationName:{to:{transform:"translate3d(0, "+t.actionLoaderSvgAnimationHeight+", 0)"}},borderWidth:t.actionLoaderBorderSize,width:t.actionLoaderSize,height:t.actionLoaderSvgHeight}},r),o.hasContent&&{marginRight:Is(4)})}},Cu={root:function(){return {flex:1}}},ku={root:function(e){var r=e.variables;return {display:"block",fontSize:r.descriptionFontSize,fontWeight:r.descriptionFontWeight,lineHeight:r.descriptionLineHeight}}},wu={root:function(e){var r=e.variables;return {display:"block",fontSize:r.headerFontSize,fontWeight:r.headerFontWeight,lineHeight:r.headerLineHeight}}},xu={root:function(e){var r,o=e.variables;return (r={height:o.iconSize,width:o.iconSize,marginRight:o.iconSpace})["& ."+ka]={height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}},r}},Su={smallest:20,smaller:24,small:28,medium:32,large:44,larger:64,largest:96},Bu={root:function(e){var r=e.props.size,o=Is(Su[r]);return {position:"relative",backgroundColor:"inherit",display:"inline-block",verticalAlign:"middle",height:o,width:o}}},Eu={smallest:6,smaller:10,small:10,medium:10,large:10,larger:16,largest:0},Ou={root:function(e){var r,o=e.variables,t=e.props,n=t.color,a=t.size,i=t.state;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center"},{height:r=Is(Eu[a]),width:r},{verticalAlign:"middle",borderRadius:"9999px",position:"absolute",bottom:0,right:0,boxShadow:"0 0 0 "+o.statusBorderWidth+" "+o.statusBorderColor},"success"===i&&{backgroundColor:o.statusSuccessBackgroundColor},"info"===i&&{backgroundColor:o.statusInfoBackgroundColor},"warning"===i&&{backgroundColor:o.statusWarningBackgroundColor},"error"===i&&{backgroundColor:o.statusErrorBackgroundColor},"unknown"===i&&{backgroundColor:o.statusBackgroundColor},!!n&&{backgroundColor:n})}},Fu={root:function(e){var r=e.props.state,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.statusIconSize,height:o.statusIconSize,color:o.statusColor},"success"===r&&{color:o.statusSuccessColor},"info"===r&&{color:o.statusInfoColor},"error"===r&&{color:o.statusErrorColor},"warning"===r&&{color:o.statusWarningColor},{"& > :first-child":{height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}}})}},Au={root:function(e){var r=e.variables,o=e.props;return Object.assign({boxSizing:"border-box",display:"inline-block"},o.circular&&{borderRadius:r.imageCircularRadius},o.avatar&&{width:o.fluid?"100%":r.imageAvatarSize,borderRadius:r.imageAvatarRadius},{borderColor:r.avatarBorderColor,borderStyle:"solid",borderWidth:r.avatarBorderWidth,height:"100%",objectFit:"cover",verticalAlign:"top",width:"100%"},!o.avatar&&{borderRadius:r.squareAvatarBorderRadius})}},Pu={smallest:20,smaller:24,small:28,medium:32,large:44,larger:64,largest:96},ju={smallest:10,smaller:12,small:16,medium:16,large:20,larger:32,largest:40},Ru={root:function(e){var r=e.variables,o=e.props,t=Is(Pu[o.size]),n=Is(ju[o.size]);return Object.assign({color:r.iconColor,background:r.iconBackgroundColor,width:t,height:t,borderRadius:"50%",display:"inline-flex",alignItems:"center"},o.square&&{borderRadius:r.squareAvatarBorderRadius},{"& > :first-child":{margin:"0 auto",width:n,height:n,"& svg":{width:"100%",height:"100%"}}})}},Iu={smallest:20,smaller:24,small:28,medium:32,large:44,larger:64,largest:96},Mu={root:function(e){var r=e.props,o=e.variables,t=Is(Iu[r.size]);return Object.assign({alignItems:"center",overflow:"hidden",color:o.labelColor,backgroundColor:o.labelBackground,borderRadius:"50%",display:"inline-block",width:t,height:t,lineHeight:t,fontSize:Is(Iu[r.size]/2.333),verticalAlign:"top",textAlign:"center",padding:"0"},r.square&&{borderRadius:o.squareAvatarBorderRadius},r.circular&&{borderRadius:o.labelCircularRadius})}},Du={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=t.borderWidth,a=cu(Object.assign({variables:t,borderRadius:t.borderRadiusMedium,borderPadding:n},r.circular&&{borderPadding:Is(4)}));return Object.assign({height:o.height,minWidth:Dr()(r.loading)?o.minWidth:o.loadingMinWidth,maxWidth:o.maxWidth,color:o.color,backgroundColor:o.backgroundColor,borderRadius:o.borderRadius,display:"inline-flex",justifyContent:"center",alignItems:"center",position:"relative",padding:o.padding,verticalAlign:"middle",cursor:"pointer",transition:ws,userSelect:"none"},!(r.text||r.flat||"small"===r.size)&&Object.assign({},r.primary&&{boxShadow:o.primaryBoxShadow},!r.primary&&{boxShadow:o.boxShadow}),"small"===r.size&&{padding:o.sizeSmallPadding,height:o.sizeSmallHeight,minWidth:o.sizeSmallMinWidth},!r.text&&Object.assign({outline:0,borderWidth:n,borderStyle:"solid",borderColor:o.borderColor,":hover":{color:o.colorHover,backgroundColor:o.backgroundColorHover,borderColor:o.borderColorHover}},!r.disabledFocusable&&{":active":{transition:ks,color:o.colorActive,backgroundColor:o.backgroundColorActive,borderColor:o.borderColorActive,boxShadow:"none"}},{":focus":a[":focus"],":focus-visible":Object.assign({},a[":focus-visible"],{backgroundColor:o.backgroundColorFocus,borderColor:o.borderColorFocus,color:o.colorFocus,borderWidth:n,":hover":{borderColor:o.borderColorHover}})}),r.circular&&!r.text&&Object.assign({minWidth:o.height,padding:0,borderRadius:o.circularBorderRadius},"small"===r.size&&{minWidth:o.sizeSmallHeight}),r.text&&Object.assign({color:o.textColor,backgroundColor:"transparent",borderColor:"transparent",padding:"0 "+Is(8)},du({outline:!0}),{":hover":Object.assign({color:o.textColorHover},du({outline:!1})),":active":{color:t.colorScheme.brand.backgroundPressed},":focus":Object.assign({boxShadow:"none"},a[":focus"]),":focus-visible":a[":focus-visible"]},r.primary&&{color:o.textPrimaryColor}),r.primary&&!r.text&&Object.assign({color:o.primaryColor,backgroundColor:o.primaryBackgroundColor,borderColor:o.primaryBorderColor},!r.disabledFocusable&&{":active":{transition:ks,backgroundColor:o.primaryBackgroundColorActive,boxShadow:"none"}},{":focus":a[":focus"],":focus-visible":Object.assign({},a[":focus-visible"],{backgroundColor:o.primaryBackgroundColorFocus}),":hover":{color:o.primaryColorHover,backgroundColor:o.primaryBackgroundColorHover}}),r.inverted&&Object.assign({backgroundColor:t.colorScheme.silver.background,borderColor:t.colorScheme.silver.border,color:t.colorScheme.silver.foreground},!r.disabledFocusable&&{":active":{transition:ks,backgroundColor:t.colorScheme.silver.backgroundPressed,color:t.colorScheme.silver.foregroundHover}},{":hover":{backgroundColor:t.colorScheme.silver.backgroundHover,color:t.colorScheme.silver.foregroundHover},":focus":Object.assign({},a[":focus"],{boxShadow:"none"}),":focus-visible":Object.assign({},a[":focus-visible"],!r.disabledFocusable&&{backgroundColor:t.colorScheme.silver.backgroundPressed,color:t.colorScheme.silver.foregroundHover})}),r.tinted&&Object.assign({backgroundColor:o.tintedBackgroundColor,borderColor:o.tintedBorderColor,color:o.tintedColor},!r.disabledFocusable&&{":active":{transition:ks,backgroundColor:o.tintedBackgroundColorActive}},{":hover":{color:o.tintedColorHover,backgroundColor:o.tintedBackgroundColorHover,borderColor:o.tintedBorderColorHover},":focus":{boxShadow:"none"}}),r.disabled&&{pointerEvents:"none"},(r.disabled||r.disabledFocusable)&&Object.assign({cursor:"default",color:o.colorDisabled,boxShadow:"none",":hover":{color:o.colorDisabled}},r.text&&{color:o.textColorDisabled,backgroundColor:"transparent",":hover":{color:o.textColorDisabled}},!r.text&&{backgroundColor:o.backgroundColorDisabled,borderColor:o.borderColorDisabled}),r.fluid&&{width:"100%",maxWidth:"100%"},r.iconOnly&&Object.assign({minWidth:o.height,padding:0},!r.inverted&&!r.disabledFocusable&&{":hover":Object.assign({},du({outline:!1}),{color:o.textColorIconOnlyHover,background:o.backgroundColorIconOnlyHover})},"small"===r.size&&{minWidth:o.sizeSmallHeight}))},icon:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.iconSize,height:o.iconSize},r.loading&&{margin:0,opacity:0,width:0},r.hasContent&&Object.assign({margin:"0 "+Is(10)+" 0 0"},"after"===r.iconPosition&&{margin:"0 0 0 "+Is(10)}))},loader:function(e){var r,o=e.props,t=e.variables;return Object.assign(((r={})["& ."+hu]={width:"small"===o.size?t.sizeSmallLoaderSize:t.loaderSize,height:"small"===o.size?t.sizeSmallLoaderSize:t.loaderSize},r["& ."+vu]={":before":{animationName:{to:{transform:"translate3d(0, "+("small"===o.size?t.sizeSmallLoaderSvgAnimationHeight:t.loaderSvgAnimationHeight)+", 0)"}},borderWidth:"small"===o.size?t.sizeSmallLoaderBorderSize:t.loaderBorderSize,width:"small"===o.size?t.sizeSmallLoaderSize:t.loaderSize,height:"small"===o.size?t.sizeSmallLoaderSvgHeight:t.loaderSvgHeight}},r),o.hasContent&&{marginRight:Is(4)})}},zu=function(e){return e?{marginRight:Is(8)}:{borderRadius:0}},_u={root:function(){return {}},middleButton:function(e){var r=e.props;return Object.assign({},zu(r.circular))},firstButton:function(e){var r=e.props,o=e.variables;return Object.assign({},zu(r.circular),!r.circular&&{borderTopLeftRadius:o.borderRadius,borderBottomLeftRadius:o.borderRadius})},lastButton:function(e){var r=e.props,o=e.variables;return Object.assign({},zu(r.circular),!r.circular&&{borderTopRightRadius:o.borderRadius,borderBottomRightRadius:o.borderRadius})}},Hu={root:function(e){var r=e.props,o=e.variables;return Object.assign({overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap",fontSize:o.contentFontSize,fontWeight:o.contentFontWeight,lineHeight:o.contentLineHeight},"small"===r.size&&{fontSize:o.sizeSmallContentFontSize,lineHeight:o.sizeSmallContentLineHeight})}},Tu={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",verticalAlign:"middle"},r.active&&{fontWeight:o.itemCurrentFontWeight},r.disabled&&{color:o.disabledColor},"smaller"===r.size&&{paddingLeft:o.linkPaddingLeftSmaller,paddingRight:o.linkPaddingRightSmaller,gap:o.linkSmallerGap},"small"===r.size&&{paddingLeft:o.linkPaddingLeftSmall,paddingRight:o.linkPaddingRightSmall,gap:o.linkSmallGap},"medium"===r.size&&{paddingLeft:o.linkPaddingLeftMedium,paddingRight:o.linkPaddingRightMedium,gap:o.linkMediumGap},"large"===r.size&&{paddingLeft:o.linkPaddingLeftLarge,paddingRight:o.linkPaddingRightLarge,gap:o.linkLargeGap})}},Wu={root:function(e){return e.props,e.variables,{verticalAlign:"middle"}}},Lu={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=cu(Object.assign({variables:t},"smaller"===r.size&&{borderPadding:{top:o.linkPaddingTop,right:o.linkPaddingRightSmaller,bottom:o.linkPaddingBottom,left:o.linkPaddingLeftSmaller}},"small"===r.size&&{borderPadding:{top:o.linkPaddingTop,right:o.linkPaddingRightSmall,bottom:o.linkPaddingBottom,left:o.linkPaddingLeftSmall}},"medium"===r.size&&{borderPadding:{top:o.linkPaddingTop,right:o.linkPaddingRightMedium,bottom:o.linkPaddingBottom,left:o.linkPaddingLeftMedium}},"large"===r.size&&{borderPadding:{top:o.linkPaddingTop,right:o.linkPaddingRightLarge,bottom:o.linkPaddingBottom,left:o.linkPaddingLeftLarge}}));return Object.assign({userSelect:"none",display:"flex",alignItems:"center",position:"relative",":visited":{color:"inherit"}},n)}},Nu={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center"},"smaller"===r.size&&{fontSize:o.fontSizeSmaller},"small"===r.size&&{fontSize:o.fontSizeSmall},"medium"===r.size&&{fontSize:o.fontSizeMedium},"large"===r.size&&{fontSize:o.fontSizeLarge})}},Uu={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables;return {backgroundColor:o.backgroundColor,border:t.borderWidth+" solid "+o.backgroundColor,display:"flex",flexDirection:"column",listStyle:"none",margin:0,padding:"compact"===r.density?"0 "+Is(4)+" "+Is(2):"0 "+Is(10)+" 0 "+Is(10)}}},Zu={comfy:{root:function(e){var r=e.props;return Object.assign({},(!r.attached||"top"===r.attached)&&{paddingTop:Is(16)},("bottom"===r.attached||!0===r.attached)&&{paddingTop:Is(2)})},gutter:function(e){var r,o=e.props;return (r={marginTop:e.variables.gutterMargin})["end"===o.contentPosition?"right":"left"]=0,r},message:function(e){var r=e.variables;return {marginLeft:r.messageMargin,marginRight:r.messageMargin}}},compact:{root:function(e){var r=e.props;return Object.assign({},(!r.attached||"top"===r.attached)&&{paddingTop:Is(8)},{marginTop:Is(-2),marginBottom:Is(-2)})},gutter:function(e){return {marginTop:e.variables.gutterMarginCompact,left:Is(28)}},message:function(e){var r=e.variables;return {marginLeft:r.messageMarginCompact,marginRight:r.messageMarginEndCompact,width:"calc(100% - "+r.messageMarginCompact+" - "+r.messageMarginEndCompact+")"}}}},Vu=function(e){return void 0===e&&(e=Oo),Zu[e]},Gu={root:function(e){var r=e.props;return Object.assign({paddingBottom:0,position:"relative"},Vu(r.density).root(e))},gutter:function(e){var r=e.props;return Object.assign({position:"absolute"},("bottom"===r.attached||!0===r.attached)&&{display:"none"},Vu(r.density).gutter(e))},message:function(e){var r=e.props;return Object.assign({float:"end"===r.contentPosition?"right":"left",position:"relative"},Vu(r.density).message(e))}},Xu={border:"0",clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:"0",position:"absolute",width:"1px"},Yu=function(e){return {zIndex:e,overflow:"visible",opacity:1,width:"auto"}},$u={comfy:{root:function(e){var r,o,t,n,a=e.props,i=e.variables;return Object.assign({marginLeft:a.mine?i.offset:0,marginRight:a.mine?0:i.offset,maxWidth:"calc(100% - "+i.offset+")",minWidth:i.offset,paddingLeft:i.padding,paddingRight:i.padding,paddingTop:Is(8),paddingBottom:Is(10),backgroundColor:a.mine?i.backgroundColorMine:i.backgroundColor,border:i.border},(i.hasMention||i.isImportant)&&((r={})["& ."+Va.bar]={backgroundColor:i.hasMention?i.hasMentionColor:i.isImportantColor,position:"absolute",borderBottomLeftRadius:"inherit",borderTopLeftRadius:"inherit",height:"100%",left:"0",top:"0",width:Is(3)},r),!0===a.attached&&((o={})[a.mine?"borderTopRightRadius":"borderTopLeftRadius"]=0,o[a.mine?"borderBottomRightRadius":"borderBottomLeftRadius"]=0,o.paddingTop=Is(5),o.paddingBottom=Is(7),o),"top"===a.attached&&((t={})[a.mine?"borderBottomRightRadius":"borderBottomLeftRadius"]=0,t),"bottom"===a.attached&&((n={})[a.mine?"borderTopRightRadius":"borderTopLeftRadius"]=0,n.paddingTop=Is(5),n.paddingBottom=Is(7),n))},author:function(e){var r=e.props,o=e.variables;return Object.assign({},(r.mine||"bottom"===r.attached||!0===r.attached)&&Xu,{color:o.authorColor,fontWeight:o.authorFontWeight,marginRight:o.authorMarginRight,marginBottom:o.headerMarginBottom})},badge:function(e){var r,o=e.props;return (r={})["start"===o.badgePosition?"left":"right"]=0,r.transform="start"===o.badgePosition?"translateX(-50%)":"translateX(50%)",r.top=Is(4),r.position="absolute",r},content:function(e){var r=e.props;return Object.assign({},r.hasBadge&&"end"===r.badgePosition&&{marginRight:Is(4)})},reactionGroup:function(e){var r=e.props,o=e.variables;return Object.assign({marginLeft:o.reactionGroupMarginLeft},r.hasBadge&&"end"===r.badgePosition&&{marginRight:Is(2)},{float:"right"})},timestamp:function(e){var r=e.props,o=e.variables;return Object.assign({marginBottom:o.headerMarginBottom},("bottom"===r.attached||!0===r.attached)&&!r.hasHeaderReactionGroup&&Xu)}},compact:{root:function(e){var r,o,t=e.theme.siteVariables,n=e.variables,a=cu({borderRadius:"inherit",variables:t}),i=((r={backgroundColor:n.compactHoverBackground,border:n.compactHoverBorder})["& ."+Va.timestamp]={opacity:1},r);return Object.assign({border:n.compactBorder,padding:n.paddingCompact,width:"100%"},(n.hasMention||n.isImportant)&&((o={})["& ."+Va.bar]={backgroundColor:n.hasMention?n.hasMentionColor:n.isImportantColor,position:"absolute",borderRadius:Is(2),height:Is(20),left:Is(-56),top:n.paddingCompact,width:Is(2)},o),{":focus-visible":Object.assign({},a[":focus-visible"],i),"&:hover":i})},author:function(e){var r=e.props,o=e.variables;return Object.assign({},("bottom"===r.attached||!0===r.attached)&&Xu,{color:r.mine?o.authorColorMineCompact:o.contentColor,float:"left",fontWeight:o.authorFontWeightCompact,marginRight:o.authorMarginRightCompact})},badge:function(e){var r=e.variables;return {alignSelf:"flex-start",flexShrink:0,margin:Is(-2)+" "+Is(-2)+" "+Is(-2)+" "+r.compactSpacing}},compactBody:function(){return {display:"flex",justifyContent:"space-between","& > div":{minWidth:0}}},reactionGroup:function(){return {display:"flex",marginTop:Is(4)}},timestamp:function(e){return {alignSelf:"flex-start",flexShrink:0,marginLeft:e.variables.compactSpacing,marginTop:Is(2),opacity:0}}}},Ku=function(e){return void 0===e&&(e=Oo),$u[e]},qu={root:function(e){var r,o,t,n,a=e.props,i=e.variables,l=e.theme.siteVariables;return Object.assign({borderRadius:i.borderRadius,display:"inline-block",outline:0,position:"relative",wordBreak:"break-word",wordWrap:"break-word"},cu({borderRadius:"inherit",variables:l}),Dr()(i.showActionMenu)&&a.hasActionMenu&&Object.assign({":hover":(r={},r["> ."+Va.actionMenu]=Yu(i.overlayZIndex),r)},a.showActionMenu&&((o={})["> ."+Va.actionMenu]=Yu(i.overlayZIndex),o)),null==(t=(n=Ku(a.density)).root)?void 0:t.call(n,e))},actionMenu:function(e){var r=e.props,o=e.variables,t=r.hasActionMenu&&(r.focused||r.showActionMenu),n=Dr()(o.showActionMenu)?t:o.showActionMenu;return Object.assign({backgroundColor:o.backgroundColor,border:"1px solid",borderColor:o.reactionGroupBorderColor,borderRadius:o.borderRadius,boxShadow:o.actionMenuBoxShadow,"[data-popper-escaped]":{opacity:0},zIndex:-1,overflow:"hidden",opacity:0,width:0},n&&Yu(o.overlayZIndex))},author:function(e){var r,o,t=e.props;return null==(r=(o=Ku(t.density)).author)?void 0:r.call(o,e)},compactBody:function(e){var r,o,t=e.props;return null==(r=(o=Ku(t.density)).compactBody)?void 0:r.call(o,e)},timestamp:function(e){var r,o,t=e.props;return Object.assign({display:"inline-block"},null==(r=(o=Ku(t.density)).timestamp)?void 0:r.call(o,e))},content:function(e){var r,o,t=e.props,n=e.variables;return Object.assign({color:n.contentColor,display:"block","& a":{outline:"none",color:t.mine?n.linkColorMine:n.linkColor,":focus":{textDecoration:"underline"}}},null==(r=(o=Ku(t.density)).content)?void 0:r.call(o,e))},badge:function(e){var r,o,t=e.props,n=e.variables;return Object.assign({backgroundColor:n.hasMention?n.hasMentionNubbinColor:n.isImportantColor,borderRadius:"50%",boxShadow:n.badgeShadow,color:n.badgeTextColor,height:"auto",padding:Is(4),width:"auto",zIndex:n.zIndex,"& > :first-child":{display:"inline-flex"}},null==(r=(o=Ku(t.density)).badge)?void 0:r.call(o,e))},reactionGroup:function(e){var r,o,t=e.props;return null==(r=(o=Ku(t.density)).reactionGroup)?void 0:r.call(o,e)}},Ju={root:function(e){var r=e.props,o=e.variables;return Object.assign({color:o.detailsColor,display:"inline-block",fontSize:o.detailsFontSize},"comfy"===r.density&&Object.assign({},("top"===r.attached||!r.attached||r.hasHeaderReactionGroup)&&{marginLeft:o.detailsMargin}),"compact"===r.density&&{alignSelf:"flex-start",flexShrink:0,marginLeft:o.detailsMargin})}},Qu={root:function(e){var r=e.props,o=e.variables;return {color:o.color,position:"absolute",right:"compact"===r.density?o.rightPositionCompact:o.rightPosition,bottom:"compact"===r.density?o.bottomPositionCompact:o.bottomPosition,":after":Object.assign({content:'"'+r.title+'"'},Xu)}}},ef="ui-checkbox",rf=ef+"__indicator",of=function(e,r){return "url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' style='background-color: "+encodeURIComponent(r)+"; padding: 2px;' focusable='false' viewBox='8 8 22.5 22.5'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M23.5 11.875a.968.968 0 0 1-.289.711l-8.25 8.25c-.192.193-.43.289-.711.289s-.519-.096-.711-.289l-4.75-4.75a.965.965 0 0 1-.289-.711c0-.125.027-.25.082-.375s.129-.234.223-.328a.953.953 0 0 1 .695-.297c.135 0 .266.025.391.074.125.05.231.121.32.215l4.039 4.047 7.539-7.547a.886.886 0 0 1 .32-.215c.125-.049.255-.074.391-.074a1.004 1.004 0 0 1 .922.625.97.97 0 0 1 .078.375z' /%3E%3C/g%3E%3C/svg%3E\")"},tf=function(e,r){return "url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' style='background-color: "+escape(r)+"; padding: 2px;' focusable='false' viewBox='8 8 22.5 22.5'%3E%3Cg%3E%3Cpath fill='"+escape(e)+"' d='M10 16v-1h12v1H10z 11.875a.968.968 0 0 1-.289.711l-8.25 8.25c-.192.193-.43.289-.711.289s-.519-.096-.711-.289l-4.75-4.75a.965.965 0 0 1-.289-.711c0-.125.027-.25.082-.375s.129-.234.223-.328a.953.953 0 0 1 .695-.297c.135 0 .266.025.391.074.125.05.231.121.32.215l4.039 4.047 7.539-7.547a.886.886 0 0 1 .32-.215c.125-.049.255-.074.391-.074a1.004 1.004 0 0 1 .922.625.97.97 0 0 1 .078.375z' /%3E%3C/g%3E%3C/svg%3E\")"},nf=function(e){return {content:"' '",display:"block",borderRadius:"50%",width:e.toggleIndicatorSize,height:e.toggleIndicatorSize,transition:"margin .3s ease"}},af={root:function(e){var r,o=e.props,t=e.variables,n=e.theme;return Object.assign({position:"relative",display:"inline-grid",gridTemplateColumns:"auto "+t.gap+" 1fr",msGridColumns:"auto "+t.gap+" 1fr"},"start"===o.labelPosition&&{gridTemplateColumns:"1fr "+t.gap+" auto",msGridColumns:"1fr "+t.gap+" auto"},{cursor:"pointer",outline:0,color:t.textColor,padding:t.rootPadding,verticalAlign:"middle",alignItems:"start"},cu({variables:n.siteVariables,borderRadius:"3px"}),{":hover":(r={color:t.textColorHover},r["& ."+rf]=Object.assign({},!o.toggle&&Object.assign({},o.checked&&"mixed"!==o.checked&&{borderColor:t.checkedBackgroundHover,backgroundImage:of(t.checkedIndicatorColor,t.checkedBackgroundHover)},!o.checked&&{borderColor:t.borderColorHover}),o.toggle&&!o.disabled&&Object.assign({borderColor:t.borderColorHover,":before":Object.assign({},nf(t),{borderColor:t.borderColorHover,borderStyle:t.borderStyle,borderWidth:t.borderWidth,margin:t.togglePadding,background:"transparent"})},o.checked&&{borderColor:t.checkedBorderColor,background:t.checkedBackgroundHover,":before":Object.assign({},nf(t),{margin:t.toggleCheckedPadding,background:t.checkedIndicatorColor})})),r)},o.checked&&{color:t.checkedTextColor},o.disabled&&{cursor:"default",pointerEvents:"none",color:t.disabledColor})},checkbox:function(e){var r=e.props,o=e.variables;return Object.assign({msGridRowAlign:"center",gridColumn:1,msGridColumn:1},"start"===r.labelPosition&&{gridColumn:3,msGridColumn:3},{boxShadow:"unset",width:Is(16),height:Is(16),borderColor:o.borderColor,borderStyle:o.borderStyle,borderRadius:o.borderRadius,borderWidth:o.borderWidth,color:o.indicatorColor,margin:o.margin,padding:o.padding,userSelect:"none",backgroundImage:of(o.indicatorColor,o.background),backgroundPosition:"center",backgroundRepeat:"no-repeat"},r.checked&&{borderColor:o.checkedBorderColor,backgroundColor:o.checkedBackground,backgroundImage:of(o.checkedIndicatorColor,o.checkedBackground)},"mixed"===r.checked&&{backgroundImage:tf(o.checkedIndicatorColor,o.checkedBackground)},r.disabled&&{backgroundColor:o.disabledBackground,borderColor:o.disabledBorderColor},r.disabled&&r.checked&&{color:o.disabledCheckedIndicatorColor,borderColor:o.disabledBackgroundChecked,backgroundColor:o.disabledBackgroundChecked,backgroundImage:of(o.disabledCheckedIndicatorColor,o.disabledBackgroundChecked)},r.disabled&&"mixed"===r.checked&&{color:o.disabledCheckedIndicatorColor,borderColor:o.disabledBackgroundChecked,backgroundColor:o.disabledBackgroundChecked,backgroundImage:tf(o.disabledCheckedIndicatorColor,o.disabledBackgroundChecked)})},toggle:function(e){var r=e.props,o=e.variables;return Object.assign({msGridRowAlign:"center",gridColumn:1,msGridColumn:1},"start"===r.labelPosition&&{gridColumn:3,msGridColumn:3},{boxShadow:"unset",boxSizing:"border-box",background:o.background,borderColor:o.borderColor,borderStyle:o.borderStyle,borderRadius:o.toggleBorderRadius,borderWidth:o.borderWidth,margin:o.toggleMargin,userSelect:"none",width:o.toggleWidth,height:o.toggleHeight,":before":Object.assign({},nf(o),{borderColor:r.disabled?o.disabledToggleIndicatorColor:o.borderColor,borderStyle:o.borderStyle,borderWidth:o.borderWidth,margin:o.togglePadding})},r.checked&&{borderColor:o.checkedBorderColor,background:o.checkedBackground,":before":Object.assign({},nf(o),{margin:o.toggleCheckedPadding,background:o.checkedIndicatorColor})},r.disabled&&Object.assign({background:o.disabledBackground,borderColor:o.disabledBorderColor},r.checked&&{background:o.disabledBackgroundChecked,borderColor:"transparent",":before":Object.assign({},nf(o),{margin:o.toggleCheckedPadding,background:o.disabledCheckedIndicatorColor})}))},label:function(e){var r=e.props;return Object.assign({display:"block",userSelect:"none",gridColumn:3,msGridColumn:3},"start"===r.labelPosition&&{gridColumn:1,msGridColumn:1})}},lf={root:function(e){var r,o=e.variables;return (r={background:o.rootBackground,border:o.border,borderRadius:o.rootBorderRadius,outline:"none",padding:o.rootPadding,position:"relative",width:o.rootWidth,maxWidth:"100vw",maxHeight:"100vh",overflowX:"hidden",overflowY:"auto",display:"grid",gridTemplateColumns:"1fr auto",msGridColumns:"1fr auto",boxShadow:o.boxShadow,color:o.foregroundColor})["@media screen and (max-width: "+o.rootWidth+")"]={padding:o.rootPaddingZoom},r},footer:function(){return {gridColumn:"1 / -1",gridRow:3,msGridRow:3}},actions:function(e){var r,o,t=e.variables;return (o={display:"flex",width:"100%"})["& ."+Fn]={flexWrap:"wrap",width:"100%"},o["@media screen and (max-width: "+t.footerActionsBreakpoint+")"]=((r={})["& .ui-button"]={width:"100%",maxWidth:"100%",margin:0},r["& ."+Fn+" > :not(:last-child)"]={marginBottom:"0.5rem"},r),o},content:function(e){var r,o=e.variables;return (r={margin:o.contentMargin,gridColumn:"1 / span 2",gridRow:2,msGridColumn:1,msGridColumnSpan:2,msGridRow:2,justifySelf:"left",width:"100%"})["@media screen and (max-width: "+o.rootWidth+"), screen and (max-height: 400px)"]={maxHeight:"100%",overflow:"unset"},r},header:function(e){var r=e.variables;return {margin:r.headerMargin,gridRow:1,msGridRow:1,gridColumn:1,msGridColumn:1,justifySelf:"left",fontSize:r.headerFontSize,fontWeight:r.headerFontWeight}},headerAction:function(e){var r=e.variables;return {gridRow:1,msGridRow:1,gridColumn:2,msGridColumn:2,color:r.foregroundColor,margin:r.headerActionMargin}},overlay:function(e){var r=e.props,o=e.variables;return Object.assign({alignItems:"center",background:"transparent",bottom:0,display:"flex",flexDirection:"column",justifyContent:"center",left:0,overflow:"auto",position:"fixed",right:0,top:0,zIndex:o.overlayZIndex},r.backdrop&&{background:o.overlayBackground})}},sf={root:function(){return {textAlign:"right"}}},cf=function(e,r,o,t){return Object.assign({content:'""',flex:1},t.vertical?{width:e+1+"px",height:"100%"}:{height:e+1+"px"},{background:En()(o,"foreground",r.dividerColor)})},df={root:function(e){var r=e.props,o=e.variables,t=r.color,n=r.fitted,a=r.size,i=r.important,l=r.hasContent,s=r.vertical,c=o.colorScheme[t];return Object.assign({color:En()(c,"foreground",o.textColor),display:"flex",alignItems:"center"},!n&&{padding:s?"0 "+o.dividerPadding:o.dividerPadding+" 0"},i&&{fontWeight:o.importantFontWeight},s&&{height:"100%"},l?{textAlign:"center",fontSize:Is(12+a),lineHeight:o.textLineHeight,"::before":Object.assign({},cf(a,o,c,r)),"::after":Object.assign({},cf(a,o,c,r))}:{"::before":Object.assign({},cf(a,o,c,r))})}},uf={root:function(){return {marginLeft:Is(20),marginRight:Is(20)}}},ff=(n(2654),n(5413),n(3629),n(690),"ui-dropdown"),gf=ff+"__trigger-button",pf={backgroundColor:"transparent",borderColor:"transparent",borderBottomColor:"transparent"},bf=Object.assign({},pf,{":hover":pf,":active":pf,":focus":Object.assign({},pf,{":active":pf})}),mf=function(e,r){return e.fluid?"100%":e.inline?"initial":r.width},hf={root:function(e){var r=e.props;return Object.assign({},r.inline&&{display:"inline-flex"})},clearIndicator:function(e){var r=e.variables,o=e.theme.siteVariables;return Object.assign({alignItems:"center",alignSelf:"center",display:"flex",justifyContent:"center",cursor:"pointer",userSelect:"none",margin:0,position:"absolute",right:Is(6),padding:Is(2),color:r.color},cu({variables:o}))},container:function(e){var r,o=e.props,t=e.variables,n=e.theme.siteVariables;return Object.assign({display:"flex",flexWrap:"wrap",position:"relative",borderStyle:"solid",borderColor:t.borderColor,outline:0,width:mf(o,t),borderWidth:o.search?"0 0 "+t.searchBorderBottomWidth+" 0":t.borderWidth,color:t.color,backgroundColor:t.backgroundColor,borderRadius:t.containerBorderRadius},o.open&&"above"===o.position&&{borderRadius:t.openAboveContainerBorderRadius},o.open&&"below"===o.position&&{borderRadius:t.openBelowContainerBorderRadius},{":hover":Object.assign({backgroundColor:t.backgroundColorHover,borderColor:t.borderColorHover},o.open&&{borderColor:t.openBorderColorHover})},o.error&&{border:Is(1)+" solid "+t.borderError,":hover":{border:Is(1)+" solid "+t.borderError}},{":active":{backgroundColor:t.backgroundColor},":focus-within":{borderBottomColor:t.borderColorFocus}},o.focused&&Object.assign({backgroundColor:t.backgroundColor},o.search&&{borderBottomColor:t.borderColorFocus},!o.search&&!o.open&&o.isFromKeyboard&&cu({variables:n})[":focus-visible"]),o.inline&&Object.assign({},bf,{alignItems:"center"}),o.inverted&&{backgroundColor:t.invertedBackgroundColor,":hover":{backgroundColor:t.invertedBackgroundColorHover},":active":{backgroundColor:t.invertedBackgroundColorHover},":focus":{backgroundColor:t.invertedBackgroundColorHover}},o.disabled&&{backgroundColor:n.colorScheme.default.backgroundDisabled,borderColor:n.colorScheme.default.borderDisabled,userSelect:"none",":hover":{backgroundColor:n.colorScheme.default.backgroundDisabled},":active":{backgroundColor:n.colorScheme.default.backgroundDisabled}},((r={})["& ."+gf]=Object.assign({},o.disabled&&{color:n.colorScheme.default.foregroundDisabled}),r))},selectedItems:function(e){var r=e.props,o=e.variables;return Object.assign({display:"flex",flexWrap:"wrap",overflowY:"auto",overflowX:"hidden",maxHeight:o.selectedItemsMaxHeight,width:"100%"},r.hasToggleIndicator&&{paddingRight:o.toggleIndicatorSize},r.multiple&&r.hasItemsSelected&&{paddingTop:Is(1),paddingBottom:Is(4)})},triggerButton:function(e){var r=e.props,o=e.variables;return Object.assign({overflow:"hidden",boxShadow:"none",minHeight:Is(32)},bf,{margin:"0",justifyContent:"left",padding:o.comboboxPaddingButton},r.multiple&&Object.assign({minWidth:0,flex:1},r.hasItemsSelected&&{position:"absolute",top:0,right:0,left:0,bottom:0,height:"100%"}),bf,{":focus":Object.assign({color:o.color},bf),":focus-visible":Object.assign({color:o.color},pf,{":after":{borderColor:"transparent",borderRightWidth:0},":before":{borderColor:"transparent",borderRightWidth:0}}),":active":Object.assign({color:o.color},pf,{animationName:"unset",animationDuration:"unset"}),":hover":Object.assign({},pf,{color:o.color})},r.inline&&{paddingLeft:0,paddingRight:0,width:"initial"})},list:function(e){var r=e.props,o=e.variables;return Object.assign({outline:0,borderStyle:"solid",borderWidth:r.open?o.listBorderWidth:"0px",borderColor:o.listBorderColor,zIndex:o.overlayZIndex,maxHeight:o.listMaxHeight,overflowY:"auto",width:mf(r,o),background:o.listBackgroundColor},"above"===r.position&&{borderRadius:o.aboveListBorderRadius},"below"===r.position&&{borderRadius:o.belowListBorderRadius},r.open&&{boxShadow:o.listBoxShadow,padding:o.listPadding})},loadingMessage:function(e){return {backgroundColor:e.variables.loadingMessageBackgroundColor}},noResultsMessage:function(e){return {backgroundColor:e.variables.noResultsMessageBackgroundColor}},headerMessage:function(e){return {backgroundColor:e.variables.headerMessageBackgroundColor}},toggleIndicator:function(e){var r=e.props,o=e.variables;return Object.assign({alignItems:"center",display:"flex",justifyContent:"center",alignSelf:"center",cursor:"pointer"},r.disabled&&{cursor:"default"},{userSelect:"none",margin:0,position:"absolute",right:Is(8)},r.multiple&&r.hasItemsSelected&&{top:Is(8)},{color:o.color},r.disabled&&{color:o.disabledColor})}},vf={root:function(e){return {flexBasis:e.variables.comboboxFlexBasis,flexGrow:1}},input:function(e){var r=e.props;return Object.assign({width:"100%",backgroundColor:"transparent",borderWidth:0},r.inline&&{padding:0,lineHeight:"initial"})}},yf="ui-dropdown__selecteditem",Cf=yf+"__icon",kf={root:function(e){var r,o=e.props,t=e.variables,n=e.theme.siteVariables,a=cu({variables:n});return Object.assign({maxWidth:t.selectedItemsMaxWidth,display:"inline-flex",alignItems:"center",padding:"0 "+Is(8),startPaddingLeft:"0px",lineHeight:Is(20),borderRadius:Is(9999),fontSize:Is(14)},o.hasImage&&{paddingLeft:"0px"},{cursor:"pointer",margin:".25rem 0 0 .4rem",color:t.selectedItemColor,position:"relative",border:t.selectedItemBorder,height:Is(24),overflow:"visible",outline:0,fontWeight:n.fontWeightSemibold},t.selectedItemBackgroundColor&&{backgroundColor:t.selectedItemBackgroundColor},{":focus":{color:t.selectedItemColorFocus},":hover":(r={color:t.selectedItemColorHover,backgroundColor:t.selectedItemBackgroundColorHover},r["& ."+Cf]={color:t.selectedItemIconColorHover},r),":focus-visible":{":after":a[":focus-visible"][":after"]}})},image:function(){return {height:Is(20),width:Is(20)}},header:function(e){var r=e.props;return e.variables,Object.assign({},r.hasImage&&{marginLeft:Is(3)},{marginRight:Is(3),overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"})},icon:function(e){var r=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:Is(16),minWidth:Is(16),height:Is(16),"& > :first-child":{width:Is(16),height:Is(16),"& svg":{width:Is(16),height:Is(16)}},cursor:"pointer",color:r.selectedItemIconColor},du({outline:!0}),{":hover":Object.assign({color:r.selectedItemIconColorHover},du({outline:!1}))})}},wf="ui-dropdown__item",xf=wf+"__content",Sf=wf+"__header",Bf=function(e){return "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' fill='"+encodeURIComponent(e)+"' focusable='false' view-box='8 8 16 16'%3E%3Cg%3E%3Cpath d='M23.5 11.875a.968.968 0 0 1-.289.711l-8.25 8.25c-.192.193-.43.289-.711.289s-.519-.096-.711-.289l-4.75-4.75a.965.965 0 0 1-.289-.711c0-.125.027-.25.082-.375s.129-.234.223-.328a.953.953 0 0 1 .695-.297c.135 0 .266.025.391.074.125.05.231.121.32.215l4.039 4.047 7.539-7.547a.886.886 0 0 1 .32-.215c.125-.049.255-.074.391-.074a1.004 1.004 0 0 1 .922.625.97.97 0 0 1 .078.375z' /%3E%3C/g%3E%3C/svg%3E\")"},Ef={root:function(e){var r,o,t=e.props,n=e.variables,a=e.theme.siteVariables;return Object.assign({display:"flex",alignItems:"center",minHeight:0,padding:Is(4)+" "+Is(11),whiteSpace:"nowrap",border:n.listItemFocusBorderWidth+" solid transparent",backgroundColor:n.listItemBackgroundColor},t.selected&&{fontWeight:n.listItemSelectedFontWeight,color:n.listItemSelectedColor},{position:"relative"},t.active&&Object.assign({},t.isFromKeyboard&&cu({variables:a,borderRadius:0})[":focus-visible"],!t.isFromKeyboard&&Object.assign({color:n.listItemColorHover,backgroundColor:n.listItemBackgroundColorHover},t.hasHeader&&((r={})["& ."+Sf]={color:n.listItemColorHover},r),t.hasContent&&((o={})["& ."+xf]={color:n.listItemColorHover},o))))},image:function(){return {margin:Is(3)+" "+Is(12)+" "+Is(3)+" "+Is(4)}},header:function(e){var r=e.props,o=e.variables;return Object.assign({flexGrow:1,lineHeight:o.listItemHeaderLineHeight,fontSize:o.listItemHeaderFontSize,color:o.listItemContentColor},r.hasContent&&{marginBottom:Is(-1),color:o.listItemHeaderColor},r.selected&&{fontWeight:o.listItemSelectedFontWeight,color:o.listItemSelectedColor},{whiteSpace:"normal"})},content:function(e){var r=e.variables;return {flexGrow:1,lineHeight:r.listItemContentLineHeight,fontSize:r.listItemContentFontSize,color:r.listItemContentColor}},checkableIndicator:function(e){var r=e.props,o=e.variables;return Object.assign({backgroundImage:Bf(o.listItemSelectedColor)},r.active&&!r.isFromKeyboard&&{backgroundImage:Bf(o.listItemColorHover)},{backgroundPosition:"center",backgroundRepeat:"no-repeat",position:"absolute",width:Is(24),height:Is(24),right:Is(7),top:Is(-3)})},endMedia:function(){return {flexShrink:0,lineHeight:Is(16)}},main:function(){return {display:"flex",flexDirection:"column",flexGrow:1,minWidth:0}}},Of="ui-embed__control",Ff=function(e){return "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='0 0 24 24'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M5.74609 3C4.7796 3 3.99609 3.7835 3.99609 4.75V19.25C3.99609 20.2165 4.7796 21 5.74609 21H9.24609C10.2126 21 10.9961 20.2165 10.9961 19.25V4.75C10.9961 3.7835 10.2126 3 9.24609 3H5.74609Z' /%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M14.7461 3C13.7796 3 12.9961 3.7835 12.9961 4.75V19.25C12.9961 20.2165 13.7796 21 14.7461 21H18.2461C19.2126 21 19.9961 20.2165 19.9961 19.25V4.75C19.9961 3.7835 19.2126 3 18.2461 3H14.7461Z' /%3E%3C/g%3E%3C/svg%3E\")"},Af={root:function(e){var r,o,t=e.variables,n=e.theme.siteVariables,a=cu({variables:n});return Object.assign({display:"inline-block",verticalAlign:"middle",position:"relative",cursor:"pointer",width:t.width,height:t.height||"auto",outline:0},a[":focus"],{":focus-visible":(r={},r["& ."+Of]=Object.assign({borderColor:t.focusBorderColor,opacity:1},a[":focus-visible"]),r),":hover":(o={},o["& ."+Of]={opacity:1,zIndex:t.zIndex},o)})},control:function(e){var r,o=e.props,t=e.variables;return Object.assign({width:Is(48),height:Is(48),color:t.controlColor,padding:Is(4),borderRadius:"50%",backgroundColor:t.controlBackgroundColor,backgroundImage:(r=t.controlColor,"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='0 0 24 24'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(r)+"' d='M5 5.27368C5 3.56682 6.82609 2.48151 8.32538 3.2973L20.687 10.0235C22.2531 10.8756 22.2531 13.124 20.687 13.9762L8.32538 20.7024C6.82609 21.5181 5 20.4328 5 18.726V5.27368Z' /%3E%3C/g%3E%3C/svg%3E\")"),backgroundRepeat:"no-repeat",backgroundPosition:"center",backgroundSize:t.controlBackgroundSize,backgroundPositionX:Is(12)},o.active&&{backgroundImage:Ff(t.controlColor)},{opacity:o.active?0:1,pointerEvents:"none",transition:"opacity .22s ease-in-out",left:"50%",position:"absolute",top:"50%",transform:"translate(-50%, -50%)"})},iframe:function(e){var r=e.props;return Object.assign({display:"block"},!r.iframeLoaded&&{display:"none"})}},Pf={root:function(e){e.props;var r=e.variables;return {height:"100%",width:"100%",display:"flex",flexDirection:"column",justifyContent:"space-evenly",justifyItems:"start","> *:not(:last-child)":{marginBottom:r.fieldsMarginBottom},"> :last-child":{marginTop:r.lastChildMarginTop}}}},jf={root:function(e){return e.props,e.variables,{}},label:function(e){var r=e.props,o=r.type,t=r.inline,n=r.required;return Object.assign({},(!o||"radio"!==o&&"checkbox"!==o)&&{display:"block",marginBottom:Is(4)},t&&{marginRight:Is(10),display:"inline"},n&&{"::after":{content:'"*"'}})},control:function(e){var r=e.props,o=(e.variables,r.type);return Object.assign({},o&&("radio"===o||"checkbox"===o)&&{marginRight:Is(10)})},message:function(e){var r=e.props,o=e.variables;return Object.assign({},r.hasErrorMessage&&{color:o.colorScheme.red.foreground},{display:"block",paddingLeft:o.messagePaddingLeft})},icon:function(e){var r=e.props,o=e.variables;return Object.assign({},r.hasErrorMessage&&{color:o.colorScheme.red.foreground})}},Rf={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",lineHeight:o.lineHeight,marginBottom:o.marginBottom},r.inline&&{marginRight:Is(10),display:"inline"},r.required&&{"::after":{content:'"*"'}})}},If={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",paddingLeft:o.paddingLeft},r.error&&{color:o.colorScheme.red.foreground})}},Mf=function(e){var r=e.trim();return "start"===r||"end"===r?"flex-"+r:r},Df={root:function(e){var r,o=e.props,t=e.variables;return Object.assign({display:"flex"},o.debug&&{border:"1px dotted grey",background:"lightgrey"},o.inline&&{display:"inline-flex"},o.column&&{flexDirection:"column"},o.hAlign&&(o.column?{alignItems:Mf(o.hAlign)}:{justifyContent:Mf(o.hAlign)}),o.vAlign&&(o.column?{justifyContent:Mf(o.vAlign)}:{alignItems:Mf(o.vAlign)}),o.space&&{justifyContent:"space-"+o.space},o.wrap&&{flexWrap:"wrap"},o.fill&&{width:"100%",height:"100%"},o.padding&&{padding:t[o.padding]},o.gap&&{"> *:not(:last-child)":(r={},r[o.column?"marginBottom":"marginRight"]=t[o.gap],r)})}},zf={root:function(e){var r=e.props,o=e.variables;return Object.assign({},r.align&&{alignSelf:Mf(r.align)},r.size&&{flexBasis:o.hasOwnProperty(r.size)?o[r.size]:r.size},"number"==typeof r.shrink&&{flexShrink:r.shrink},!1===r.shrink&&{flexShrink:0},r.grow&&{flexGrow:r.grow},!0===r.grow&&{flexGrow:1},r.push&&("column"===r.flexDirection?{marginTop:"auto"}:{marginLeft:"auto"}))}},_f=function(e){var r=Number(e);return !isNaN(r)&&r>0?"repeat("+e+", 1fr)":String(e)},Hf={root:function(e){var r=e.props,o=e.variables,t=o.height,n=o.width,a=o.defaultColumnCount,i=o.gridGap,l=o.padding,s=r.rows,c=r.columns,d=void 0===c?!r.rows&&a:c;return Object.assign({height:t,width:n,padding:l,gridGap:i,display:"grid",justifyContent:"space-evenly"},s&&!d&&{gridAutoFlow:"column"},s&&{gridTemplateRows:_f(s),msGridRows:_f(s)},d&&{gridTemplateColumns:_f(d),msGridColumns:_f(d)},{"& > *":{outlineOffset:"-3px"}})}},Tf=function(e){switch(e){case"start":return "left";case"end":return "right";default:return e}},Wf={root:function(e){var r=e.props,o=e.variables,t=o.colorScheme[r.color];return Object.assign({display:"block",color:En()(t,"foreground",o.color),textAlign:Tf(r.align)},r.hasDescription&&{marginBottom:0})}},Lf={root:function(e){var r=e.props,o=e.variables,t=o.colorScheme[r.color];return {display:"block",color:En()(t,"foreground",o.color),fontSize:Is(22),fontWeight:400}}},Nf=function(){return {padding:Is(4)}},Uf={root:function(e){var r,o=e.props,t=e.variables;return Object.assign({speak:"none",verticalAlign:"middle"},function(e,r){switch(e){case"none":return {marginLeft:0,marginRight:0};case"before":return {marginLeft:r,marginRight:0};case"after":return {marginLeft:0,marginRight:r};case"both":return {marginLeft:r,marginRight:r}}}(o.xSpacing,t.horizontalSpace),o.circular&&Object.assign({},Nf(),{borderRadius:"50%"}),o.disabled&&{color:t.disabledColor},{display:"inline-block"},(o.bordered||t.borderColor)&&(r=t.borderColor||t.color||"currentColor",Object.assign({},Nf(),{boxShadow:"0 0 0 .05rem "+r+" inset"})),{backgroundColor:t.backgroundColor})},outlinePart:function(e){var r=e.props;return Object.assign({display:"none"},r.outline&&{display:"block"})},filledPart:function(e){var r=e.props;return Object.assign({},r.outline&&{display:"none"})},svg:function(e){var r=e.props,o=r.size,t=r.disabled,n=r.rotate,a=e.variables,i=e.rtl,l=function(e,r){var o={large:{x:24,xx:28}};return r.sizeModifier&&o[e]&&o[e][r.sizeModifier]?Is(o[e][r.sizeModifier]):r[e+"Size"]}(o,a);return Object.assign({display:"block",width:l,height:l,fill:a.color||"currentColor"},t&&{fill:a.disabledColor},{transform:"rotate("+n+"deg) /* @noflip */"},i&&{transform:"rotate("+-1*n+"deg) /* @noflip */"})},svgFlippingInRtl:function(e){var r=e.props,o=e.rtl;return Object.assign({},z(Uf.svg)(e),o&&{transform:"scaleX(-1) rotate("+r.rotate+"deg) /* @noflip */"})},redPath:function(e){return {fill:e.variables.redColor}}},Zf={root:function(e){var r=e.props,o=e.variables;return Object.assign({boxSizing:"border-box",display:"inline-block",verticalAlign:"middle",width:r.fluid?"100%":o.width,height:o.height||"auto"},r.circular&&{borderRadius:o.circularRadius},r.avatar&&{width:r.fluid?"100%":o.avatarSize,borderRadius:o.avatarRadius})}},Vf={root:function(e){var r=e.props;return e.variables,Object.assign({flexDirection:"column",justifyContent:"center",display:"inline-flex",position:"relative",outline:0,verticalAlign:"middle"},r.fluid&&{width:"100%"},"inline"===r.labelPosition&&{flexDirection:"row",alignItems:"center"})},input:function(e){var r=e.props,o=e.variables;return Object.assign({backgroundColor:o.backgroundColor},r.inverted&&{backgroundColor:o.backgroundColorInverted},{lineHeight:"unset",color:o.fontColor,borderColor:o.borderColor,borderRadius:o.borderRadius,borderStyle:"solid",borderWidth:o.borderWidth,outline:"none",padding:o.inputPadding,position:"relative"},r.fluid&&{width:"100%"},r.inline&&{float:"left"},r.disabled&&{color:o.colorDisabled,boxShadow:"none"},{"::placeholder":Object.assign({color:o.placeholderColor,opacity:1},r.disabled&&{color:o.colorDisabled}),":focus":Object.assign({},!r.error&&{borderColor:o.inputFocusBorderColor,borderRadius:o.inputFocusBorderRadius})},!r.hasValue&&{":-webkit-autofill:focus":{"-webkit-text-fill-color":"transparent"}},r.clearable&&{padding:o.inputPaddingWithIconAtEnd},r.hasIcon&&{padding:"start"===r.iconPosition?o.inputPaddingWithIconAtStart:o.inputPaddingWithIconAtEnd},"inside"===r.labelPosition&&{paddingTop:o.inputInsideLabelPaddingTop},r.error&&{border:Is(1)+" solid "+o.borderColorError},{"::-ms-clear":{display:"none"}})},icon:function(e){var r=e.props,o=e.variables;return Object.assign({color:o.iconColor,outline:0,display:"flex",alignItems:"center",justifyContent:"center",position:o.iconPosition,top:0,bottom:0},r.error&&{color:o.colorError},r.requiredAndSuccessful&&{color:o.successfulColor},r.disabled&&{color:o.colorDisabled},"start"===r.iconPosition&&{left:o.iconLeft},"end"===r.iconPosition&&{right:o.iconRight},r.clearable&&r.hasValue&&Object.assign({height:"100%",width:Is(16),color:o.iconColor},r.disabled&&{color:o.colorDisabled}))},inputContainer:function(){return {position:"relative"}}},Gf={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",transition:"all .2s",lineHeight:o.lineHeight,marginBottom:o.marginBottom},"inside"===r.labelPosition&&Object.assign({bottom:o.insideLabelBottom,top:0,left:0,margin:0,position:"absolute",display:"flex",alignItems:"center",zIndex:100,paddingLeft:o.insideLabelPaddingLeft},r.hasValue&&{transform:"translateY(-16px)",fontSize:o.insideLabelActiveFontSize}),"inline"===r.labelPosition&&{paddingRight:o.inlineLabelPaddingRight},r.required&&{"::after":{content:'"*"'}})}},Xf={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables;return Object.assign({display:"inline-flex",alignItems:"center",overflow:"hidden",height:o.height,lineHeight:o.height,color:o.foreground,backgroundColor:o.background,fontSize:Is(14),borderRadius:t.borderRadiusMedium,padding:o.padding},r.hasImage&&("start"===r.imagePosition?{paddingLeft:o.startPaddingLeft}:{paddingRight:o.endPaddingRight}),r.circular&&{borderRadius:o.circularRadius},"black"===r.color&&{color:o.blackForeground,backgroundColor:o.blackBackground},"white"===r.color&&{color:o.whiteForeground,backgroundColor:o.whiteBackground},"brand"===r.color&&{color:o.brandForeground,backgroundColor:o.brandBackground},"grey"===r.color&&{color:o.greyForeground,backgroundColor:o.greyBackground},"orange"===r.color&&{color:o.orangeForeground,backgroundColor:o.orangeBackground},"red"===r.color&&{color:o.redForeground,backgroundColor:o.redBackground},"green"===r.color&&{color:o.greenForeground,backgroundColor:o.greenBackground},"yellow"===r.color&&{color:o.yellowForeground,backgroundColor:o.yellowBackground})},content:function(e){var r=e.props,o=(e.variables,r.hasImage&&"start"===r.imagePosition||r.hasIcon&&"start"===r.iconPosition),t=r.hasImage&&"end"===r.imagePosition||r.hasIcon&&"end"===r.iconPosition;return Object.assign({},o&&{marginLeft:Is(3)},!o&&r.circular&&{marginLeft:Is(4)},t&&{marginRight:Is(3)},!t&&r.circular&&{marginRight:Is(4)})},image:function(e){var r=e.variables;return {height:r.height,width:r.height}},icon:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.iconSize,height:o.iconSize,"& > :first-child":{height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}}},r.hasActionableIcon&&{cursor:"pointer"})}},Yf=function(e){var r=e.name,o=e.color;return {position:"relative",border:"2px "+e.style+" "+o,"::before":{content:"'"+r+"'",position:"absolute",padding:"1px 4px 1px",top:"-2px",left:"-2px",fontSize:"8px",fontWeight:900,lineHeight:1,letterSpacing:"1px",color:"#fff",background:o}}},$f=function(){return Object.assign({},Yf({name:"LAYOUT",color:"cornflowerblue",style:"solid"}),{padding:"8px",margin:"2px"})},Kf=function(){return Object.assign({},Yf({name:"AREA",color:"lightsalmon",style:"dashed"}),{padding:"8px",margin:"2px"})},qf=function(e){return e.filter(Boolean).length},Jf={root:function(e){var r,o=e.props,t=o.alignItems,n=o.debug,a=o.gap,i=o.justifyItems,l=o.hasMain,s=o.mainSize,c=o.hasEnd,d=o.endSize,u=o.hasStart,f=o.startSize,g=o.vertical;return Object.assign({},n&&$f(),((r={justifyItems:i,alignItems:t,display:"grid"})[g?"gridTemplateRows":"gridTemplateColumns"]=[u&&f,a&&u&&l&&a,l&&s,a&&(u||l)&&c&&a,c&&d].filter(Boolean).join(" "),r),g&&{gridAutoFlow:"row",msGridColumns:"1fr"})},gap:function(e){var r=e.props;return Object.assign({},r.debug&&function(e){var r=e.vertical;return {display:"grid",background:"#ccc","::before":Object.assign({content:'"GAP"'},r?{letterSpacing:"1px"}:{textOrientation:"upright",writingMode:"vertical-rl"},{alignSelf:"center",justifySelf:"center",fontSize:"8px",fontWeight:900,lineHeight:0,color:"#fff"})}}({vertical:r.vertical}))},start:function(e){var r,o=e.props;return Object.assign({},o.debug&&Kf(),((r={alignItems:"center",display:"inline-flex"})[o.vertical?"msGridRow":"msGridColumn"]="1",r))},main:function(e){var r,o=e.props;return Object.assign({},o.debug&&Kf(),((r={alignItems:"center",display:"grid"})[o.vertical?"msGridRow":"msGridColumn"]=qf([o.hasStart,o.hasStart&&o.gap,o.hasMain]),r))},end:function(e){var r,o=e.props;return Object.assign({},o.debug&&Kf(),((r={alignItems:"center",display:"inline-flex"})[o.vertical?"msGridRow":"msGridColumn"]=qf([o.hasStart,o.hasStart&&o.gap,o.hasMain&&o.gap]),r))}},Qf={above:"column-reverse",below:"column",start:"row-reverse",end:"row"},eg={root:function(e){var r=e.props;return {alignItems:"center",display:r.inline?"inline-flex":"flex",justifyContent:"center",flexDirection:Qf[r.labelPosition]}},indicator:function(e){var r=e.props,o=e.variables;return {height:o.containerHeights[r.size],width:o.containerWidths[r.size],overflow:"hidden"}},svg:function(e){var r=e.props,o=(e.theme,e.variables),t={animationName:{to:{transform:"translate3d(0, "+o.svgTranslatePosition[r.size]+", 0)"}},animationDelay:"0s",animationDirection:"normal",animationDuration:"2s",animationFillMode:"both",animationPlayState:"running",animationTimingFunction:"steps(60, end)",animationIterationCount:"infinite"};return Object.assign({},{animationName:{to:{opacity:1}},animationDelay:"1.5s",animationDirection:"normal",animationDuration:".3s",animationFillMode:"both",animationIterationCount:"1",animationPlayState:"running",animationTimingFunction:"ease-out",display:"block",overflow:"hidden",position:"relative"},{":before":Object.assign({},t,{backgroundImage:r.secondary?o.secondarySvgContent:o.svgContent,content:'" "',display:"block",overflow:"hidden",height:o.svgHeights[r.size],width:o.svgWidths[r.size]})})},label:function(){return {margin:Is(10)}}},rg={root:function(e){var r=e.variables;return {gridTemplateRows:"minmax("+r.height+", max-content)",paddingLeft:r.paddingLeft,paddingRight:r.paddingRight}}},og={root:function(e){var r=e.props;return Object.assign({},r.debug&&$f(),{display:r.horizontal?"inline-flex":"block"},r.isListTag&&{listStyle:"none",padding:0,margin:0})}},tg="ui-list__itemendmedia",ng={root:function(e){var r,o,t=e.props,n=e.variables,a=e.theme.siteVariables,i=cu({variables:a});return Object.assign({display:"flex",alignItems:"center",minHeight:n.minHeight,padding:n.rootPadding},(t.selectable||t.navigable)&&Object.assign(((r={position:"relative",userSelect:"none"})["& ."+tg]={display:"none"},r["&:hover"]=function(e,r){var o;return (o={background:r.selectableFocusHoverBackgroundColor,color:r.selectableFocusHoverColor,cursor:"pointer"})["& .ui-list__itemheader"]={color:"inherit"},o["& .ui-list__itemcontent"]={color:"inherit"},o["& .ui-list__itemheadermedia"]=Object.assign({},Xu,{color:"inherit"}),o["& .ui-list__itemcontentmedia"]={display:"none",color:"inherit"},o["& ."+tg]={display:"block",color:"inherit"},o}(0,n),r[":focus"]=i[":focus"],r[":focus-visible"]=Object.assign({},i[":focus-visible"],{zIndex:n.zIndex}),r),t.selected&&{background:(o=n).selectedBackgroundColor,color:o.selectedColor}),t.important&&{fontWeight:n.importantFontWeight})},headerWrapper:function(){return {display:"flex"}},contentWrapper:function(){return {display:"flex"}},main:function(){return {display:"flex",flexDirection:"column",flexGrow:1,minWidth:0}}},ag={root:function(e){var r=e.props,o=e.variables;return Object.assign({flexGrow:1,fontSize:o.contentFontSize,lineHeight:o.contentLineHeight},r.truncate&&{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},(!r.hasHeader||r.hasContentMedia)&&{marginRight:o.gap})}},ig={root:function(e){var r=e.variables;return {fontSize:r.contentMediaFontSize,lineHeight:r.contentMediaLineHeight}}},lg={root:function(e){var r=e.props;return Object.assign({flexShrink:0},(r.selectable||r.navigable)&&{display:"none"})}},sg={root:function(e){var r=e.props,o=e.variables;return Object.assign({flexGrow:1,fontSize:o.headerFontSize,lineHeight:o.headerLineHeight},r.truncate&&{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},(!r.hasContent||r.hasHeaderMedia)&&{marginRight:o.gap})}},cg={root:function(e){var r=e.variables;return {alignSelf:"flex-end",fontSize:r.headerMediaFontSize,lineHeight:r.headerMediaLineHeight}}},dg={root:function(e){var r=e.props,o=e.variables;return Object.assign({},r.important&&{"::before":{content:'""',position:"absolute",left:Is(8),width:Is(2),height:Is(2),background:"#000"}},(r.hasHeader||r.hasContent)&&{marginRight:o.gap})}},ug={root:function(e){var r=e.props,o=e.variables,t=e.theme,n=r.iconOnly,a=r.fluid,i=r.pointing,l=r.pills,s=r.primary,c=r.underlined,d=r.vertical,u=r.submenu,f=Zs(o.colorScheme,null,s),g=t.siteVariables;return Object.assign({display:"flex",minHeight:Is(24),margin:0,padding:0,color:o.color,backgroundColor:o.backgroundColor||"inherit",listStyleType:"none"},n&&{alignItems:"center"},d&&Object.assign({flexDirection:"column",backgroundColor:o.verticalBackgroundColor,padding:Is(8)+" 0"},u&&{boxShadow:o.verticalBoxShadow},!a&&!u&&{width:"fit-content"},n&&{display:"inline-block",width:"auto"}),!l&&!n&&!(i&&d)&&!c&&{border:o.borderWidth+" solid "+(s?o.primaryBorderColor:o.borderColor||f.border),borderRadius:g.borderRadiusMedium},c&&{borderBottom:o.underlinedBottomBorderWidth+" solid "+o.underlinedBorderColor})}},fg=Is(5),gg=Is(8),pg=Is(12),bg=function(e){return {paddingBottom:0,borderBottom:"solid "+Is(4)+" "+e,transition:"color .1s ease"}},mg={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=r.active,a=r.iconOnly,i=r.isFromKeyboard,l=r.pointing,s=r.primary,c=r.underlined,d=r.vertical,u=r.disabled,f=Zs(o.colorScheme,null,s);return Object.assign({color:"inherit",display:"block",cursor:"pointer",whiteSpace:"nowrap",overflow:"hidden"},l&&d&&{border:"1px solid transparent"},a&&{border:Is(2)+" solid transparent"},{padding:o.horizontalPadding},d&&{padding:o.verticalItemPadding},l&&d&&{padding:Is(8)+" "+Is(18)},c&&{padding:Is(4)+" 0"},a&&{margin:Is(1),padding:Is(5),display:"flex",alignItems:"center",justifyContent:"center",overflow:"visible"},n&&Object.assign({},a&&Object.assign({color:o.iconOnlyColorActive},du({outline:!1})),c&&Object.assign({color:o.activeUnderlinedColor},bg(o.activeUnderlinedBorderBottomColor),s&&Object.assign({color:o.activeUnderlinedPrimaryColor},bg(o.borderColorActive||f.borderActive)),!s&&{fontWeight:700})),i&&Object.assign({color:"inherit"},a&&Object.assign({},cu({variables:t}),du({outline:!1})),s?Object.assign({},a&&{borderColor:o.borderColorActive||f.borderActive}):Object.assign({},c&&{fontWeight:700},c&&n&&bg(o.colorActive)),(c||d)&&Object.assign({},cu({variables:t}),{":focus-visible":Object.assign({},cu({variables:t})[":focus-visible"],{borderColor:o.borderColorActive})})),{":focus":{outline:0},":hover":Object.assign({color:o.colorHover},c&&{color:o.underlinedColorHover},!u&&Object.assign({},a&&du({outline:!1}),s?Object.assign({},a&&{color:"inherit"},!n&&c&&bg(o.underlinedBorderColor||f.backgroundActive)):!n&&c&&bg(o.backgroundColorActive||f.backgroundActive)))},u&&{cursor:"default"})},menu:function(e){return {zIndex:e.variables.menuZIndex}}},hg={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.iconSize,height:o.iconSize,"& > :first-child":{height:"100%",width:"100%"}},r.hasContent&&{marginRight:Is(10)},!r.iconOnly&&{marginTop:0,marginBottom:Is(-8),verticalAlign:"top"})}},vg={root:function(e){var r=e.props,o=(r.hasIcon?26:0)+(r.hasMenu?16:0);return Object.assign({whiteSpace:"normal",lineHeight:1.5,marginTop:Is(-4),marginBottom:Is(-4),display:"inline-block",userSelect:"none"},(r.inSubmenu||r.vertical)&&{width:"max-content",minWidth:Is(46-o),maxWidth:Is(262-o),marginRight:Is(16)})}},yg=function(e){return e?{}:{transform:"rotate(90deg)"}},Cg={root:function(e){var r=e.props,o=e.variables;return Object.assign({position:"relative",float:"right",left:Is(12),userSelect:"none",marginRight:Is(4)},r.inSubmenu&&{position:"absolute",top:Is(6),right:Is(2),left:"unset"},{content:'" "',display:"block",overflow:"hidden",height:Is(16),width:Is(16),backgroundSize:Is(16),color:o.indicatorColor},r.active&&Object.assign({color:o.activeIndicatorColor},r.primary&&Object.assign({color:o.activePrimaryIndicatorColor},r.vertical&&{color:o.activePrimaryVerticalIndicatorColor})),r.underlined&&{color:o.indicatorColor},r.iconOnly&&{color:o.indicatorColor},yg(r.vertical))}},kg={root:function(e){var r,o=e.props,t=e.variables,n=o.active,a=o.disabled,i=o.iconOnly,l=o.isFromKeyboard,s=o.pills,c=o.pointing,d=o.secondary,u=o.underlined,f=o.vertical,g=o.primary,p=o.on,b=Zs(t.colorScheme,null,g);return Object.assign({color:"inherit",lineHeight:1,position:"relative",verticalAlign:"middle",display:"block"},d&&{background:"salmon"},f&&{border:"solid "+t.verticalItemBorderWidth+" "+t.verticalItemBorderColor},s&&Object.assign({},f?{margin:"0 0 "+fg+" 0"}:{margin:"0 "+gg+" 0 0"},{borderRadius:Is(5)}),u&&{display:"flex",alignItems:"center",height:Is(29),lineHeight:t.lineHeightBase,padding:"0 "+Is(4),margin:"0 "+Is(4)+" 0 0",":nth-child(n+2)":{marginLeft:""+Is(4)},boxShadow:"none"},!f&&!s&&!u&&!i&&{boxShadow:"-1px 0 0 0 "+(g?t.primaryBorderColor:t.borderColor||b.border)+" inset"},n&&!f&&Object.assign({color:t.wrapperColorActive},!u&&{background:t.backgroundColorActive},!u&&"hover"!==p&&Object.assign({background:t.backgroundColorActive||b.backgroundActive},i&&{background:t.activeIconOnlyWrapperBackgroundColor},!i&&g&&{color:b.foregroundActive}),u&&{color:t.activeUnderlinedWrapperColor},c&&!f&&Object.assign({},function(e){var r,o,t=e.props,n=e.variables,a=e.colors,i=t.pointing,l=t.primary,s=n.backgroundColorActive||a.backgroundActive,c=n.borderColor||l?n.primaryBorderColor:a.border;return "start"===i?(o={borderTop:"1px solid "+c,borderLeft:"1px solid "+c},r="-1px"):(o={borderBottom:"1px solid "+c,borderRight:"1px solid "+c},r="100%"),{"::after":Object.assign({visibility:"visible",background:s,position:"absolute",content:'""',top:r,left:"50%",transform:"translateX(-50%) translateY(-50%) rotate(45deg)",margin:".5px 0 0",width:Is(10),height:Is(10),border:"none"},o,{zIndex:n.beakZIndex,transition:"background .1s ease"})}}({props:o,variables:t,colors:b}))),l&&Object.assign({color:t.wrapperColorFocus},!u&&Object.assign({background:t.wrapperBackgroundColorFocus},g&&{background:t.primaryWrapperBackgroundColorFocus,color:t.primaryWrapperColorFocus}),!i&&!u&&function(e){var r=e.props,o=e.variables,t=e.colors,n=r.primary,a=r.underlined,i=r.active,l=r.vertical;return !i||a||l?Object.assign({color:o.colorActive||t.foregroundActive,background:o.backgroundColorFocus||t.backgroundFocus},n&&{color:t.foregroundFocus,background:t.backgroundFocus},l&&Object.assign({background:o.verticalBackgroundColorFocus,color:o.colorFocus||t.foregroundFocus,border:Is(1)+" solid transparent",padding:Is(1)},n&&{color:o.color})):{}}({props:o,variables:t,colors:b}),i&&{background:t.iconOnlyWrapperBackgroundColorFocus,color:t.iconOnlyColorActive}),n&&{'[data-tabs="true"]':Object.assign({},!u&&Object.assign({background:t.backgroundColorActive||b.backgroundActive},i&&{background:t.activeIconOnlyWrapperBackgroundColor},!i&&g&&{color:b.foregroundActive}),c&&f&&{"::before":Object.assign({content:"''",position:"absolute",width:Is(3),height:"calc(100% + "+Is(4)+")",top:Is(-2),backgroundColor:t.pointingIndicatorBackgroundColor},l&&{display:"none"},"end"===c?{right:Is(-2)}:{left:Is(-2)})})},{":hover":Object.assign({color:t.wrapperColorHover,background:t.backgroundColorHover||b.backgroundHover},n&&{background:t.activeWrapperBackgroundColorHover},f&&{color:t.wrapperColorHover,background:t.backgroundColorHover||b.backgroundHover},g&&{color:t.primaryWrapperColorHover},u&&{color:t.underlinedWrapperColorHover,background:t.underlinedWrapperBackgroundHover},i&&{background:t.iconOnlyBackgroundColorHover,color:t.iconOnlyColorHover},(r={},r["&>."+Oa+">."+ha]=Object.assign({color:t.indicatorColorHover},g&&{color:t.primaryIndicatorColorHover},yg(f)),r))},i&&{borderRadius:t.iconOnlyBorderRadius,display:"flex"},{":first-child":Object.assign({},!s&&!i&&!(c&&f)&&!u&&Object.assign({},f&&{"::before":{display:"none"}},!f&&{borderBottomLeftRadius:Is(3),borderTopLeftRadius:Is(3)}))},a&&{color:t.colorDisabled||b.foregroundDisabled,cursor:"default",":hover":{}})}},wg={root:function(e){var r,o=e.props,t=e.variables,n=Zs(t.colorScheme,null,o.primary),a=o.primary?t.primaryBorderColor:t.borderColor||n.border,i=o.vertical?"borderTop":"borderLeft";return Object.assign({},o.pointing&&o.vertical&&{marginBottom:pg},o.pills&&Object.assign({},o.vertical?{margin:"0 0 "+fg+" 0"}:{margin:"0 "+gg+" 0 0"}),o.hasContent?{display:"flex",justifyContent:"center",flexDirection:"column",textAlign:"center"}:Object.assign(((r={})[i]="1px solid "+a,r),!o.vertical&&{alignSelf:"stretch"},o.vertical&&o.inSubmenu&&{margin:"8px 0"}))}},xg="ui-popup__content__content",Sg={root:function(){return {boxSizing:"border-box",display:"inline-block"}},popupContent:function(){var e;return (e={})["& ."+xg]={borderWidth:"0px",padding:"0px"},e}},Bg={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables;return Object.assign({display:"inline-flex",width:"fit-content",position:"relative",height:o.height,maxHeight:o.height,borderRadius:o.borderRadius,background:o.background,margin:o.margin,minWidth:o.minWidth,":hover":{background:o.backgroundHover}},r.rectangular&&Object.assign({borderRadius:o.roundedBorderRadius},("small"===r.size||"smaller"===r.size)&&{borderRadius:o.smallerRoundedBorderRadius}),"smaller"===r.size&&{minWidth:o.smallerMinWidth,margin:o.smallerMargin,height:o.smallerHeight,maxHeight:o.smallerHeight},"small"===r.size&&{minWidth:o.smallMinWidth,margin:o.smallMargin,height:o.smallHeight,maxHeight:o.smallHeight},r.disabled&&{pointerEvents:"none",cursor:"not-allowed",background:o.disabledBackground,color:o.disabledColor,":hover":{background:o.disabledBackground}},"outline"===r.appearance&&Object.assign({borderWidth:"1px",borderStyle:"solid",background:o.outlineBackground,borderColor:o.outlineBorderColor,":hover":{background:o.outlineBackground}},r.disabled&&{borderColor:o.outlineDisabledborder}),"inverted"===r.appearance&&Object.assign({background:o.invertedBackground,":hover":{background:o.invertedBackground}},r.disabled&&{background:o.disabledBackground}),r.selectable&&Object.assign({cursor:"pointer"},r.selected&&{background:"transparent",boxShadow:"inset "+o.selectedIconColor+" 0px 0px 0px 1px"}),cu({variables:t}))}},Eg={root:function(e){var r=e.props,o=e.variables;return Object.assign({fontSize:o.contentFontSize,padding:o.contentPadding,alignSelf:"center"},"small"===r.size&&{fontSize:o.contentFontSizeSmall,padding:o.contentPaddingSmall},"smaller"===r.size&&{fontSize:o.contentFontSizeSmaller,padding:o.contentPaddingSmaller},r.actionable&&{paddingRight:0})}},Og={root:function(e){var r,o=e.props,t=e.variables;return Object.assign({border:"none",background:"transparent",margin:t.actionMargin,width:t.actionWidth,cursor:"pointer",outline:"none"},("small"===o.size||"smaller"===o.size)&&{width:t.smallOrSmallerActionWidth},((r={})["& ."+ka]={height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}},r))}},Fg={root:function(e){var r=e.props,o=e.variables;return Object.assign({width:o.imageWidth,height:o.imageHeight,borderRadius:"50%"},"small"===r.size&&{width:o.smallImageWidth,height:o.smallImageHeight},"smaller"===r.size&&{width:o.smallerImageWidth,height:o.smallerImageHeight})}},Ag={root:function(e){var r,o=e.props,t=e.variables;return Object.assign({border:"none",background:"transparent",margin:t.iconMargin,width:t.iconWidth,cursor:"pointer",outline:"none"},("small"===o.size||"smaller"===o.size)&&{width:t.smallOrSmallerIconWidth},o.selectable&&o.hasImage&&Object.assign({width:t.selectedImageIconWidth,height:t.selectedImageIconWidth,marginLeft:0,color:t.selectedIconColor},"small"===o.size&&{width:t.smallSelectedImageIconWidth,height:t.smallSelectedImageIconWidth},"smaller"===o.size&&{width:t.smallerSelectedImageIconWidth,height:t.smallerSelectedImageIconWidth}),((r={})["& ."+ka]=Object.assign({height:"100%",width:"100%"},o.selectable&&o.hasImage&&{position:"relative","::after":{content:'""',position:"absolute",background:t.selectedIconCheckColor,left:"10%",top:"10%",borderRadius:"50%",width:"80%",height:"80%"}},{"& svg":Object.assign({},o.selectable&&o.hasImage&&{position:"absolute"},{zIndex:100,height:"100%",width:"100%"})}),r))}},Pg={root:function(){return {display:"flex"}}},jg=function(e){var r=e.padding,o=e.placement;return Object.assign({},"bottom"===o&&{paddingTop:r},"top"===o&&{paddingBottom:r},"left"===o&&{paddingRight:r},"right"===o&&{paddingLeft:r})},Rg=function(e){var r=e.backgroundColor,o=e.borderColor,t=e.rtl,n=e.borderSize,a=e.gap,i=e.height,l=e.padding,s=e.placement,c=e.svg,d=e.width;return Object.assign({display:"block",position:"absolute",zIndex:1},("bottom"===s||"top"===s)&&{paddingLeft:a,paddingRight:a,height:i,width:"calc("+d+" + ("+a+" * 2))"},("left"===s||"right"===s)&&{paddingBottom:a,paddingTop:a,height:"calc("+d+" + ("+a+" * 2))",width:i},"bottom"===s&&{top:"calc("+l+" - "+i+" + ("+n+" * 2))"},"top"===s&&{bottom:"calc("+l+" - "+i+" + "+n+")"},"left"===s&&{right:"calc("+l+" - "+i+" + "+n+")"},"right"===s&&{left:"calc("+l+" - "+i+" + "+n+")"},{"::before":Object.assign({content:'" "',display:"block",height:i,position:"relative",transformOrigin:"center top",borderBottomColor:"transparent",borderLeftColor:"transparent",borderRightColor:"transparent",borderTopColor:"transparent",borderStyle:"solid",left:0,top:0},"bottom"===s&&{borderBottomColor:r,borderWidth:"0 "+i+" "+i},"top"===s&&{borderTopColor:r,borderWidth:i+" "+i+" 0",top:"calc("+n+" * -1)"},"left"===s&&{borderLeftColor:r,borderWidth:i+" 0 "+i+" "+i},"right"===s&&{borderRightColor:r,borderWidth:i+" "+i+" "+i+" 0"}),"::after":Object.assign({content:'" "',display:"block",height:i,position:"relative",transformOrigin:"center top",zIndex:-1,borderBottomColor:"transparent",borderLeftColor:"transparent",borderRightColor:"transparent",borderTopColor:"transparent",borderStyle:"solid"},"bottom"===s&&{borderBottomColor:o,borderWidth:"0 "+i+" "+i,left:0,bottom:"calc("+i+" + 1px)"},"top"===s&&{borderTopColor:o,borderWidth:i+" "+i+" 0",left:0,bottom:i},"left"===s&&{borderLeftColor:o,borderWidth:i+" 0 "+i+" "+i,left:n,bottom:d},"right"===s&&{borderRightColor:o,borderWidth:i+" "+i+" "+i+" 0",right:n,bottom:d})},c&&{"::before":Object.assign({content:'" "',backgroundImage:c,backgroundRepeat:"no-repeat",backgroundPosition:"center",display:"block",position:"relative"},"bottom"===s&&{height:"calc("+d+" + ("+a+" * 2))",width:i,left:a,bottom:"calc("+d+" - "+i+" + "+n+")",transform:"rotate(90deg) /* @noflip */"},"top"===s&&{height:"calc("+d+" + ("+a+" * 2))",width:i,left:a,bottom:"calc("+a+" + "+i+" - "+n+")",transform:"rotate(-90deg) /* @noflip */"},"left"===s&&{height:d,width:i,left:0,transform:t?"rotate(0) /* @noflip */":"rotate(180deg) /* @noflip */"},"right"===s&&{height:d,width:i,right:0,transform:t?"rotate(180deg) /* @noflip */":"rotate(0) /* @noflip */"}),"::after":void 0})},Ig={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",zIndex:o.zIndex},r.pointing&&Object.assign({pointerEvents:"none"},jg({placement:r.basePlacement,padding:o.pointerMargin})),r.autoSize&&{display:"flex"})},pointer:function(e){var r=e.props,o=e.variables,t=e.rtl;return Rg({backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderSize:o.borderSize,gap:o.pointerGap,padding:o.pointerMargin,height:o.pointerHeight,width:o.pointerWidth,placement:r.basePlacement,rtl:t})},content:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",background:o.backgroundColor,color:o.color,boxShadow:o.boxShadow,border:o.borderSize+" solid "+o.borderColor,borderRadius:o.borderRadius,padding:o.padding,transform:"rotate(360deg)"},r.pointing&&{pointerEvents:"all"},r.autoSize&&{overflow:"auto"})}},Mg={root:function(e){var r=e.variables;return {background:r.background,color:r.color,textAlign:"left","& ::-webkit-scrollbar":{height:r.scrollbarHeight,width:r.scrollbarWidth,":disabled":{display:"none"}},"& ::-webkit-scrollbar-thumb":{borderRadius:r.scrollbarThumbBorderRadius,border:"solid "+r.scrollbarThumbBorderSize+" transparent",backgroundClip:"content-box",backgroundColor:r.scrollbarThumbBackgroundColor,":hover":{backgroundColor:r.scrollbarThumbHoverBackgroundColor,border:"solid "+r.scrollbarThumbHoverBorderSize+" transparent"}},"& ::-webkit-scrollbar-track":{background:"transparent"}}}},Dg={root:function(e){return {display:"flex",flexDirection:e.props.vertical?"column":"row"}}},zg="ui-radiogroup__item",_g=zg+"__indicator",Hg=function(e){return {color:e,":hover":{color:e},":focus":{color:e}}},Tg={root:function(e){var r,o=e.props,t=e.variables,n=e.theme.siteVariables;return Object.assign({position:"relative",alignItems:"center",borderStyle:"solid",borderWidth:""+Is(1),borderColor:"transparent",borderRadius:n.borderRadiusMedium,color:t.textColorDefault,cursor:"pointer",display:o.vertical?"flex":"inline-flex",fontSize:t.textFontSize,padding:t.padding,margin:t.margin,":hover":(r={color:t.textColorDefaultHoverFocus},r["& ."+_g]=Object.assign({borderColor:t.textColorDefaultHoverFocus},!o.disabled&&!o.checked&&{borderColor:t.indicatorBorderColorDefaultHover}),r),":focus":{color:t.textColorDefaultHoverFocus}},o.checked&&Object.assign({},Hg(t.textColorChecked)),o.disabled&&Object.assign({},Hg(t.colorDisabled)),cu({variables:n}))},indicator:function(e){var r=e.props,o=e.variables;return Object.assign({margin:Is(2)+" 0",outline:0,display:"flex",alignItems:"center",justifyContent:"center",width:Is(16),height:Is(16),verticalAlign:"midddle",color:o.indicatorColorDefault},r.checked&&{color:o.indicatorBackgroundColorChecked},r.disabled&&{color:o.colorDisabled})},label:function(){return {margin:"0 0 0 "+Is(12),userSelect:"none"}}},Wg={root:function(e){var r=e.props,o=e.variables,t=Zs(o.colorScheme,r.color);return Object.assign({borderColor:"transparent",borderRadius:o.borderRadius,borderStyle:o.borderStyle,borderWidth:o.borderWidth,boxShadow:o.boxShadow,padding:o.padding,color:o.color,backgroundColor:o.backgroundColor},r.color&&{borderColor:t.foreground},r.inverted&&{color:o.backgroundColor,backgroundColor:r.color?t.foreground:o.color},r.disabled&&Object.assign({boxShadow:"none",borderColor:o.disabledBorderColor,color:o.disabledColor,backgroundColor:o.disabledBackgroundColor},r.inverted&&{color:o.disabledBackgroundColor,backgroundColor:o.disabledColor}))}},Lg={"0%":{backgroundPosition:"-1200px 0"},"100%":{backgroundPosition:"1200px 0"}},Ng="ui-skeleton__line",Ug="ui-skeleton__shape",Zg="ui-skeleton__button",Vg="ui-skeleton__input",Gg="ui-skeleton__avatar",Xg="ui-skeleton__text",Yg=function(e,r){return {position:"static",overflow:"hidden",animationDuration:"4.5s",animationName:Lg,animationIterationCount:"infinite",backgroundColor:"#FFFFFF",animationTimingFunction:"linear",backgroundImage:"linear-gradient(to right, "+r+" 0%, "+e+" 20%, "+r+" 40%)",backgroundSize:"1200px 100%"}},$g={animationName:{from:{opacity:1},"50%":{opacity:.5},to:{opacity:1}},animationDuration:"1.5s",animationIterationCount:"infinite"},Kg={root:function(e){var r,o,t,n,a=e.props,i=e.variables,l=(r=i.animationBackground,o=i.animationBackgroundSecondary,{pulse:(t={},t["& ."+Ng]=$g,t["& ."+Ug]=$g,t["& ."+Zg]=$g,t["& ."+Gg]=$g,t["& ."+Vg]=$g,t["& ."+Xg]=$g,t),wave:(n={},n["& ."+Ng]=Yg(r,o),n["& ."+Ug]=Yg(r,o),n["& ."+Zg]=Yg(r,o),n["& ."+Gg]=Yg(r,o),n["& ."+Vg]=Yg(r,o),n["& ."+Xg]=Yg(r,o),n)});return Object.assign({width:"100%"},a.animation&&l[a.animation])}},qg={root:function(e){var r=e.props,o=e.variables;return {display:"block",width:r.width,height:r.height,backgroundColor:o.lineBackground,margin:o.lineMargin}}},Jg={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",width:r.width,height:r.height,backgroundColor:o.shapeBackground,margin:o.shapeMargin},r.round&&{borderRadius:"50%"})}},Qg={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-block",background:o.buttonBackground,height:o.buttonHeight,width:o.buttonWidth},"small"===r.size&&{height:o.buttonSmallHeight,width:o.buttonSmallWidth},r.circular&&Object.assign({width:o.buttonHeight,borderRadius:o.buttonCircularBorderRadius},"small"===r.size&&{width:o.buttonSmallHeight}),r.iconOnly&&Object.assign({width:o.buttonHeight},"small"===r.size&&{width:o.buttonSmallHeight}),r.fluid&&{width:"100%",maxWidth:"100%"})}},ep={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",background:o.textBackground,height:o.textMediumHeight,width:o.textWidth},"smaller"===r.size&&{height:o.textSmallerHeight},"small"===r.size&&{height:o.textSmallHeight},"large"===r.size&&{height:o.textLargeHeight},"larger"===r.size&&{height:o.textLargerHeight})}},rp={root:function(e){var r=e.props,o=e.variables;return Object.assign({flexDirection:"column",justifyContent:"center",display:"inline-flex",position:"relative",height:o.inputHeight,width:o.inputWidth,background:o.inputBackground},r.fluid&&{width:"100%"})}},op={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"inline-block",verticalAlign:"middle",borderRadius:"50%",background:o.buttonBackground,height:o.avatarMedium,width:o.avatarMedium},"smallest"===r.size&&{height:o.avatarSmallest,width:o.avatarSmallest},"smaller"===r.size&&{height:o.avatarSmaller,width:o.avatarSmaller},"small"===r.size&&{height:o.avatarSmall,width:o.avatarSmall},"large"===r.size&&{height:o.avatarLarge,width:o.avatarLarge},"larger"===r.size&&{height:o.avatarLarger,width:o.avatarLarger},"largest"===r.size&&{height:o.avatarLargest,width:o.avatarLargest})}},tp=(n(738),"ui-slider"),np=function(e,r){return {cursor:"pointer",pointerEvents:"none",position:"absolute",border:0,height:r.railHeight,marginTop:"calc("+r.height+" / 2 - "+r.railHeight+" / 2)"}},ap="&+ ."+(tp+"__thumb"),ip=function(e){return e.fluid&&!e.vertical&&{width:"100%"}},lp={root:function(e){var r=e.props,o=e.variables;return Object.assign({height:o.height},r.disabled&&{pointerEvents:"none"},r.vertical&&{height:o.length,width:o.height},ip(r))},input:function(e){var r,o,t,n,a=e.props,i=e.variables,l=e.theme.siteVariables,s={height:i.activeThumbHeight,width:i.activeThumbWidth,background:i.activeThumbColor,marginTop:"calc("+i.height+" / 2  - "+i.activeThumbHeight+" / 2)",marginLeft:"calc(-"+i.activeThumbWidth+" / 2)"},c=cu({variables:l,borderPadding:i.thumbBorderPadding}),d={border:0,width:"1px"};return Object.assign(((r={WebkitAppearance:"none",cursor:"pointer",height:"100%",width:"100%",margin:0,padding:0,opacity:0})["::-webkit-slider-thumb"]=Object.assign({},d,{"-webkit-appearance":"none"}),r["::-moz-range-thumb"]=d,r["::-ms-thumb"]=Object.assign({},d,{marginTop:"calc(-"+i.thumbHeight+" / 2)"}),r["::-ms-fill-lower"]={display:"none"},r["::-ms-fill-upper"]={display:"none"},r),ip(a),{":active":(o={},o[ap]=s,o),":focus":(t={outline:0},t[ap]=c[":focus"],t),":focus-visible":(n={},n[ap]=Object.assign({},c[":focus-visible"],s),n)})},inputWrapper:function(e){var r=e.props,o=e.variables,t="calc("+o.length+" / 2)";return Object.assign({position:"relative",display:"inline-block",height:o.height,width:o.length},r.vertical&&{transform:"rotate(-90deg)",transformOrigin:t+" "+t},ip(r))},rail:function(e){var r=e.props,o=e.variables;return Object.assign({width:"100%",background:o.railColor},np(0,o),r.disabled&&{background:o.disabledRailColor})},track:function(e){var r=e.props,o=e.variables;return Object.assign({background:o.trackColor},np(0,o),r.disabled&&{background:o.disabledTrackColor})},thumb:function(e){var r=e.props,o=e.variables;return Object.assign({border:0,borderRadius:"100%",cursor:"pointer",pointerEvents:"none",position:"absolute",background:o.thumbColor,height:o.thumbHeight,width:o.thumbWidth,marginTop:"calc("+o.height+" / 2  - "+o.thumbHeight+" / 2)",marginLeft:"calc(-"+o.thumbWidth+" / 2)"},r.disabled&&{background:o.disabledThumbColor})}},sp="& ."+_a.content,cp={root:function(e){e.props;var r,o=e.variables,t=e.theme.siteVariables;return {cursor:"pointer",background:"transparent",border:Is(0),padding:Is(0),display:"inline-flex",justifyContent:"center",alignItems:"center",color:o.meReacting?o.meReactingColor:o.otherReactingColor,":hover":(r={color:o.meReacting?o.meReactingColorHover:o.otherReactingColorHover},r[sp]={fontWeight:o.fontWeightHover},r),position:"relative",":focus":{outline:"none"},":focus-visible":{":after":{content:'""',position:"absolute",top:"-"+Is(2),right:"-"+Is(2),bottom:"-"+Is(2),left:"-"+Is(2),borderWidth:"1px",borderStyle:"solid",borderColor:o.borderColorFocus,borderRadius:t.borderRadiusMedium,boxShadow:"0px 0px 0px 1px "+o.boxShadowColor+" inset"}}}},icon:function(e){return {display:"inline-flex",alignItems:"center",justifyContent:"center",marginRight:e.props.hasContent?Is(4):Is(0)}},content:function(e){return {fontSize:e.variables.contentFontSize}}},dp={root:function(){return {}},reaction:function(e){return {":not(:last-child)":{marginRight:e.variables.reactionSpacing}}}},up=function(e,r){switch(e){case"success":return r.successBackgroundColor;case"info":return r.infoBackgroundColor;case"warning":return r.warningBackgroundColor;case"error":return r.errorBackgroundColor;default:return r.defaultBackgroundColor}},fp=function(e,r){switch(e){case"success":return r.successTextColor;case"info":return r.infoTextColor;case"warning":return r.warningTextColor;case"error":return r.errorTextColor;default:return r.defaultTextColor}},gp={smallest:6,smaller:10,small:10,medium:10,large:10,larger:16,largest:0},pp={root:function(e){var r=e.props,o=r.color,t=r.size,n=r.state,a=e.variables;return Object.assign({display:"inline-flex",alignItems:"center",justifyContent:"center"},function(e,r){var o=r.borderColor&&r.borderWidth||0,t=Is(e+2*o);return {height:t,width:t}}(gp[t],a),{verticalAlign:"middle",borderRadius:"9999px"},a.borderColor&&{borderColor:a.borderColor,borderWidth:Is(a.borderWidth),borderStyle:"solid"},{backgroundColor:o||up(n,a)})},icon:function(e){var r=e.props.state,o=e.variables;return {display:"inline-flex",alignItems:"center",justifyContent:"center",width:o.iconSize,height:o.iconSize,color:fp(r,o),"& > :first-child":{height:"100%",width:"100%","& svg":{height:"100%",width:"100%"}}}}},bp={menuButton:function(e){var r=e.props,o=e.variables;return Object.assign({borderTopRightRadius:0,borderBottomRightRadius:0,borderRightWidth:0,padding:o.padding,minWidth:o.minWidth},"small"===r.size&&{height:o.smallDimension,padding:o.smallPadding,minWidth:o.smallMinWidth},(r.flat||"small"===r.size)&&{boxShadow:"none"},{":focus-visible":{borderRightWidth:0,":before":{borderRightWidth:0},":after":{borderRightWidth:0}},":active":{animationName:"unset",animationDuration:"unset"}})},root:function(e){var r=e.props,o=e.variables,t=(e.theme.siteVariables,cu({variables:{borderRadius:o.focusBorderRadius,borderWidth:o.focusBorderWidth,focusInnerBorderColor:o.focusInnerBorderColor,focusOuterBorderColor:o.focusOuterBorderColor,zIndexes:{foreground:o.focusBorderZIndex}}}));return {borderRadius:o.borderRadius,position:"relative",whiteSpace:"nowrap",display:"inline-block",width:"fit-content",":focus-within":Object.assign({boxShadow:"none"},r.isFromKeyboard&&Object.assign({},t[":focus-visible"]))}}},mp=function(e,r){return r?"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M21.5,13.5c0,0.1,0,0.3-0.1,0.4l-5,5C16.3,19,16.1,19,16,19c-0.1,0-0.3-0.1-0.4-0.1l-5-5c-0.1-0.1-0.2-0.2-0.1-0.4 c0-0.3,0.2-0.5,0.5-0.5c0.1,0,0.3,0.1,0.4,0.1l4.6,4.6l4.7-4.6c0.1-0.1,0.2-0.1,0.4-0.1C21.3,13,21.5,13.2,21.5,13.5z' /%3E%3C/svg%3E\")":"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M16,19.5c-0.3,0-0.5-0.1-0.7-0.3l-5-5C10.1,14,10,13.8,10,13.5c0-0.6,0.4-1,1-1c0.3,0,0.5,0.1,0.7,0.3l4.3,4.3l4.3-4.3 c0.2-0.2,0.4-0.3,0.7-0.3c0.6,0,1,0.4,1,1c0,0.3-0.1,0.5-0.3,0.7l-5,5C16.5,19.4,16.3,19.5,16,19.5z' /%3E%3C/svg%3E\")"},hp=function(e,r,o){return {content:'""',width:o,height:o,backgroundImage:mp(e,r),backgroundRepeat:"no-repeat"}},vp={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=t.borderWidth,a=cu({variables:{borderRadius:o.focusBorderRadius,borderWidth:o.focusBorderWidth,focusInnerBorderColor:o.focusInnerBorderColor,focusOuterBorderColor:o.focusOuterBorderColor,zIndexes:{foreground:o.focusBorderZIndex}},borderPadding:n}),i=function(){return r.primary?o.toggleButtonPrimaryHoverColor:o.toggleButtonColorHover};return Object.assign({height:o.toggleButtonHeight,minWidth:o.toggleButtonHeight,color:o.toggleButtonColor,backgroundColor:o.toggleButtonBackgroundColor,borderRadius:o.toggleButtonBorderRadius,display:"inline-flex",justifyContent:"center",alignItems:"center",position:"relative",verticalAlign:"middle",cursor:"pointer",outline:0,padding:0,borderWidth:n,borderStyle:"solid",borderColor:o.toggleButtonBorderColor,borderTopLeftRadius:0,borderBottomLeftRadius:0,borderLeftColor:"transparent",boxShadow:r.primary?o.toggleButtonPrimaryBoxShadow:o.toggleButtonBoxShadow},(r.flat||"small"===r.size||r.disabled)&&{boxShadow:"none"},du({outline:!0}),{":before":Object.assign({},hp(r.disabled?o.toggleButtonColorDisabled:r.primary?o.toggleButtonPrimaryColor:o.toggleButtonColor,!0,o.toggleButtonIndicatorSize)),":hover":Object.assign({},du({outline:!0}),{color:i(),backgroundColor:o.toggleButtonBackgroundColorHover,borderTopColor:o.toggleButtonBorderColorHover,borderRightColor:o.toggleButtonBorderColorHover,borderBottomColor:o.toggleButtonBorderColorHover,":before":Object.assign({},hp(i(),!0,o.toggleButtonIndicatorSize))}),":active":{color:o.toggleButtonColorActive,backgroundColor:o.toggleButtonBackgroundColorActive,borderColor:o.toggleButtonBorderColorActive,boxShadow:"none"},":focus":a[":focus"],":focus-visible":{backgroundColor:o.toggleButtonBackgroundColorFocus,borderColor:o.toggleButtonBorderColorFocus,color:o.toggleButtonColorFocus,borderWidth:n,":hover":{borderColor:o.toggleButtonBorderColorHover}}},r.primary&&{color:o.toggleButtonPrimaryColor,backgroundColor:o.toggleButtonPrimaryBackgroundColor,borderWidth:"0 0 0 "+t.borderWidth,borderColor:o.toggleButtonPrimaryBorderColor,":active":{backgroundColor:o.toggleButtonPrimaryBackgroundColorActive,boxShadow:"none"},":focus":a[":focus"],":focus-visible":{backgroundColor:o.toggleButtonPrimaryBackgroundColorFocus},":hover":{color:o.toggleButtonPrimaryHoverColor,backgroundColor:o.toggleButtonPrimaryHoverBackgroundColor}},r.disabled&&{cursor:"default",color:o.toggleButtonColorDisabled,boxShadow:"none",pointerEvents:"none",":hover":{color:o.toggleButtonColorDisabled},backgroundColor:o.toggleButtonBackgroundColorDisabled,borderWidth:"0 0 0 "+t.borderWidth,borderColor:o.borderColorDisabled},"small"===r.size&&{height:o.smallDimension,width:o.smallDimension,minWidth:o.smallMinWidth})}},yp={root:function(e){var r=e.props,o=e.variables;return {height:"auto",alignItems:"center",display:"inline-block","::before":Object.assign({content:'""',position:"absolute",top:0,bottom:0,width:"1px",height:"100%",zIndex:1,background:o.dividerColor},r.primary&&{background:o.dividerPrimaryColor})}}},Cp={root:function(e){var r=e.props,o=e.variables,t=o.colorScheme[Us(r.color)];return Object.assign({},r.color&&{color:t.foreground},!0===r.atMention&&{color:o.atMentionOtherColor},r.truncated&&{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},r.disabled&&{color:o.disabledColor},r.error&&{color:o.errorColor},r.success&&{color:o.successColor},r.temporary&&{fontStyle:"italic"},r.align&&{display:"block",textAlign:Tf(r.align)},"light"===r.weight&&{fontWeight:o.fontWeightLight},"semilight"===r.weight&&{fontWeight:o.fontWeightSemilight},"regular"===r.weight&&{fontWeight:o.fontWeightRegular},"semibold"===r.weight&&{fontWeight:o.fontWeightSemibold},"bold"===r.weight&&{fontWeight:o.fontWeightBold},"smallest"===r.size&&{fontSize:o.fontSizeSmallest,lineHeight:o.fontLineHeightSmallest},"smaller"===r.size&&{fontSize:o.fontSizeSmaller,lineHeight:o.fontLineHeightSmaller},"small"===r.size&&{fontSize:o.fontSizeSmall,lineHeight:o.fontLineHeightSmall},"medium"===r.size&&{fontSize:o.fontSizeMedium,lineHeight:o.fontLineHeightMedium},"large"===r.size&&{fontSize:o.fontSizeLarge,lineHeight:o.fontLineHeightLarge},"larger"===r.size&&{fontSize:o.fontSizeLarger,lineHeight:o.fontLineHeightLarger},"largest"===r.size&&{fontSize:o.fontSizeLargest,lineHeight:o.fontLineHeightLargest},"me"===r.atMention&&{color:o.atMentionMeColor,fontWeight:o.atMentionMeFontWeight},r.timestamp&&{color:o.timestampColor},r.important&&{color:o.importantColor,fontWeight:o.importantWeight})}},kp={root:function(e){var r=e.props,o=e.variables;return Object.assign({margin:o.margin,height:o.height,backgroundColor:o.backgroundColor},r.inverted&&{backgroundColor:o.invertedBackgroundColor},{color:o.fontColor,borderColor:o.borderColor,borderRadius:o.borderRadius,borderStyle:"solid",borderWidth:o.borderWidth,outline:0,padding:o.padding,resize:r.resize||"none"},r.fluid&&{width:"100%"},r.disabled&&{pointerEvents:"none",color:o.disabledColor,boxShadow:"none"},r.error&&{border:Is(1)+" solid "+o.borderColorError},{"::placeholder":Object.assign({color:o.placeholderColor,opacity:1},r.disabled&&{color:o.disabledColor}),":focus":{borderColor:o.borderColorFocus}})}},wp={root:function(){return {display:"flex",alignItems:"center",position:"relative"}},offsetMeasure:function(){return {position:"absolute",visibility:"hidden",left:0,top:0}},overflowContainer:function(){return {display:"flex",overflow:"hidden",flexGrow:1}},overflowSentinel:function(e){var r=e.props;return {width:Is(100),display:r.overflowOpen?"block":"none",visibility:"hidden"}}},xp={root:function(){return {display:"flex",whiteSpace:"nowrap"}}},Sp={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=Zs(o.colorScheme),a=t.borderWidth,i=cu({variables:t});return Object.assign({position:"relative",backgroundColor:o.background,borderColor:"transparent",borderWidth:a,borderStyle:"solid",height:o.itemHeight,color:o.foreground||n.foreground1,display:"flex",alignItems:"center",justifyContent:"center",userSelect:"none"},!0!==r.fitted&&"horizontally"!==r.fitted&&{paddingLeft:o.customItemHorizontalPadding,paddingRight:o.customItemHorizontalPadding},!0!==r.fitted&&"vertically"!==r.fitted&&{paddingTop:o.customItemVerticalPadding,paddingBottom:o.customItemVerticalPadding},{":focus":i[":focus"],":focus-visible":i[":focus-visible"]})}},Bp={root:function(e){var r=e.variables,o=Zs(r.colorScheme);return {borderLeft:"1px solid "+(r.dividerBorder||o.border),margin:r.dividerMargin,alignSelf:"stretch"}}},Ep={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=Zs(o.colorScheme),a=t.borderWidth,i=cu({variables:t});return Object.assign({position:"relative",backgroundColor:o.background,borderWidth:a,borderStyle:"solid",borderColor:"transparent",borderRadius:o.borderRadius,height:o.itemHeight,minWidth:o.itemHeight,padding:o.itemPadding,color:o.foreground||n.foreground1,cursor:"pointer",userSelect:"none",":focus":i[":focus"]},r.active&&Object.assign({color:o.foregroundActive||n.foregroundActive,backgroundColor:o.backgroundActive},du({outline:!1})),{":hover":Object.assign({color:o.foregroundHover||n.foregroundHover,backgroundColor:o.backgroundHover||n.backgroundHover},du({outline:!1})),":focus-visible":i[":focus-visible"]},(r.disabled||r.disabledFocusable)&&{color:o.foregroundDisabled||n.foregroundDisabled1,backgroundColor:o.backgroundDisabled,cursor:"default",":hover":{}},r.disabled&&{pointerEvents:"none"})}},Op={root:function(e){var r=e.variables,o=Zs(r.colorScheme);return {display:"flex",flexDirection:"column",listStyleType:"none",margin:0,padding:r.menuPadding,backgroundColor:r.menuBackground||o.background,boxShadow:r.menuBoxShadow,borderStyle:"solid",borderColor:r.menuBorder||o.border,borderWidth:r.menuBorderWidth,borderRadius:r.menuBorderRadius,maxWidth:r.menuMaxWidth,zIndex:r.overlayZIndex}}},Fp={root:function(e){var r=e.variables,o=Zs(r.colorScheme);return {borderTop:"1px solid "+(r.menuDividerBorder||o.border),margin:r.menuDividerMargin,alignSelf:"stretch"}}},Ap=function(e){return "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' fill='"+encodeURIComponent(e)+"' focusable='false' view-box='8 8 16 16'%3E%3Cg%3E%3Cpath d='M23.5 11.875a.968.968 0 0 1-.289.711l-8.25 8.25c-.192.193-.43.289-.711.289s-.519-.096-.711-.289l-4.75-4.75a.965.965 0 0 1-.289-.711c0-.125.027-.25.082-.375s.129-.234.223-.328a.953.953 0 0 1 .695-.297c.135 0 .266.025.391.074.125.05.231.121.32.215l4.039 4.047 7.539-7.547a.886.886 0 0 1 .32-.215c.125-.049.255-.074.391-.074a1.004 1.004 0 0 1 .922.625.97.97 0 0 1 .078.375z' /%3E%3C/g%3E%3C/svg%3E\")"},Pp="ui-toolbar__menuitemsubmenuindicator",jp="ui-toolbar__menuitemactiveindicator",Rp={root:function(e){var r,o,t=e.props,n=e.variables,a=e.theme.siteVariables,i=Zs(n.colorScheme),l=cu({variables:a,borderRadius:0});return Object.assign({position:"relative",color:n.menuItemForeground||i.foreground1,borderWidth:n.menuBorderWidth,backgroundColor:"transparent",borderColor:"transparent",display:"flex",alignItems:"center",textAlign:"left",width:"100%",maxWidth:"100%",padding:n.menuItemPadding,cursor:"pointer",minHeight:n.itemHeight,lineHeight:n.lineHeightBase,userSelect:"none",":focus":{outline:0},":hover":(r={color:n.menuItemForegroundHover||i.menuItemForegroundHover,backgroundColor:n.menuItemBackgroundHover||i.menuItemBackgroundHover},r["& ."+Pp]={color:n.menuItemForegroundHover||i.menuItemForegroundHover},r["& ."+jp]={backgroundImage:Ap(n.menuItemForegroundHover||i.menuItemForegroundHover)},r),":focus-visible":l[":focus-visible"]},(t.disabled||t.disabledFocusable)&&((o={cursor:"default",color:n.menuItemForegroundDisabled||i.foregroundDisabled1,backgroundColor:n.menuItemBackgroundDisabled})["& ."+Pp]={color:n.menuItemForegroundDisabled||i.foregroundDisabled1},o["& ."+jp]={backgroundImage:Ap(n.menuItemForegroundDisabled||i.foregroundDisabled1)},o[":hover"]={},o),t.disabled&&{pointerEvents:"none"})},wrapper:function(){return {display:"block"}}},Ip={root:function(e){var r=e.props;return Object.assign({},r.hasContent&&{marginRight:Is(10),marginTop:Is(3),display:"flex",alignSelf:"start"})}},Mp={root:function(e){var r=e.variables,o=Zs(r.colorScheme);return {display:"flex",alignItems:"center",justifyContent:"center",color:r.menuItemForeground||o.foreground1,width:Is(16),height:"100%",position:"absolute",right:Is(7),top:0}}},Dp={root:function(e){var r=e.variables,o=Zs(r.colorScheme);return {backgroundImage:Ap(r.menuItemForeground||o.foreground1),backgroundPosition:"center",backgroundRepeat:"no-repeat",width:Is(24),height:"100%",position:"absolute",right:Is(7)}}},zp={root:function(){return {padding:0}}},_p={root:function(){return {}}},Hp={root:function(){return {display:"block",paddingLeft:""+Is(10)}}},Tp="ui-tree__title",Wp=Tp+"__selection-indicator",Lp={root:function(e){var r,o,t,n=e.theme.siteVariables,a=e.props,i=cu({variables:n});return {listStyleType:"none",":focus":Object.assign({},a.selectable&&(r={},r["& ."+Wp]={display:"inline-block"},r),i[":focus"]),":focus-visible":Object.assign({outline:0},a.selectable&&(o={},o["& ."+Wp]={display:"inline-block"},o),(t={},t["> ."+Tp]=Object.assign({position:"relative"},i[":focus-visible"]),t))}}},Np={root:function(e){var r,o,t,n=e.props,a=e.variables,i=e.theme.siteVariables,l=cu({variables:i});return Object.assign({padding:a.padding,cursor:"pointer",color:a.color,position:"relative",marginLeft:Is(1+10*(n.level-1)),paddingRight:a.paddingRight,paddingLeft:a.paddingLeft,userSelect:"none"},n.selectable&&{display:"flex",justifyContent:"space-between",alignItems:"center"},{":focus":Object.assign({},n.selectable&&(r={},r["> ."+Wp]={display:"inline-block"},r),l[":focus"]),":focus-visible":l[":focus-visible"],":hover":Object.assign({},n.selectable&&(o={background:a.hoverBackground},o["> ."+Wp]={display:"inline-block"},o))},n.showIndicator&&((t={})["> ."+Wp]={display:"inline-block"},t))},selectionIndicator:function(e){var r,o,t=e.props,n=e.variables;return Object.assign({display:"none",float:"right",verticalAlign:"middle",boxShadow:"unset",width:Is(16),height:Is(16),borderColor:n.borderColor,borderStyle:n.borderStyle,borderRadius:n.borderRadius,borderWidth:n.borderWidth,color:n.indicatorColor,margin:n.selectionIndicatorMargin,padding:n.padding,userSelect:"none",backgroundImage:of(n.indicatorColor,n.background),backgroundPosition:"center",backgroundRepeat:"no-repeat"},t.selected&&{borderColor:n.checkedBorderColor,backgroundImage:of(n.checkedIndicatorColor,n.checkedBackground)},t.indeterminate&&{borderColor:n.checkedBorderColor,backgroundImage:(r=n.checkedIndicatorColor,o=n.checkedBackground,"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' style='background-color: "+escape(o)+"; padding: 2px;' focusable='false' viewBox='8 8 22.5 22.5'%3E%3Cg%3E%3Cpath fill='"+escape(r)+"' d='M10 16v-1h12v1H10z 11.875a.968.968 0 0 1-.289.711l-8.25 8.25c-.192.193-.43.289-.711.289s-.519-.096-.711-.289l-4.75-4.75a.965.965 0 0 1-.289-.711c0-.125.027-.25.082-.375s.129-.234.223-.328a.953.953 0 0 1 .695-.297c.135 0 .266.025.391.074.125.05.231.121.32.215l4.039 4.047 7.539-7.547a.886.886 0 0 1 .32-.215c.125-.049.255-.074.391-.074a1.004 1.004 0 0 1 .922.625.97.97 0 0 1 .078.375z' /%3E%3C/g%3E%3C/svg%3E\")")},t.disabled&&{background:n.disabledBackground,borderColor:n.disabledBorderColor},t.disabled&&t.selected&&{color:n.disabledCheckedIndicatorColor,borderColor:n.disabledBackgroundChecked,backgroundImage:of(n.disabledCheckedIndicatorColor,n.disabledBackgroundChecked)})}},Up={root:function(e){var r=e.variables;return {display:"inline-block",verticalAlign:"middle",width:r.width,height:r.height||"auto"}}},Zp={root:function(e){var r=e.props,o=e.variables;return Object.assign({display:"none",position:"absolute",maxWidth:o.maxWidth,zIndex:o.zIndex},r.pointing&&Object.assign({pointerEvents:"all"},jg({placement:r.basePlacement,padding:o.pointerMargin})),r.open&&{display:"block"})},pointer:function(e){var r,o=e.props,t=e.variables,n=e.rtl;return Object.assign({display:"block",position:"absolute",width:t.pointerWidth,height:t.pointerHeight},Rg({backgroundColor:o.subtle?t.subtleBackgroundColor:t.backgroundColor,borderSize:t.borderSize,borderColor:o.subtle?t.subtleBorderColor:"transparent",gap:t.pointerGap,padding:t.pointerMargin,height:t.pointerHeight,width:t.pointerWidth,placement:o.basePlacement,rtl:n,svg:(r=o.subtle?t.subtleBackgroundColor:t.backgroundColor,"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='"+encodeURIComponent(r)+"' viewBox='0 0 6 16'%3E%3Cpath d='M.708 9.527a2.002 2.002 0 0 1 0-3.055l3.284-2.78C5.324 2.562 5.991 1.332 5.991 0c0 1.002.02 15.013 0 16 0-1.333-.665-2.562-1.995-3.689L.708 9.527z' fill-rule='evenodd' clip-rule='evenodd'/%3E%3C/svg%3E%0A\");")}))},content:function(e){var r=e.props,o=e.variables;return Object.assign({display:"block",padding:o.padding,textAlign:"left",color:o.color,background:o.backgroundColor,borderRadius:o.borderRadius,boxShadow:o.boxShadow},r.subtle&&{background:o.subtleBackgroundColor,color:o.subtleForegroundColor,borderStyle:"solid",borderWidth:o.borderSize,borderColor:o.subtleBorderColor},r.pointing&&{pointerEvents:"all"})}},Vp={root:function(){return {display:"inline-block",position:"relative"}},itemsContainerWrapper:function(e){var r=e.variables,o=e.props;return Object.assign({display:"flex",width:Is(r.width),overflowX:"hidden"},o.shouldFocusContainer&&o.isFromKeyboard&&{border:"1px solid "+r.focusOuterBorderColor,borderRadius:r.focusOuterBorderRadius})},itemsContainer:function(){return {padding:0,margin:0,display:"flex",listStyle:"none",willChange:"transform"}}},Gp={root:function(e){var r=e.variables;return {width:Is(r.width),marginBottom:Is(16),":focus":{outline:"none"}}}},Xp={root:function(e){var r=e.props,o=e.variables,t=e.theme,n=r.iconOnly,a=r.primary,i=r.vertical,l=r.thumbnails,s=Zs(o.colorScheme,null,a),c=t.siteVariables;return Object.assign({display:"flex",minHeight:Is(24),margin:0,padding:0,color:o.color,backgroundColor:o.backgroundColor||"inherit",listStyleType:"none",justifyContent:"center",position:"relative",zIndex:2},!i&&l&&{justifyContent:"start",transform:"translateX("+Is(o.width/2-o.thumbnailWidth/2-+r.activeIndex*o.thumbnailWidth)+")",transition:"transform .5s ease"},n&&{alignItems:"center"},i&&Object.assign({flexDirection:"column",backgroundColor:o.verticalBackgroundColor,width:"fit-content",padding:Is(8)+" 0"},n&&{display:"inline-block",width:"auto"}),!n&&!i&&{border:o.borderWidth+" solid "+(a?o.primaryBorderColor:o.borderColor||s.border),borderRadius:c.borderRadiusMedium})}},Yp="ui-carousel__navigationitem",$p=Yp+"__indicator",Kp={root:function(e){var r,o=e.props,t=e.variables,n=o.active,a=o.iconOnly,i=o.primary,l=o.vertical,s=o.thumbnails,c=o.disableClickableNav,d=Zs(t.colorScheme,null,i);return Object.assign({color:"inherit",display:"block",cursor:"pointer",whiteSpace:"nowrap"},a&&{border:Is(2)+" solid transparent"},l?{padding:t.verticalItemPadding}:{padding:t.horizontalPadding},a&&{margin:Is(1),padding:Is(5),display:"flex",alignItems:"center",justifyContent:"center"},n&&a&&Object.assign({color:t.iconOnlyColorActive},du({outline:!1})),{":focus-visible":Object.assign({},a&&Object.assign({borderRadius:"50%"},s&&{borderRadius:"0"},{borderColor:t.iconOnlyColorActive},du({outline:!1})))},a&&i&&{color:"inherit",borderColor:t.borderColorActive||d.borderActive},c&&{cursor:"default"},{":focus":{outline:0},":hover":Object.assign((r={color:"inherit"},r["& ."+$p]={background:t.indicatorBackgroundColor},r),a&&du({outline:!1}),i&&a&&{color:"inherit"})})},content:function(e){var r=e.props,o=r.hasIndicator?26:0;return Object.assign({whiteSpace:"normal",lineHeight:1.5,marginTop:Is(-4),marginBottom:Is(-4),display:"inline-block"},r.thumbnails&&Object.assign({width:Is(60)},!r.active&&{opacity:.4}),r.vertical&&{width:"max-content",minWidth:Is(46-o),maxWidth:Is(262-o),marginRight:Is(16)})},indicator:function(e){var r=e.props,o=e.variables;return Object.assign({borderRadius:"50%",width:Is(7),height:Is(7),background:o.indicatorBackgroundColor},r.active&&{background:o.indicatorActiveBackgroundColor},r.hasContent&&{marginRight:Is(10)},!r.iconOnly&&{marginTop:0,marginBottom:Is(-8),verticalAlign:"top"})}},qp="ui-carousel__paddle__content",Jp=function(e,r){return r?"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M21.5 15.97c0 .28-.1.52-.29.71l-7 7c-.19.19-.43.29-.71.29-.14 0-.26-.03-.38-.08s-.23-.13-.32-.22-.16-.2-.22-.32a1.036 1.036 0 0 1-.01-.77c.05-.12.12-.23.21-.32l6.3-6.29-6.3-6.29a.85.85 0 0 1-.21-.32c-.05-.13-.07-.26-.07-.39a.995.995 0 0 1 .3-.7c.09-.09.2-.16.32-.22.12-.05.24-.08.38-.08.28 0 .52.1.71.29l7 7c.19.19.29.43.29.71z' /%3E%3C/g%3E%3C/svg%3E\")":"url(\"data:image/svg+xml, %3Csvg xmlns='http://www.w3.org/2000/svg' role='presentation' focusable='false' viewBox='8 8 16 16'%3E%3Cg%3E%3Cpath fill='"+encodeURIComponent(e)+"' d='M19.5 8.97c0 .14-.03.27-.07.39-.05.12-.12.23-.21.32l-6.3 6.29 6.3 6.29c.09.09.17.2.21.32a1.036 1.036 0 0 1-.01.77c-.05.12-.13.23-.22.32s-.2.16-.32.22a.995.995 0 0 1-1.09-.21l-7-7c-.19-.19-.29-.43-.29-.71s.1-.52.29-.71l7-7a.995.995 0 0 1 1.09-.21c.12.06.23.13.32.22s.16.2.22.32c.05.12.08.25.08.38z' /%3E%3C/g%3E%3C/svg%3E\")"},Qp=function(e,r,o){return {width:o,height:o,backgroundImage:Jp(e,r),backgroundRepeat:"no-repeat"}},eb={root:function(e){var r,o=e.props,t=e.variables,n=e.theme.siteVariables.borderWidth,a=cu({variables:{borderRadius:t.focusBorderRadius,borderWidth:t.focusBorderWidth,focusInnerBorderColor:t.focusInnerBorderColor,focusOuterBorderColor:t.focusOuterBorderColor,zIndexes:{foreground:t.focusBorderZIndex}},borderPadding:n});return Object.assign({height:t.paddleHeight,minWidth:t.paddleHeight,color:t.paddleColor,backgroundColor:t.paddleBackgroundColor,borderRadius:t.paddleBorderRadius,border:0,display:"inline-flex",justifyContent:"center",alignItems:"center",position:"relative",verticalAlign:"middle",cursor:"pointer",marginBottom:Is(40),outline:0,padding:0,transition:ws,zIndex:1},o.hidden&&{visibility:"hidden"},o.disableClickableNav&&{cursor:"default"},{":hover":Object.assign({},du({outline:!1}),(r={},r["& ."+qp]=Object.assign({},Qp(t.paddleColor,o.next,t.paddleIndicatorSize)),r.background=t.paddleBackgroundColorHover,r)),":active":{transition:ks,backgroundColor:t.paddleBackgroundColorActive},":focus":a[":focus"],":focus-visible":Object.assign({},a[":focus-visible"])},o.disabled&&{cursor:"default",color:t.paddleColorDisabled,pointerEvents:"none",":hover":{color:t.paddleColorDisabled},backgroundColor:t.paddleBackgroundColorDisabled})},content:function(e){var r=e.props,o=e.variables,t=e.rtl;return Object.assign({},Qp(r.disabled?o.paddleColorDisabled:o.paddleColor,r.next,o.paddleIndicatorSize),t&&{transform:"scaleX(-1)"})}},rb={root:function(e){var r=e.variables;return {display:"flex",width:Is(r.width),justifyContent:"space-between",alignItems:"center",position:"absolute",top:0,right:0,left:0,bottom:0}}},ob={root:function(e){return {display:"flex",flexDirection:"column",background:e.variables.backgroundColor}}},tb={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=cu({variables:t});return Object.assign({display:"flex",flexDirection:"row",alignItems:"center",fontSize:o.bodyFontSize,height:o.defaultRowHeight,color:o.color,backgroundColor:o.backgroundColor,borderWidth:o.borderWidth,borderStyle:"solid",borderColor:"transparent",borderBottomColor:o.rowBorderColor,padding:o.rowPadding,position:"relative",width:"100%",":hover":{color:o.hoverColor,backgroundColor:o.backgroundHoverColor,borderColor:o.rowBorderHoverColor}},n,r.header&&{fontSize:o.headerFontSize,":hover":{color:o.color,backgroundColor:o.backgroundColor}},r.compact&&{height:o.compactRowHeight})}},nb={root:function(e){var r=e.variables,o=e.theme.siteVariables,t=cu({variables:o});return Object.assign({display:"flex",flexFlow:"row nowrap",flexGrow:1,flexBasis:0,minWidth:r.minCellWidth,outline:0,borderWidth:r.borderWidth,borderStyle:"solid",borderColor:"transparent"},t,{padding:r.cellPadding,position:"relative",height:"100%"})},content:function(e){var r=e.props;return Object.assign({alignSelf:"center"},r.truncateContent&&{display:"block",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"})}},ab="ui-card__expandablebox",ib={root:function(e){var r,o=e.props,t=e.variables,n=e.theme.siteVariables,a=cu({variables:n,borderRadius:t.borderRadius});return Object.assign({display:"flex",flexDirection:"column",position:"relative",padding:t.padding,margin:t.margin,width:t.width,height:t.height,borderWidth:t.borderWidth,borderStyle:t.borderStyle,borderColor:t.borderColor,borderRadius:t.borderRadius,backgroundColor:t.backgroundColor},o.ghost&&{backgroundColor:t.ghostBackgroundColor},o.inverted&&{backgroundColor:t.invertedBackgroundColor},o.selected&&{backgroundColor:t.selectedBackgroundColor},{boxShadow:t.boxShadow},o.elevated&&{boxShadow:t.elevatedBoxShadow},{":hover":Object.assign({backgroundColor:t.backgroundColorHover},o.ghost&&{backgroundColor:t.ghostBackgroundColorHover},o.inverted&&{backgroundColor:t.invertedBackgroundColorHover},o.selected&&{backgroundColor:t.selectedBackgroundColorHover},{borderColor:t.borderColorHover,boxShadow:t.boxShadowHover},o.elevated&&{boxShadow:t.elevatedBoxShadowHover})},a,o.actionable&&{cursor:"pointer",":focus-visible":Object.assign({backgroundColor:t.backgroundColorFocus},o.ghost&&{backgroundColor:t.ghostBackgroundColorFocus},o.inverted&&{backgroundColor:t.invertedBackgroundColorFocus},o.selected&&{backgroundColor:t.selectedBackgroundColorFocus},{boxShadow:t.boxShadowFocus},o.elevated&&{boxShadow:t.elevatedBoxShadowFocus},a[":focus-visible"]),":active":Object.assign({backgroundColor:t.backgroundColorPressed},o.ghost&&{backgroundColor:t.ghostBackgroundColorPressed},o.inverted&&{backgroundColor:t.invertedBackgroundColorPressed},o.selected&&{backgroundColor:t.selectedBackgroundColorPressed},{borderColor:t.borderColorPressed,boxShadow:t.boxShadowPressed},o.elevated&&{boxShadow:t.elevatedBoxShadowPressed})},"small"===o.size&&{width:t.sizeSmallWidth,height:t.sizeSmallHeight,padding:t.sizeSmallPadding},"large"===o.size&&{width:t.sizeLargeWidth,height:t.sizeLargeHeight,padding:t.sizeLargePadding},o.fluid&&{width:t.fluidWidth,height:t.fluidHeight},o.horizontal&&{flexDirection:"row"},o.compact&&{padding:t.compactPadding},o.centered&&{alignItems:"center"},o.disabled&&Object.assign({cursor:"not-allowed",color:t.colorDisabled,backgroundColor:t.backgroundColorDisabled,borderColor:t.borderColorDisabled,boxShadow:t.boxShadowDisabled},o.inverted&&{backgroundColor:t.invertedBackgroundColorDisabled},o.ghost&&{backgroundColor:t.ghostBackgroundColorDisabled},o.selected&&{backgroundColor:t.selectedBackgroundColorDisabled},{":hover":{boxShadow:t.boxShadowDisabled},":focus-visible":Object.assign({boxShadow:t.boxShadowDisabled},a[":focus-visible"]),":active":{boxShadow:t.boxShadowDisabled}}),o.expandable&&((r={})["& ."+ab]={maxHeight:t.expandableBoxStartMaxHeight,transition:t.expandableBoxExpandTransition,overflow:"hidden"},r["&:hover ."+ab]={maxHeight:t.expandableBoxEndMaxHeight,transition:t.expandableBoxExpandTransition},r["&:focus ."+ab]={maxHeight:t.expandableBoxEndMaxHeight,transition:t.expandableBoxExpandTransition},r))}},lb={root:function(e){var r=e.variables,o=e.props;return Object.assign({display:"flex",flexDirection:"column",margin:r.headerMargin},o.fitted&&{margin:r.fittedHeaderMargin})}},sb={root:function(e){var r=e.variables,o=e.props;return Object.assign({display:"flex",flexDirection:"column",margin:r.bodyMargin},o.fitted&&{margin:r.fittedBodyMargin})}},cb={root:function(e){var r=e.variables,o=e.props;return Object.assign({display:"flex",flexDirection:"column",margin:r.footerMargin},o.fitted&&{margin:r.fittedFooterMargin})}},db={root:function(e){var r=e.props,o=e.variables;return Object.assign({margin:o.previewMargin},r.horizontal&&{margin:o.previewMarginHorizontal},r.fitted&&{margin:o.fittedPreviewMargin})}},ub={root:function(e){var r=e.variables;return {position:"absolute",top:r.topControlsTop,right:r.topControlsRight}}},fb={root:function(){return {display:"flex"}}},gb="ui-input",pb=gb+"__input",bb={root:function(e){var r,o=e.props;return Object.assign({},!o.allowManualInput&&((r={})["& ."+pb]={cursor:"pointer"},r))}},mb={root:function(e){return {minHeight:e.variables.calendarMinHeight}}},hb={root:function(e){var r=e.variables;return {display:"flex",alignItems:"center",paddingTop:r.calendarHeaderPaddingTop,paddingBottom:r.calendarHeaderPaddingBottom}},label:function(e){var r=e.variables;return {fontWeight:r.calendarHeaderLabelFontWeight,flexGrow:1,paddingLeft:r.calendarHeaderLabelPaddingLeft}}},vb={root:function(e){var r=e.variables;return {textAlign:"center",verticalAlign:"middle",fontWeight:r.calendarHeaderCellFontWeight,height:r.calendarHeaderCellHeight,width:r.calendarHeaderCellWidth,padding:r.calendarHeaderCellPadding,display:"table-cell"}}},yb={root:function(e){var r=e.props,o=e.variables;return Object.assign({height:o.calendarCellHeight,width:o.calendarCellWidth,padding:o.calendarCellPadding,":hover":{backgroundColor:o.calendarCellHoverBackgroundColor,color:o.calendarCellHoverColor}},r.quiet&&{color:o.calendarCellQuietColor},r.selected&&{color:o.calendarCellSelectedColor,backgroundColor:o.calendarCellSelectedBackgroundColor},r.disabled&&{color:o.calendarCellDisabledColor,cursor:"default",backgroundColor:o.calendarCellDisabledBackgroundColor,":hover":{}})}},Cb={root:function(e){var r=e.props,o=e.variables,t=e.theme.siteVariables,n=t.borderWidth,a=cu({variables:t,borderPadding:n});return Object.assign({textAlign:"center",height:"100%",width:"100%",cursor:"pointer",border:o.calendarCellBorder,padding:o.calendarCellPadding,margin:o.calendarCellMargin,display:"table-cell",position:"relative"},a,{backgroundColor:o.calendarCellBackgroundColor,color:o.calendarCellColor,":hover":{backgroundColor:o.calendarCellHoverBackgroundColor,color:o.calendarCellHoverColor}},r.quiet&&{color:o.calendarCellQuietColor},r.selected&&{color:o.calendarCellSelectedColor,backgroundColor:o.calendarCellSelectedBackgroundColor},r.disabled&&{color:o.calendarCellDisabledColor,cursor:"default",backgroundColor:o.calendarCellDisabledBackgroundColor,":hover":{}},r.today&&{backgroundColor:o.calendarCellTodayBackgroundColor,color:o.calendarCellTodayColor,borderRadius:o.calendarCellTodayBorderRadius})}},kb={root:function(){return {"border-spacing":"0rem",tableLayout:"fixed"}}},wb={root:function(e){var r,o=e.props,t=e.variables;return Object.assign({},o.isRowSelectionActive&&((r={})[":hover .ui-datepicker__calendarcellbutton"]={backgroundColor:t.calendarCellHoverBackgroundColor,color:t.calendarCellHoverColor},r))}},xb=W({siteVariables:o,componentVariables:t,componentStyles:i,fontFaces:[{name:"Segoe UI",paths:["https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-regular.woff2"],props:{fontWeight:400}},{name:"Segoe UI",paths:["https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-semibold.woff2"],props:{fontWeight:600}},{name:"Segoe UI",paths:["https://static2.sharepointonline.com/files/fabric/assets/fonts/segoeui-westeuropean/segoeui-bold.woff2"],props:{fontWeight:700}}],staticStyles:["/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}",function(e){return {body:{padding:e.bodyPadding,margin:e.bodyMargin,fontFamily:e.bodyFontFamily,fontSize:e.bodyFontSize,lineHeight:e.bodyLineHeight},"*":{boxSizing:"border-box"},"*:before":{boxSizing:"border-box"},"*:after":{boxSizing:"border-box"},"[hidden]":{display:"none!important"}}}],animations:js});})();var i=a.en,l=a.kC,s=a.zt,c=a.Rl,d=a.xv,u=a.y0,f=a.It,g=a.$v;

// Copyright (c) Microsoft Corporation.
const wrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto'
});
const defaultTheme = react.mergeThemes(react.getTheme(), lightTheme);
/** Theme context for library's react components */
const ThemeContext = React.createContext(defaultTheme);
const initialFluentNorthstarTheme = f(g, {
    componentStyles: {
        ChatMessage: {
            root: {
                lineHeight: '1.4286'
            }
        }
    },
    fontFaces: [],
    // suppressing font faces from teamsTheme as recommended by FluentUI N* to avoid font styling to other elements
    siteVariables: {
        // suppressing body styles from teamsTheme to avoid inherited styling to other elements
        bodyPadding: undefined,
        bodyFontSize: undefined,
        bodyFontFamily: undefined,
        bodyBackground: undefined,
        bodyColor: undefined,
        bodyLineHeight: undefined
    }
});
/**
 * Provider to apply a Fluent theme across this library's react components.
 *
 * @remarks Components in this library are composed primarily from [Fluent UI](https://developer.microsoft.com/fluentui#/controls/web),
 * controls, and also from [Fluent React Northstar](https://fluentsite.z22.web.core.windows.net/0.53.0) controls.
 * This provider handles applying any theme provided to both the underlying Fluent UI controls, as well as the Fluent React Northstar controls.
 *
 * @public
 */
const FluentThemeProvider = (props) => {
    const { fluentTheme, rtl, children } = props;
    let fluentUITheme = react.mergeThemes(defaultTheme, fluentTheme);
    // merge in rtl from FluentThemeProviderProps
    fluentUITheme = react.mergeThemes(fluentUITheme, {
        rtl
    });
    const fluentNorthstarTheme = f(initialFluentNorthstarTheme, {
        componentVariables: {
            Chat: {
                backgroundColor: fluentUITheme.palette.white
            },
            ChatMessage: {
                authorColor: fluentUITheme.palette.neutralPrimary,
                contentColor: fluentUITheme.palette.neutralPrimary,
                backgroundColor: fluentUITheme.palette.neutralLighter,
                backgroundColorMine: fluentUITheme.palette.themeLight
            }
        },
        componentStyles: {
            ChatMessage: {
                timestamp: {
                    WebkitTextFillColor: fluentUITheme.palette.neutralSecondary
                }
            }
        }
        // add more northstar components to align with Fluent UI theme
    });
    return React__default['default'].createElement(ThemeContext.Provider, { value: fluentUITheme },
        React__default['default'].createElement(react.ThemeProvider, { theme: fluentUITheme, className: wrapper },
            React__default['default'].createElement(s, { theme: fluentNorthstarTheme, className: wrapper, rtl: rtl }, children)));
};
/**
 * React hook to access theme
 *
 * @public
 */
const useTheme = () => React.useContext(ThemeContext);

// Copyright (c) Microsoft Corporation.
const WifiWarning16Filled = () => 
// All ErrorBar icons are 16px x 16px (when 1rem = 16 px).
// There is no 16px version of this icon in the fluent icon package, so scale the larger
// one down to required size.
React__default['default'].createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.8)'
    }) },
    React__default['default'].createElement(reactIcons.WifiWarning20Filled, null));
const MoreHorizontal18Regular = () => 
// MoreHorizontal icons are 16px x 16px or 20px x 20px so scaling to get desired size
React__default['default'].createElement("div", { className: react.mergeStyles({
        transform: 'scale(0.9)'
    }) },
    React__default['default'].createElement(reactIcons.MoreHorizontal20Regular, null));
const GalleryLeftButton = () => {
    const rtl = useTheme().rtl;
    return rtl ? React__default['default'].createElement(reactIcons.ChevronRight20Regular, null) : React__default['default'].createElement(reactIcons.ChevronLeft20Regular, null);
};
const GalleryRightButton = () => {
    const rtl = useTheme().rtl;
    return rtl ? React__default['default'].createElement(reactIcons.ChevronLeft20Regular, null) : React__default['default'].createElement(reactIcons.ChevronRight20Regular, null);
};
/**
 * The default set of icons that are available to use in the UI components.
 *
 * @remark Icons used only in the composites are available in {@link DEFAULT_COMPOSITE_ICONS}.
 *
 * @public
 */
const DEFAULT_COMPONENT_ICONS = {
    ChatMessageOptions: React__default['default'].createElement(MoreHorizontal18Regular, null),
    ControlButtonCameraOff: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    ControlButtonCameraOn: React__default['default'].createElement(reactIcons.Video20Filled, null),
    ControlButtonEndCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    ControlButtonMicOff: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    ControlButtonMicOn: React__default['default'].createElement(reactIcons.Mic20Filled, null),
    ControlButtonOptions: React__default['default'].createElement(reactIcons.Settings20Filled, null),
    ControlButtonParticipants: React__default['default'].createElement(reactIcons.People20Filled, null),
    ControlButtonScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    ControlButtonScreenShareStop: React__default['default'].createElement(reactIcons.ShareScreenStop20Filled, null),
    EditBoxCancel: React__default['default'].createElement(reactIcons.Dismiss20Regular, null),
    EditBoxSubmit: React__default['default'].createElement(reactIcons.Checkmark20Regular, null),
    ErrorBarCallCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallCameraAlreadyInUse: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallLocalVideoFreeze: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallMacOsCameraAccessDenied: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    ErrorBarCallMacOsMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneAccessDenied: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallMicrophoneMutedBySystem: React__default['default'].createElement(reactIcons.MicOff16Filled, null),
    ErrorBarCallMicrophoneUnmutedBySystem: React__default['default'].createElement(reactIcons.Mic16Filled, null),
    ErrorBarCallNetworkQualityLow: React__default['default'].createElement(WifiWarning16Filled, null),
    ErrorBarCallNoMicrophoneFound: React__default['default'].createElement(reactIcons.MicProhibited16Filled, null),
    ErrorBarCallNoSpeakerFound: React__default['default'].createElement(reactIcons.SpeakerMute16Filled, null),
    ErrorBarClear: React__default['default'].createElement(reactIcons.Dismiss16Regular, null),
    ErrorBarCallVideoRecoveredBySystem: React__default['default'].createElement(reactIcons.Video16Filled, null),
    ErrorBarCallVideoStoppedBySystem: React__default['default'].createElement(reactIcons.VideoProhibited16Filled, null),
    HorizontalGalleryLeftButton: React__default['default'].createElement(GalleryLeftButton, null),
    HorizontalGalleryRightButton: React__default['default'].createElement(GalleryRightButton, null),
    MessageDelivered: React__default['default'].createElement(reactIcons.CheckmarkCircle16Regular, null),
    MessageEdit: React__default['default'].createElement(reactIcons.Edit20Regular, null),
    MessageFailed: React__default['default'].createElement(reactIcons.ErrorCircle16Regular, null),
    MessageRemove: React__default['default'].createElement(reactIcons.Delete20Regular, null),
    MessageResend: React__default['default'].createElement(reactIcons.ArrowClockwise16Regular, null),
    MessageSeen: React__default['default'].createElement(reactIcons.Eye16Regular, null),
    MessageSending: React__default['default'].createElement(reactIcons.Circle16Regular, null),
    OptionsCamera: React__default['default'].createElement(reactIcons.Video20Regular, null),
    OptionsMic: React__default['default'].createElement(reactIcons.Mic20Regular, null),
    OptionsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Regular, null),
    ParticipantItemMicOff: React__default['default'].createElement(reactIcons.MicOff16Regular, null),
    ParticipantItemOptions: React__default['default'].createElement(React__default['default'].Fragment, null),
    ParticipantItemOptionsHovered: React__default['default'].createElement(reactIcons.MoreHorizontal20Filled, null),
    ParticipantItemScreenShareStart: React__default['default'].createElement(reactIcons.ShareScreenStart20Filled, null),
    SendBoxSend: React__default['default'].createElement(reactIcons.Send20Regular, null),
    SendBoxSendHovered: React__default['default'].createElement(reactIcons.Send20Filled, null),
    VideoTileMicOff: React__default['default'].createElement(reactIcons.MicOff16Filled, null),
    SplitButtonPrimaryActionCameraOn: React__default['default'].createElement(reactIcons.Video20Filled, null),
    SplitButtonPrimaryActionCameraOff: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    SplitButtonPrimaryActionMicUnmuted: React__default['default'].createElement(reactIcons.Mic20Filled, null),
    SplitButtonPrimaryActionMicMuted: React__default['default'].createElement(reactIcons.MicOff20Filled, null)
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const inputBoxWrapperStyle = react.mergeStyles({
    padding: '0'
});
/**
 * @private
 */
const inputBoxStyle = react.mergeStyles({
    overflow: 'auto',
    minHeight: '2.25rem',
    // prevents the input text box from being sized to 0px when the CallWithChatComposite chat pane is closed.
    maxHeight: '8.25rem',
    outline: 'red 5px',
    fontWeight: react.FontWeights.regular,
    fontSize: '0.875rem',
    width: '100%',
    height: '2.25rem',
    lineHeight: '1.5rem',
    '::-webkit-input-placeholder': {
        fontSize: '0.875rem'
    },
    '::-moz-placeholder': {
        fontSize: '0.875rem'
    },
    ':-moz-placeholder': {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const inputBoxNewLineSpaceAffordance = {
    marginBottom: '2rem'
};
/**
 *
 * @private
 */
const textContainerStyle = {
    alignSelf: 'center',
    position: 'relative',
    width: '100%'
};
/**
 * @private
 */
const textFieldStyle = {
    root: {
        width: '100%',
        minHeight: '0',
        fontSize: '8.25rem'
    },
    wrapper: {},
    fieldGroup: {
        outline: 'none',
        border: 'none',
        height: 'auto',
        minHeight: '0',
        /**
         * Removing fieldGroup border to make sure no border is rendered around the text area in sendbox.
         */
        ':after': {
            border: 'none'
        }
    },
    field: {
        borderRadius: '0.25rem'
    }
};
/**
 * @private
 */
const inputButtonStyle = react.mergeStyles({
    color: 'grey',
    margin: 'auto',
    width: '1.0625rem',
    height: '1.0625rem',
    backgroundColor: 'transparent',
    '&:hover': {
        backgroundColor: 'transparent'
    }
});
/**
 * @private
 */
const newLineButtonsContainerStyle = {
    position: 'absolute',
    right: '0.8rem',
    bottom: '0.8rem',
    gap: '1rem'
};
/**
 * @private
 */
const inputButtonTooltipStyle = react.mergeStyles({
    // The toolTip host container show be a flex box, so that alignItems: 'center' works for inside buttons
    display: 'flex'
});
/**
 * @private
 */
const iconWrapperStyle$1 = react.mergeStyles({
    pointerEvents: 'none'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const isDarkThemed = (theme) => {
    const themeBlackBrightness = getPerceptualBrightnessOfHexColor(theme.palette.black);
    const themeWhiteBrightness = getPerceptualBrightnessOfHexColor(theme.palette.white);
    if (Number.isNaN(themeBlackBrightness) || Number.isNaN(themeWhiteBrightness)) {
        return false;
    }
    return themeBlackBrightness > themeWhiteBrightness;
};
const getPerceptualBrightnessOfHexColor = (hexColor) => {
    // return NaN if hexColor is not a hex code
    if (!/^#[0-9A-Fa-f]{6}$/i.test(hexColor)) {
        return NaN;
    }
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);
    // arithmetic mean μ of the red, green, and blue color coordinates. Source: https://en.wikipedia.org/wiki/Brightness
    return (r + g + b) / 3;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const InputBoxComponent = (props) => {
    const { styles, id, 'data-ui-id': dataUiId, textValue, onChange, textFieldRef, placeholderText, onKeyDown, onEnterKeyDown, supportNewline, inputClassName, errorMessage, disabled, children } = props;
    const mergedRootStyle = react.mergeStyles(inputBoxWrapperStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    const mergedInputFieldStyle = react.mergeStyles(inputBoxStyle, inputClassName, props.inlineChildren ? {} : inputBoxNewLineSpaceAffordance);
    const mergedTextContainerStyle = react.mergeStyles(textContainerStyle, styles === null || styles === void 0 ? void 0 : styles.textFieldContainer);
    const mergedTextFieldStyle = react.concatStyleSets(textFieldStyle, {
        fieldGroup: styles === null || styles === void 0 ? void 0 : styles.textField,
        errorMessage: styles === null || styles === void 0 ? void 0 : styles.systemMessage,
        suffix: {
            backgroundColor: 'transparent',
            padding: props.inlineChildren ? '0 0.25rem' : '0 0'
        }
    });
    const mergedChildrenStyle = react.mergeStyles(props.inlineChildren ? {} : newLineButtonsContainerStyle);
    const onTextFieldKeyDown = React.useCallback((ev) => {
        if (isEnterKeyEventFromCompositionSession(ev)) {
            return;
        }
        if (ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline)) {
            ev.preventDefault();
            onEnterKeyDown && onEnterKeyDown();
        }
        onKeyDown && onKeyDown(ev);
    }, [onEnterKeyDown, onKeyDown, supportNewline]);
    const onRenderChildren = () => {
        return React__default['default'].createElement(react.Stack, { horizontal: true, className: mergedChildrenStyle }, children);
    };
    const renderTextField = () => {
        const textFieldProps = {
            autoFocus: props.autoFocus === 'sendBoxTextField',
            multiline: true,
            autoAdjustHeight: true,
            multiple: false,
            resizable: false,
            componentRef: textFieldRef,
            id,
            inputClassName: mergedInputFieldStyle,
            placeholder: placeholderText,
            autoComplete: 'off',
            styles: mergedTextFieldStyle,
            disabled,
            errorMessage,
            onRenderSuffix: onRenderChildren
        };
        return React__default['default'].createElement(react.TextField, Object.assign({}, textFieldProps, { "data-ui-id": dataUiId, value: textValue, onChange: onChange, onKeyDown: onTextFieldKeyDown }));
    };
    return React__default['default'].createElement(react.Stack, { className: mergedRootStyle },
        React__default['default'].createElement("div", { className: mergedTextContainerStyle }, renderTextField()));
};
/**
 * @private
 */
const InputBoxButton = (props) => {
    const { onRenderIcon, onClick, ariaLabel, className, id, tooltipContent } = props;
    const [isHover, setIsHover] = React.useState(false);
    const mergedButtonStyle = react.mergeStyles(inputButtonStyle, className);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React__default['default'].createElement(react.TooltipHost, { hostClassName: inputButtonTooltipStyle, content: tooltipContent, calloutProps: Object.assign({}, calloutProps) },
        React__default['default'].createElement(react.IconButton, { className: mergedButtonStyle, ariaLabel: ariaLabel, onClick: onClick, id: id, onMouseEnter: () => {
                setIsHover(true);
            }, onMouseLeave: () => {
                setIsHover(false);
            }, 
            // VoiceOver fix: Avoid icon from stealing focus when IconButton is double-tapped to send message by wrapping with Stack with pointerEvents style to none
            onRenderIcon: () => React__default['default'].createElement(react.Stack, { className: iconWrapperStyle$1 }, onRenderIcon(isHover)) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * Announcer component to maker aria announcements on actions
 */
const Announcer$1 = (props) => {
    const { announcementString, ariaLive } = props;
    return React__default['default'].createElement(react.Stack, { "aria-label": announcementString, "aria-live": ariaLive, styles: announcerStyles });
};
/**
 * Styles to hide the announcer from view but still existing on the DOM tree it so that narration can happen.
 */
const announcerStyles = {
    root: {
        position: 'absolute',
        width: '1px',
        height: '1px',
        padding: 0,
        margin: '-1px',
        overflow: 'hidden',
        clip: 'rect(0,0,0,0)',
        whiteSpace: 'nowrap',
        border: 0
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SendBoxErrorBar = (props) => {
    const { error, dismissAfterMs, onDismiss } = props;
    const [errorMessage, setErrorMessage] = React__default['default'].useState(error === null || error === void 0 ? void 0 : error.message);
    // Using `any` because `NodeJS.Timeout` here will cause `declaration error` with jest.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const timeoutRef = React__default['default'].useRef();
    React__default['default'].useEffect(() => {
        setErrorMessage(error === null || error === void 0 ? void 0 : error.message);
    }, [error]);
    React.useEffect(() => {
        if (error && dismissAfterMs !== undefined) {
            timeoutRef.current = setTimeout(() => {
                setErrorMessage(undefined);
                onDismiss && onDismiss();
            }, dismissAfterMs);
        }
        return () => {
            timeoutRef.current && clearTimeout(timeoutRef.current);
        };
    }, [dismissAfterMs, onDismiss, error]);
    if (errorMessage) {
        return React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(Announcer$1, { announcementString: errorMessage, ariaLive: 'polite' }),
            React__default['default'].createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning, styles: {
                    iconContainer: {
                        display: 'none'
                    }
                } }, errorMessage));
    }
    else {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SendBoxErrors = (props) => {
    const { fileUploadError, fileUploadsPendingError } = props;
    const errorToDisplay = React__default['default'].useMemo(() => {
        if (fileUploadError && fileUploadsPendingError) {
            return fileUploadError.timestamp > fileUploadsPendingError.timestamp ? fileUploadError : fileUploadsPendingError;
        }
        return fileUploadError || fileUploadsPendingError;
    }, [fileUploadError, fileUploadsPendingError]);
    return React__default['default'].createElement(SendBoxErrorBar, { error: errorToDisplay, dismissAfterMs: 10 * 1000 });
};

// Copyright (c) Microsoft Corporation.
const EMPTY_MESSAGE_REGEX = /^\s*$/;
const MAXIMUM_LENGTH_OF_MESSAGE$1 = 8000;
/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
const SendBox = (props) => {
    const { disabled, systemMessage, supportNewline, onSendMessage, onTyping, onRenderIcon, onRenderSystemMessage, styles, autoFocus } = props;
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.sendBox;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const ids = useIdentifiers();
    const activeFileUploads = activeFileUploadsTrampoline();
    const [textValue, setTextValue] = React.useState('');
    const [textValueOverflow, setTextValueOverflow] = React.useState(false);
    const sendTextFieldRef = React__default['default'].useRef(null);
    const [fileUploadsPendingError, setFileUploadsPendingError] = React.useState(undefined);
    const sendMessageOnClick = () => {
        var _a;
        // don't send a message when disabled
        if (disabled || textValueOverflow) {
            return;
        }
        // Don't send message until all files have been uploaded successfully
        setFileUploadsPendingError(undefined);
        if (hasIncompleteFileUploads()) {
            return;
        }
        const message = textValue;
        // we don't want to send empty messages including spaces, newlines, tabs
        // Message can be empty if there is a valid file upload
        if (!EMPTY_MESSAGE_REGEX.test(message) || hasFile()) {
            onSendMessage && onSendMessage(sanitizeText(message));
            setTextValue('');
        }
        (_a = sendTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const setText = (newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE$1) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow ? strings.textTooLong : undefined;
    const errorMessage = systemMessage !== null && systemMessage !== void 0 ? systemMessage : textTooLongMessage;
    const mergedSendButtonStyle = React.useMemo(() => react.mergeStyles(sendButtonStyle, styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer), [styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer]);
    const mergedStyles = React.useMemo(() => react.concatStyleSets(styles), [styles]);
    const hasText = !!textValue;
    const hasTextOrFile = hasText || hasFile();
    const mergedSendIconStyle = React.useMemo(() => react.mergeStyles(sendIconStyle, {
        color: !!errorMessage || !hasTextOrFile ? theme.palette.neutralTertiary : theme.palette.themePrimary
    }, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon), [errorMessage, hasTextOrFile, theme, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon]);
    const onRenderSendIcon = React.useCallback((isHover) => onRenderIcon ? onRenderIcon(isHover) : React__default['default'].createElement(react.Icon, { iconName: isHover && textValue ? 'SendBoxSendHovered' : 'SendBoxSend', className: mergedSendIconStyle }), [mergedSendIconStyle, onRenderIcon, textValue]);
    // Ensure that errors are cleared when there are no files in sendBox
    React__default['default'].useEffect(() => {
        if (!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(upload => !upload.error).length)) {
            setFileUploadsPendingError(undefined);
        }
    }, [activeFileUploads]);
    const sendBoxErrorsProps = React.useMemo(() => {
        var _a;
        return {
            fileUploadsPendingError: fileUploadsPendingError,
            fileUploadError: (_a = activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(fileUpload => fileUpload.error).pop()) === null || _a === void 0 ? void 0 : _a.error
        };
    }, [activeFileUploads, fileUploadsPendingError]);
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(sendBoxWrapperStyles, {
            overflow: 'visible'
        } // This is needed for the mention popup to be visible
        ) },
        React__default['default'].createElement(SendBoxErrors, Object.assign({}, sendBoxErrorsProps)),
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(borderAndBoxShadowStyle({
                theme,
                hasErrorMessage: !!errorMessage,
                disabled: !!disabled
            })) },
            React__default['default'].createElement(InputBoxComponent, { autoFocus: autoFocus, "data-ui-id": ids.sendboxTextField, inlineChildren: true, disabled: disabled, errorMessage: onRenderSystemMessage ? onRenderSystemMessage(errorMessage) : errorMessage, textFieldRef: sendTextFieldRef, id: "sendbox", placeholderText: strings.placeholderText, textValue: textValue, onChange: (_, newValue) => setText(newValue), onKeyDown: ev => {
                    const keyWasSendingMessage = ev.key === 'Enter' && (ev.shiftKey === false || !supportNewline);
                    if (!keyWasSendingMessage) {
                        onTyping === null || onTyping === void 0 ? void 0 : onTyping();
                    }
                }, onEnterKeyDown: () => {
                    sendMessageOnClick();
                }, styles: mergedStyles, supportNewline: supportNewline, maxLength: MAXIMUM_LENGTH_OF_MESSAGE$1 },
                React__default['default'].createElement(InputBoxButton, { onRenderIcon: onRenderSendIcon, onClick: e => {
                        if (!textValueOverflow) {
                            sendMessageOnClick();
                        }
                        e.stopPropagation();
                    }, id: 'sendIconWrapper', className: mergedSendButtonStyle, ariaLabel: localeStrings.sendButtonAriaLabel, tooltipContent: localeStrings.sendButtonAriaLabel }))));
};
/**
 * @private
 */
const hasIncompleteFileUploads = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline();
    return !!((activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.length) && !activeFileUploads.filter(fileUpload => !fileUpload.error).every(fileUpload => fileUpload.uploadComplete));
};
const hasFile = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline();
    return !!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.find(file => !file.error));
};
const sanitizeText = (message) => {
    if (EMPTY_MESSAGE_REGEX.test(message)) {
        return '';
    }
    else {
        return message;
    }
};
const activeFileUploadsTrampoline = (props) => {
    return [];
};

// Copyright (c) Microsoft Corporation.
/** @private */
const MESSAGE_STATUS_INDICATOR_SIZE_REM = 1;
/**
 * ErrorIcon seems designed slightly smaller than other icons we try to match the size and then fix positioning here.
 *
 * @private
 */
const MessageStatusIndicatorErrorIconStyle = react.mergeStyles({
    marginRight: '-0.06rem',
    fontSize: '1.06rem'
});
/**
 * @private
 */
const MessageStatusIndicatorIconStyle = react.mergeStyles({
    fontSize: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`,
    height: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});

// Copyright (c) Microsoft Corporation.
/** @private */
const AnnouncerContext = React__default['default'].createContext({
    announceAssertive: logContextWarning,
    announcePolite: logContextWarning
});
function logContextWarning() {
    console.warn('Announcement failed, LiveAnnouncer context is missing');
}

// Copyright (c) Microsoft Corporation.
/** @private */
const AnnouncerMessage = (props) => {
    const { message, ariaLive, clearOnUnmount, announceAssertive, announcePolite } = props;
    const announce = React.useCallback(() => {
        if (ariaLive === 'assertive') {
            announceAssertive(message || '', uuid.v1());
        }
        if (ariaLive === 'polite') {
            announcePolite(message || '', uuid.v1());
        }
    }, [announceAssertive, announcePolite, ariaLive, message]);
    React.useEffect(() => {
        announce();
        return () => {
            if (clearOnUnmount) {
                announceAssertive('', uuid.v1());
                announcePolite('', uuid.v1());
            }
        };
    }, [message, clearOnUnmount, announce, announceAssertive, announcePolite]);
    return null;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const LiveMessage = (props) => React__default['default'].createElement(AnnouncerContext.Consumer, null, contextProps => React__default['default'].createElement(AnnouncerMessage, Object.assign({}, contextProps, props)));

// Copyright (c) Microsoft Corporation.
/**
 * Component to display the status of a sent message.
 *
 * Adds an icon and tooltip corresponding to the message status.
 *
 * @public
 */
const MessageStatusIndicator = (props) => {
    const { status, styles, remoteParticipantsCount, onToggleToolTip, readCount } = props;
    const localeStrings = useLocale$1().strings.messageStatusIndicator;
    const [isTooltipToggled, setIsTooltipToggled] = React.useState(false);
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    switch (status) {
        case 'failed':
            return React__default['default'].createElement(react.TooltipHost, { content: strings.failedToSendTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                strings.failedToSendAriaLabel &&
                    // live message is used here and in the following tooltips so that aria labels are announced on mobile
                    React__default['default'].createElement(LiveMessage, { message: strings.failedToSendAriaLabel, ariaLive: "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.failedToSendAriaLabel, iconName: "MessageFailed", className: react.mergeStyles(MessageStatusIndicatorErrorIconStyle, {
                        color: theme.palette.redDark
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'sending':
            return React__default['default'].createElement(react.TooltipHost, { content: strings.sendingTooltipText, "data-ui-id": "chat-composite-message-tooltip", calloutProps: Object.assign({}, calloutProps), styles: hostStyles$1 },
                strings.sendingAriaLabel && React__default['default'].createElement(LiveMessage, { message: strings.sendingAriaLabel, ariaLive: "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.sendingAriaLabel, iconName: "MessageSending", className: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'seen':
            return React__default['default'].createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1, content: 
                // when it's just 1 to 1 texting, we don't need to know who has read the message, just show message as 'seen'
                // when readcount is 0, we have a bug, show 'seen' to cover up as a fall back
                // when participant count is 0, we have a bug, show 'seen' to cover up as a fall back
                readCount === 0 || remoteParticipantsCount && remoteParticipantsCount <= 1 || !readCount || !remoteParticipantsCount || strings.readByTooltipText === undefined ? strings.seenTooltipText : _formatString(strings.readByTooltipText, {
                    messageThreadReadCount: `${readCount}`,
                    remoteParticipantsCount: `${remoteParticipantsCount}`
                }), onTooltipToggle: () => {
                    if (onToggleToolTip) {
                        onToggleToolTip(!isTooltipToggled);
                        setIsTooltipToggled(!isTooltipToggled);
                    }
                } },
                strings.seenAriaLabel && React__default['default'].createElement(LiveMessage, { message: strings.seenAriaLabel, ariaLive: "polite" }),
                React__default['default'].createElement(react.Icon, { "data-ui-id": "chat-composite-message-status-icon", role: "status", "aria-label": strings.seenAriaLabel, iconName: "MessageSeen", className: react.mergeStyles({
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        case 'delivered':
            return React__default['default'].createElement(react.TooltipHost, { calloutProps: Object.assign({}, calloutProps), content: strings.deliveredTooltipText, "data-ui-id": "chat-composite-message-tooltip", styles: hostStyles$1 },
                strings.deliveredAriaLabel && React__default['default'].createElement(LiveMessage, { message: strings.deliveredAriaLabel, ariaLive: "polite" }),
                React__default['default'].createElement(react.Icon, { role: "status", "data-ui-id": "chat-composite-message-status-icon", "aria-label": strings.deliveredAriaLabel, iconName: "MessageDelivered", className: react.mergeStyles(MessageStatusIndicatorIconStyle, {
                        color: theme.palette.themePrimary
                    }, styles === null || styles === void 0 ? void 0 : styles.root) }));
        default:
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};
// The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles$1 = {
    root: {
        display: 'inline-block'
    }
};

// Copyright (c) Microsoft Corporation.
// Minimum chat bubble width. This matches the minimum chat bubble width from FluentUI
// that can contain a message and a timestamp.
const CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM = 6.25;
// Chat messages should span just short of the width of the container.
// When calculating the width of a message we also must take into account
// the width of the avatar/gutter and the gap between the message and avatar/gutter.
const AVATAR_WIDTH_REM = 2;
const AVATAR_MESSAGE_GAP_REM = 0.5;
const MESSAGE_AMOUNT_OUT_FROM_EDGE_REM = 2;
// Avatars should display on top of chat messages when the chat thread is narrow
const MESSAGE_AVATAR_OVERLAP_REM = 0.425;
const CHAT_MESSAGE_ZINDEX = 1;
const AVATAR_ZINDEX = 2;
// new message button should be on top of chat message
const NEW_MESSAGE_BUTTON_ZINDEX = 2;
/**
 * @private
 */
const messageThreadContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    maxHeight: '100%',
    overflow: 'auto',
    position: 'relative',
    alignSelf: 'center'
});
/**
 * @private
 */
const noMessageStatusStyle = react.mergeStyles({
    // This should match the size of the message status indicator icon to ensure
    // multiple messages sent by the user are aligned correctly.
    width: `${MESSAGE_STATUS_INDICATOR_SIZE_REM}rem`
});
/**
 * @private
 */
const chatStyle = {
    paddingBottom: '0.5rem',
    paddingTop: '0.8rem',
    border: 'none',
    overflow: 'auto',
    // `height: 100%` ensures that the Chat component covers 100% of it's parents height
    // to prevent intermittent scrollbars when gifs are present in the chat.
    height: '100%'
};
/**
 * @private
 */
const newMessageButtonContainerStyle = react.mergeStyles({
    position: 'absolute',
    zIndex: NEW_MESSAGE_BUTTON_ZINDEX,
    bottom: 0,
    right: '1.5rem'
});
/**
 * @private
 */
const defaultChatItemMessageContainer = (overlapAvatarAndMessage) => {
    const messageAvatarGap = overlapAvatarAndMessage ? -MESSAGE_AVATAR_OVERLAP_REM : AVATAR_MESSAGE_GAP_REM;
    return {
        marginRight: '0rem',
        marginLeft: `${messageAvatarGap}rem`,
        width: `calc(100% - ${AVATAR_WIDTH_REM + MESSAGE_AMOUNT_OUT_FROM_EDGE_REM + messageAvatarGap}rem)`,
        zIndex: CHAT_MESSAGE_ZINDEX,
        '& msft-mention': {
            color: '#D83B01',
            fontWeight: 600
        }
    };
};
/**
 * @private
 */
const defaultMyChatMessageContainer = {
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginLeft: '0rem',
    // This makes message bubble show border in high contrast mode making each message distinguishable
    border: '1px solid transparent'
};
/**
 * @private
 */
const FailedMyChatMessageContainer = Object.assign(Object.assign({}, defaultChatItemMessageContainer), { backgroundColor: 'rgba(168, 0, 0, 0.2)' });
/**
 * @private
 */
const defaultChatMessageContainer = (theme) => ({
    maxWidth: '100%',
    minWidth: `${CHAT_MESSAGE_CONTAINER_MIN_WIDTH_REM}rem`,
    marginRight: '0rem',
    '& img': {
        maxWidth: '100% !important',
        // Add !important to make sure it won't be overridden by style defined in element
        height: 'auto !important'
    },
    '& p': {
        // Deal with awkward padding seen in messages from Teams.
        // For more info see https://github.com/Azure/communication-ui-library/pull/1507
        marginBlock: '0.125rem'
    },
    '& blockquote': {
        backgroundColor: theme.palette.white,
        clear: 'left',
        minHeight: '2.25rem',
        width: 'fit-content',
        margin: '7px 0px',
        padding: '7px 15px',
        border: 'solid',
        borderRadius: '4px',
        borderWidth: '1px',
        borderColor: theme.palette.neutralQuaternary,
        borderLeftWidth: '4px'
    },
    '& table': {
        backgroundColor: theme.palette.white,
        border: theme.palette.neutralQuaternary,
        borderCollapse: 'collapse',
        tableLayout: 'auto',
        width: '100%',
        '& tr': {
            border: `1px solid ${theme.palette.neutralQuaternary}`,
            '& td': {
                border: `1px solid ${theme.palette.neutralQuaternary}`,
                wordBreak: 'normal',
                padding: '0px 5px'
            }
        }
    },
    // This makes message bubble show border in high contrast mode making each message distinguishable
    border: '1px solid transparent'
});
/**
 * @private
 */
const gutterWithAvatar = {
    width: `${AVATAR_WIDTH_REM}rem`,
    position: 'relative',
    float: 'left',
    display: 'block',
    visibility: 'visible',
    zIndex: AVATAR_ZINDEX
};
/**
 * @private
 */
const gutterWithHiddenAvatar = Object.assign(Object.assign({}, gutterWithAvatar), { visibility: 'hidden', 
    // we use this hidden avatar just as a width placeholder
    // the placeholder is needed for responsive bubble width
    height: 0 });
/**
 * @private
 */
const messageStatusContainerStyle = (mine) => react.mergeStyles({
    marginLeft: mine ? '0.25rem' : '0rem'
});
/**
 * @private
 */
const newMessageButtonStyle = react.mergeStyles({
    float: 'right',
    width: 'fit-content'
});
/**
 * @private
 */
const buttonWithIconStyles$1 = {
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
react.mergeStyles({
    border: 'none',
    minHeight: '1.5rem',
    '&:hover': {
        background: 'none'
    },
    '&:active': {
        background: 'none'
    }
});
/**
 * @private
 */
const DownIconStyle = react.mergeStyles({
    marginRight: '0.5em'
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const delay = (delay) => {
    return new Promise(function (resolve) {
        setTimeout(resolve, delay);
    });
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const systemMessageIconStyle = react.mergeStyles({
    margin: '0 0.688rem 0 0'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SystemMessage = (props) => {
    const { iconName, content } = props;
    const Icon = React__default['default'].createElement(react.FontIcon, { iconName: iconName, className: react.mergeStyles(systemMessageIconStyle) });
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(props === null || props === void 0 ? void 0 : props.containerStyle), tabIndex: 0 },
        Icon,
        React__default['default'].createElement(react.Text, { style: {
                wordBreak: 'break-word'
            }, role: "status", title: content }, content));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const editBoxStyle = (inlineEditButtons) => {
    const paddingRight = inlineEditButtons ? {} : {
        paddingRight: '0.5rem'
    };
    return react.mergeStyles(Object.assign({ marginTop: '0.0875rem', marginBottom: '0.0875rem' }, paddingRight));
};
/**
 * @private
 */
const editingButtonStyle = react.mergeStyles({
    margin: 'auto .3rem'
});
/**
 * @private
 */
const inputBoxIcon = react.mergeStyles({
    margin: 'auto',
    '&:hover svg': {
        stroke: 'currentColor'
    }
});
/**
 * @private
 */
const editBoxStyleSet = {
    root: {
        width: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Conditionally modify locale strings passed to the file card
 * @returns file upload card strings
 */
const useLocaleFileCardStringsTrampoline = () => {
    return {
        removeFile: '',
        uploadCompleted: '',
        uploading: ''
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * A component for displaying a file card with file icon and progress bar.
 */
const _FileCard = (props) => {
    var _a, _b, _c, _d;
    const { fileName, fileExtension, progress, actionIcon } = props;
    const theme = react.useTheme();
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const localeStrings = useLocaleFileCardStringsTrampoline();
    const uploadStartedString = (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.uploading) !== null && _b !== void 0 ? _b : localeStrings.uploading;
    const uploadCompletedString = (_d = (_c = props.strings) === null || _c === void 0 ? void 0 : _c.uploadCompleted) !== null && _d !== void 0 ? _d : localeStrings.uploadCompleted;
    const showProgressIndicator = progress !== undefined && progress > 0 && progress < 1;
    React.useEffect(() => {
        if (showProgressIndicator) {
            setAnnouncerString(`${uploadStartedString} ${fileName}`);
        }
        else if (progress === 1) {
            setAnnouncerString(`${fileName} ${uploadCompletedString}`);
        }
        else {
            setAnnouncerString(undefined);
        }
    }, [progress, showProgressIndicator, fileName, uploadStartedString, uploadCompletedString]);
    const progressBarThicknessPx = 4;
    const containerClassName = react.mergeStyles({
        width: '12rem',
        background: theme.palette.neutralLighter,
        borderRadius: theme.effects.roundedCorner4,
        border: `${_pxToRem(1)} solid ${theme.palette.neutralQuaternary}`,
        cursor: 'pointer'
    });
    const fileInfoWrapperClassName = react.mergeStyles({
        padding: _pxToRem(12),
        // To make space for the progress indicator.
        paddingBottom: showProgressIndicator ? _pxToRem(12 - progressBarThicknessPx * 2) : _pxToRem(12)
    });
    const fileNameContainerClassName = react.mergeStyles({
        paddingLeft: _pxToRem(4),
        minWidth: '75%',
        maxWidth: '75%'
    });
    const fileNameTextClassName = react.mergeStyles({
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        lineHeight: 'normal',
        whiteSpace: 'nowrap',
        paddingRight: _pxToRem(4)
    });
    const actionIconClassName = react.mergeStyles({
        cursor: 'pointer'
    });
    const progressIndicatorStyles = {
        itemProgress: {
            padding: `${_pxToRem(progressBarThicknessPx - 1)} 0`,
            // item progress height won't apply without an explicit padding
            // To make the progress indicator border curve along the bottom of file card.
            borderRadius: `0 0 ${theme.effects.roundedCorner4} ${theme.effects.roundedCorner4}`
        },
        progressBar: {
            height: _pxToRem(progressBarThicknessPx)
        }
    };
    return React__default['default'].createElement("div", { "data-is-focusable": true },
        React__default['default'].createElement(Announcer$1, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(react.Stack, { className: containerClassName, onClick: () => {
                var _a;
                (_a = props.actionHandler) === null || _a === void 0 ? void 0 : _a.call(props);
            } },
            React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", verticalAlign: "center", className: fileInfoWrapperClassName },
                React__default['default'].createElement(react.Stack, null,
                    React__default['default'].createElement(react.Icon, { "data-ui-id": 'filetype-icon', iconName: reactFileTypeIcons.getFileTypeIconProps({
                            extension: fileExtension,
                            size: 24,
                            imageFileType: 'svg'
                        }).iconName })),
                React__default['default'].createElement(react.Stack, { className: fileNameContainerClassName },
                    React__default['default'].createElement(react.Text, { className: fileNameTextClassName }, fileName)),
                React__default['default'].createElement(react.Stack, { verticalAlign: "center", className: actionIconClassName }, actionIcon && actionIcon)),
            showProgressIndicator && React__default['default'].createElement(react.ProgressIndicator, { percentComplete: progress, styles: progressIndicatorStyles })));
};

// Copyright (c) Microsoft Corporation.
/**
 * Note: If we use stack tokens.childrenGap, when child elements are wrapped and moved to the next line,
 * an extra margin is added to the left of each line.
 * This is a workaround to avoid this issue.
 */
const fileCardGroupClassName = react.mergeStyles({
    flexFlow: 'row wrap',
    '& > *': {
        margin: _pxToRem(2)
    },
    /**
     * margin for children is overriden by parent stack, so adding left margin for each child
     */
    '& > *:not(:first-child)': {
        marginLeft: _pxToRem(2)
    }
});
/**
 * @internal
 * Used with `_FileCard` component where `_FileCard` components are passed as children.
 * Renders the children equally spaced in multiple rows.
 */
const _FileCardGroup = (props) => {
    const { children, ariaLabel } = props;
    if (!children) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: fileCardGroupClassName, "aria-label": ariaLabel }, children);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const iconButtonClassName = react.mergeStyles({
    color: 'unset',
    width: '1rem',
    height: '1rem',
    background: 'transparent',
    ':hover': {
        color: 'unset',
        background: 'transparent'
    }
});

// Copyright (c) Microsoft Corporation.
const actionIconStyle$1 = {
    height: '1rem'
};
/**
 * @internal
 */
const _FileUploadCards = (props) => {
    var _a;
    const files = props.activeFileUploads;
    const localeStrings = useLocaleFileCardStringsTrampoline();
    const removeFileButtonString = React.useMemo(() => () => {
        var _a, _b;
        return (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.removeFile) !== null && _b !== void 0 ? _b : localeStrings.removeFile;
    }, [(_a = props.strings) === null || _a === void 0 ? void 0 : _a.removeFile, localeStrings.removeFile]);
    if (!files || files.length === 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(_FileCardGroup, null, files && files.filter(file => !file.error).map(file => React__default['default'].createElement(_FileCard, { fileName: file.filename, progress: file.progress, key: file.id, fileExtension: extension(file.filename), actionIcon: React__default['default'].createElement(react.IconButton, { className: iconButtonClassName, ariaLabel: removeFileButtonString() },
            React__default['default'].createElement(react.Icon, { iconName: "CancelFileUpload", style: actionIconStyle$1 })), actionHandler: () => {
            props.onCancelFileUpload && props.onCancelFileUpload(file.id);
        }, strings: props.strings })));
};

// Copyright (c) Microsoft Corporation.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM$1 = 3;
/**
 * @private
 */
const chatActionsCSS = {
    'ul&': {
        right: '0',
        left: 'auto',
        top: '-1.2rem',
        bottom: 'auto',
        position: 'absolute'
    },
    '& a': {
        margin: '0',
        padding: '0',
        border: '0'
    }
};
/**
 * @private
 */
const iconWrapperStyle = (theme, isSubMenuOpen) => ({
    root: {
        margin: _pxToRem(3),
        // Show hover styles when the Edit/Delete menu is showing as this action button is still considered 'active'
        color: isSubMenuOpen ? theme.palette.black : theme.palette.neutralPrimary,
        strokeWidth: isSubMenuOpen ? _pxToRem(0.5) : _pxToRem(0),
        stroke: theme.palette.black,
        ':hover, :focus': {
            color: theme.palette.black,
            strokeWidth: _pxToRem(0.5)
        }
    }
});
/**
 * @private
 */
const chatMessageDateStyle = react.mergeStyles({
    fontWeight: react.FontWeights.semibold
});
/**
 * @private
 */
const chatMessageEditedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.semibold,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const chatMessageFailedTagStyle = (theme) => react.mergeStyles({
    fontWeight: react.FontWeights.light,
    color: theme.semanticColors.errorText
});
/**
 * @private
 */
const chatMessageMenuStyle = react.mergeStyles({
    minWidth: '8.5rem',
    height: 'max-content',
    cursor: 'pointer',
    overflow: 'hidden'
});
/**
 * @private
 */
const chatMessageEditContainerStyle = {
    margin: 0,
    padding: 0,
    maxWidth: 'unset',
    minWidth: 'unset',
    backgroundColor: 'transparent'
};
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const menuItemIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM$1}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset'
    }
};
/**
 * @private
 */
const menuIconStyleSet = {
    root: {
        height: 'calc(100% - 8px)',
        // Adjust for the pixel margin Fluent applies
        width: '1.25rem'
    }
};
/**
 * @private
 */
const menuSubIconStyleSet = {
    root: {
        height: 'unset',
        lineHeight: '100%',
        width: '1.25rem'
    }
};

// Copyright (c) Microsoft Corporation.
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const onRenderCancelIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, {
        color
    });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxCancel', className: className });
};
const onRenderSubmitIcon = (color) => {
    const className = react.mergeStyles(inputBoxIcon, {
        color
    });
    return React__default['default'].createElement(react.Icon, { iconName: 'EditBoxSubmit', className: className });
};
/**
 * @private
 */
const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, strings, message } = props;
    const [textValue, setTextValue] = React.useState(message.content || '');
    const [attachedFilesMetadata, setAttachedFilesMetadata] = React__default['default'].useState(getMessageAttachedFilesMetadata());
    const editTextFieldRef = React__default['default'].useRef(null);
    const theme = useTheme();
    const messageState = getMessageState(textValue, attachedFilesMetadata !== null && attachedFilesMetadata !== void 0 ? attachedFilesMetadata : []);
    const submitEnabled = messageState === 'OK';
    React.useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        setTextValue(newValue !== null && newValue !== void 0 ? newValue : '');
    };
    const textTooLongMessage = messageState === 'too long' ? _formatString(strings.editBoxTextLimit, {
        limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}`
    }) : undefined;
    const onRenderThemedCancelIcon = React.useCallback(() => onRenderCancelIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const onRenderThemedSubmitIcon = React.useCallback(() => onRenderSubmitIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const editBoxStyles = React.useMemo(() => {
        return react.concatStyleSets(editBoxStyleSet, {
            textField: {
                borderColor: theme.palette.themePrimary
            }
        });
    }, [theme.palette.themePrimary]);
    const onRenderFileUploads = React.useCallback(() => {
        return (attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.length) && React__default['default'].createElement("div", { style: {
                margin: '0.25rem'
            } },
            React__default['default'].createElement(_FileUploadCards, { activeFileUploads: attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.map(file => ({
                    id: file.name,
                    filename: file.name,
                    progress: 1
                })), onCancelFileUpload: fileId => {
                    setAttachedFilesMetadata(attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.filter(file => file.name !== fileId));
                } }));
    }, [attachedFilesMetadata]);
    const getContent = () => {
        return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(borderAndBoxShadowStyle({
                theme,
                hasErrorMessage: message.failureReason !== undefined,
                disabled: false
            })) },
            React__default['default'].createElement(InputBoxComponent, { inlineChildren: props.inlineEditButtons, id: 'editbox', textFieldRef: editTextFieldRef, inputClassName: editBoxStyle(props.inlineEditButtons), placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onKeyDown: ev => {
                    if (ev.key === 'ArrowUp' || ev.key === 'ArrowDown') {
                        ev.stopPropagation();
                    }
                }, onEnterKeyDown: () => {
                    submitEnabled && onSubmit(textValue, message.metadata, {
                        attachedFilesMetadata
                    });
                }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles },
                React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, tooltipContent: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                        onCancel && onCancel(message.messageId);
                    }, id: 'dismissIconWrapper' }),
                React__default['default'].createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, tooltipContent: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: e => {
                        submitEnabled && onSubmit(textValue, message.metadata, {
                            attachedFilesMetadata
                        });
                        e.stopPropagation();
                    }, id: 'submitIconWrapper' })),
            message.failureReason && React__default['default'].createElement("div", { className: react.mergeStyles(chatMessageFailedTagStyle(theme), {
                    padding: '0.5rem'
                }) }, message.failureReason),
            onRenderFileUploads());
    };
    return React__default['default'].createElement(i.Message, { styles: chatMessageEditContainerStyle, content: getContent() });
};
const isMessageTooLong = (messageText) => messageText.length > MAXIMUM_LENGTH_OF_MESSAGE;
const isMessageEmpty = (messageText, attachedFilesMetadata) => messageText.trim().length === 0 && attachedFilesMetadata.length === 0;
const getMessageState = (messageText, attachedFilesMetadata) => isMessageEmpty(messageText, attachedFilesMetadata) ? 'too short' : isMessageTooLong(messageText) ? 'too long' : 'OK';
// @TODO: Remove when file-sharing feature becomes stable.
const getMessageAttachedFilesMetadata = (message) => {
    return [];
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const formatTimeForChatMessage = (messageDate) => {
    let hours = messageDate.getHours();
    let minutes = messageDate.getMinutes().toString();
    const isAm = hours < 12;
    if (hours > 12) {
        hours = hours - 12;
    }
    if (hours === 0) {
        hours = 12;
    }
    if (minutes.length < 2) {
        minutes = '0' + minutes;
    }
    return hours.toString() + ':' + minutes + ' ' + (isAm ? 'a.m.' : 'p.m.');
};
/**
 * @private
 */
const formatDateForChatMessage = (messageDate) => {
    const year = messageDate.getFullYear().toString();
    let month = (messageDate.getMonth() + 1).toString();
    let day = messageDate.getDate().toString();
    if (month.length === 1) {
        month = '0' + month;
    }
    if (day.length === 1) {
        day = '0' + day;
    }
    return year + '-' + month + '-' + day;
};
/**
 * Given a message date object in ISO8601 and a current date object, generates a user friendly timestamp text like the
 * following:
 *
 * 1:30 p.m.
 * Yesterday 1:30 p.m.
 * Monday 1:30 p.m.
 * 2021-01-10 1:30 p.m.
 *
 * If message is after yesterday, then only show the time.
 * If message is before yesteray and after day before yesterday, then show 'Yesterday' plus the time.
 * If message is before day before yesterday and within the current week, then show 'Monday/Tuesday/etc' plus the time.
 *   - We consider start of the week as Sunday. If current day is Sunday, then any time before that is in previous week.
 * If message is in previous or older weeks, then show date string plus the time.
 *
 * @param messageDate - date of message
 * @param currentDate - date used as offset to create the user friendly timestamp (e.g. to create 'Yesterday' instead of an absolute date)
 *
 * @private
 */
const formatTimestampForChatMessage = (messageDate, todayDate, dateStrings) => {
    // If message was in the same day timestamp string is just the time like '1:30 p.m.'.
    const startOfDay = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
    if (messageDate > startOfDay) {
        return formatTimeForChatMessage(messageDate);
    }
    // If message was yesterday then timestamp string is like this 'Yesterday 1:30 p.m.'.
    const yesterdayDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - 1);
    if (messageDate > yesterdayDate) {
        return dateStrings.yesterday + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before Sunday and today is Sunday (start of week) then timestamp string is like
    // '2021-01-10 1:30 p.m.'.
    const weekDay = todayDate.getDay();
    if (weekDay === 0) {
        return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message was before first day of the week then timestamp string is like Monday 1:30 p.m.
    const firstDayOfTheWeekDate = new Date(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate() - weekDay);
    if (messageDate > firstDayOfTheWeekDate) {
        return dayToDayName(messageDate.getDay(), dateStrings) + ' ' + formatTimeForChatMessage(messageDate);
    }
    // If message date is in previous or older weeks then timestamp string is like 2021-01-10 1:30 p.m.
    return formatDateForChatMessage(messageDate) + ' ' + formatTimeForChatMessage(messageDate);
};
const dayToDayName = (day, dateStrings) => {
    switch (day) {
        case 0:
            return dateStrings.sunday;
        case 1:
            return dateStrings.monday;
        case 2:
            return dateStrings.tuesday;
        case 3:
            return dateStrings.wednesday;
        case 4:
            return dateStrings.thursday;
        case 5:
            return dateStrings.friday;
        case 6:
            return dateStrings.saturday;
        default:
            throw new Error(`Invalid day [${day}] passed`);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Chat message actions flyout that contains actions such as Edit Message, or Remove Message.
 *
 * @private
 */
const ChatMessageActionFlyout = (props) => {
    var _a, _b;
    const theme = react.useTheme();
    const messageReadByCount = (_a = props.messageReadBy) === null || _a === void 0 ? void 0 : _a.length;
    const sortedMessageReadyByList = [...((_b = props.messageReadBy) !== null && _b !== void 0 ? _b : [])].sort((a, b) => a.displayName.localeCompare(b.displayName));
    const messageReadByList = sortedMessageReadyByList === null || sortedMessageReadyByList === void 0 ? void 0 : sortedMessageReadyByList.map(person => {
        const personaOptions = {
            hidePersonaDetails: true,
            size: react.PersonaSize.size24,
            text: person.displayName,
            showOverflowTooltip: false,
            styles: {
                root: {
                    margin: '0.25rem'
                }
            }
        };
        const { onRenderAvatar } = props;
        return {
            key: person.displayName,
            text: person.displayName,
            itemProps: {
                styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
            },
            onRenderIcon: () => { var _a; return onRenderAvatar ? onRenderAvatar((_a = person.id) !== null && _a !== void 0 ? _a : '', personaOptions) : React__default['default'].createElement(react.Persona, Object.assign({}, personaOptions)); },
            iconProps: {
                styles: menuIconStyleSet
            }
        };
    });
    const menuItems = React.useMemo(() => {
        const items = [{
                key: 'Edit',
                'data-ui-id': 'chat-composite-message-contextual-menu-edit-action',
                text: props.strings.editMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageEdit',
                    styles: menuIconStyleSet
                },
                onClick: props.onEditClick
            }, {
                key: 'Remove',
                text: props.strings.removeMessage,
                itemProps: {
                    styles: props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined
                },
                iconProps: {
                    iconName: 'MessageRemove',
                    styles: menuIconStyleSet
                },
                onClick: props.onRemoveClick
            }];
        // only show read by x of x if more than 3 participants in total including myself
        // TODO: change strings.messageReadCount to be required if we can fallback to our own en-us strings for anything that Contoso doesn't provide
        if (props.remoteParticipantsCount && messageReadByCount !== undefined && props.remoteParticipantsCount >= 2 && props.showMessageStatus && props.strings.messageReadCount && props.messageStatus !== 'failed') {
            items.push({
                key: 'Read Count',
                'data-ui-id': 'chat-composite-message-contextual-menu-read-info',
                text: _formatString(props.strings.messageReadCount, {
                    messageReadByCount: `${messageReadByCount}`,
                    remoteParticipantsCount: `${props.remoteParticipantsCount}`
                }),
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: messageReadByCount > 0 ? theme.palette.neutralPrimary : theme.palette.neutralTertiary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                subMenuProps: {
                    id: 'chat-composite-message-contextual-menu-read-name-list',
                    items: messageReadByList !== null && messageReadByList !== void 0 ? messageReadByList : [],
                    calloutProps: preventUnwantedDismissProps,
                    styles: react.concatStyleSets({
                        root: {
                            maxWidth: _pxToRem(320),
                            span: {
                                overflow: 'hidden',
                                textOverflow: 'ellipsis'
                            }
                        }
                    })
                },
                iconProps: {
                    iconName: 'MessageSeen',
                    styles: {
                        root: {
                            color: messageReadByCount > 0 ? theme.palette.themeDarkAlt : theme.palette.neutralTertiary
                        }
                    }
                },
                submenuIconProps: {
                    iconName: 'HorizontalGalleryRightButton',
                    styles: menuSubIconStyleSet
                },
                disabled: messageReadByCount <= 0
            });
        }
        else if (props.messageStatus === 'failed' && props.strings.resendMessage) {
            items.push({
                key: 'Resend',
                text: props.strings.resendMessage,
                itemProps: {
                    styles: react.concatStyleSets({
                        linkContent: {
                            color: theme.palette.neutralPrimary
                        },
                        root: {
                            borderTop: `1px solid ${theme.palette.neutralLighter}`
                        }
                    }, props.increaseFlyoutItemSize ? menuItemIncreasedSizeStyles : undefined)
                },
                calloutProps: preventUnwantedDismissProps,
                iconProps: {
                    iconName: 'MessageResend',
                    styles: {
                        root: {
                            color: theme.palette.themeDarkAlt
                        }
                    }
                },
                onClick: props.onResendClick
            });
        }
        return items;
    }, [props.strings.editMessage, props.strings.removeMessage, props.strings.messageReadCount, props.strings.resendMessage, props.messageStatus, props.increaseFlyoutItemSize, props.onEditClick, props.onRemoveClick, props.onResendClick, props.remoteParticipantsCount, props.showMessageStatus, messageReadByCount, theme.palette.neutralPrimary, theme.palette.neutralTertiary, theme.palette.neutralLighter, theme.palette.themeDarkAlt, messageReadByList]);
    // gap space uses pixels
    return React__default['default'].createElement(react.ContextualMenu, { id: "chat-composite-message-contextual-menu", alignTargetEdge: true, gapSpace: 5 /*px*/, isBeakVisible: false, items: menuItems, hidden: props.hidden, target: props.target, onDismiss: props.onDismiss, directionalHint: react.DirectionalHint.topRightEdge, className: chatMessageMenuStyle, calloutProps: preventUnwantedDismissProps });
};
/**
 * Similar to {@link preventDismissOnEvent}, but not prevent dismissing from scrolling, since it is causing bugs in chat thread.
 */
const preventUnwantedDismissProps = {
    preventDismissOnEvent: (ev) => {
        return ev.type === 'resize';
    }
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ChatMessageContent = (props) => {
    switch (props.message.contentType) {
        case 'text':
            return MessageContentAsText(props);
        case 'html':
            return MessageContentAsRichTextHTML(props);
        case 'richtext/html':
            return MessageContentAsRichTextHTML(props);
        default:
            console.warn('unknown message content type');
            return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
};
const MessageContentWithLiveAria = (props) => {
    return React__default['default'].createElement("div", { "data-ui-status": props.message.status, role: "text", "aria-label": props.ariaLabel },
        React__default['default'].createElement(LiveMessage, { message: props.liveMessage, ariaLive: "polite" }),
        props.content);
};
const MessageContentAsRichTextHTML = (props) => {
    return React__default['default'].createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: processHtmlToReact(props) });
};
const MessageContentAsText = (props) => {
    return React__default['default'].createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: React__default['default'].createElement(Linkify__default['default'], { componentDecorator: (decoratedHref, decoratedText, key) => {
                return React__default['default'].createElement(react.Link, { target: "_blank", href: decoratedHref, key: key }, decoratedText);
            } }, props.message.content) });
};
// https://stackoverflow.com/questions/28899298/extract-the-text-out-of-html-string-using-javascript
const extractContent = (s) => {
    const span = document.createElement('span');
    span.innerHTML = s;
    return span.textContent || span.innerText;
};
const generateLiveMessage = (props) => {
    const liveAuthor = _formatString(props.strings.liveAuthorIntro, {
        author: `${props.message.senderDisplayName}`
    });
    return `${props.message.editedOn ? props.strings.editedTag : ''} ${props.message.mine ? '' : liveAuthor} ${extractContent(props.message.content || '')} `;
};
const messageContentAriaText = (props) => {
    // Strip all html tags from the content for aria.
    return props.message.content ? props.message.mine ? _formatString(props.strings.messageContentMineAriaText, {
        message: DOMPurify__default['default'].sanitize(props.message.content, {
            ALLOWED_TAGS: []
        })
    }) : _formatString(props.strings.messageContentAriaText, {
        author: `${props.message.senderDisplayName}`,
        message: DOMPurify__default['default'].sanitize(props.message.content, {
            ALLOWED_TAGS: []
        })
    }) : undefined;
};
const processNodeDefinitions = htmlToReact.ProcessNodeDefinitions();
const htmlToReactParser = htmlToReact.Parser();
const processHtmlToReact = (props) => {
    var _a;
    const steps = [{
            // Process everything else in the default way
            shouldProcessNode: htmlToReact.IsValidNodeDefinitions.alwaysValid,
            processNode: processNodeDefinitions.processDefaultNode
        }];
    return htmlToReactParser.parseWithInstructions((_a = props.message.content) !== null && _a !== void 0 ? _a : '', htmlToReact.IsValidNodeDefinitions.alwaysValid, steps);
};

// Copyright (c) Microsoft Corporation.
/**
 * Props for the Chat.Message action menu.
 * This is the 3 dots that appear when hovering over one of your own chat messages.
 *
 * @private
 */
const chatMessageActionMenuProps = (menuProps) => {
    if (!menuProps.enabled) {
        return undefined;
    }
    const menuClass = react.mergeStyles(chatActionsCSS, {
        'ul&': {
            boxShadow: menuProps.theme.effects.elevation4,
            backgroundColor: menuProps.theme.palette.white
        }
    });
    const actionMenuProps = {
        showActionMenu: menuProps.forceShow === true ? true : undefined,
        iconOnly: true,
        activeIndex: -1,
        className: menuClass,
        onItemClick: () => menuProps.onActionButtonClick(),
        items: [{
                children: React__default['default'].createElement(c, { innerRef: menuProps.menuButtonRef },
                    React__default['default'].createElement(react.Icon, { iconName: "ChatMessageOptions", "data-ui-id": "chat-composite-message-action-icon", "aria-label": menuProps.ariaLabel, styles: iconWrapperStyle(menuProps.theme, menuProps.forceShow) })),
                key: 'menuButton',
                indicator: false
            }]
    };
    return actionMenuProps;
};

var __awaiter$n = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fileDownloadCardsStyle = {
    marginTop: '0.25rem'
};
const actionIconStyle = {
    height: '1rem'
};
/**
 * @internal
 */
const _FileDownloadCards = (props) => {
    var _a, _b;
    const { userId, fileMetadata } = props;
    const [showSpinner, setShowSpinner] = React.useState(false);
    const localeStrings = useLocaleStringsTrampoline();
    const downloadFileButtonString = React.useMemo(() => () => {
        var _a, _b;
        return (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.downloadFile) !== null && _b !== void 0 ? _b : localeStrings.downloadFile;
    }, [(_a = props.strings) === null || _a === void 0 ? void 0 : _a.downloadFile, localeStrings.downloadFile]);
    const fileCardGroupDescription = React.useMemo(() => () => {
        var _a, _b;
        const fileGroupLocaleString = (_b = (_a = props.strings) === null || _a === void 0 ? void 0 : _a.fileCardGroupMessage) !== null && _b !== void 0 ? _b : localeStrings.fileCardGroupMessage;
        return _formatString(fileGroupLocaleString, {
            fileCount: `${fileMetadata.length}`
        });
    }, [(_b = props.strings) === null || _b === void 0 ? void 0 : _b.fileCardGroupMessage, localeStrings.fileCardGroupMessage, fileMetadata]);
    const fileDownloadHandler = React.useCallback((userId, file) => __awaiter$n(void 0, void 0, void 0, function* () {
        if (!props.downloadHandler) {
            window.open(file.url, '_blank', 'noopener,noreferrer');
        }
        else {
            setShowSpinner(true);
            try {
                const response = yield props.downloadHandler(userId, file);
                setShowSpinner(false);
                if (response instanceof URL) {
                    window.open(response.toString(), '_blank', 'noopener,noreferrer');
                }
                else {
                    props.onDownloadErrorMessage && props.onDownloadErrorMessage(response.errorMessage);
                }
            }
            finally {
                setShowSpinner(false);
            }
        }
    }), [props]);
    if (!fileMetadata || fileMetadata.length === 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement("div", { style: fileDownloadCardsStyle, "data-ui-id": "file-download-card-group" },
        React__default['default'].createElement(_FileCardGroup, { ariaLabel: fileCardGroupDescription() }, fileMetadata && fileMetadata.filter(attachment => {
            return true;
        }).map(file => React__default['default'].createElement(_FileCard, { fileName: file.name, key: file.name, fileExtension: file.extension, actionIcon: showSpinner ? React__default['default'].createElement(react.Spinner, { size: react.SpinnerSize.medium, "aria-live": 'polite', role: 'status' }) : React__default['default'].createElement(react.IconButton, { className: iconButtonClassName, ariaLabel: downloadFileButtonString() },
                React__default['default'].createElement(DownloadIconTrampoline, null)) , actionHandler: () => fileDownloadHandler(userId, file) }))));
};
/**
 * @private
 */
const DownloadIconTrampoline = () => {
    // Return _some_ available icon, as the real icon is beta-only.
    return React__default['default'].createElement(react.Icon, { iconName: "EditBoxCancel", style: actionIconStyle });
};
const useLocaleStringsTrampoline = () => {
    return {
        downloadFile: '',
        fileCardGroupMessage: ''
    };
};

// Copyright (c) Microsoft Corporation.
const generateDefaultTimestamp = (createdOn, showDate, strings) => {
    const formattedTimestamp = showDate ? formatTimestampForChatMessage(createdOn, new Date(), strings) : formatTimeForChatMessage(createdOn);
    return formattedTimestamp;
};
// onDisplayDateTimeString from props overwrite onDisplayDateTimeString from locale
const generateCustomizedTimestamp = (props, createdOn, locale) => {
    return '';
};
/** @private */
const MessageBubble = (props) => {
    var _a;
    const ids = useIdentifiers();
    const theme = useTheme();
    useLocale$1();
    const { userId, message, onRemoveClick, onResendClick, disableEditing, showDate, messageContainerStyle, strings, onEditClick, remoteParticipantsCount = 0, onRenderAvatar, showMessageStatus, messageStatus, fileDownloadHandler } = props;
    const defaultTimeStamp = message.createdOn ? generateDefaultTimestamp(message.createdOn, showDate, strings) : undefined;
    const customTimestamp = message.createdOn ? generateCustomizedTimestamp(props, message.createdOn) : '';
    const formattedTimestamp = customTimestamp || defaultTimeStamp;
    // Track if the action menu was opened by touch - if so we increase the touch targets for the items
    const [wasInteractionByTouch, setWasInteractionByTouch] = React.useState(false);
    // The chat message action flyout should target the Chat.Message action menu if clicked,
    // or target the chat message if opened via touch press.
    // Undefined indicates the flyout menu should not be being shown.
    const messageRef = React.useRef(null);
    const messageActionButtonRef = React.useRef(null);
    const [chatMessageActionFlyoutTarget, setChatMessageActionFlyoutTarget] = React.useState(undefined);
    const chatActionsEnabled = !disableEditing && message.status !== 'sending' && !!message.mine;
    const [messageReadBy, setMessageReadBy] = React.useState([]);
    const actionMenuProps = wasInteractionByTouch ? undefined : chatMessageActionMenuProps({
        ariaLabel: (_a = strings.actionMenuMoreOptions) !== null && _a !== void 0 ? _a : '',
        enabled: chatActionsEnabled,
        menuButtonRef: messageActionButtonRef,
        // Force show the action button while the flyout is open (otherwise this will dismiss when the pointer is hovered over the flyout)
        forceShow: chatMessageActionFlyoutTarget === messageActionButtonRef,
        onActionButtonClick: () => {
            if (message.messageType === 'chat') {
                props.onActionButtonClick(message, setMessageReadBy);
                setChatMessageActionFlyoutTarget(messageActionButtonRef);
            }
        },
        theme
    });
    const onActionFlyoutDismiss = React.useCallback(() => {
        // When the flyout dismiss is called, since we control if the action flyout is visible
        // or not we need to set the target to undefined here to actually hide the action flyout
        setChatMessageActionFlyoutTarget(undefined);
    }, [setChatMessageActionFlyoutTarget]);
    const defaultOnRenderFileDownloads = React.useCallback(() => React__default['default'].createElement(_FileDownloadCards, { userId: userId, fileMetadata: message['attachedFilesMetadata'] || [], downloadHandler: fileDownloadHandler }), [userId, message, fileDownloadHandler]);
    const editedOn = 'editedOn' in message ? message.editedOn : undefined;
    const getMessageDetails = React.useCallback(() => {
        if (messageStatus === 'failed') {
            return React__default['default'].createElement("div", { className: chatMessageFailedTagStyle(theme) }, strings.failToSendTag);
        }
        else if (message.messageType === 'chat' && editedOn) {
            return React__default['default'].createElement("div", { className: chatMessageEditedTagStyle(theme) }, strings.editedTag);
        }
        return undefined;
    }, [editedOn, message.messageType, messageStatus, strings.editedTag, strings.failToSendTag, theme]);
    const getContent = React.useCallback(() => {
        return React__default['default'].createElement("div", { tabIndex: 0 },
            React__default['default'].createElement(ChatMessageContent, { message: message, strings: strings }),
            props.onRenderFileDownloads ? props.onRenderFileDownloads(userId, message) : defaultOnRenderFileDownloads());
    }, [defaultOnRenderFileDownloads, message, props, strings, userId]);
    const chatMessage = React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement("div", { ref: messageRef },
            React__default['default'].createElement(i.Message, { "data-ui-id": "chat-composite-message", className: react.mergeStyles(messageContainerStyle), styles: messageContainerStyle, content: getContent(), author: React__default['default'].createElement(d, { className: chatMessageDateStyle }, message.senderDisplayName), mine: message.mine, timestamp: React__default['default'].createElement(d, { "data-ui-id": ids.messageTimestamp }, formattedTimestamp), details: getMessageDetails(), positionActionMenu: false, actionMenu: actionMenuProps, onTouchStart: () => setWasInteractionByTouch(true), onPointerDown: () => setWasInteractionByTouch(false), onKeyDown: () => setWasInteractionByTouch(false), onBlur: () => setWasInteractionByTouch(false), onClick: () => {
                    if (!wasInteractionByTouch) {
                        return;
                    }
                    // If the message was touched via touch we immediately open the menu
                    // flyout (when using mouse the 3-dot menu that appears on hover
                    // must be clicked to open the flyout).
                    // In doing so here we set the target of the flyout to be the message and
                    // not the 3-dot menu button to position the flyout correctly.
                    setChatMessageActionFlyoutTarget(messageRef);
                    if (message.messageType === 'chat') {
                        props.onActionButtonClick(message, setMessageReadBy);
                    }
                } })),
        chatActionsEnabled && React__default['default'].createElement(ChatMessageActionFlyout, { hidden: !chatMessageActionFlyoutTarget, target: chatMessageActionFlyoutTarget, increaseFlyoutItemSize: wasInteractionByTouch, onDismiss: onActionFlyoutDismiss, onEditClick: onEditClick, onRemoveClick: onRemoveClick, onResendClick: onResendClick, strings: strings, messageReadBy: messageReadBy, messageStatus: messageStatus !== null && messageStatus !== void 0 ? messageStatus : 'failed', remoteParticipantsCount: remoteParticipantsCount, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus }));
    return chatMessage;
};
/** @private */
const ChatMessageComponentAsMessageBubble = React__default['default'].memo(MessageBubble);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$m = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatMessageComponent = (props) => {
    const [isEditing, setIsEditing] = React.useState(false);
    const onEditClick = React.useCallback(() => setIsEditing(true), [setIsEditing]);
    const { onDeleteMessage, onSendMessage, message } = props;
    const clientMessageId = 'clientMessageId' in message ? message.clientMessageId : undefined;
    const content = 'content' in message ? message.content : undefined;
    const onRemoveClick = React.useCallback(() => {
        if (onDeleteMessage && message.messageId) {
            onDeleteMessage(message.messageId);
        }
        // when fail to send, message does not have message id, delete message using clientMessageId
        else if (onDeleteMessage && message.messageType === 'chat' && clientMessageId) {
            onDeleteMessage(clientMessageId);
        }
    }, [onDeleteMessage, message.messageId, message.messageType, clientMessageId]);
    const onResendClick = React.useCallback(() => {
        onDeleteMessage && clientMessageId && onDeleteMessage(clientMessageId);
        onSendMessage && onSendMessage(content !== undefined ? content : '');
    }, [clientMessageId, content, onSendMessage, onDeleteMessage]);
    if (isEditing && message.messageType === 'chat') {
        return React__default['default'].createElement(ChatMessageComponentAsEditBox, { message: message, inlineEditButtons: props.inlineAcceptRejectEditButtons, strings: props.strings, onSubmit: (text, metadata, options) => __awaiter$m(void 0, void 0, void 0, function* () {
                props.onUpdateMessage && message.messageId && (yield props.onUpdateMessage(message.messageId, text, metadata, options));
                setIsEditing(false);
            }), onCancel: messageId => {
                props.onCancelEditMessage && props.onCancelEditMessage(messageId);
                setIsEditing(false);
            } });
    }
    else {
        return React__default['default'].createElement(ChatMessageComponentAsMessageBubble, Object.assign({}, props, { onRemoveClick: onRemoveClick, onEditClick: onEditClick, onResendClick: onResendClick, onRenderAvatar: props.onRenderAvatar, strings: props.strings }));
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * A utility hook for providing the width of a parent element.
 * Returns updated width if parent/window resizes.
 * @param containerRef - Ref of a parent element whose width will be returned.
 * @internal
 */
const _useContainerWidth = (containerRef) => {
    const [width, setWidth] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { width } = entries[0].contentRect;
        setWidth(width);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return width;
};
/**
 * A utility hook for providing the height of a parent element.
 * Returns updated height if parent/window resizes.
 * @param containerRef - Ref of a parent element whose height will be returned.
 * @internal
 */
const _useContainerHeight = (containerRef) => {
    const [height, setHeight] = React.useState(undefined);
    const observer = React.useRef(new ResizeObserver(entries => {
        const { height } = entries[0].contentRect;
        setHeight(height);
    }));
    React.useEffect(() => {
        if (containerRef.current) {
            observer.current.observe(containerRef.current);
        }
        const currentObserver = observer.current;
        return () => {
            currentObserver.disconnect();
        };
    }, [containerRef, observer]);
    return height;
};
const NARROW_WIDTH_REM = 30;
/**
 * Utility function to determine if container width is narrow
 * @param containerWidthRem  container width in rem
 * @returns boolean
 */
const isNarrowWidth = (containerWidthRem) => containerWidthRem <= _convertRemToPx(NARROW_WIDTH_REM);

/**
 * @private
 *logic: Looking at message A, how do we know it's read number?
 * Assumption: if user read the latest message, user has read all messages before that
 * ReadReceipt behaviour: read receipt is only sent to the last message
 *
 * If participant read a message that is sent later than message A, then the participant has read message A
 * How do we check if the message is sent later than message A?
 * We compare if the messageID of the last read message is larger than or equal to the message A's id
 * Because messageID is the creation timestamp of each message
 * Timestamps are in epoch time so lecixographical ordering is the same as time ordering.
 *
 * if MessageId of B is larger than message Id of A, then B is created after A
 * if the last read message is created after the message A is sent, then user should have read message A as well */
var getParticipantsWhoHaveReadMessage = ((message, readReceiptsBySenderId) => {
    return Object.entries(readReceiptsBySenderId)
        // Filter to only read receipts that match the message OR the participant has read a different message after this message has been created
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.lastReadMessage >= message.messageId)
        // make sure the person is not removed from chat
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .filter(([_, readReceipt]) => readReceipt.displayName && readReceipt.displayName !== '')
        // Map properties to useful array
        .map(([id, readReceipt]) => ({
        id,
        displayName: readReceipt.displayName
    }));
});

// Copyright (c) Microsoft Corporation.
const offScreenStyle = {
    border: 0,
    clip: 'rect(0 0 0 0)',
    height: '1px',
    margin: '-1px',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    padding: 0,
    width: '1px',
    position: 'absolute'
};
/** @private */
const MessageBlock = (props) => React__default['default'].createElement("div", { style: offScreenStyle, role: "log", "aria-live": props.ariaLive }, props.message ? props.message : '');

// Copyright (c) Microsoft Corporation.
/** @private */
const EMPTY_MESSAGE = {
    message: '',
    id: ''
};
/** @private */
const Announcer = (props) => {
    var _a, _b;
    const newAssertive = (_a = props.assertive) !== null && _a !== void 0 ? _a : EMPTY_MESSAGE;
    const oldAssertive = React__default['default'].useRef(EMPTY_MESSAGE);
    const [activeAssertive1, setActiveAssertive1] = React__default['default'].useState(EMPTY_MESSAGE);
    const [activeAssertive2, setActiveAssertive2] = React__default['default'].useState(EMPTY_MESSAGE);
    const alternateAssertive = React__default['default'].useRef(false);
    React.useEffect(() => {
        if (oldAssertive.current.message !== (newAssertive === null || newAssertive === void 0 ? void 0 : newAssertive.message) || oldAssertive.current.id !== (newAssertive === null || newAssertive === void 0 ? void 0 : newAssertive.id)) {
            setActiveAssertive1(alternateAssertive.current ? EMPTY_MESSAGE : newAssertive);
            setActiveAssertive2(alternateAssertive.current ? newAssertive : EMPTY_MESSAGE);
            oldAssertive.current = newAssertive;
            alternateAssertive.current = !alternateAssertive.current;
        }
    }, [newAssertive]);
    const newPolite = (_b = props.polite) !== null && _b !== void 0 ? _b : EMPTY_MESSAGE;
    const oldPolite = React__default['default'].useRef(EMPTY_MESSAGE);
    const [activePolite1, setActivePolite1] = React__default['default'].useState(EMPTY_MESSAGE);
    const [activePolite2, setActivePolite2] = React__default['default'].useState(EMPTY_MESSAGE);
    const alternatePolite = React__default['default'].useRef(false);
    React.useEffect(() => {
        if (oldPolite.current.message !== (newPolite === null || newPolite === void 0 ? void 0 : newPolite.message) || oldPolite.current.id !== (newPolite === null || newPolite === void 0 ? void 0 : newPolite.id)) {
            setActivePolite1(alternatePolite.current ? EMPTY_MESSAGE : newPolite);
            setActivePolite2(alternatePolite.current ? newPolite : EMPTY_MESSAGE);
            oldPolite.current = newPolite;
            alternatePolite.current = !alternatePolite.current;
        }
    }, [newPolite]);
    return React__default['default'].createElement("div", null,
        React__default['default'].createElement(MessageBlock, { ariaLive: "assertive", message: activeAssertive1.message }),
        React__default['default'].createElement(MessageBlock, { ariaLive: "assertive", message: activeAssertive2.message }),
        React__default['default'].createElement(MessageBlock, { ariaLive: "polite", message: activePolite1.message }),
        React__default['default'].createElement(MessageBlock, { ariaLive: "polite", message: activePolite2.message }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const LiveAnnouncer = (props) => {
    const [politeMessage, setPoliteMessage] = React__default['default'].useState(EMPTY_MESSAGE);
    const [assertiveMessage, setAssertiveMessage] = React__default['default'].useState(EMPTY_MESSAGE);
    const announcePolite = React.useCallback((message, id) => {
        setPoliteMessage({
            message,
            id
        });
    }, []);
    const announceAssertive = React.useCallback((message, id) => {
        setAssertiveMessage({
            message,
            id
        });
    }, []);
    const updateFunctions = React.useMemo(() => ({
        announcePolite,
        announceAssertive
    }), [announceAssertive, announcePolite]);
    return React__default['default'].createElement(AnnouncerContext.Provider, { value: updateFunctions },
        props.children,
        React__default['default'].createElement(Announcer, { assertive: assertiveMessage, polite: politeMessage }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$l = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isMessageSame = (first, second) => {
    return first.messageId === second.messageId && first.content === second.content && first.contentType === second.contentType && JSON.stringify(first.createdOn) === JSON.stringify(second.createdOn) && first.senderId === second.senderId && first.senderDisplayName === second.senderDisplayName && first.status === second.status;
};
/**
 * Get the latest message from the message array.
 *
 * @param messages
 */
const getLatestChatMessage = (messages) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && !!message.createdOn) {
            return message;
        }
    }
    return undefined;
};
/**
 * Compare latestMessageFromPreviousMessages & latestMessageFromNewMessages to see if the new message is not from
 * current user.
 */
const isThereNewMessageNotFromCurrentUser = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId !== userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId !== userId;
};
/**
 * Returns true if the current user sent the latest message and false otherwise. It will ignore messages that have no
 * sender, messages that have failed to send, and messages from the current user that is marked as SEEN. This is meant
 * as an indirect way to detect if user is at bottom of the chat when the component updates with new messages. If we
 * updated this component due to current user sending a message we want to then call scrollToBottom.
 */
const didUserSendTheLatestMessage = (userId, latestMessageFromPreviousMessages, latestMessageFromNewMessages) => {
    if (latestMessageFromNewMessages === undefined) {
        return false;
    }
    if (latestMessageFromPreviousMessages === undefined) {
        return latestMessageFromNewMessages.senderId === userId;
    }
    return !isMessageSame(latestMessageFromNewMessages, latestMessageFromPreviousMessages) && latestMessageFromNewMessages.senderId === userId;
};
const DefaultJumpToNewMessageButton = (props) => {
    const { text, onClick } = props;
    return React__default['default'].createElement(react.PrimaryButton, { className: newMessageButtonStyle, styles: buttonWithIconStyles$1, text: text, onClick: onClick, onRenderIcon: () => React__default['default'].createElement(react.Icon, { iconName: "Down", className: DownIconStyle }) });
};
const generateParticipantsStr = (participants, defaultName) => participants.map(participant => `${!participant.displayName || participant.displayName === '' ? defaultName : participant.displayName}`).join(', ');
const ParticipantSystemMessageComponent = ({ message, style, defaultName }) => {
    const { strings } = useLocale$1();
    const participantsStr = generateParticipantsStr(message.participants, defaultName);
    const messageSuffix = message.systemMessageType === 'participantAdded' ? strings.messageThread.participantJoined : strings.messageThread.participantLeft;
    if (participantsStr !== '') {
        return React__default['default'].createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: `${participantsStr} ${messageSuffix}`, containerStyle: style });
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const DefaultSystemMessage = (props) => {
    var _a;
    const message = props.message;
    switch (message.messageType) {
        case 'system':
            switch (message.systemMessageType) {
                case 'content':
                    return React__default['default'].createElement(SystemMessage, { iconName: (message.iconName ? message.iconName : ''), content: (_a = message.content) !== null && _a !== void 0 ? _a : '', containerStyle: props === null || props === void 0 ? void 0 : props.messageContainerStyle });
                case 'participantAdded':
                case 'participantRemoved':
                    return React__default['default'].createElement(ParticipantSystemMessageComponent, { message: message, style: props.messageContainerStyle, defaultName: props.strings.noDisplayNameSub });
            }
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};
const memoizeAllMessages = memoizeFnAll((_messageKey, message, showMessageDate, showMessageStatus, onRenderAvatar, shouldOverlapAvatarAndMessage, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, theme, _attached, statusToRender, participantCount, readCount, onRenderMessage, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage, disableEditing) => {
    var _a, _b, _c, _d;
    const messageProps = {
        message,
        strings,
        showDate: showMessageDate,
        onUpdateMessage,
        onCancelEditMessage,
        onDeleteMessage,
        onSendMessage,
        disableEditing
    };
    const chatMessageItemProps = (message, messageProps) => {
        var _a, _b, _c;
        const chatMessageComponent = onRenderMessage === undefined ? defaultChatMessageRenderer(messageProps) : onRenderMessage(messageProps, defaultChatMessageRenderer);
        const personaOptions = {
            hidePersonaDetails: true,
            size: react.PersonaSize.size32,
            text: message.senderDisplayName,
            showOverflowTooltip: false
        };
        const chatItemMessageStyle = (message.mine ? styles === null || styles === void 0 ? void 0 : styles.myChatItemMessageContainer : styles === null || styles === void 0 ? void 0 : styles.chatItemMessageContainer) || defaultChatItemMessageContainer(shouldOverlapAvatarAndMessage);
        const chatGutterStyles = message.attached === 'top' || message.attached === false ? gutterWithAvatar : gutterWithHiddenAvatar;
        return {
            gutter: {
                styles: chatGutterStyles,
                content: message.mine ? '' : onRenderAvatar ? onRenderAvatar((_a = message.senderId) !== null && _a !== void 0 ? _a : '', personaOptions) : React__default['default'].createElement(react.Persona, Object.assign({}, personaOptions))
            },
            contentPosition: message.mine ? 'end' : 'start',
            message: {
                styles: chatItemMessageStyle,
                content: React__default['default'].createElement(l, { hAlign: message.mine ? 'end' : undefined, vAlign: "end" },
                    chatMessageComponent,
                    React__default['default'].createElement("div", { className: react.mergeStyles(messageStatusContainerStyle((_b = message.mine) !== null && _b !== void 0 ? _b : false), (styles === null || styles === void 0 ? void 0 : styles.messageStatusContainer) ? styles.messageStatusContainer((_c = message.mine) !== null && _c !== void 0 ? _c : false) : '') }, showMessageStatus && statusToRender ? onRenderMessageStatus ? onRenderMessageStatus({
                        status: statusToRender
                    }) : defaultStatusRenderer(message, statusToRender, participantCount !== null && participantCount !== void 0 ? participantCount : 0, readCount !== null && readCount !== void 0 ? readCount : 0) : React__default['default'].createElement("div", { className: react.mergeStyles(noMessageStatusStyle) })))
            },
            attached: message.attached,
            key: _messageKey
        };
    };
    switch (message.messageType) {
        case 'chat':
            {
                const myChatMessageStyle = message.status === 'failed' ? (_b = (_a = styles === null || styles === void 0 ? void 0 : styles.failedMyChatMessageContainer) !== null && _a !== void 0 ? _a : styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer) !== null && _b !== void 0 ? _b : FailedMyChatMessageContainer : (_c = styles === null || styles === void 0 ? void 0 : styles.myChatMessageContainer) !== null && _c !== void 0 ? _c : defaultMyChatMessageContainer;
                const chatMessageStyle = (_d = styles === null || styles === void 0 ? void 0 : styles.chatMessageContainer) !== null && _d !== void 0 ? _d : defaultChatMessageContainer(theme);
                messageProps.messageContainerStyle = message.mine ? myChatMessageStyle : chatMessageStyle;
                return chatMessageItemProps(message, messageProps);
            }
        case 'system':
            {
                messageProps.messageContainerStyle = styles === null || styles === void 0 ? void 0 : styles.systemMessageContainer;
                const systemMessageComponent = onRenderMessage === undefined ? React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, messageProps)) : onRenderMessage(messageProps, props => React__default['default'].createElement(DefaultSystemMessage, Object.assign({}, props)));
                return {
                    children: systemMessageComponent,
                    key: _messageKey
                };
            }
        default:
            {
                // We do not handle custom type message by default, users can handle custom type by using onRenderMessage function.
                const customMessageComponent = onRenderMessage === undefined ? React__default['default'].createElement(React__default['default'].Fragment, null) : onRenderMessage(messageProps);
                return {
                    children: customMessageComponent,
                    key: _messageKey
                };
            }
    }
});
const getLastChatMessageIdWithStatus = (messages, status) => {
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.messageType === 'chat' && message.status === status && message.mine) {
            return message.messageId;
        }
    }
    return undefined;
};
/**
 * `MessageThread` allows you to easily create a component for rendering chat messages, handling scrolling behavior of new/old messages and customizing icons & controls inside the chat thread.
 * @param props - of type MessageThreadProps
 *
 * Users will need to provide at least chat messages and userId to render the `MessageThread` component.
 * Users can also customize `MessageThread` by passing in their own Avatar, `MessageStatusIndicator` icon, `JumpToNewMessageButton`, `LoadPreviousMessagesButton` and the behavior of these controls.
 *
 * `MessageThread` internally uses the `Chat` & `Chat.Message` component from `@fluentui/react-northstar`. You can checkout the details about these [two components](https://fluentsite.z22.web.core.windows.net/0.53.0/components/chat/props).
 *
 * @public
 */
const MessageThread = (props) => {
    var _a;
    const { messages: newMessages, userId, participantCount, readReceiptsBySenderId, styles, disableJumpToNewMessageButton = false, showMessageDate = false, showMessageStatus = false, numberOfChatMessagesToReload = 5, onMessageSeen, onRenderMessageStatus, onRenderAvatar, onLoadPreviousChatMessages, onRenderJumpToNewMessageButton, onRenderMessage, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage } = props;
    const onRenderFileDownloads = onRenderFileDownloadsTrampoline();
    const [messages, setMessages] = React.useState([]);
    // We need this state to wait for one tick and scroll to bottom after messages have been initialized.
    // Otherwise chatScrollDivRef.current.clientHeight is wrong if we scroll to bottom before messages are initialized.
    const [chatMessagesInitialized, setChatMessagesInitialized] = React.useState(false);
    const [isAtBottomOfScroll, setIsAtBottomOfScroll] = React.useState(true);
    const [forceUpdate, setForceUpdate] = React.useState(0);
    // Used to decide if should auto scroll to bottom or show "new message" button
    const [latestPreviousChatMessage, setLatestPreviousChatMessage] = React.useState(undefined);
    const [latestCurrentChatMessage, setLatestCurrentChatMessage] = React.useState(undefined);
    const [existsNewChatMessage, setExistsNewChatMessage] = React.useState(false);
    const [lastSeenChatMessage, setLastSeenChatMessage] = React.useState(undefined);
    const [lastDeliveredChatMessage, setLastDeliveredChatMessage] = React.useState(undefined);
    const [lastSendingChatMessage, setLastSendingChatMessage] = React.useState(undefined);
    // readCount and participantCount will only need to be updated on-fly when user hover on an indicator
    const [readCountForHoveredIndicator, setReadCountForHoveredIndicator] = React.useState(undefined);
    const isAllChatMessagesLoadedRef = React.useRef(false);
    // isAllChatMessagesLoadedRef needs to be updated every time when a new adapter is set in order to display correct data
    // onLoadPreviousChatMessages is updated when a new adapter is set
    React.useEffect(() => {
        if (onLoadPreviousChatMessages) {
            isAllChatMessagesLoadedRef.current = false;
        }
    }, [onLoadPreviousChatMessages]);
    const previousTopRef = React.useRef(-1);
    const previousHeightRef = React.useRef(-1);
    const messageIdSeenByMeRef = React.useRef('');
    const chatScrollDivRef = React.useRef(null);
    const chatThreadRef = React.useRef(null);
    const isLoadingChatMessagesRef = React.useRef(false);
    // When the chat thread is narrow, we perform space optimizations such as overlapping
    // the avatar on top of the chat message and moving the chat accept/reject edit buttons
    // to a new line
    const chatThreadWidth = _useContainerWidth(chatThreadRef);
    const isNarrow = chatThreadWidth ? isNarrowWidth(chatThreadWidth) : false;
    const messagesRef = React.useRef(messages);
    const setMessagesRef = (messagesWithAttachedValue) => {
        messagesRef.current = messagesWithAttachedValue;
        setMessages(messagesWithAttachedValue);
    };
    const isAtBottomOfScrollRef = React.useRef(isAtBottomOfScroll);
    const setIsAtBottomOfScrollRef = (isAtBottomOfScrollValue) => {
        isAtBottomOfScrollRef.current = isAtBottomOfScrollValue;
        setIsAtBottomOfScroll(isAtBottomOfScrollValue);
    };
    const chatMessagesInitializedRef = React.useRef(chatMessagesInitialized);
    const setChatMessagesInitializedRef = (chatMessagesInitialized) => {
        chatMessagesInitializedRef.current = chatMessagesInitialized;
        setChatMessagesInitialized(chatMessagesInitialized);
    };
    // we try to only send those message status if user is scrolled to the bottom.
    const sendMessageStatusIfAtBottom = React.useCallback(() => __awaiter$l(void 0, void 0, void 0, function* () {
        if (!isAtBottomOfScrollRef.current || !document.hasFocus() || !messagesRef.current || messagesRef.current.length === 0 || !showMessageStatus) {
            return;
        }
        const messagesWithId = messagesRef.current.filter(message => {
            return message.messageType === 'chat' && !message.mine && !!message.messageId;
        });
        if (messagesWithId.length === 0) {
            return;
        }
        const lastMessage = messagesWithId[messagesWithId.length - 1];
        try {
            if (onMessageSeen && lastMessage && lastMessage.messageId && lastMessage.messageId !== messageIdSeenByMeRef.current) {
                yield onMessageSeen(lastMessage.messageId);
                messageIdSeenByMeRef.current = lastMessage.messageId;
            }
        }
        catch (e) {
            console.log('onMessageSeen Error', lastMessage, e);
        }
    }), [showMessageStatus, onMessageSeen]);
    const scrollToBottom = React.useCallback(() => {
        if (chatScrollDivRef.current) {
            chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight;
        }
        setExistsNewChatMessage(false);
        setIsAtBottomOfScrollRef(true);
        sendMessageStatusIfAtBottom();
    }, [sendMessageStatusIfAtBottom]);
    const handleScrollToTheBottom = React.useCallback(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        const atBottom = Math.ceil(chatScrollDivRef.current.scrollTop) >= chatScrollDivRef.current.scrollHeight - chatScrollDivRef.current.clientHeight;
        if (atBottom) {
            sendMessageStatusIfAtBottom();
            if (!isAtBottomOfScrollRef.current) {
                scrollToBottom();
            }
        }
        setIsAtBottomOfScrollRef(atBottom);
    }, [scrollToBottom, sendMessageStatusIfAtBottom]);
    // Infinite scrolling + threadInitialize function
    const fetchNewMessageWhenAtTop = React.useCallback(() => __awaiter$l(void 0, void 0, void 0, function* () {
        if (!isLoadingChatMessagesRef.current) {
            if (onLoadPreviousChatMessages) {
                isLoadingChatMessagesRef.current = true;
                try {
                    // Fetch message until scrollTop reach the threshold for fetching new message
                    while (!isAllChatMessagesLoadedRef.current && chatScrollDivRef.current && chatScrollDivRef.current.scrollTop <= 500) {
                        isAllChatMessagesLoadedRef.current = yield onLoadPreviousChatMessages(numberOfChatMessagesToReload);
                        yield delay(200);
                    }
                }
                finally {
                    // Set isLoadingChatMessagesRef to false after messages are fetched
                    isLoadingChatMessagesRef.current = false;
                }
            }
        }
    }), [numberOfChatMessagesToReload, onLoadPreviousChatMessages]);
    // The below 2 of useEffects are design for fixing infinite scrolling problem
    // Scrolling element will behave differently when scrollTop = 0(it sticks at the top)
    // we need to get previousTop before it prepend contents
    // Execute order [newMessage useEffect] => get previousTop => dom update => [messages useEffect]
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        previousTopRef.current = chatScrollDivRef.current.scrollTop;
        previousHeightRef.current = chatScrollDivRef.current.scrollHeight;
    }, [newMessages]);
    React.useEffect(() => {
        if (!chatScrollDivRef.current) {
            return;
        }
        chatScrollDivRef.current.scrollTop = chatScrollDivRef.current.scrollHeight - (previousHeightRef.current - previousTopRef.current);
    }, [messages]);
    // Fetch more messages to make the scroll bar appear, infinity scroll is then handled in the handleScroll function.
    React.useEffect(() => {
        fetchNewMessageWhenAtTop();
    }, [fetchNewMessageWhenAtTop]);
    /**
     * One time run useEffects. Sets up listeners when component is mounted and tears down listeners when component
     * unmounts unless these function changed
     */
    React.useEffect(() => {
        window && window.addEventListener('click', sendMessageStatusIfAtBottom);
        window && window.addEventListener('focus', sendMessageStatusIfAtBottom);
        return () => {
            window && window.removeEventListener('click', sendMessageStatusIfAtBottom);
            window && window.removeEventListener('focus', sendMessageStatusIfAtBottom);
        };
    }, [sendMessageStatusIfAtBottom]);
    React.useEffect(() => {
        const chatScrollDiv = chatScrollDivRef.current;
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', handleScrollToTheBottom);
        chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.addEventListener('scroll', fetchNewMessageWhenAtTop);
        return () => {
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', handleScrollToTheBottom);
            chatScrollDiv === null || chatScrollDiv === void 0 ? void 0 : chatScrollDiv.removeEventListener('scroll', fetchNewMessageWhenAtTop);
        };
    }, [fetchNewMessageWhenAtTop, handleScrollToTheBottom]);
    /**
     * ClientHeight controls the number of messages to render. However ClientHeight will not be initialized after the
     * first render (not sure but I guess Fluent is updating it in hook which is after render maybe?) so we need to
     * trigger a re-render until ClientHeight is initialized. This force re-render should only happen once.
     */
    const clientHeight = (_a = chatThreadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight;
    React.useEffect(() => {
        if (clientHeight === undefined) {
            setForceUpdate(forceUpdate + 1);
            return;
        }
        // Only scroll to bottom if isAtBottomOfScrollRef is true
        isAtBottomOfScrollRef.current && scrollToBottom();
    }, [clientHeight, forceUpdate, scrollToBottom, chatMessagesInitialized]);
    /**
     * This needs to run to update latestPreviousChatMessage & latestCurrentChatMessage.
     * These two states are used to manipulate scrollbar
     */
    React.useEffect(() => {
        setLatestPreviousChatMessage(getLatestChatMessage(messagesRef.current));
        setLatestCurrentChatMessage(getLatestChatMessage(newMessages));
        setMessagesRef(newMessages);
        !chatMessagesInitializedRef.current && setChatMessagesInitializedRef(true);
        setLastDeliveredChatMessage(getLastChatMessageIdWithStatus(newMessages, 'delivered'));
        setLastSeenChatMessage(getLastChatMessageIdWithStatus(newMessages, 'seen'));
        setLastSendingChatMessage(getLastChatMessageIdWithStatus(newMessages, 'sending'));
    }, [newMessages]);
    /**
     * This needs to run after messages are rendered so we can manipulate the scroll bar.
     */
    React.useEffect(() => {
        // If user just sent the latest message then we assume we can move user to bottom of scroll.
        if (isThereNewMessageNotFromCurrentUser(userId, latestPreviousChatMessage, latestCurrentChatMessage) && !isAtBottomOfScrollRef.current) {
            setExistsNewChatMessage(true);
        }
        else if (didUserSendTheLatestMessage(userId, latestPreviousChatMessage, latestCurrentChatMessage) || isAtBottomOfScrollRef.current) {
            scrollToBottom();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messages]);
    const participantCountRef = React.useRef(participantCount);
    const readReceiptsBySenderIdRef = React.useRef(readReceiptsBySenderId);
    participantCountRef.current = participantCount;
    readReceiptsBySenderIdRef.current = readReceiptsBySenderId;
    const onActionButtonClickMemo = React.useCallback((message, setMessageReadBy) => {
        if (participantCountRef.current && participantCountRef.current - 1 > 1 && readReceiptsBySenderIdRef.current) {
            setMessageReadBy(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current));
        }
    }, []);
    const localeStrings = useLocale$1().strings.messageThread;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    // To rerender the defaultChatMessageRenderer if app running across days(every new day chat time stamp need to be regenerated)
    const defaultChatMessageRenderer = React.useCallback((messageProps) => {
        if (messageProps.message.messageType === 'chat') {
            return React__default['default'].createElement(ChatMessageComponent, Object.assign({}, messageProps, { onRenderFileDownloads: onRenderFileDownloads, message: messageProps.message, userId: props.userId, remoteParticipantsCount: participantCount ? participantCount - 1 : 0, inlineAcceptRejectEditButtons: !isNarrow, onRenderAvatar: onRenderAvatar, showMessageStatus: showMessageStatus, messageStatus: messageProps.message.status, onActionButtonClick: onActionButtonClickMemo }));
        }
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }, [onRenderFileDownloads, props.userId, participantCount, isNarrow, onRenderAvatar, showMessageStatus, onActionButtonClickMemo]);
    const defaultStatusRenderer = React.useCallback((message, status, participantCount, readCount) => {
        const onToggleToolTip = (isToggled) => {
            if (isToggled && readReceiptsBySenderIdRef.current) {
                setReadCountForHoveredIndicator(getParticipantsWhoHaveReadMessage(message, readReceiptsBySenderIdRef.current).length);
            }
            else {
                setReadCountForHoveredIndicator(undefined);
            }
        };
        return React__default['default'].createElement(MessageStatusIndicator, { status: status, readCount: readCount, onToggleToolTip: onToggleToolTip, 
            // -1 because participant count does not include myself
            remoteParticipantsCount: participantCount ? participantCount - 1 : 0 });
    }, []);
    const theme = useTheme();
    const messagesToDisplay = React.useMemo(() => memoizeAllMessages(memoizedMessageFn => {
        return messages.map((message, index) => {
            let key = message.messageId;
            let statusToRender = undefined;
            if (message.messageType === 'chat') {
                if ((!message.messageId || message.messageId === '') && 'clientMessageId' in message) {
                    key = message.clientMessageId;
                }
                if (showMessageStatus && message.mine) {
                    switch (message.messageId) {
                        case lastSeenChatMessage:
                            {
                                statusToRender = 'seen';
                                break;
                            }
                        case lastSendingChatMessage:
                            {
                                statusToRender = 'sending';
                                break;
                            }
                        case lastDeliveredChatMessage:
                            {
                                statusToRender = 'delivered';
                                break;
                            }
                    }
                }
                if (message.mine && message.status === 'failed') {
                    statusToRender = 'failed';
                }
            }
            return memoizedMessageFn(key !== null && key !== void 0 ? key : 'id_' + index, message, showMessageDate, showMessageStatus, onRenderAvatar, isNarrow, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, theme, 
            // Temporary solution to make sure we re-render if attach attribute is changed.
            // The proper fix should be in selector.
            message.messageType === 'chat' ? message.attached : undefined, statusToRender, participantCount, readCountForHoveredIndicator, onRenderMessage, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage, props.disableEditing);
        });
    }), [messages, showMessageDate, showMessageStatus, onRenderAvatar, isNarrow, styles, onRenderMessageStatus, defaultStatusRenderer, defaultChatMessageRenderer, strings, theme, participantCount, readCountForHoveredIndicator, onRenderMessage, onUpdateMessage, onCancelEditMessage, onDeleteMessage, onSendMessage, lastSeenChatMessage, lastSendingChatMessage, lastDeliveredChatMessage, props.disableEditing]);
    const chatBody = React.useMemo(() => {
        var _a;
        return React__default['default'].createElement(LiveAnnouncer, null,
            React__default['default'].createElement(i, { styles: u(chatStyle, linkStyles(theme), (_a = styles === null || styles === void 0 ? void 0 : styles.chatContainer) !== null && _a !== void 0 ? _a : {}), items: messagesToDisplay }));
    }, [theme, styles === null || styles === void 0 ? void 0 : styles.chatContainer, messagesToDisplay]);
    return React__default['default'].createElement(c, { innerRef: chatThreadRef },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(messageThreadContainerStyle, styles === null || styles === void 0 ? void 0 : styles.root), grow: true },
            existsNewChatMessage && !disableJumpToNewMessageButton && React__default['default'].createElement("div", { className: react.mergeStyles(newMessageButtonContainerStyle, styles === null || styles === void 0 ? void 0 : styles.newMessageButtonContainer) }, onRenderJumpToNewMessageButton ? onRenderJumpToNewMessageButton({
                text: strings.newMessagesIndicator,
                onClick: scrollToBottom
            }) : React__default['default'].createElement(DefaultJumpToNewMessageButton, { text: strings.newMessagesIndicator, onClick: scrollToBottom })),
            React__default['default'].createElement(c, { innerRef: chatScrollDivRef }, chatBody)));
};
const onRenderFileDownloadsTrampoline = (props) => {
    return undefined;
};
const linkStyles = (theme) => {
    return {
        '& a:link': {
            color: theme.palette.themePrimary
        },
        '& a:visited': {
            color: theme.palette.themeDarker
        },
        '& a:hover': {
            color: theme.palette.themeDarker
        },
        '& a:selected': {
            color: theme.palette.themeDarker
        }
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const container = () => react.mergeStyles({
    position: 'relative',
    // ensures child element's `position: absolute` is relative to this container
    display: 'contents'
});
/**
 * @private
 */
const loadingSpinnerContainer = () => react.mergeStyles({
    // Position centrally on top of content. Parent must have position: relative.
    position: 'absolute',
    top: '50%',
    bottom: '0',
    left: '50%',
    right: '0',
    transform: 'translate(-50%, -50%)'
});
/**
 * @private
 */
const loadSpinnerStyles = {
    root: {
        height: '100%' // ensure height fills container
    },
    circle: {
        maxHeight: '5rem',
        height: '50%',
        width: 'unset',
        // remove default width applied by fluent for spinners
        aspectRatio: '1 / 1',
        // make height match width to ensure a circle shape
        borderWidth: '0.25em'
    }
};
/**
 * @private
 */
const mediaContainer = (theme) => react.mergeStyles({
    position: 'relative',
    height: '100%',
    width: '100%',
    background: 'transparent',
    display: 'flex',
    '& video': {
        borderRadius: theme.effects.roundedCorner4
    }
});
/**
 * @private
 */
const invertedVideoInPipStyle = (theme) => react.mergeStyles(mediaContainer(theme), {
    // The HTMLElement returned by the headless SDK is already inverted.
    // But in picture-in-picture mode, we do not want to invert the host HTMLElement.
    // Instead, we need to target the :picture-in-picture pseudoclass.
    //
    // First reset the host HTMLElement.
    transform: 'rotateY(180deg)',
    // This doesn't work yet on latest Edge.
    // Probably just not implemented yet.
    // picture-in-picture API is not yet stable: https://www.w3.org/TR/picture-in-picture/#css-pseudo-class
    '& video:picture-in-picture': {
        transform: 'rotateY(180deg)'
    }
});

// Copyright (c) Microsoft Corporation.
/**
 * Utility component to convert an HTMLElement with a video stream into a JSX element.
 *
 * Use to convert an HTMLElement returned by headless calling API into a component that can be rendered as a {@link VideoTile}.
 *
 * @public
 */
const StreamMedia = (props) => {
    const containerEl = React.useRef(null);
    const theme = useTheme();
    const { isMirrored, videoStreamElement, styles, loadingState = 'none' } = props;
    const [pipEnabled, setPipEnabled] = React.useState(false);
    React.useEffect(() => {
        const container = containerEl.current;
        if (!container) {
            return;
        }
        // If videoStreamElement changes, we clear the container to make sure we don't have duplicate, and replace it with
        // the new videoStreamElement. If videoStreamElement is undefined nothing is appended and container should be empty
        // and we don't render anyting.
        container.innerHTML = '';
        setPipEnabled(false);
        if (videoStreamElement) {
            videoStreamElement.addEventListener('enterpictureinpicture', () => {
                setPipEnabled(true);
            });
            videoStreamElement.addEventListener('leavepictureinpicture', () => {
                setPipEnabled(false);
            });
            container.appendChild(videoStreamElement);
        }
        return () => {
            container.innerHTML = '';
            setPipEnabled(false);
        };
    }, [videoStreamElement]);
    return React__default['default'].createElement("div", { className: container() },
        React__default['default'].createElement("div", { "data-ui-id": "stream-media-container", className: react.mergeStyles(isMirrored && pipEnabled ? invertedVideoInPipStyle(theme) : mediaContainer(theme), styles === null || styles === void 0 ? void 0 : styles.root), ref: containerEl }),
        loadingState === 'loading' && React__default['default'].createElement("div", { className: loadingSpinnerContainer() },
            React__default['default'].createElement(react.Spinner, { "data-ui-id": "stream-media-loading-spinner", styles: loadSpinnerStyles })));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantItemContainerStyle = (options) => {
    return {
        paddingTop: '0.25rem',
        paddingBottom: '0.25rem',
        display: 'flex',
        maxWidth: '100%',
        minWidth: '8rem',
        cursor: options.localparticipant || !options.clickable ? 'default' : 'pointer',
        alignItems: 'center'
    };
};
/**
 * @private
 */
const menuButtonContainerStyle = {
    width: '1.5rem'
};
/**
 * @private
 */
const participantStateMaxWidth = '5rem';
/**
 * @private
 */
const participantStateStringStyles = {
    maxWidth: participantStateMaxWidth,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    lineHeight: 'normal',
    paddingLeft: '1rem',
    marginLeft: 'auto',
    marginRight: 0
};
/**
 * @private
 */
const iconContainerStyle$1 = {
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    paddingTop: '0.2rem'
};
/**
 * @private
 */
const iconStyles$2 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    // ensure the icon center is on the center line and not slightly above it
    alignItems: 'center'
});
/**
 * @private
 */
const meContainerStyle = {
    paddingRight: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Component to render a calling or chat participant.
 *
 * Displays the participant's avatar, displayName and status as well as optional icons and context menu.
 *
 * @public
 */
const ParticipantItem = (props) => {
    const { userId, displayName, onRenderAvatar, menuItems, onRenderIcon, presence, styles, me, onClick, showParticipantOverflowTooltip } = props;
    const [itemHovered, setItemHovered] = React.useState(false);
    const [itemFocused, setItemFocused] = React.useState(false);
    const [menuHidden, setMenuHidden] = React.useState(true);
    const containerRef = React.useRef(null);
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.participantItem;
    const ids = useIdentifiers();
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    // For 'me' show empty name so avatar will get 'Person' icon, when there is no name
    const meAvatarText = (displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || '';
    const avatarOptions = {
        text: me ? meAvatarText : (displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || strings.displayNamePlaceholder,
        size: react.PersonaSize.size32,
        presence: presence,
        initialsTextColor: 'white',
        showOverflowTooltip: showParticipantOverflowTooltip,
        showUnknownPersonaCoin: !me && (!(displayName === null || displayName === void 0 ? void 0 : displayName.trim()) || displayName === strings.displayNamePlaceholder)
    };
    const avatar = onRenderAvatar ? onRenderAvatar(userId !== null && userId !== void 0 ? userId : '', avatarOptions) : React__default['default'].createElement(react.Persona, Object.assign({ className: react.mergeStyles({
            // Prevents persona text from being vertically truncated if a global line height is less than 1.15.
            lineHeight: '1.15rem'
        }, styles === null || styles === void 0 ? void 0 : styles.avatar) }, avatarOptions));
    const meTextStyle = React.useMemo(() => react.mergeStyles(meContainerStyle, {
        color: theme.palette.neutralSecondary
    }, styles === null || styles === void 0 ? void 0 : styles.me), [theme.palette.neutralSecondary, styles === null || styles === void 0 ? void 0 : styles.me]);
    const contextualMenuStyle = React.useMemo(() => react.mergeStyles({
        background: theme.palette.neutralLighterAlt
    }, styles === null || styles === void 0 ? void 0 : styles.menu), [theme.palette.neutralLighterAlt, styles === null || styles === void 0 ? void 0 : styles.menu]);
    const infoContainerStyle = React.useMemo(() => react.mergeStyles(iconContainerStyle$1, {
        color: theme.palette.neutralTertiary
    }, styles === null || styles === void 0 ? void 0 : styles.iconContainer), [theme.palette.neutralTertiary, styles === null || styles === void 0 ? void 0 : styles.iconContainer]);
    const menuButton = React.useMemo(() => React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "end", className: react.mergeStyles(menuButtonContainerStyle), title: strings.menuTitle, "data-ui-id": ids.participantItemMenuButton },
        React__default['default'].createElement(react.Icon, { iconName: itemHovered || itemFocused || !menuHidden ? 'ParticipantItemOptionsHovered' : 'ParticipantItemOptions', className: iconStyles$2 })), [strings.menuTitle, ids.participantItemMenuButton, itemHovered, itemFocused, menuHidden]);
    const onDismissMenu = () => {
        setItemHovered(false);
        setItemFocused(false);
        setMenuHidden(true);
    };
    const participantStateString = participantStateStringTrampoline$1();
    return React__default['default'].createElement("div", { ref: containerRef, role: 'menuitem', "data-is-focusable": true, "data-ui-id": "participant-item", className: react.mergeStyles(participantItemContainerStyle({
            localparticipant: me,
            clickable: !!menuItems
        }), styles === null || styles === void 0 ? void 0 : styles.root), onMouseEnter: () => setItemHovered(true), onMouseLeave: () => setItemHovered(false), onFocus: () => setItemFocused(true), onBlur: () => setItemFocused(false), onClick: () => {
            {
                setItemHovered(true);
                setMenuHidden(false);
                onClick === null || onClick === void 0 ? void 0 : onClick(props);
            }
        }, tabIndex: 0 },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles({
                width: `calc(100% - ${!me && participantStateString ? participantStateMaxWidth : menuButtonContainerStyle.width})`,
                alignItems: 'center'
            }) },
            avatar,
            me && React__default['default'].createElement(react.Text, { className: meTextStyle }, strings.isMeText),
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(infoContainerStyle) }, onRenderIcon && onRenderIcon(props))),
        !me && participantStateString ? React__default['default'].createElement(react.Text, { "data-ui-id": "participant-item-state-string", className: react.mergeStyles(participantStateStringStyles) }, participantStateString) : React__default['default'].createElement("div", null, menuItems && menuItems.length > 0 && React__default['default'].createElement(React__default['default'].Fragment, null,
            menuButton,
            React__default['default'].createElement(react.ContextualMenu, { items: menuItems, hidden: menuHidden, target: containerRef, onItemClick: onDismissMenu, onDismiss: onDismissMenu, directionalHint: react.DirectionalHint.bottomRightEdge, className: contextualMenuStyle, calloutProps: {
                    preventDismissOnEvent: _preventDismissOnEvent
                } }))));
};
const participantStateStringTrampoline$1 = (props, strings) => {
    return undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const participantListStyle$1 = react.mergeStyles({
    height: '100%',
    padding: '0.125rem'
});
/**
 * @private
 */
const participantListItemStyle = {
    root: {
        paddingLeft: '1rem',
        paddingRight: '1rem',
        ':focus-visible': {
            margin: '0.125rem'
        }
    }
};
/**
 * @private
 */
const iconStyles$1 = react.mergeStyles({
    display: 'flex',
    lineHeight: 0,
    alignItems: 'center'
});

// Copyright (c) Microsoft Corporation.
const onRenderParticipantDefault = (participant, strings, myUserId, onRenderAvatar, createParticipantMenuItems, styles, onParticipantClick, showParticipantOverflowTooltip) => {
    const callingParticipant = participant;
    let presence = undefined;
    if (callingParticipant) {
        if (callingParticipant.state === 'Connected') {
            presence = react.PersonaPresence.online;
        }
        else if (callingParticipant.state === 'Idle') {
            presence = react.PersonaPresence.away;
        }
    }
    const menuItems = createParticipantMenuItems && createParticipantMenuItems(participant);
    const onRenderIcon = (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isScreenSharing) || (callingParticipant === null || callingParticipant === void 0 ? void 0 : callingParticipant.isMuted) ? () => React__default['default'].createElement(react.Stack, { horizontal: true, tokens: {
            childrenGap: '0.5rem'
        } },
        callingParticipant.isScreenSharing && React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemScreenShareStart", className: iconStyles$1, ariaLabel: strings.sharingIconLabel }),
        callingParticipant.isMuted && React__default['default'].createElement(react.Icon, { iconName: "ParticipantItemMicOff", className: iconStyles$1, ariaLabel: strings.mutedIconLabel })) : () => null;
    return React__default['default'].createElement(ParticipantItem, { styles: styles, key: participant.userId, userId: participant.userId, displayName: participant.displayName, me: myUserId ? participant.userId === myUserId : false, menuItems: menuItems, presence: presence, onRenderIcon: onRenderIcon, onRenderAvatar: onRenderAvatar, onClick: () => onParticipantClick === null || onParticipantClick === void 0 ? void 0 : onParticipantClick(participant), showParticipantOverflowTooltip: showParticipantOverflowTooltip });
};
const getParticipantsForDefaultRender = (participants, excludeMe, myUserId) => {
    if (!excludeMe || !myUserId) {
        return [...participants];
    }
    const userIndex = participants.map(p => p.userId).indexOf(myUserId);
    if (userIndex === -1) {
        return [...participants];
    }
    const remoteParticipants = [...participants];
    remoteParticipants.splice(userIndex, 1);
    return remoteParticipants;
};
/**
 * Component to render all calling or chat participants.
 *
 * By default, each participant is rendered with {@link ParticipantItem}. See {@link ParticipantListProps.onRenderParticipant} to override.
 *
 * @public
 */
const ParticipantList = (props) => {
    var _a, _b, _c, _d;
    const { excludeMe = false, myUserId, participants, onRemoveParticipant, onRenderAvatar, onRenderParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip } = props;
    const ids = useIdentifiers();
    const strings = useLocale$1().strings.participantItem;
    const displayedParticipants = React.useMemo(() => {
        return onRenderParticipant ? participants : getParticipantsForDefaultRender(participants, excludeMe, myUserId);
    }, [participants, excludeMe, myUserId, onRenderParticipant]);
    const createParticipantMenuItems = React.useCallback((participant) => {
        var _a, _b;
        let menuItems = [];
        let participantIsRemovable = participant.isRemovable;
        if (participant.userId !== myUserId && onRemoveParticipant && participantIsRemovable) {
            menuItems.push({
                key: 'remove',
                text: strings.removeButtonLabel,
                onClick: () => onRemoveParticipant(participant.userId),
                itemProps: {
                    styles: (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles
                },
                'data-ui-id': ids.participantListRemoveParticipantButton
            });
        }
        if (onFetchParticipantMenuItems) {
            menuItems = onFetchParticipantMenuItems(participant.userId, myUserId, menuItems);
        }
        return menuItems;
    }, [ids.participantListRemoveParticipantButton, myUserId, onFetchParticipantMenuItems, onRemoveParticipant, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles) === null || _b === void 0 ? void 0 : _b.participantSubMenuItemsStyles, strings.removeButtonLabel]);
    const participantItemStyles = React.useMemo(() => { var _a; return react.merge(participantListItemStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.participantItemStyles); }, [(_c = props.styles) === null || _c === void 0 ? void 0 : _c.participantItemStyles]);
    return React__default['default'].createElement(react.Stack, { "data-ui-id": ids.participantList, className: react.mergeStyles(participantListStyle$1, (_d = props.styles) === null || _d === void 0 ? void 0 : _d.root) }, displayedParticipants.map((participant) => onRenderParticipant ? onRenderParticipant(participant) : onRenderParticipantDefault(participant, strings, myUserId, onRenderAvatar, createParticipantMenuItems, participantItemStyles, props.onParticipantClick, showParticipantOverflowTooltip)));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * For keyboard navigation - when this component has active focus, enter key and space keys should have the same behavior as mouse click.
 *
 * @private
 */
const submitWithKeyboard = (e, onSubmit) => {
    if (e.key === 'Enter' || e.key === ' ') {
        onSubmit(e);
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Maps the individual item in menuProps.items passed in the {@link DrawerMenu} into a UI component.
 *
 * @private
 */
const DrawerMenuItem = (props) => {
    var _a;
    const theme = useTheme();
    const onClick = (ev) => props.onItemClick && props.onItemClick(ev, props.itemKey);
    const onKeyPress = (ev) => onClick && submitWithKeyboard(ev, onClick);
    const secondaryIcon = props.secondaryIconProps ? React__default['default'].createElement(MenuItemIcon, Object.assign({}, props.secondaryIconProps)) : props.subMenuProps ? React__default['default'].createElement(MenuItemIcon, { iconName: "ChevronRight" }) : undefined;
    return React__default['default'].createElement(react.Stack, { tabIndex: 0, role: "menuitem", horizontal: true, className: react.mergeStyles(drawerMenuItemRootStyles(theme.palette.neutralLight, theme.fonts.small), props.disabled ? disabledDrawerMenuItemRootStyles(theme.palette.neutralQuaternaryAlt) : undefined, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root), onKeyPress: props.disabled ? undefined : onKeyPress, onClick: props.disabled ? undefined : onClick, tokens: menuItemChildrenGap, id: props.id },
        props.iconProps && React__default['default'].createElement(react.Stack.Item, { role: "presentation", styles: props.disabled ? {
                root: {
                    color: theme.palette.neutralTertiaryAlt
                }
            } : undefined },
            React__default['default'].createElement(MenuItemIcon, Object.assign({}, props.iconProps))),
        React__default['default'].createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, grow: true },
            React__default['default'].createElement(react.Text, { styles: props.disabled ? {
                    root: {
                        color: theme.palette.neutralTertiaryAlt
                    }
                } : undefined }, props.text)),
        props.secondaryText && React__default['default'].createElement(react.Stack.Item, { styles: drawerMenuItemTextStyles, className: react.mergeStyles(secondaryTextStyles) },
            React__default['default'].createElement(react.Text, { styles: {
                    root: {
                        color: props.disabled ? theme.palette.neutralTertiaryAlt : theme.palette.neutralSecondary
                    }
                } }, props.secondaryText)),
        props.secondaryComponent && React__default['default'].createElement(react.Stack.Item, null, props.secondaryComponent),
        secondaryIcon && React__default['default'].createElement(react.Stack.Item, null, secondaryIcon));
};
const MenuItemIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({ className: react.mergeStyles(iconStyles) }, props));
const menuItemChildrenGap = {
    childrenGap: '0.5rem'
};
const drawerMenuItemRootStyles = (hoverBackground, fontSize) => (Object.assign(Object.assign({}, fontSize), { height: '3rem', lineHeight: '3rem', padding: '0rem 0.75rem', cursor: 'pointer', ':hover, :focus': {
        background: hoverBackground
    } }));
const disabledDrawerMenuItemRootStyles = (background) => ({
    pointerEvents: 'none',
    background: background,
    ':hover, :focus': {
        background: background
    }
});
/** Ensure long text entries appropriately show ellipsis instead of wrapping to a new line or showing a scrollbar */
const drawerMenuItemTextStyles = {
    root: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
const iconStyles = {
    // Vertically center icons in the menu item. Using line-height does not work for centering fluent SVG icons.
    display: 'flex',
    alignItems: 'center',
    height: '100%',
    // This can be removed when we upgrade to fluent-react-icons v2 (that removes the inner span element)
    ' span': {
        display: 'flex',
        alignItems: 'center',
        height: '100%'
    }
};
const secondaryTextStyles = {
    // limit width for secondaryText in the menu item so it does not overlap with text on left.
    maxWidth: '50%'
};

// Copyright (c) Microsoft Corporation.
/**
 * Container that holds the content of the drawer
 *
 * @private
 */
const DrawerContentContainer = (props) => {
    var _a;
    const theme = react.useTheme();
    const backgroundColor = theme.palette.white;
    const borderRadius = theme.effects.roundedCorner4;
    const rootStyles = react.mergeStyles(containerStyles$1(backgroundColor, borderRadius), (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root);
    return React__default['default'].createElement(react.Stack, { className: rootStyles },
        props.heading && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(headingContainerStyles) },
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(headingStyles(theme)) }, props.heading)),
        props.children);
};
const containerStyles$1 = (backgroundColor, borderRadius) => (Object.assign({ background: backgroundColor, borderTopRightRadius: borderRadius, borderTopLeftRadius: borderRadius }, react.AnimationStyles.slideUpIn10));
const headingContainerStyles = {
    textAlign: 'center',
    width: '100%',
    padding: '0.5rem'
};
const headingStyles = (theme) => ({
    color: theme.palette.neutralSecondary,
    fontSize: theme.fonts.smallPlus.fontSize,
    lineHeight: '1rem',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis'
});

// Copyright (c) Microsoft Corporation.
/**
 * An element that fills the space the DrawerContentContainer does not take up.
 * This is the element that enables the light dismiss feature.
 *
 * @private
 */
const DrawerLightDismiss = (props) => {
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(lightDismissContainerStyles, props.styles), grow: true, onClick: () => props.onDismiss() });
};
const lightDismissContainerStyles = {
    root: {
        height: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * A `Drawer` can be used to reveal lightweight views inside your application.
 * They appear from the bottom of the screen upwards and are light-dismissed.
 *
 * @internal
 */
const _DrawerSurface = (props) => {
    var _a, _b, _c, _d;
    const rootStyles = props.disableMaxHeight ? react.mergeStyles(drawerSurfaceStyles, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) : react.mergeStyles(drawerSurfaceStyles, focusTrapZoneStyles, (_b = props.styles) === null || _b === void 0 ? void 0 : _b.root);
    const containerStyles = react.mergeStyleSets(drawerContentContainerStyles, (_c = props.styles) === null || _c === void 0 ? void 0 : _c.drawerContentContainer);
    return React__default['default'].createElement(react.Stack, { className: rootStyles },
        React__default['default'].createElement(DrawerLightDismiss, { styles: (_d = props.styles) === null || _d === void 0 ? void 0 : _d.lightDismissRoot, onDismiss: props.onLightDismiss }),
        React__default['default'].createElement(react.FocusTrapZone, { onKeyDown: e => {
                if (e.key === 'Escape' || e.key === 'Esc') {
                    props.onLightDismiss && props.onLightDismiss();
                }
            }, 
            // Ensure when the focus trap has focus, the light dismiss area can still be clicked with mouse to dismiss.
            // Note: this still correctly captures keyboard focus, this just allows mouse click outside of the focus trap.
            isClickableOutsideFocusTrap: true },
            React__default['default'].createElement(DrawerContentContainer, { styles: containerStyles, heading: props.heading }, props.children)));
};
const drawerSurfaceStyles = {
    width: '100%',
    height: '100%',
    background: 'rgba(0,0,0,0.4)'
};
const focusTrapZoneStyles = {
    // Targets FocusTrapZone in drawer.
    // Setting percentage to Height to transform a container does not work unless the
    // direct parent container also has a Height set other than 'auto'.
    '> div:nth-child(2)': {
        maxHeight: '75%',
        overflow: 'auto'
    }
};
const drawerContentContainerStyles = {
    root: {
        // Needed to fill max height from parent, drawerSurfaceStyles
        height: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Takes a set of menu items and returns a created menu inside a {@link _DrawerSurface}.
 *
 * @internal
 */
const _DrawerMenu = (props) => {
    var _a, _b;
    // This component breaks from a pure component pattern in order to internally support sub menus.
    // When a sub menu item is clicked the menu items displayed is updated to be that of the submenu.
    // To track this state we store a list of the keys clicked up until this point.
    const [selectedKeyPath, setSelectedKeyPath] = React.useState([]);
    // Get the menu items that should be rendered
    const menuItemsToRender = React.useMemo(() => {
        var _a;
        let items = props.items;
        for (const subMenuKey of selectedKeyPath) {
            items = (_a = items === null || items === void 0 ? void 0 : items.find(item => item.itemKey === subMenuKey)) === null || _a === void 0 ? void 0 : _a.subMenuProps;
        }
        return items;
    }, [props.items, selectedKeyPath]);
    // When an item is clicked and it contains a submenu, push the key for the submenu. This will ensure
    // a new render is triggered, menuItemsToRender will be re-calculated and the submenu will render.
    const onItemClick = React.useCallback((item, ev, itemKey) => {
        var _a;
        if (item.subMenuProps) {
            setSelectedKeyPath([...selectedKeyPath, item.itemKey]);
        }
        (_a = item.onItemClick) === null || _a === void 0 ? void 0 : _a.call(item, ev, itemKey);
    }, [selectedKeyPath]);
    // Ensure the first item has a border radius that matches the DrawerSurface
    const borderRadius = useTheme().effects.roundedCorner4;
    const firstItemStyle = menuItemsToRender && ((_a = menuItemsToRender[0]) === null || _a === void 0 ? void 0 : _a.styles);
    const modifiedFirstItemStyle = React.useMemo(() => react.merge(firstItemStyle !== null && firstItemStyle !== void 0 ? firstItemStyle : {}, {
        root: {
            borderTopRightRadius: borderRadius,
            borderTopLeftRadius: borderRadius
        }
    }), [firstItemStyle, borderRadius]);
    return React__default['default'].createElement(_DrawerSurface, { disableMaxHeight: props.disableMaxHeight, styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.drawerSurfaceStyles, onLightDismiss: props.onLightDismiss, heading: props.heading },
        React__default['default'].createElement(react.Stack, { styles: props.styles, role: "menu", "data-ui-id": "drawer-menu" }, menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(0, 1).map(item => React__default['default'].createElement(DrawerMenuItem, Object.assign({}, item, { key: '0', styles: modifiedFirstItemStyle, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } }))), menuItemsToRender === null || menuItemsToRender === void 0 ? void 0 :
            menuItemsToRender.slice(1).map((item, i) => React__default['default'].createElement(DrawerMenuItem, Object.assign({}, item, { key: `${i + 1}`, onItemClick: (ev, itemKey) => {
                    onItemClick(item, ev, itemKey);
                } })))));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @private */
const remoteVideoTileWrapperStyle = {
    height: '100%',
    width: '100%',
    position: 'relative'
};
/** @private */
const drawerMenuWrapperStyles = {
    root: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        // Any zIndex > 0 will work because this is the only absolutely
        // positioned element in the container.
        zIndex: 2
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * Helper hook to maintain the video stream lifecycle. This calls onCreateStreamView and onDisposeStreamView
 * appropriately based on react lifecycle events and prop changes.
 *
 * @remarks
 *
 * Notes on handling changes to scaling mode:
 *
 * Ideally we have access to the original StreamRenderView and can call view.updateScalingMode() and do not need to recreate the stream view.
 * However, to support backwards compat we cannot guarantee this. If we don't have access to the original StreamRenderView we need to dispose
 * the old view and create a new one.
 *
 * Supporting both of these scenarios became too complex and fragile. When we introduce a breaking change this should be update to ensure that
 * onCreateStreamView _must_ return a view object with updateScalingMode and update logic in this hook to call view.updateScalingMode instead
 * of recreating the stream.
 *
 * @private
 */
const useVideoStreamLifecycleMaintainer = (props) => {
    const { isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode } = props;
    const [videoStreamViewResult, setVideoStreamViewResult] = React.useState();
    React.useEffect(() => {
        var _a;
        if (isStreamAvailable && !renderElementExists) {
            (_a = onCreateStreamView === null || onCreateStreamView === void 0 ? void 0 : onCreateStreamView({
                isMirrored,
                scalingMode
            })) === null || _a === void 0 ? void 0 : _a.then(result => {
                result && setVideoStreamViewResult(result);
            });
        }
        // Always clean up element to make tile up to date and be able to dispose correctly
        return () => {
            if (renderElementExists) {
                // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
                if (!isScreenSharingOn) {
                    onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
                }
            }
        };
    }, [isMirrored, isScreenSharingOn, isStreamAvailable, onCreateStreamView, onDisposeStreamView, renderElementExists, scalingMode]);
    // The execution order for above useEffect is onCreateRemoteStreamView =>(async time gap) RenderElement generated => element disposed => onDisposeRemoteStreamView
    // Element disposed could happen during async time gap, which still cause leaks for unused renderElement.
    // Need to do an entire cleanup when remoteTile gets disposed and make sure element gets correctly disposed
    React.useEffect(() => {
        return () => {
            // TODO: Remove `if isScreenSharingOn` when we isolate dispose behavior for screen share
            if (!isScreenSharingOn) {
                onDisposeStreamView === null || onDisposeStreamView === void 0 ? void 0 : onDisposeStreamView();
            }
        };
    }, [isScreenSharingOn, onDisposeStreamView]);
    return videoStreamViewResult;
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for local video streams
 *
 * @private
 */
const useLocalVideoStreamLifecycleMaintainer = (props) => {
    const { onCreateLocalStreamView, onDisposeLocalStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateLocalStreamView === null || onCreateLocalStreamView === void 0 ? void 0 : onCreateLocalStreamView(options);
    }, [onCreateLocalStreamView]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeLocalStreamView === null || onDisposeLocalStreamView === void 0 ? void 0 : onDisposeLocalStreamView();
    }, [onDisposeLocalStreamView]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};
/**
 * Extension of {@link useVideoStreamLifecycleMaintainer} specifically for remote video streams
 *
 * @private
 */
const useRemoteVideoStreamLifecycleMaintainer = (props) => {
    const { remoteParticipantId, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const onCreateStreamView = React.useMemo(() => (options) => {
        return onCreateRemoteStreamView === null || onCreateRemoteStreamView === void 0 ? void 0 : onCreateRemoteStreamView(remoteParticipantId, options);
    }, [onCreateRemoteStreamView, remoteParticipantId]);
    const onDisposeStreamView = React.useMemo(() => () => {
        onDisposeRemoteStreamView === null || onDisposeRemoteStreamView === void 0 ? void 0 : onDisposeRemoteStreamView(remoteParticipantId);
    }, [onDisposeRemoteStreamView, remoteParticipantId]);
    return useVideoStreamLifecycleMaintainer(Object.assign(Object.assign({}, props), { onCreateStreamView,
        onDisposeStreamView }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useVideoTileContextualMenuProps = (props) => {
    const { remoteParticipant, view, strings, isPinned, onPinParticipant, onUnpinParticipant, disablePinMenuItem, toggleAnnouncerString } = props;
    const scalingMode = React.useMemo(() => {
        return undefined;
    }, []);
    const contextualMenuProps = React.useMemo(() => {
        const items = [];
        if (isPinned !== undefined) {
            if (isPinned && onUnpinParticipant && (strings === null || strings === void 0 ? void 0 : strings.unpinParticipantForMe)) {
                let unpinActionString = undefined;
                if (toggleAnnouncerString && strings.unpinParticipantMenuItemAriaLabel && remoteParticipant.displayName) {
                    unpinActionString = _formatString(strings === null || strings === void 0 ? void 0 : strings.unpinParticipantMenuItemAriaLabel, {
                        participantName: remoteParticipant.displayName
                    });
                }
                items.push({
                    key: 'unpin',
                    text: strings.unpinParticipantForMe,
                    iconProps: {
                        iconName: 'UnpinParticipant',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onUnpinParticipant(remoteParticipant.userId);
                        unpinActionString && (toggleAnnouncerString === null || toggleAnnouncerString === void 0 ? void 0 : toggleAnnouncerString(unpinActionString));
                    },
                    'data-ui-id': 'video-tile-unpin-participant-button',
                    ariaLabel: unpinActionString
                });
            }
            if (!isPinned && onPinParticipant && (strings === null || strings === void 0 ? void 0 : strings.pinParticipantForMe)) {
                let pinActionString = undefined;
                if (toggleAnnouncerString && strings.pinnedParticipantAnnouncementAriaLabel && remoteParticipant.displayName) {
                    pinActionString = _formatString(strings === null || strings === void 0 ? void 0 : strings.pinnedParticipantAnnouncementAriaLabel, {
                        participantName: remoteParticipant.displayName
                    });
                }
                items.push({
                    key: 'pin',
                    text: disablePinMenuItem ? strings.pinParticipantForMeLimitReached : strings.pinParticipantForMe,
                    iconProps: {
                        iconName: 'PinParticipant',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        onPinParticipant(remoteParticipant.userId);
                        pinActionString && (toggleAnnouncerString === null || toggleAnnouncerString === void 0 ? void 0 : toggleAnnouncerString(pinActionString));
                    },
                    'data-ui-id': 'video-tile-pin-participant-button',
                    disabled: disablePinMenuItem,
                    ariaLabel: pinActionString
                });
            }
        }
        if (scalingMode) {
            if (scalingMode === 'Crop' && (strings === null || strings === void 0 ? void 0 : strings.fitRemoteParticipantToFrame)) {
                items.push({
                    key: 'fitRemoteParticipantToFrame',
                    text: strings.fitRemoteParticipantToFrame,
                    iconProps: {
                        iconName: 'VideoTileScaleFit',
                        styles: {
                            root: {
                                lineHeight: '1rem',
                                textAlign: 'center'
                            }
                        }
                    },
                    onClick: () => {
                        view === null || view === void 0 ? void 0 : view.updateScalingMode('Fit');
                    },
                    'data-ui-id': 'video-tile-fit-to-frame',
                    ariaLabel: strings.fitRemoteParticipantToFrame
                });
            }
            else if (scalingMode === 'Fit' && (strings === null || strings === void 0 ? void 0 : strings.fillRemoteParticipantFrame)) {
                {
                    items.push({
                        key: 'fillRemoteParticipantFrame',
                        text: strings.fillRemoteParticipantFrame,
                        iconProps: {
                            iconName: 'VideoTileScaleFill',
                            styles: {
                                root: {
                                    lineHeight: '1rem',
                                    textAlign: 'center'
                                }
                            }
                        },
                        onClick: () => {
                            view === null || view === void 0 ? void 0 : view.updateScalingMode('Crop');
                        },
                        'data-ui-id': 'video-tile-fill-frame',
                        ariaLabel: strings.fillRemoteParticipantFrame
                    });
                }
            }
        }
        if (items.length === 0) {
            return undefined;
        }
        return {
            items,
            styles: {}
        };
    }, [scalingMode, strings, view, isPinned, onPinParticipant, onUnpinParticipant, remoteParticipant.userId, remoteParticipant.displayName, disablePinMenuItem, toggleAnnouncerString]);
    return contextualMenuProps;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const rootStyles = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const videoContainerStyles = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    minWidth: '100%',
    minHeight: '100%',
    objectPosition: 'center',
    objectFit: 'cover',
    zIndex: 0
};
/**
 * @private
 */
const overlayContainerStyles = {
    width: '100%',
    height: '100%',
    zIndex: 5
};
/**
 * @private
 */
const tileInfoContainerStyle = react.mergeStyles({
    position: 'absolute',
    bottom: '0',
    left: '0',
    padding: '0.5rem',
    width: '100%'
});
/**
 * @private
 */
const disabledVideoHint = react.mergeStyles({
    backgroundColor: 'inherit',
    boxShadow: 'none',
    textAlign: 'left',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    alignItems: 'center',
    padding: '0.15rem',
    maxWidth: '100%'
});
/**
 * @private
 */
const videoHint = react.mergeStyles(disabledVideoHint, {
    // This will appear on top of the video stream, so no dependency on theme and explicitly use a translucent white
    backgroundColor: 'rgba(255,255,255,0.8)'
});
/**
 * @private
 */
const displayNameStyle = {
    padding: '0.1rem',
    fontSize: '0.75rem',
    fontWeight: 600,
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    maxWidth: '100%'
};
/**
 * @private
 */
const iconContainerStyle = {
    margin: 'auto',
    alignItems: 'center',
    '& svg': {
        display: 'block',
        // Similar to text color, icon color will be inherited from parent container
        color: 'inherit'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getVideoTileOverrideColor = (isVideoRendered, theme, color) => {
    // when video is being rendered, the info has a grey-ish background, so no use of theme
    return {
        color: isVideoRendered ? react.DefaultPalette[color] : theme.palette[color]
    };
};

// Copyright (c) Microsoft Corporation.
// Coin max size is set to PersonaSize.size100
const DEFAULT_PERSONA_MAX_SIZE_PX = 100;
// Coin min size is set PersonaSize.size32
const DEFAULT_PERSONA_MIN_SIZE_PX = 32;
const DefaultPlaceholder = (props) => {
    const { text, noVideoAvailableAriaLabel, coinSize, hidePersonaDetails } = props;
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
            position: 'absolute',
            height: '100%',
            width: '100%'
        }) },
        React__default['default'].createElement(react.Stack, { styles: defaultPersonaStyles }, coinSize && React__default['default'].createElement(react.Persona, { coinSize: coinSize, hidePersonaDetails: hidePersonaDetails, text: text !== null && text !== void 0 ? text : '', initialsTextColor: "white", "aria-label": noVideoAvailableAriaLabel !== null && noVideoAvailableAriaLabel !== void 0 ? noVideoAvailableAriaLabel : '', showOverflowTooltip: false })));
};
const defaultPersonaStyles = {
    root: {
        margin: 'auto',
        maxHeight: '100%'
    }
};
/**
 * A component to render the video stream for a single call participant.
 *
 * Use with {@link GridLayout} in a {@link VideoGallery}.
 *
 * @public
 */
const VideoTile = (props) => {
    const { children, displayName, initialsName, isMirrored, isMuted, onRenderPlaceholder, renderElement, showLabel = true, showMuteIndicator = true, styles, userId, noVideoAvailableAriaLabel, isSpeaking, personaMinSize = DEFAULT_PERSONA_MIN_SIZE_PX, personaMaxSize = DEFAULT_PERSONA_MAX_SIZE_PX } = props;
    // need to set a default otherwise the resizeObserver will get stuck in an infinite loop.
    const [personaSize, setPersonaSize] = React.useState(1);
    const videoTileRef = React.useRef(null);
    useLocale$1();
    const theme = useTheme();
    const isVideoRendered = !!renderElement;
    const observer = React.useRef(new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        const personaCalcSize = Math.min(width, height) / 3;
        // we only want to set the persona size if it has changed
        if (personaCalcSize !== personaSize) {
            setPersonaSize(Math.max(Math.min(personaCalcSize, personaMaxSize), personaMinSize));
        }
    }));
    React.useLayoutEffect(() => {
        if (videoTileRef.current) {
            observer.current.observe(videoTileRef.current);
        }
        const currentObserver = observer.current;
        return () => currentObserver.disconnect();
    }, [observer, videoTileRef]);
    const longPressHandlersTrampoline = React.useMemo(() => {
        return {};
    }, []);
    const hoverHandlers = React.useMemo(() => {
        return {};
    }, []);
    const placeholderOptions = {
        userId,
        text: initialsName !== null && initialsName !== void 0 ? initialsName : displayName,
        noVideoAvailableAriaLabel,
        coinSize: personaSize,
        styles: defaultPersonaStyles,
        hidePersonaDetails: true
    };
    const videoHintWithBorderRadius = react.mergeStyles(videoHint, {
        borderRadius: theme.effects.roundedCorner4
    });
    const tileInfoStyle = React.useMemo(() => react.mergeStyles(isVideoRendered ? videoHintWithBorderRadius : disabledVideoHint, getVideoTileOverrideColor(isVideoRendered, theme, 'neutralPrimary'), styles === null || styles === void 0 ? void 0 : styles.displayNameContainer), [isVideoRendered, videoHintWithBorderRadius, theme, styles === null || styles === void 0 ? void 0 : styles.displayNameContainer]);
    const ids = useIdentifiers();
    const canShowLabel = showLabel && (displayName || showMuteIndicator && isMuted);
    const participantStateString = participantStateStringTrampoline();
    return React__default['default'].createElement(react.Stack, Object.assign({ "data-ui-id": ids.videoTile, className: react.mergeStyles(rootStyles, {
            background: theme.palette.neutralLighter,
            borderRadius: theme.effects.roundedCorner4
        }, isSpeaking && {
            '&::after': {
                content: `''`,
                position: 'absolute',
                border: `0.25rem solid ${theme.palette.themePrimary}`,
                borderRadius: theme.effects.roundedCorner4,
                width: '100%',
                height: '100%',
                pointerEvents: 'none'
            }
        }, styles === null || styles === void 0 ? void 0 : styles.root) }, longPressHandlersTrampoline),
        React__default['default'].createElement("div", Object.assign({ ref: videoTileRef, style: {
                width: '100%',
                height: '100%'
            } }, hoverHandlers, { "data-is-focusable": true }),
            isVideoRendered ? React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, isMirrored && {
                    transform: 'scaleX(-1)'
                }, styles === null || styles === void 0 ? void 0 : styles.videoContainer) }, renderElement) : React__default['default'].createElement(react.Stack, { className: react.mergeStyles(videoContainerStyles, {
                    opacity: 1
                }) }, onRenderPlaceholder ? onRenderPlaceholder(userId !== null && userId !== void 0 ? userId : '', placeholderOptions, DefaultPlaceholder) : React__default['default'].createElement(DefaultPlaceholder, Object.assign({}, placeholderOptions))),
            (canShowLabel || participantStateString) && React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoContainerStyle, tokens: tileInfoContainerTokens },
                React__default['default'].createElement(react.Stack, { horizontal: true, className: tileInfoStyle },
                    canShowLabel && React__default['default'].createElement(react.Text, { className: react.mergeStyles(displayNameStyle), title: displayName, style: {
                            color: 'inherit'
                        }, "data-ui-id": "video-tile-display-name" }, displayName),
                    participantStateString ,
                    showMuteIndicator && isMuted && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(iconContainerStyle) },
                        React__default['default'].createElement(react.Icon, { iconName: "VideoTileMicOff" })))),
            children && React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayContainerStyles, styles === null || styles === void 0 ? void 0 : styles.overlayContainer) }, children)));
};
const participantStateStringTrampoline = (props, locale) => {
    return undefined;
};
const tileInfoContainerTokens = {
    // A horizontal Stack sets the left margin to 0 for all it's children.
    // We need to allow the children to set their own margins
    childrenGap: 'none'
};

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering remote participants. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering a VideoTile when its position in the
 * array changes causing a rerender in the parent component. https://reactjs.org/docs/react-api.html#reactmemo
 *
 * @internal
 */
const _RemoteVideoTile = React__default['default'].memo((props) => {
    var _a;
    const { isAvailable, isReceiving = true, 
    // default to true to prevent any breaking change
    isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, renderElement, userId, onRenderAvatar, showMuteIndicator, remoteParticipant, participantState, menuKind, isPinned, onPinParticipant, onUnpinParticipant, disablePinMenuItem, toggleAnnouncerString, strings } = props;
    const remoteVideoStreamProps = React.useMemo(() => ({
        isMirrored: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored,
        isScreenSharingOn,
        isStreamAvailable: isAvailable,
        isStreamReceiving: isReceiving,
        onCreateRemoteStreamView,
        onDisposeRemoteStreamView,
        remoteParticipantId: userId,
        renderElementExists: !!renderElement,
        scalingMode: remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode
    }), [isAvailable, isReceiving, isScreenSharingOn, onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.isMirrored, remoteVideoViewOptions === null || remoteVideoViewOptions === void 0 ? void 0 : remoteVideoViewOptions.scalingMode, renderElement, userId]);
    // Handle creating, destroying and updating the video stream as necessary
    const createVideoStreamResult = useRemoteVideoStreamLifecycleMaintainer(remoteVideoStreamProps);
    const contextualMenuProps = useVideoTileContextualMenuProps({
        remoteParticipant,
        view: createVideoStreamResult === null || createVideoStreamResult === void 0 ? void 0 : createVideoStreamResult.view,
        isPinned,
        onPinParticipant,
        onUnpinParticipant,
        disablePinMenuItem,
        toggleAnnouncerString
    });
    const videoTileContextualMenuProps = React.useMemo(() => {
        if (menuKind !== 'contextual') {
            return {};
        }
        return videoTileContextualMenuPropsTrampoline(contextualMenuProps);
    }, [contextualMenuProps, menuKind]);
    const showLoadingIndicator = isAvailable && isReceiving === false && participantState !== 'Disconnected';
    const [drawerMenuItemProps, setDrawerMenuItemProps] = React__default['default'].useState([]);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: showLoadingIndicator ? 'loading' : 'none' });
    }, [renderElement, showLoadingIndicator]);
    return React__default['default'].createElement(react.Stack, { style: remoteVideoTileWrapperStyle },
        React__default['default'].createElement(VideoTile, Object.assign({ key: userId, userId: userId, initialsName: (_a = remoteParticipant.displayName) !== null && _a !== void 0 ? _a : '', renderElement: renderVideoStreamElement, displayName: remoteParticipant.displayName || (strings === null || strings === void 0 ? void 0 : strings.displayNamePlaceholder), onRenderPlaceholder: onRenderAvatar, isMuted: remoteParticipant.isMuted, isSpeaking: remoteParticipant.isSpeaking, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize, showLabel: props.showLabel }, videoTileContextualMenuProps)),
        drawerMenuItemProps.length > 0 && React__default['default'].createElement(react.Layer, { hostId: props.drawerMenuHostId },
            React__default['default'].createElement(react.Stack, { styles: drawerMenuWrapperStyles },
                React__default['default'].createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItemProps([]), items: drawerMenuItemProps, heading: remoteParticipant.displayName }))));
});
const videoTileContextualMenuPropsTrampoline = (contextualMenuProps) => {
    if (!contextualMenuProps) {
        return {};
    }
    return {};
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const screenSharingContainerStyle = react.mergeStyles({
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const screenSharingNotificationContainerStyle = (theme) => react.mergeStyles({
    backgroundColor: 'inherit',
    padding: '1rem',
    maxWidth: '95%',
    borderRadius: theme.effects.roundedCorner4,
    color: theme.palette.neutralSecondary
});
/**
 * @private
 */
const screenSharingNotificationIconContainerStyle = react.mergeStyles({
    height: '2rem',
    lineHeight: 0
});
/**
 * @private
 */
const screenSharingNotificationIconStyle = (theme) => react.mergeStyles({
    // svg is (20px x 20px) but path is only (16px x 12px), so need to scale at 2.5 to get 40px
    transform: 'scale(2.5)',
    color: theme.palette.neutralTertiary
});
/**
 * @private
 */
const screenSharingNotificationTextStyle = react.mergeStyles({
    fontSize: '1rem',
    // Text component will take body color by default (white in Dark Mode), so forcing it to be parent container color
    color: 'inherit'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of local screen share component. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const LocalScreenShare = React__default['default'].memo((props) => {
    const { localParticipant } = props;
    const theme = useTheme();
    const locale = useLocale$1();
    if (!localParticipant || !localParticipant.isScreenSharingOn) {
        return null;
    }
    const localScreenSharingNotification = React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingContainerStyle },
        React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: screenSharingNotificationContainerStyle(theme), tokens: {
                childrenGap: '1rem'
            } },
            React__default['default'].createElement(react.Stack, { horizontal: true, verticalAlign: "center", className: screenSharingNotificationIconContainerStyle },
                React__default['default'].createElement(react.Icon, { iconName: "ControlButtonScreenShareStart", className: screenSharingNotificationIconStyle(theme) })),
            React__default['default'].createElement(react.Text, { className: screenSharingNotificationTextStyle, "aria-live": "polite" }, locale.strings.videoGallery.screenIsBeingSharedMessage)));
    const displayName = !(localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName) ? locale.strings.videoGallery.displayNamePlaceholder : localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.displayName;
    return React__default['default'].createElement(VideoTile, { displayName: displayName, isMuted: localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.isMuted, onRenderPlaceholder: () => React__default['default'].createElement(React__default['default'].Fragment, null) }, localScreenSharingNotification);
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const loadingStyle = react.mergeStyles({
    height: '100%',
    width: '100%'
});

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering the remote screen share stream. React.memo is used for a performance
 * boost by memoizing the same rendered component to avoid rerendering this when the parent component rerenders.
 * https://reactjs.org/docs/react-api.html#reactmemo
 */
const RemoteScreenShare = React__default['default'].memo((props) => {
    const { userId, displayName, isMuted, renderElement, onCreateRemoteStreamView, onDisposeRemoteStreamView, isReceiving } = props;
    const locale = useLocale$1();
    if (!renderElement) {
        onCreateRemoteStreamView && onCreateRemoteStreamView(userId);
    }
    React.useEffect(() => {
        return () => {
            // TODO: Isolate disposing behaviors for screenShare and videoStream
            onDisposeRemoteStreamView && onDisposeRemoteStreamView(userId);
        };
    }, [onDisposeRemoteStreamView, userId]);
    const loadingMessage = displayName ? _formatString(locale.strings.videoGallery.screenShareLoadingMessage, {
        participant: displayName
    }) : '';
    return React__default['default'].createElement(VideoTile, { displayName: displayName, isMuted: isMuted, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, loadingState: isReceiving === false ? 'loading' : 'none' }) : undefined, onRenderPlaceholder: () => React__default['default'].createElement(LoadingSpinner, { loadingMessage: loadingMessage }) });
});
const LoadingSpinner = (props) => {
    return React__default['default'].createElement(react.Stack, { verticalAlign: "center", className: loadingStyle },
        React__default['default'].createElement(react.Spinner, { label: props.loadingMessage, size: react.SpinnerSize.xSmall, "aria-live": 'assertive' }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoGalleryOuterDivStyle = react.mergeStyles({
    position: 'relative',
    width: '100%',
    height: '100%'
});
/**
 * @private
 */
const localVideoCameraCycleButtonStyles = (theme) => {
    return {
        root: {
            position: 'absolute',
            width: _pxToRem(32),
            height: _pxToRem(32),
            right: '0rem',
            top: '0rem',
            color: '#FFFFFF',
            // only shows up on running video feed to we want to force specific colours.
            zIndex: 2,
            // shows the button directly over the local video feed.
            background: 'rgba(0,0,0,0.4)',
            borderRadius: theme.effects.roundedCorner2
        },
        rootFocused: {
            // styles to remove the unwanted white highlight and blue colour after tapping on button.
            color: '#FFFFFF',
            background: 'rgba(0,0,0,0.4)' // sets opacity of background to be visible on all backdrops in video stream.
        },
        icon: {
            paddingLeft: _pxToRem(3),
            paddingRight: _pxToRem(3),
            margin: 0
        },
        flexContainer: {
            paddingBottom: _pxToRem(8),
            height: 'unset'
        }
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * local video tile camera cycle button - for use on mobile screens only.
 * @internal
 */
const LocalVideoCameraCycleButton = (props) => {
    const { cameras, selectedCamera, onSelectCamera, label, ariaDescription } = props;
    const theme = react.useTheme();
    return React__default['default'].createElement(react.IconButton, { "data-ui-id": 'local-camera-switcher-button', styles: localVideoCameraCycleButtonStyles(theme), iconProps: {
            iconName: 'LocalCameraSwitch'
        }, ariaLabel: label, ariaDescription: ariaDescription, "aria-live": 'polite', onClick: () => {
            if (cameras && cameras.length > 1 && selectedCamera !== undefined) {
                const index = cameras.findIndex(camera => selectedCamera.id === camera.id);
                const newCamera = cameras[(index + 1) % cameras.length];
                if (onSelectCamera !== undefined) {
                    onSelectCamera(newCamera);
                }
            }
        } });
};

// Copyright (c) Microsoft Corporation.
/**
 * A memoized version of VideoTile for rendering local participant.
 *
 * @internal
 */
const _LocalVideoTile = React__default['default'].memo((props) => {
    const { isAvailable, isMuted, onCreateLocalStreamView, onDisposeLocalStreamView, localVideoViewOptions, renderElement, userId, showLabel, displayName, initialsName, onRenderAvatar, showMuteIndicator, styles, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription } = props;
    const localVideoStreamProps = React.useMemo(() => ({
        isMirrored: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored,
        isStreamAvailable: isAvailable,
        onCreateLocalStreamView,
        onDisposeLocalStreamView,
        renderElementExists: !!renderElement,
        scalingMode: localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode
    }), [isAvailable, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.isMirrored, localVideoViewOptions === null || localVideoViewOptions === void 0 ? void 0 : localVideoViewOptions.scalingMode, onCreateLocalStreamView, onDisposeLocalStreamView, renderElement]);
    // Handle creating, destroying and updating the video stream as necessary
    useLocalVideoStreamLifecycleMaintainer(localVideoStreamProps);
    const renderVideoStreamElement = React.useMemo(() => {
        // Checking if renderElement is well defined or not as calling SDK has a number of video streams limitation which
        // implies that, after their threshold, all streams have no child (blank video)
        if (!renderElement || !renderElement.childElementCount) {
            // Returning `undefined` results in the placeholder with avatar being shown
            return undefined;
        }
        return React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(FloatingLocalCameraCycleButton, { showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview !== null && showCameraSwitcherInLocalPreview !== void 0 ? showCameraSwitcherInLocalPreview : false, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: localVideoCameraSwitcherLabel, localVideoSelectedDescription: localVideoSelectedDescription }),
            React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement, isMirrored: true }));
    }, [localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription, renderElement, showCameraSwitcherInLocalPreview]);
    return React__default['default'].createElement(VideoTile, { key: userId !== null && userId !== void 0 ? userId : 'local-video-tile', userId: userId, renderElement: renderVideoStreamElement, showLabel: showLabel, displayName: displayName, initialsName: initialsName, styles: styles, onRenderPlaceholder: onRenderAvatar, isMuted: isMuted, showMuteIndicator: showMuteIndicator, personaMinSize: props.personaMinSize });
});
const FloatingLocalCameraCycleButton = (props) => {
    const { showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel, localVideoSelectedDescription } = props;
    const ariaDescription = (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) && localVideoSelectedDescription && _formatString(localVideoSelectedDescription, {
        cameraName: localVideoCameraCycleButtonProps.selectedCamera.name
    });
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "end" }, showCameraSwitcherInLocalPreview && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.cameras) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.selectedCamera) !== undefined && (localVideoCameraCycleButtonProps === null || localVideoCameraCycleButtonProps === void 0 ? void 0 : localVideoCameraCycleButtonProps.onSelectCamera) !== undefined && React__default['default'].createElement(LocalVideoCameraCycleButton, { cameras: localVideoCameraCycleButtonProps.cameras, selectedCamera: localVideoCameraCycleButtonProps.selectedCamera, onSelectCamera: localVideoCameraCycleButtonProps.onSelectCamera, label: localVideoCameraSwitcherLabel, ariaDescription: ariaDescription }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const rootLayoutStyle$1 = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%',
        padding: '0.5rem'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const videoGalleryLayoutGap = {
    childrenGap: '0.5rem'
};

/**
 * Calculates the participants that should be rendered based on the list of dominant
 * speakers and currently rendered participants in a call.
 * @param args - SmartDominantSpeakerParticipantsArgs
 * @returns VideoGalleryRemoteParticipant[] {@link @azure/communication-react#VideoGalleryRemoteParticipant}
 */
const smartDominantSpeakerParticipants = (args) => {
    const { participants, dominantSpeakers = [], lastVisibleParticipants = [], maxDominantSpeakers } = args;
    // Don't apply any logic if total number of video streams is less than max dominant speakers.
    if (participants.length <= maxDominantSpeakers) {
        return participants;
    }
    const participantsMap = participantsById(participants);
    // Only use the Max allowed dominant speakers that exist in participants
    const dominantSpeakerIds = dominantSpeakers.filter(id => !!participantsMap[id]).slice(0, maxDominantSpeakers);
    const newVisibleParticipantIds = lastVisibleParticipants.map(p => p.userId).slice(0, maxDominantSpeakers);
    const newDominantSpeakerIds = dominantSpeakerIds.filter(id => !newVisibleParticipantIds.includes(id));
    // Remove participants that are no longer dominant and replace them with new dominant speakers.
    for (let index = 0; index < maxDominantSpeakers; index++) {
        const newVisibleParticipantId = newVisibleParticipantIds[index];
        if (newVisibleParticipantId === undefined || !dominantSpeakerIds.includes(newVisibleParticipantId)) {
            const replacement = newDominantSpeakerIds.shift();
            if (!replacement) {
                break;
            }
            newVisibleParticipantIds[index] = replacement;
        }
    }
    let newVisibleParticipants = newVisibleParticipantIds.map(participantId => participantsMap[participantId]).filter(p => p !== undefined);
    const newVisibleParticipantIdsSet = new Set(newVisibleParticipantIds);
    const remainingParticipants = participants.filter(p => !newVisibleParticipantIdsSet.has(p.userId));
    newVisibleParticipants = newVisibleParticipants.concat(remainingParticipants);
    return newVisibleParticipants;
};
const participantsById = (participants) => {
    const response = {};
    participants.forEach(p => response[p.userId] = p);
    return response;
};

// Copyright (c) Microsoft Corporation.
const DEFAULT_MAX_REMOTE_VIDEOSTREAMS = 4;
const DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS = 6;
const _useOrganizedParticipants = (props) => {
    const visibleGridParticipants = React.useRef([]);
    const visibleOverflowGalleryParticipants = React.useRef([]);
    const { remoteParticipants = [], dominantSpeakers = [], maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEOSTREAMS, maxOverflowGalleryDominantSpeakers = DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS, isScreenShareActive = false, pinnedParticipantUserIds = [] } = props;
    const videoParticipants = remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    visibleGridParticipants.current = pinnedParticipantUserIds.length > 0 || isScreenShareActive ? [] : smartDominantSpeakerParticipants({
        participants: videoParticipants,
        dominantSpeakers,
        lastVisibleParticipants: visibleGridParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    const visibleGridParticipantsSet = new Set(visibleGridParticipants.current.map(p => p.userId));
    const remoteParticipantsOrdered = putVideoParticipantsFirst(remoteParticipants);
    visibleOverflowGalleryParticipants.current = smartDominantSpeakerParticipants({
        participants: remoteParticipantsOrdered.filter(p => !visibleGridParticipantsSet.has(p.userId)),
        dominantSpeakers: dominantSpeakers,
        lastVisibleParticipants: visibleOverflowGalleryParticipants.current,
        maxDominantSpeakers: maxOverflowGalleryDominantSpeakers
    });
    const getGridParticipants = React.useCallback(() => {
        if (isScreenShareActive) {
            return [];
        }
        return visibleGridParticipants.current.length > 0 ? visibleGridParticipants.current : visibleOverflowGalleryParticipants.current;
    }, [isScreenShareActive]);
    const gridParticipants = getGridParticipants();
    const getOverflowGalleryRemoteParticipants = React.useCallback(() => {
        if (isScreenShareActive) {
            // If screen sharing is active, assign video and audio participants as overflow gallery participants
            return visibleGridParticipants.current.concat(visibleOverflowGalleryParticipants.current);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            return visibleGridParticipants.current.length > 0 ? visibleOverflowGalleryParticipants.current : [];
        }
    }, [isScreenShareActive]);
    const overflowGalleryParticipants = getOverflowGalleryRemoteParticipants();
    return {
        gridParticipants,
        overflowGalleryParticipants: overflowGalleryParticipants
    };
};
const putVideoParticipantsFirst = (remoteParticipants) => {
    const videoParticipants = [];
    const audioParticipants = [];
    remoteParticipants.forEach(p => {
        var _a;
        if ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) {
            videoParticipants.push(p);
        }
        else {
            audioParticipants.push(p);
        }
    });
    const remoteParticipantSortedByVideo = videoParticipants.concat(audioParticipants);
    return remoteParticipantSortedByVideo;
};
/**
 * Hook to determine which participants should be in grid and overflow gallery and their order respectively
 * @private
 */
const useOrganizedParticipants = (args) => {
    return _useOrganizedParticipants(args);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Horizontal Gallery button width in rem
 */
const HORIZONTAL_GALLERY_BUTTON_WIDTH = 1.75;
/**
 * @private
 */
const leftRightButtonStyles = (theme) => {
    return {
        background: 'none',
        padding: 0,
        height: 'auto',
        minWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        maxWidth: `${HORIZONTAL_GALLERY_BUTTON_WIDTH}rem`,
        border: `1px solid ${theme.palette.neutralLight}`,
        borderRadius: theme.effects.roundedCorner4
    };
};
/**
 * Horizontal Gallery gap size in rem between tiles and buttons
 */
const HORIZONTAL_GALLERY_GAP = 0.5;
/**
 * @private
 */
const rootStyle = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};
/**
 * @private
 */
const childrenContainerStyle = {
    height: '100%',
    width: '100%',
    gap: `${HORIZONTAL_GALLERY_GAP}rem`
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper function to bucketize a given array of items into buckets of a specified size.
 *
 * @param arr array to bucketize
 * @param bucketSize number of children for each bucket
 * @returns nested array of given children
 *
 * @private
 */
function bucketize(arr, bucketSize) {
    const bucketArray = [];
    if (bucketSize <= 0) {
        return bucketArray;
    }
    for (let i = 0; i < arr.length; i += bucketSize) {
        bucketArray.push(arr.slice(i, i + bucketSize));
    }
    return bucketArray;
}

// Copyright (c) Microsoft Corporation.
/**
 * {@link HorizontalGallery} default children per page
 */
const DEFAULT_CHILDREN_PER_PAGE = 5;
/**
 * Renders a horizontal gallery that parents children horizontally. Handles pagination based on the childrenPerPage prop.
 * @param props - HorizontalGalleryProps {@link @azure/communication-react#HorizontalGalleryProps}
 * @returns
 */
const HorizontalGallery = (props) => {
    var _a;
    const { children, childrenPerPage = DEFAULT_CHILDREN_PER_PAGE, styles, onFetchTilesToRender } = props;
    const ids = useIdentifiers();
    const [page, setPage] = React.useState(0);
    const numberOfChildren = React__default['default'].Children.count(children);
    const lastPage = Math.ceil(numberOfChildren / childrenPerPage) - 1;
    const indexesArray = React.useMemo(() => {
        return bucketize([...Array(numberOfChildren).keys()], childrenPerPage);
    }, [numberOfChildren, childrenPerPage]);
    React.useEffect(() => {
        if (onFetchTilesToRender && indexesArray) {
            onFetchTilesToRender(indexesArray[page]);
        }
    }, [indexesArray, onFetchTilesToRender, page]);
    const firstIndexOfCurrentPage = page * childrenPerPage;
    const clippedPage = firstIndexOfCurrentPage < numberOfChildren - 1 ? page : lastPage;
    const childrenOnCurrentPage = React.useMemo(() => {
        return indexesArray[clippedPage].map(index => {
            return React__default['default'].Children.toArray(children)[index];
        });
    }, [indexesArray, clippedPage, children]);
    const showButtons = numberOfChildren > childrenPerPage;
    const disablePreviousButton = page === 0;
    const disableNextButton = page === lastPage;
    const childrenStyles = React.useMemo(() => {
        return {
            root: styles === null || styles === void 0 ? void 0 : styles.children
        };
    }, [styles === null || styles === void 0 ? void 0 : styles.children]);
    // If children per page is 0 or less return empty element
    if (childrenPerPage <= 0) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(rootStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.root) },
        showButtons && React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "previous-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryLeftButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.previousButton, onClick: () => setPage(Math.max(0, Math.min(lastPage, page - 1))), disabled: disablePreviousButton, identifier: ids.overflowGalleryLeftNavButton }),
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(childrenContainerStyle) }, childrenOnCurrentPage.map((child, i) => {
            return React__default['default'].createElement(react.Stack.Item, { styles: childrenStyles, key: i, "data-ui-id": ids.horizontalGalleryVideoTile }, child);
        })),
        showButtons && React__default['default'].createElement(HorizontalGalleryNavigationButton, { key: "next-nav-button", icon: React__default['default'].createElement(react.Icon, { iconName: "HorizontalGalleryRightButton" }), styles: styles === null || styles === void 0 ? void 0 : styles.nextButton, onClick: () => setPage(Math.min(lastPage, page + 1)), disabled: disableNextButton, identifier: ids.overflowGalleryRightNavButton }));
};
const HorizontalGalleryNavigationButton = (props) => {
    const theme = useTheme();
    return React__default['default'].createElement(react.DefaultButton, { className: react.mergeStyles(leftRightButtonStyles(theme), props.styles), onClick: props.onClick, disabled: props.disabled, "data-ui-id": props.identifier }, props.icon);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
react.mergeStyles({
    position: 'relative',
    width: '100%',
    height: '100%'
});
/**
 * Small floating modal width and height in rem for small screen
 */
const SMALL_FLOATING_MODAL_SIZE_REM = {
    width: 3.625,
    height: 6.5
};
/**
 * Large floating modal width and height in rem for large screen
 * Aspect ratio: 16:9
 */
const LARGE_FLOATING_MODAL_SIZE_REM = {
    width: 13.438,
    height: 7.5
};
/**
 * @private
 * z-index to ensure that the local video tile is above the video gallery.
 */
const LOCAL_VIDEO_TILE_ZINDEX = 2;
/**
 * @private
 */
const localVideoTileContainerStyle = (theme, localVideoTileSizeRem) => {
    return {
        minWidth: `${localVideoTileSizeRem.width}rem`,
        minHeight: `${localVideoTileSizeRem.height}rem`,
        position: 'absolute',
        bottom: `${localVideoTileOuterPaddingRem}rem`,
        borderRadius: theme.effects.roundedCorner4,
        overflow: 'hidden',
        right: `${localVideoTileOuterPaddingRem}rem`
    };
};
/**
 * @private
 */
const localVideoTileWithControlsContainerStyle = (theme, localVideoTileSizeRem) => {
    return react.concatStyleSets(localVideoTileContainerStyle(theme, localVideoTileSizeRem), {
        root: {
            boxShadow: theme.effects.elevation8
        }
    });
};
/**
 * @private
 */
const floatingLocalVideoModalStyle = (theme, modalSizeRem) => {
    return react.concatStyleSets({
        main: localVideoTileContainerStyle(theme, modalSizeRem)
    }, {
        main: {
            boxShadow: theme.effects.elevation8,
            ':focus-within': {
                boxShadow: theme.effects.elevation16,
                border: `${_pxToRem(2)} solid ${theme.palette.neutralPrimary}`
            }
        }
    }, localVideoModalStyles);
};
/**
 * Padding equal to the amount the modal should stay inside the bounds of the container.
 * i.e. if this is 0.5rem, the modal should always be at least 0.5rem inside the container at all times on all sides.
 * @private
 */
const localVideoTileOuterPaddingRem = 0.5;
/**
 * @private
 */
const floatingLocalVideoTileStyle = {
    root: {
        position: 'absolute',
        zIndex: LOCAL_VIDEO_TILE_ZINDEX,
        height: '100%',
        width: '100%'
    }
};
/**
 * Styles for the local video tile modal when it is focused, will cause keyboard move icon to appear over video
 * @private
 */
const localVideoModalStyles = {
    keyboardMoveIconContainer: {
        zIndex: LOCAL_VIDEO_TILE_ZINDEX + 1 // zIndex to set the keyboard movement Icon above the other layers in the video tile.
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const horizontalGalleryContainerStyle = (shouldFloatLocalVideo, isNarrow) => {
    return {
        minHeight: isNarrow ? `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem` : `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
        width: shouldFloatLocalVideo ? isNarrow ? `calc(100% - ${SMALL_FLOATING_MODAL_SIZE_REM.width}rem)` : `calc(100% - ${LARGE_FLOATING_MODAL_SIZE_REM.width}rem)` : '100%',
        paddingRight: '0.5rem'
    };
};
/**
 * @private
 */
const horizontalGalleryStyle = (isNarrow) => {
    return {
        children: isNarrow ? SMALL_HORIZONTAL_GALLERY_TILE_STYLE : LARGE_HORIZONTAL_GALLERY_TILE_STYLE
    };
};
/**
 * Small horizontal gallery tile size in rem
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 6.5,
    width: 6.5
};
/**
 * Large horizontal gallery tile size in rem
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM = {
    height: 7.5,
    minWidth: 7.5,
    maxWidth: 13.43
};
/**
 * @private
 */
const SMALL_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`,
    maxHeight: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${SMALL_HORIZONTAL_GALLERY_TILE_SIZE_REM.width}rem`
};
/**
 * @private
 */
const LARGE_HORIZONTAL_GALLERY_TILE_STYLE = {
    minHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    minWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.minWidth}rem`,
    maxHeight: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.height}rem`,
    maxWidth: `${LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.maxWidth}rem`,
    width: '100%',
    height: '100%'
};

// Copyright (c) Microsoft Corporation.
/**
 * Helper function to calculate children per page for HorizontalGallery based on width of container, child, buttons, and
 * gaps in between
 *
 * @private
 */
const calculateHorizontalChildrenPerPage = (args) => {
    const { numberOfChildren, containerWidth, buttonWidthRem, gapWidthRem } = args;
    const childMinWidth = _convertRemToPx(LARGE_HORIZONTAL_GALLERY_TILE_SIZE_REM.minWidth);
    const gapWidth = _convertRemToPx(gapWidthRem);
    /** First check how many children can fit in containerWidth.
     *    __________________________________
     *   |                ||                |
     *   |                ||                |
     *   |________________||________________|
     *   <-----------containerWidth--------->
     *  containerWidth = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
     */
    const numberOfChildrenInContainer = Math.floor((containerWidth + gapWidth) / (childMinWidth + gapWidth));
    // If all children fit then return numberOfChildrenInContainer
    if (numberOfChildren <= numberOfChildrenInContainer) {
        return numberOfChildrenInContainer;
    }
    const buttonWidth = _convertRemToPx(buttonWidthRem);
    /** We know we need to paginate. So we need to subtract the buttonWidth twice and gapWidth twice from
     * containerWidth to compute childrenSpace
     *   <-----------containerWidth--------->
     *    __________________________________
     *   | ||             ||             || |
     *   |<||             ||             ||>|
     *   |_||_____________||_____________||_|
     *       <-------childrenSpace------>
     */
    const childrenSpace = containerWidth - 2 * buttonWidth - 2 * gapWidth;
    // Now that we have childrenSpace width we can figure out how many children can fit in childrenSpace.
    // childrenSpace = n * childWidth + (n - 1) * gapWidth. Isolate n and take the floor.
    return Math.max(Math.floor((childrenSpace + gapWidth) / (childMinWidth + gapWidth)), 1);
};

// Copyright (c) Microsoft Corporation.
/**
 * Wrapped HorizontalGallery that adjusts the number of items per page based on the
 * available width obtained from a ResizeObserver, width per child, gap width, and button width
 */
const ResponsiveHorizontalGallery = (props) => {
    const { gapWidthRem, buttonWidthRem = 0, onFetchTilesToRender, onChildrenPerPageChange } = props;
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const leftPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingLeft) : 0;
    const rightPadding = containerRef.current ? parseFloat(getComputedStyle(containerRef.current).paddingRight) : 0;
    const childrenPerPage = calculateHorizontalChildrenPerPage({
        numberOfChildren: React__default['default'].Children.count(props.children),
        containerWidth: (containerWidth !== null && containerWidth !== void 0 ? containerWidth : 0) - leftPadding - rightPadding,
        gapWidthRem,
        buttonWidthRem
    });
    onChildrenPerPageChange === null || onChildrenPerPageChange === void 0 ? void 0 : onChildrenPerPageChange(childrenPerPage);
    return React__default['default'].createElement("div", { "data-ui-id": "responsive-horizontal-gallery", ref: containerRef, className: react.mergeStyles(props.containerStyles) },
        React__default['default'].createElement(HorizontalGallery, { childrenPerPage: childrenPerPage, styles: props.horizontalGalleryStyles, onFetchTilesToRender: onFetchTilesToRender }, props.children));
};

// Copyright (c) Microsoft Corporation.
/**
 * A ResponsiveHorizontalGallery styled for the {@link VideoGallery}
 *
 * @private
 */
const OverflowGallery = (props) => {
    const { shouldFloatLocalVideo = false, onFetchTilesToRender, isNarrow = false, overflowGalleryElements, horizontalGalleryStyles, onChildrenPerPageChange } = props;
    const containerStyles = React.useMemo(() => {
        return horizontalGalleryContainerStyle(shouldFloatLocalVideo, isNarrow);
    }, [shouldFloatLocalVideo, isNarrow]);
    const galleryStyles = React.useMemo(() => {
        return react.concatStyleSets(horizontalGalleryStyle(isNarrow), horizontalGalleryStyles);
    }, [isNarrow, horizontalGalleryStyles]);
    return React__default['default'].createElement(ResponsiveHorizontalGallery, { key: "responsive-horizontal-gallery", containerStyles: containerStyles, onFetchTilesToRender: onFetchTilesToRender, horizontalGalleryStyles: galleryStyles, buttonWidthRem: HORIZONTAL_GALLERY_BUTTON_WIDTH, gapWidthRem: HORIZONTAL_GALLERY_GAP, onChildrenPerPageChange: onChildrenPerPageChange }, overflowGalleryElements);
};

// Copyright (c) Microsoft Corporation.
/**
 * DefaultLayout displays remote participants, local video component, and screen sharing component in
 * a grid an overflow gallery.
 *
 * @private
 */
const DefaultLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, parentWidth, pinnedParticipantUserIds = [] } = props;
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = React.useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = React.useState([...Array(maxRemoteVideoStreams - activeVideoStreams).keys()]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    if (localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    const overflowGallery = React.useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React__default['default'].createElement(OverflowGallery, { isNarrow: isNarrow, shouldFloatLocalVideo: false, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, onFetchTilesToRender: setIndexesToRender, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            } });
    }, [isNarrow, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, setIndexesToRender]);
    return React__default['default'].createElement(react.Stack, { styles: rootLayoutStyle$1, tokens: videoGalleryLayoutGap },
        screenShareComponent ? screenShareComponent : React__default['default'].createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
        overflowGallery);
};

// Copyright (c) Microsoft Corporation.
const animationDuration = react.AnimationVariables.durationValue2;
const ZERO = {
    x: 0,
    y: 0
};
const DEFAULT_PROPS = {
    isOpen: false,
    isDarkOverlay: true,
    className: '',
    containerClassName: '',
    enableAriaHiddenSiblings: true
};
const getModalClassNames = react.classNamesFunction();
const getMoveDelta = (ev) => {
    let delta = 10;
    if (ev.shiftKey) {
        if (!ev.ctrlKey) {
            delta = 50;
        }
    }
    else if (ev.ctrlKey) {
        delta = 1;
    }
    return delta;
};
const useComponentRef = (props, focusTrapZone) => {
    React__namespace.useImperativeHandle(props.componentRef, () => ({
        focus() {
            if (focusTrapZone.current) {
                focusTrapZone.current.focus();
            }
        }
    }), [focusTrapZone]);
};
const ModalBase = React__namespace.forwardRef((propsWithoutDefaults, ref) => {
    const props = react.getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
    const { allowTouchBodyScroll, className, children, containerClassName, scrollableContentClassName, elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, ignoreExternalFocusing, isBlocking, isAlert, isClickableOutsideFocusTrap, isDarkOverlay, onDismiss, layerProps, overlay, isOpen, titleAriaId, styles, subtitleAriaId, theme, topOffsetFixed, responsiveMode, onLayerDidMount, isModeless, dragOptions, onDismissed, minDragPosition, maxDragPosition } = props;
    const rootRef = React__namespace.useRef(null);
    const focusTrapZone = React__namespace.useRef(null);
    const focusTrapZoneElm = React__namespace.useRef(null);
    const mergedRef = reactHooks.useMergedRefs(rootRef, ref);
    const modalResponsiveMode = react.useResponsiveMode(mergedRef);
    const focusTrapZoneId = reactHooks.useId('ModalFocusTrapZone');
    const win = reactWindowProvider.useWindow();
    const { setTimeout, clearTimeout } = reactHooks.useSetTimeout();
    const [isModalOpen, setIsModalOpen] = React__namespace.useState(isOpen);
    const [isVisible, setIsVisible] = React__namespace.useState(isOpen);
    const [coordinates, setCoordinates] = React__namespace.useState(ZERO);
    const [modalRectangleTop, setModalRectangleTop] = React__namespace.useState();
    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = reactHooks.useBoolean(false);
    const internalState = reactHooks.useConst(() => ({
        onModalCloseTimer: 0,
        allowTouchBodyScroll,
        scrollableContent: null,
        lastSetCoordinates: ZERO,
        events: new react.EventGroup({})
    }));
    const { keepInBounds } = dragOptions || {};
    const isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : (isBlocking && !isModeless);
    const layerClassName = layerProps === undefined ? '' : layerProps.className;
    const classNames = getModalClassNames(styles, {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        theme: theme,
        className,
        containerClassName,
        scrollableContentClassName,
        isOpen,
        isVisible,
        hasBeenOpened: internalState.hasBeenOpened,
        modalRectangleTop,
        topOffsetFixed,
        isModeless,
        layerClassName,
        windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,
        isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector
    });
    const mergedLayerProps = Object.assign(Object.assign({ eventBubblingEnabled: false }, layerProps), { onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount, insertFirst: isModeless, className: classNames.layer });
    // Allow the user to scroll within the modal but not on the body
    const allowScrollOnModal = React__namespace.useCallback((elt) => {
        if (elt) {
            if (internalState.allowTouchBodyScroll) {
                react.allowOverscrollOnElement(elt, internalState.events);
            }
            else {
                react.allowScrollOnElement(elt, internalState.events);
            }
        }
        else {
            internalState.events.off(internalState.scrollableContent);
        }
        internalState.scrollableContent = elt;
    }, [internalState]);
    const registerInitialModalPosition = () => {
        const dialogMain = focusTrapZoneElm.current;
        const modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();
        if (modalRectangle) {
            if (topOffsetFixed) {
                setModalRectangleTop(modalRectangle.top);
            }
            if (keepInBounds) {
                // x/y are unavailable in IE, so use the equivalent left/top
                internalState.minPosition = minDragPosition !== null && minDragPosition !== void 0 ? minDragPosition : {
                    x: -modalRectangle.left,
                    y: -modalRectangle.top
                };
                internalState.maxPosition = maxDragPosition !== null && maxDragPosition !== void 0 ? maxDragPosition : {
                    x: modalRectangle.left,
                    y: modalRectangle.top
                };
                // Make sure the initial co-ordinates are within clamp bounds.
                setCoordinates({
                    x: getClampedAxis('x', coordinates.x),
                    y: getClampedAxis('y', coordinates.y)
                });
            }
        }
    };
    /**
     * Clamps an axis to a specified min and max position.
     *
     * @param axis A string that represents the axis (x/y).
     * @param position The position on the axis.
     */
    const getClampedAxis = React__namespace.useCallback((axis, position) => {
        const { minPosition, maxPosition } = internalState;
        if (keepInBounds && minPosition && maxPosition) {
            position = Math.max(minPosition[axis], position);
            position = Math.min(maxPosition[axis], position);
        }
        return position;
    }, [keepInBounds, internalState]);
    const handleModalClose = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
        setIsModalOpen(false);
        setCoordinates(ZERO);
        (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);
        onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();
    };
    const handleDragStart = React__namespace.useCallback(() => {
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = false;
    }, [internalState, setModalMenuClose]);
    const handleDrag = React__namespace.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (ev, dragData) => {
        setCoordinates(prevValue => ({
            x: getClampedAxis('x', prevValue.x + dragData.delta.x),
            y: getClampedAxis('y', prevValue.y + dragData.delta.y)
        }));
    }, [getClampedAxis]);
    const handleDragStop = React__namespace.useCallback(() => {
        if (focusTrapZone.current) {
            focusTrapZone.current.focus();
        }
    }, []);
    const handleEnterKeyboardMoveMode = () => {
        // We need a global handleKeyDown event when we are in the move mode so that we can
        // handle the key presses and the components inside the modal do not get the events
        const handleKeyDown = (ev) => {
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                // CTRL + ALT + SPACE is handled during keyUp
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            const newLocal = ev.altKey || ev.keyCode === react.KeyCodes.escape;
            if (isModalMenuOpen && newLocal) {
                setModalMenuClose();
            }
            if (internalState.isInKeyboardMoveMode && (ev.keyCode === react.KeyCodes.escape || ev.keyCode === react.KeyCodes.enter)) {
                internalState.isInKeyboardMoveMode = false;
                ev.preventDefault();
                ev.stopPropagation();
            }
            if (internalState.isInKeyboardMoveMode) {
                let handledEvent = true;
                const delta = getMoveDelta(ev);
                switch (ev.keyCode) {
                    /* eslint-disable no-fallthrough */
                    case react.KeyCodes.escape:
                        setCoordinates(internalState.lastSetCoordinates);
                    case react.KeyCodes.enter:
                        {
                            // TODO: determine if fallthrough was intentional
                            /* eslint-enable no-fallthrough */
                            internalState.lastSetCoordinates = ZERO;
                            // setIsInKeyboardMoveMode(false);
                            break;
                        }
                    case react.KeyCodes.up:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y - delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.down:
                        {
                            setCoordinates(prevValue => ({
                                x: prevValue.x,
                                y: getClampedAxis('y', prevValue.y + delta)
                            }));
                            break;
                        }
                    case react.KeyCodes.left:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x - delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    case react.KeyCodes.right:
                        {
                            setCoordinates(prevValue => ({
                                x: getClampedAxis('x', prevValue.x + delta),
                                y: prevValue.y
                            }));
                            break;
                        }
                    default:
                        {
                            handledEvent = false;
                        }
                }
                if (handledEvent) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        internalState.lastSetCoordinates = coordinates;
        setModalMenuClose();
        internalState.isInKeyboardMoveMode = true;
        internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);
        internalState.disposeOnKeyDown = () => {
            internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);
            internalState.disposeOnKeyDown = undefined;
        };
    };
    const handleExitKeyboardMoveMode = () => {
        var _a;
        internalState.lastSetCoordinates = ZERO;
        internalState.isInKeyboardMoveMode = false;
        (_a = internalState.disposeOnKeyDown) === null || _a === void 0 ? void 0 : _a.call(internalState);
    };
    const registerForKeyUp = () => {
        const handleKeyUp = (ev) => {
            // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
            if (ev.altKey && ev.ctrlKey && ev.keyCode === react.KeyCodes.space) {
                if (react.elementContains(internalState.scrollableContent, ev.target)) {
                    toggleModalMenuOpen();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        if (!internalState.disposeOnKeyUp) {
            internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);
            internalState.disposeOnKeyUp = () => {
                internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);
                internalState.disposeOnKeyUp = undefined;
            };
        }
    };
    React__namespace.useEffect(() => {
        clearTimeout(internalState.onModalCloseTimer);
        // Opening the dialog
        if (isOpen) {
            // This must be done after the modal content has rendered
            requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));
            setIsModalOpen(true);
            // Add a keyUp handler for all key up events once the dialog is open.
            if (dragOptions) {
                registerForKeyUp();
            }
            internalState.hasBeenOpened = true;
            setIsVisible(true);
        }
        // Closing the dialog
        if (!isOpen && isModalOpen) {
            internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);
            setIsVisible(false);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates or if min/max drag bounds are updated.
    }, [isModalOpen, isOpen, minDragPosition, maxDragPosition]);
    reactHooks.useUnmount(() => {
        internalState.events.dispose();
    });
    useComponentRef(props, focusTrapZone);
    const modalContent = React__namespace.createElement(react.FocusTrapZone, { disabled: true, id: focusTrapZoneId, ref: focusTrapZoneElm, componentRef: focusTrapZone, className: classNames.main, elementToFocusOnDismiss: elementToFocusOnDismiss, isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking, ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: forceFocusInsideTrap && !isModeless, firstFocusableSelector: firstFocusableSelector, focusPreviouslyFocusedInnerElement: true, onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined, "data-ui-id": props['data-ui-id'] },
        dragOptions && internalState.isInKeyboardMoveMode && React__namespace.createElement("div", { className: classNames.keyboardMoveIconContainer }, dragOptions.keyboardMoveIconProps ? React__namespace.createElement(react.Icon, Object.assign({}, dragOptions.keyboardMoveIconProps)) : React__namespace.createElement(react.Icon, { iconName: "move", className: classNames.keyboardMoveIcon })),
        React__namespace.createElement("div", { ref: allowScrollOnModal, className: classNames.scrollableContent, "data-is-scrollable": true },
            dragOptions && isModalMenuOpen && React__namespace.createElement(dragOptions.menu, { items: [{
                        key: 'move',
                        text: dragOptions.moveMenuItemText,
                        onClick: handleEnterKeyboardMoveMode
                    }, {
                        key: 'close',
                        text: dragOptions.closeMenuItemText,
                        onClick: handleModalClose
                    }], onDismiss: setModalMenuClose, alignTargetEdge: true, coverTarget: true, directionalHint: react.DirectionalHint.topLeftEdge, directionalHintFixed: true, shouldFocusOnMount: true, target: internalState.scrollableContent }),
            children));
    return (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    isModalOpen && modalResponsiveMode >= (responsiveMode || react.ResponsiveMode.small) && React__namespace.createElement(react.Layer, Object.assign({ ref: mergedRef }, mergedLayerProps),
        React__namespace.createElement(react.Popup, { role: isAlertRole ? 'alertdialog' : 'dialog', ariaLabelledBy: titleAriaId, ariaDescribedBy: subtitleAriaId, 
            // onDismiss={onDismiss}
            shouldRestoreFocus: !ignoreExternalFocusing, "aria-modal": !isModeless },
            React__namespace.createElement("div", { className: classNames.root, role: !isModeless ? 'document' : undefined },
                !isModeless && React__namespace.createElement(react.Overlay, Object.assign({ "aria-hidden": true, isDarkThemed: isDarkOverlay, onClick: isBlocking ? undefined : onDismiss, allowTouchBodyScroll: allowTouchBodyScroll }, overlay)),
                dragOptions ? React__namespace.createElement(DraggableZone, { handleSelector: dragOptions.dragHandleSelector || `#${focusTrapZoneId}`, preventDragSelector: "button", onStart: handleDragStart, onDragChange: handleDrag, onStop: handleDragStop, position: coordinates }, modalContent) : modalContent))) || null);
});
ModalBase.displayName = 'ModalBase';
const getDraggableZoneClassNames = react.memoizeFunction((className, isDragging) => {
    return {
        root: react.mergeStyles(className, isDragging && {
            touchAction: 'none',
            selectors: {
                '& *': {
                    userSelect: 'none'
                }
            }
        })
    };
});
const eventMapping = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend'
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup'
    }
};
class DraggableZone extends React__namespace.Component {
    constructor(props) {
        super(props);
        this._currentEventType = eventMapping.mouse;
        this._events = [];
        this._onMouseDown = (event) => {
            const onMouseDown = React__namespace.Children.only(this.props.children).props.onMouseDown;
            if (onMouseDown) {
                onMouseDown(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStart(event);
        };
        this._onMouseUp = (event) => {
            const onMouseUp = React__namespace.Children.only(this.props.children).props.onMouseUp;
            if (onMouseUp) {
                onMouseUp(event);
            }
            this._currentEventType = eventMapping.mouse;
            return this._onDragStop(event);
        };
        this._onTouchStart = (event) => {
            const onTouchStart = React__namespace.Children.only(this.props.children).props.onTouchStart;
            if (onTouchStart) {
                onTouchStart(event);
            }
            this._currentEventType = eventMapping.touch;
            return this._onDragStart(event);
        };
        this._onTouchEnd = (event) => {
            const onTouchEnd = React__namespace.Children.only(this.props.children).props.onTouchEnd;
            if (onTouchEnd) {
                onTouchEnd(event);
            }
            this._currentEventType = eventMapping.touch;
            this._onDragStop(event);
        };
        this._onDragStart = (event) => {
            // Only handle left click for dragging
            if (typeof event.button === 'number' && event.button !== 0) {
                return false;
            }
            // If the target doesn't match the handleSelector OR
            // if the target does match the preventDragSelector, bail out
            if (this.props.handleSelector && !this._matchesSelector(event.target, this.props.handleSelector) || this.props.preventDragSelector && this._matchesSelector(event.target, this.props.preventDragSelector)) {
                return;
            }
            // Remember the touch identifier if this is a touch event so we can
            // distinguish between individual touches in multitouch scenarios
            // by remembering which touch point we were given
            this._touchId = this._getTouchId(event);
            const position = this._getControlPosition(event);
            if (position === undefined) {
                return;
            }
            const dragData = this._createDragDataFromPosition(position);
            this.props.onStart && this.props.onStart(event, dragData);
            this.setState({
                isDragging: true,
                lastPosition: position
            });
            // hook up the appropriate mouse/touch events to the body to ensure
            // smooth dragging
            this._events = [react.on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */), react.on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */)];
            return;
        };
        this._onDrag = (event) => {
            // Prevent scrolling on mobile devices
            if (event.type === 'touchmove') {
                event.preventDefault();
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            }
            // create the updated drag data from the position data
            const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));
            const updatedPosition = updatedData.position;
            this.props.onDragChange && this.props.onDragChange(event, updatedData);
            this.setState({
                position: updatedPosition,
                lastPosition: position
            });
        };
        this._onDragStop = (event) => {
            if (!this.state.isDragging) {
                return;
            }
            const position = this._getControlPosition(event);
            if (!position) {
                return;
            }
            const baseDragData = this._createDragDataFromPosition(position);
            // Set dragging to false and reset the lastPosition
            this.setState({
                isDragging: false,
                lastPosition: undefined
            });
            this.props.onStop && this.props.onStop(event, baseDragData);
            if (this.props.position) {
                this.setState({
                    position: this.props.position
                });
            }
            // Remove event handlers
            this._events.forEach(dispose => dispose());
        };
        this.state = {
            isDragging: false,
            position: this.props.position || {
                x: 0,
                y: 0
            },
            lastPosition: undefined
        };
    }
    componentDidUpdate(prevProps) {
        if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {
            this.setState({
                position: this.props.position
            });
        }
    }
    componentWillUnmount() {
        this._events.forEach(dispose => dispose());
    }
    render() {
        const child = React__namespace.Children.only(this.props.children);
        const { props } = child;
        const { position } = this.props;
        const { position: statePosition, isDragging } = this.state;
        let x = statePosition.x;
        let y = statePosition.y;
        if (position && !isDragging) {
            x = position.x;
            y = position.y;
        }
        return React__namespace.cloneElement(child, {
            style: Object.assign(Object.assign({}, props.style), { transform: `translate(${x}px, ${y}px)` }),
            className: getDraggableZoneClassNames(props.className, this.state.isDragging).root,
            onMouseDown: this._onMouseDown,
            onMouseUp: this._onMouseUp,
            onTouchStart: this._onTouchStart,
            onTouchEnd: this._onTouchEnd
        });
    }
    /**
     * Get the control position based off the event that fired
     * @param event - The event to get offsets from
     */
    _getControlPosition(event) {
        const touchObj = this._getActiveTouch(event);
        // did we get the right touch?
        if (this._touchId !== undefined && !touchObj) {
            return undefined;
        }
        const eventToGetOffset = touchObj || event;
        return {
            x: eventToGetOffset.clientX,
            y: eventToGetOffset.clientY
        };
    }
    /**
     * Get the active touch point that we have saved from the event's TouchList
     * @param event - The event used to get the TouchList for the active touch point
     */
    _getActiveTouch(event) {
        return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);
    }
    /**
     * Get the initial touch identifier associated with the given event
     * @param event - The event that contains the TouchList
     */
    _getTouchId(event) {
        const touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];
        if (touch) {
            return touch.identifier;
        }
        return;
    }
    /**
     * Returns if an element (or any of the element's parents) match the given selector
     */
    _matchesSelector(element, selector) {
        if (!element || element === document.body) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        const matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector; /* for IE */
        if (!matchesSelectorFn) {
            return false;
        }
        return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);
    }
    /**
     * Attempts to find the Touch that matches the identifier  we stored in dragStart
     * @param touchList The TouchList to look for the stored identifier from dragStart
     */
    _findTouchInTouchList(touchList) {
        if (this._touchId === undefined) {
            return;
        }
        for (let i = 0; i < touchList.length; i++) {
            if (touchList[i].identifier === this._touchId) {
                return touchList[i];
            }
        }
        return undefined;
    }
    /**
     * Create DragData based off of the last known position and the new position passed in
     * @param position The new position as part of the drag
     */
    _createDragDataFromPosition(position) {
        const { lastPosition } = this.state;
        // If we have no lastPosition, use the given position
        // for last position
        if (lastPosition === undefined) {
            return {
                delta: {
                    x: 0,
                    y: 0
                },
                lastPosition: position,
                position
            };
        }
        return {
            delta: {
                x: position.x - lastPosition.x,
                y: position.y - lastPosition.y
            },
            lastPosition,
            position
        };
    }
    /**
     * Creates an updated DragData based off the current position and given baseDragData
     * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions
     */
    _createUpdatedDragData(baseDragData) {
        const { position } = this.state;
        return {
            position: {
                x: position.x + baseDragData.delta.x,
                y: position.y + baseDragData.delta.y
            },
            delta: baseDragData.delta,
            lastPosition: position
        };
    }
}
const globalClassNames = {
    root: 'ms-Modal',
    main: 'ms-Dialog-main',
    scrollableContent: 'ms-Modal-scrollableContent',
    isOpen: 'is-open',
    layer: 'ms-Modal-Layer'
};
const getStyles = (props) => {
    const { className, containerClassName, scrollableContentClassName, isOpen, isVisible, hasBeenOpened, modalRectangleTop, theme, topOffsetFixed, isModeless, layerClassName, isDefaultDragHandle, windowInnerHeight } = props;
    const { palette, effects, fonts } = theme;
    const classNames = react.getGlobalClassNames(globalClassNames, theme);
    return {
        root: [classNames.root, fonts.medium, {
                backgroundColor: 'transparent',
                position: isModeless ? 'absolute' : 'fixed',
                height: '100%',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: 0,
                pointerEvents: 'none',
                transition: `opacity ${animationDuration}`
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                alignItems: 'flex-start'
            }, isOpen && classNames.isOpen, isVisible && {
                opacity: 1,
                pointerEvents: 'auto'
            }, className],
        main: [classNames.main, {
                boxShadow: effects.elevation64,
                borderRadius: effects.roundedCorner2,
                backgroundColor: palette.white,
                boxSizing: 'border-box',
                position: 'relative',
                textAlign: 'left',
                outline: '3px solid transparent',
                maxHeight: 'calc(100% - 32px)',
                maxWidth: 'calc(100% - 32px)',
                minHeight: '176px',
                minWidth: '288px',
                overflowY: 'auto',
                zIndex: isModeless ? react.ZIndexes.Layer : undefined
            }, topOffsetFixed && typeof modalRectangleTop === 'number' && hasBeenOpened && {
                top: modalRectangleTop
            }, isDefaultDragHandle && {
                cursor: 'move'
            }, containerClassName],
        scrollableContent: [classNames.scrollableContent, {
                overflowY: 'auto',
                flexGrow: 1,
                maxHeight: '100vh',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        maxHeight: windowInnerHeight
                    }
                }
            }, scrollableContentClassName],
        layer: isModeless && [layerClassName, classNames.layer, {
                position: 'static',
                width: 'unset',
                height: 'unset'
            }],
        keyboardMoveIconContainer: {
            position: 'absolute',
            display: 'flex',
            justifyContent: 'center',
            width: '100%',
            padding: '3px 0px'
        },
        keyboardMoveIcon: {
            fontSize: fonts.xLargePlus.fontSize,
            width: '24px'
        }
    };
};
/** @internal */
const _ModalClone = react.styled(ModalBase, getStyles, undefined, {
    scope: 'Modal',
    fields: ['theme', 'styles', 'enableAriaHiddenSiblings']
});
_ModalClone.displayName = 'Modal';

// Copyright (c) Microsoft Corporation.
const DRAG_OPTIONS$1 = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
// Manually override the max position used to keep the modal in the bounds of its container.
// This is a workaround for: https://github.com/microsoft/fluentui/issues/20122
// Because our modal starts in the bottom right corner, we can say that this is the max (i.e. rightmost and bottomost)
// position the modal can be dragged to.
const modalMaxDragPosition = {
    x: _convertRemToPx(localVideoTileOuterPaddingRem),
    y: _convertRemToPx(localVideoTileOuterPaddingRem)
};
/**
 * @private
 */
const FloatingLocalVideo = (props) => {
    const { localVideoComponent, layerHostId, localVideoSizeRem, parentWidth, parentHeight } = props;
    const theme = useTheme();
    // The minimum drag position is the top left of the video gallery. i.e. the modal (PiP) should not be able
    // to be dragged offscreen and these are the top and left bounds of that calculation.
    const modalMinDragPosition = React.useMemo(() => parentWidth && parentHeight ? {
        // We use -parentWidth/Height because our modal is positioned to start in the bottom right,
        // hence (0,0) is the bottom right of the video gallery.
        x: -parentWidth + _convertRemToPx(localVideoSizeRem.width) + _convertRemToPx(localVideoTileOuterPaddingRem),
        y: -parentHeight + _convertRemToPx(localVideoSizeRem.height) + _convertRemToPx(localVideoTileOuterPaddingRem)
    } : undefined, [parentHeight, parentWidth, localVideoSizeRem.width, localVideoSizeRem.height]);
    const modalStyles = React.useMemo(() => floatingLocalVideoModalStyle(theme, localVideoSizeRem), [theme, localVideoSizeRem]);
    const layerProps = React.useMemo(() => ({
        hostId: layerHostId
    }), [layerHostId]);
    return React__default['default'].createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS$1, styles: modalStyles, layerProps: layerProps, maxDragPosition: modalMaxDragPosition, minDragPosition: modalMinDragPosition, "data-ui-id": "floating-local-video-host" }, localVideoComponent);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const rootLayoutStyle = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const innerLayoutStyle = {
    root: {
        position: 'relative',
        height: '100%',
        width: '100%',
        padding: '0.5rem'
    }
};
/**
 * @private
 */
const layerHostStyle = {
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};

// Copyright (c) Microsoft Corporation.
/**
 * FloatingLocalVideoLayout displays remote participants and a screen sharing component in
 * a grid and overflow gallery while floating the local video
 *
 * @private
 */
const FloatingLocalVideoLayout = (props) => {
    const { remoteParticipants = [], dominantSpeakers, localVideoComponent, screenShareComponent, onRenderRemoteParticipant, styles, maxRemoteVideoStreams, showCameraSwitcherInLocalPreview, parentWidth, parentHeight, pinnedParticipantUserIds = [] } = props;
    const theme = useTheme();
    const isNarrow = parentWidth ? isNarrowWidth(parentWidth) : false;
    // This is for tracking the number of children in the first page of overflow gallery.
    // This number will be used for the maxOverflowGalleryDominantSpeakers when organizing the remote participants.
    const childrenPerPage = React.useRef(4);
    const { gridParticipants, overflowGalleryParticipants } = useOrganizedParticipants({
        remoteParticipants,
        dominantSpeakers,
        maxRemoteVideoStreams,
        isScreenShareActive: !!screenShareComponent,
        maxOverflowGalleryDominantSpeakers: screenShareComponent ? childrenPerPage.current - pinnedParticipantUserIds.length % childrenPerPage.current : childrenPerPage.current
    });
    let activeVideoStreams = 0;
    const gridTiles = gridParticipants.map(p => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const shouldFloatLocalVideo = remoteParticipants.length > 0;
    if (!shouldFloatLocalVideo && localVideoComponent) {
        gridTiles.push(localVideoComponent);
    }
    /**
     * instantiate indexes available to render with indexes available that would be on first page
     *
     * For some components which do not strictly follow the order of the array, we might
     * re-render the initial tiles -> dispose them -> create new tiles, we need to take care of
     * this case when those components are here
     */
    const [indexesToRender, setIndexesToRender] = React.useState([...Array(maxRemoteVideoStreams - activeVideoStreams).keys()]);
    const overflowGalleryTiles = overflowGalleryParticipants.map((p, i) => {
        var _a, _b;
        return onRenderRemoteParticipant(p, maxRemoteVideoStreams && maxRemoteVideoStreams >= 0 ? ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) && indexesToRender.includes(i) && activeVideoStreams++ < maxRemoteVideoStreams : (_b = p.videoStream) === null || _b === void 0 ? void 0 : _b.isAvailable);
    });
    const layerHostId = reactHooks.useId('layerhost');
    const localVideoSizeRem = React.useMemo(() => {
        if (isNarrow) {
            return SMALL_FLOATING_MODAL_SIZE_REM;
        }
        return LARGE_FLOATING_MODAL_SIZE_REM;
    }, [overflowGalleryTiles.length, isNarrow]);
    const wrappedLocalVideoComponent = localVideoComponent && shouldFloatLocalVideo ?
        // When we use showCameraSwitcherInLocalPreview it disables dragging to allow keyboard navigation.
        showCameraSwitcherInLocalPreview ? React__default['default'].createElement(react.Stack, { className: react.mergeStyles(localVideoTileWithControlsContainerStyle(theme, localVideoSizeRem), {
                boxShadow: theme.effects.elevation8,
                zIndex: LOCAL_VIDEO_TILE_ZINDEX
            }) }, localVideoComponent) : overflowGalleryTiles.length > 0 ? React__default['default'].createElement(react.Stack, { className: react.mergeStyles(localVideoTileContainerStyle(theme, localVideoSizeRem)) }, localVideoComponent) : React__default['default'].createElement(FloatingLocalVideo, { localVideoComponent: localVideoComponent, layerHostId: layerHostId, localVideoSizeRem: localVideoSizeRem, parentWidth: parentWidth, parentHeight: parentHeight }) : undefined;
    const overflowGallery = React.useMemo(() => {
        if (overflowGalleryTiles.length === 0) {
            return null;
        }
        return React__default['default'].createElement(OverflowGallery, { onFetchTilesToRender: setIndexesToRender, isNarrow: isNarrow, shouldFloatLocalVideo: true, overflowGalleryElements: overflowGalleryTiles, horizontalGalleryStyles: styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, onChildrenPerPageChange: (n) => {
                childrenPerPage.current = n;
            } });
    }, [isNarrow, overflowGalleryTiles, styles === null || styles === void 0 ? void 0 : styles.horizontalGallery, setIndexesToRender]);
    return React__default['default'].createElement(react.Stack, { styles: rootLayoutStyle },
        wrappedLocalVideoComponent,
        React__default['default'].createElement(react.LayerHost, { id: layerHostId, className: react.mergeStyles(layerHostStyle) }),
        React__default['default'].createElement(react.Stack, { styles: innerLayoutStyle, tokens: videoGalleryLayoutGap },
            screenShareComponent ? screenShareComponent : React__default['default'].createElement(GridLayout, { key: "grid-layout", styles: styles === null || styles === void 0 ? void 0 : styles.gridLayout }, gridTiles),
            overflowGallery));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 * Currently the Calling JS SDK supports up to 4 remote video streams
 */
const DEFAULT_MAX_REMOTE_VIDEO_STREAMS = 4;
/**
 * @private
 * Styles to disable the selectivity of a text in video gallery
 */
const unselectable = {
    '-webkit-user-select': 'none',
    '-webkit-touch-callout': 'none',
    '-moz-user-select': 'none',
    '-ms-user-select': 'none',
    'user-select': 'none'
};
/**
 * VideoGallery represents a layout of video tiles for a specific call.
 * It displays a {@link VideoTile} for the local user as well as for each remote participant who has joined the call.
 *
 * @public
 */
const VideoGallery = (props) => {
    var _a, _b;
    const { localParticipant, remoteParticipants = [], localVideoViewOptions, remoteVideoViewOptions, dominantSpeakers, onRenderLocalVideoTile, onRenderRemoteVideoTile, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView, styles, layout, onRenderAvatar, showMuteIndicator, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEO_STREAMS, showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps } = props;
    const ids = useIdentifiers();
    const theme = useTheme();
    const localeStrings = useLocale$1().strings.videoGallery;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const shouldFloatLocalVideo = !!(layout === 'floatingLocalVideo' && remoteParticipants.length > 0);
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isNarrow = containerWidth ? isNarrowWidth(containerWidth) : false;
    /**
     * Utility function for memoized rendering of LocalParticipant.
     */
    const localVideoTile = React.useMemo(() => {
        var _a, _b;
        if (onRenderLocalVideoTile) {
            return onRenderLocalVideoTile(localParticipant);
        }
        const localVideoTileStyles = react.concatStyleSets(shouldFloatLocalVideo ? floatingLocalVideoTileStyle : {}, {
            root: {
                borderRadius: theme.effects.roundedCorner4
            }
        }, styles === null || styles === void 0 ? void 0 : styles.localVideo);
        const initialsName = !localParticipant.displayName ? '' : localParticipant.displayName;
        return React__default['default'].createElement(react.Stack, { key: "local-video-tile-key", tabIndex: 0, "aria-label": strings.localVideoMovementLabel, role: 'dialog' },
            React__default['default'].createElement(_LocalVideoTile, { userId: localParticipant.userId, onCreateLocalStreamView: onCreateLocalStreamView, onDisposeLocalStreamView: onDisposeLocalStreamView, isAvailable: (_a = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, isMuted: localParticipant.isMuted, renderElement: (_b = localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, displayName: isNarrow ? '' : strings.localVideoLabel, initialsName: initialsName, localVideoViewOptions: localVideoViewOptions, onRenderAvatar: onRenderAvatar, showLabel: !(shouldFloatLocalVideo && isNarrow), showMuteIndicator: showMuteIndicator, showCameraSwitcherInLocalPreview: showCameraSwitcherInLocalPreview, localVideoCameraCycleButtonProps: localVideoCameraCycleButtonProps, localVideoCameraSwitcherLabel: strings.localVideoCameraSwitcherLabel, localVideoSelectedDescription: strings.localVideoSelectedDescription, styles: localVideoTileStyles }));
    }, [isNarrow, localParticipant, localVideoCameraCycleButtonProps, localVideoViewOptions, onCreateLocalStreamView, onDisposeLocalStreamView, onRenderAvatar, onRenderLocalVideoTile, shouldFloatLocalVideo, showCameraSwitcherInLocalPreview, showMuteIndicator, strings.localVideoCameraSwitcherLabel, strings.localVideoLabel, strings.localVideoMovementLabel, strings.localVideoSelectedDescription, styles === null || styles === void 0 ? void 0 : styles.localVideo, theme.effects.roundedCorner4]);
    const defaultOnRenderVideoTile = React.useCallback((participant, isVideoParticipant) => {
        const remoteVideoStream = participant.videoStream;
        return React__default['default'].createElement(_RemoteVideoTile, { key: participant.userId, userId: participant.userId, remoteParticipant: participant, onCreateRemoteStreamView: isVideoParticipant ? onCreateRemoteStreamView : undefined, onDisposeRemoteStreamView: isVideoParticipant ? onDisposeRemoteStreamView : undefined, isAvailable: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isAvailable : false, isReceiving: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.isReceiving : false, renderElement: isVideoParticipant ? remoteVideoStream === null || remoteVideoStream === void 0 ? void 0 : remoteVideoStream.renderElement : undefined, remoteVideoViewOptions: isVideoParticipant ? remoteVideoViewOptions : undefined, onRenderAvatar: onRenderAvatar, showMuteIndicator: showMuteIndicator, strings: strings });
    }, [onCreateRemoteStreamView, onDisposeRemoteStreamView, remoteVideoViewOptions, onRenderAvatar, showMuteIndicator, strings]);
    const screenShareParticipant = remoteParticipants.find(participant => { var _a; return (_a = participant.screenShareStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    const localScreenShareStreamComponent = React__default['default'].createElement(LocalScreenShare, { localParticipant: localParticipant });
    const remoteScreenShareComponent = screenShareParticipant && React__default['default'].createElement(RemoteScreenShare, Object.assign({}, screenShareParticipant, { renderElement: (_a = screenShareParticipant.screenShareStream) === null || _a === void 0 ? void 0 : _a.renderElement, onCreateRemoteStreamView: onCreateRemoteStreamView, onDisposeRemoteStreamView: onDisposeRemoteStreamView, isReceiving: (_b = screenShareParticipant.screenShareStream) === null || _b === void 0 ? void 0 : _b.isReceiving }));
    const screenShareComponent = remoteScreenShareComponent ? remoteScreenShareComponent : localParticipant.isScreenSharingOn ? localScreenShareStreamComponent : undefined;
    const layoutProps = React.useMemo(() => ({
        remoteParticipants,
        screenShareComponent,
        showCameraSwitcherInLocalPreview,
        maxRemoteVideoStreams,
        dominantSpeakers,
        styles,
        onRenderRemoteParticipant: onRenderRemoteVideoTile !== null && onRenderRemoteVideoTile !== void 0 ? onRenderRemoteVideoTile : defaultOnRenderVideoTile,
        localVideoComponent: localVideoTile,
        parentWidth: containerWidth,
        parentHeight: containerHeight
    }), [remoteParticipants, screenShareComponent, showCameraSwitcherInLocalPreview, maxRemoteVideoStreams, dominantSpeakers, styles, localVideoTile, containerWidth, containerHeight, onRenderRemoteVideoTile, defaultOnRenderVideoTile]);
    const videoGalleryLayout = React.useMemo(() => {
        if (layout === 'floatingLocalVideo') {
            return React__default['default'].createElement(FloatingLocalVideoLayout, Object.assign({}, layoutProps));
        }
        return React__default['default'].createElement(DefaultLayout, Object.assign({}, layoutProps));
    }, [layout, layoutProps]);
    return React__default['default'].createElement("div", { "data-ui-id": ids.videoGallery, ref: containerRef, className: react.mergeStyles(videoGalleryOuterDivStyle, styles === null || styles === void 0 ? void 0 : styles.root, unselectable) }, videoGalleryLayout);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const controlBarStyles$1 = {
    horizontal: {
        flexFlow: 'row nowrap'
    },
    vertical: {
        flexFlow: 'column nowrap',
        width: 'fit-content',
        maxWidth: '8rem'
    },
    dockedTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        width: '100%',
        minWidth: 'fit-content'
    },
    dockedLeft: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        left: 0,
        height: '100%'
    },
    dockedRight: {
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: 0,
        right: 0,
        height: '100%'
    },
    floatingTop: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingBottom: {
        flexFlow: 'row nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        bottom: '1rem',
        left: '50%',
        transform: 'translateX(-50%)',
        minWidth: 'fit-content',
        zIndex: 10
    },
    floatingLeft: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        left: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    },
    floatingRight: {
        flexFlow: 'column nowrap',
        justifyContent: 'center',
        overflow: 'hidden',
        position: 'absolute',
        top: '50%',
        right: '1rem',
        transform: 'translateY(-50%)',
        zIndex: 10
    }
};
/**
 * @private
 */
const controlButtonStyles = {
    root: {
        background: 'none',
        border: 'none',
        borderRadius: 0,
        minHeight: '3.5rem',
        minWidth: '3.5rem',
        width: '100%',
        maxWidth: '8rem',
        svg: {
            verticalAlign: 'text-top'
        }
    },
    splitButtonMenuButton: {
        border: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '0.625rem',
        fontWeight: '400',
        lineHeight: '1rem',
        cursor: 'pointer',
        display: 'block',
        margin: '0rem 0.25rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    }
};
/**
 * making it Partial as IContextualMenuStyles has all its props non-optional and we only need title to be defined here.
 *
 * @private
 */
const participantsButtonMenuPropsStyle = {
    title: {
        background: 'initial',
        paddingLeft: '.5rem',
        fontWeight: 600,
        fontSize: '.75rem'
    }
};
/**
 * Default styles for button flyout items
 *
 * @private
 */
const buttonFlyoutItemStyles = {
    icon: {
        lineHeight: 0
    },
    checkmarkIcon: {
        lineHeight: 0
    }
};

// Copyright (c) Microsoft Corporation.
// The TooltipHost root uses display: inline by default.
// To prevent sizing issues or tooltip positioning issues, we override to inline-block.
// For more details see "Icon Button with Tooltip" on https://developer.microsoft.com/en-us/fluentui#/controls/web/button
const hostStyles = {
    root: {
        display: 'inline-block'
    }
};
/**
 * Tooltip that should wrap control bar buttons.
 *
 * @private
 */
const ControlButtonTooltip = (props) => {
    const theme = react.useTheme();
    const calloutStyle = {
        root: {
            padding: 0
        },
        calloutMain: {
            padding: '0.5rem'
        }
    };
    // Place callout with no gap between it and the button.
    const calloutProps = {
        gapSpace: 0,
        styles: calloutStyle,
        backgroundColor: isDarkThemed(theme) ? theme.palette.neutralLighter : ''
    };
    return React__default['default'].createElement(react.TooltipHost, Object.assign({}, props, { "data-ui-id": props.id, calloutProps: Object.assign(Object.assign({}, calloutProps), props.calloutProps), styles: react.mergeStyleSets(hostStyles, props.styles) }), props.children);
};

// Copyright (c) Microsoft Corporation.
const DefaultRenderIcon = (props) => {
    return (props === null || props === void 0 ? void 0 : props.checked) ? (props === null || props === void 0 ? void 0 : props.onRenderOnIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOnIcon() : null : (props === null || props === void 0 ? void 0 : props.onRenderOffIcon) ? props === null || props === void 0 ? void 0 : props.onRenderOffIcon() : null;
};
/**
 * Default button styled for the {@link ControlBar}.
 *
 * Use this component create custom buttons that are styled the same as other buttons provided by the UI Library.
 *
 * @public
 */
const ControlBarButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    const componentStyles = react.concatStyleSets(controlButtonStyles, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    const labelText = (_d = (_b = props === null || props === void 0 ? void 0 : props.text) !== null && _b !== void 0 ? _b : (_c = props === null || props === void 0 ? void 0 : props.strings) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : ((props === null || props === void 0 ? void 0 : props.checked) ? (_e = props === null || props === void 0 ? void 0 : props.strings) === null || _e === void 0 ? void 0 : _e.onLabel : (_f = props === null || props === void 0 ? void 0 : props.strings) === null || _f === void 0 ? void 0 : _f.offLabel);
    const tooltipContent = (_h = (_g = props === null || props === void 0 ? void 0 : props.strings) === null || _g === void 0 ? void 0 : _g.tooltipContent) !== null && _h !== void 0 ? _h : ((props === null || props === void 0 ? void 0 : props.disabled) ? (_j = props === null || props === void 0 ? void 0 : props.strings) === null || _j === void 0 ? void 0 : _j.tooltipDisabledContent : (props === null || props === void 0 ? void 0 : props.checked) ? (_k = props === null || props === void 0 ? void 0 : props.strings) === null || _k === void 0 ? void 0 : _k.tooltipOnContent : (_l = props === null || props === void 0 ? void 0 : props.strings) === null || _l === void 0 ? void 0 : _l.tooltipOffContent);
    const tooltipId = ((_m = props.tooltipId) !== null && _m !== void 0 ? _m : props.labelKey) ? props.labelKey + '-tooltip' : undefined;
    return React__default['default'].createElement(ControlButtonTooltip, { content: tooltipContent, id: tooltipId },
        React__default['default'].createElement(react.DefaultButton, Object.assign({}, props, { styles: componentStyles, onRenderText: props.showLabel && props.onRenderText ? props.onRenderText : undefined, onRenderIcon: (_o = props.onRenderIcon) !== null && _o !== void 0 ? _o : DefaultRenderIcon, ariaLabel: (_r = (_q = (_p = props.splitButtonAriaLabel) !== null && _p !== void 0 ? _p : props.ariaLabel) !== null && _q !== void 0 ? _q : tooltipContent) !== null && _r !== void 0 ? _r : labelText, allowDisabledFocus: (_s = props.allowDisabledFocus) !== null && _s !== void 0 ? _s : true, menuTriggerKeyCode: react.KeyCodes.down, text: undefined }), props.showLabel ? labelText : React__default['default'].createElement(React__default['default'].Fragment, null)));
};

// Copyright (c) Microsoft Corporation.
/**
 * This is a helper component to define and unify icon colors
 *
 * @internal
 */
const _HighContrastAwareIcon = (props) => {
    const { iconName, disabled } = props;
    const theme = useTheme();
    // setting colors for the icons using color from theme, so in dark mode or other accessibility modes, they have pre-defined contrast colors
    // the media query is for when in specific window accessibility mode, change the svg colors
    return React__default['default'].createElement(react.Icon, { iconName: iconName, className: react.mergeStyles({
            svg: {
                fill: disabled ? theme.palette.neutralTertiary : theme.palette.neutralPrimaryAlt,
                '@media (forced-colors: active) and (prefers-color-scheme: dark)': {
                    fill: disabled ? theme.palette.neutralPrimaryAlt : theme.palette.neutralTertiary
                }
            }
        }) });
};

// Copyright (c) Microsoft Corporation.
/**
 * Generates default {@link IContextualMenuProps} for buttons that
 * show a drop-down to select devices to use.
 *
 * @private
 */
const generateDefaultDeviceMenuProps = (props, strings, primaryActionItem, isSelectCamAllowed = true, isSelectMicAllowed = true) => {
    var _a, _b;
    const { microphones, speakers, cameras, selectedMicrophone, selectedSpeaker, selectedCamera, onSelectCamera, onSelectMicrophone, onSelectSpeaker } = props;
    const defaultMenuProps = {
        items: [],
        styles: props.styles,
        calloutProps: {
            styles: {
                root: {
                    // Confine the menu to the parents bounds.
                    // More info: https://github.com/microsoft/fluentui/issues/18835
                    // NB: 95% to keep some space for margin, drop shadow etc around the Callout.
                    maxWidth: '95%'
                }
            },
            preventDismissOnEvent: _preventDismissOnEvent
        }
    };
    const menuItemStyles = react.merge(buttonFlyoutItemStyles, (_b = (_a = props.styles) === null || _a === void 0 ? void 0 : _a.menuItemStyles) !== null && _b !== void 0 ? _b : {});
    if (cameras && selectedCamera && onSelectCamera && isSelectCamAllowed) {
        defaultMenuProps.items.push({
            key: 'cameras',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.cameraMenuTitle,
                items: [{
                        key: 'sectionCamera',
                        title: strings.cameraMenuTooltip,
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: cameras.map(camera => ({
                                key: camera.id,
                                text: camera.name,
                                title: camera.name,
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                canCheck: true,
                                isChecked: camera.id === (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id),
                                onClick: () => {
                                    if (camera.id !== (selectedCamera === null || selectedCamera === void 0 ? void 0 : selectedCamera.id)) {
                                        onSelectCamera(camera);
                                    }
                                }
                            }))
                        },
                        text: selectedCamera.name
                    }]
            }
        });
        if (primaryActionItem) {
            defaultMenuProps.items.push(primaryActionItem);
        }
    }
    if (microphones && selectedMicrophone && onSelectMicrophone && isSelectMicAllowed) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = speakers && speakers.length > 0;
        const key = speakersAvailable ? 'sectionMicrophone' : 'sectionAudioDevice';
        const title = speakersAvailable ? strings.microphoneMenuTooltip : strings.audioDeviceMenuTooltip;
        defaultMenuProps.items.push({
            key: 'microphones',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.microphoneMenuTitle,
                items: [{
                        key: key,
                        title: title,
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: microphones.map(microphone => ({
                                key: microphone.id,
                                text: microphone.name,
                                title: microphone.name,
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                canCheck: true,
                                isChecked: microphone.id === (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id),
                                onClick: () => {
                                    if (microphone.id !== (selectedMicrophone === null || selectedMicrophone === void 0 ? void 0 : selectedMicrophone.id)) {
                                        onSelectMicrophone(microphone);
                                    }
                                }
                            }))
                        },
                        text: selectedMicrophone.name
                    }]
            }
        });
    }
    if (speakers && selectedSpeaker && onSelectSpeaker) {
        defaultMenuProps.items.push({
            key: 'speakers',
            itemType: react.ContextualMenuItemType.Section,
            sectionProps: {
                title: strings.speakerMenuTitle,
                items: [{
                        key: 'sectionSpeaker',
                        subMenuProps: {
                            calloutProps: {
                                preventDismissOnEvent: _preventDismissOnEvent
                            },
                            items: speakers.map(speaker => ({
                                key: speaker.id,
                                text: speaker.name,
                                title: speaker.name,
                                itemProps: {
                                    styles: menuItemStyles
                                },
                                canCheck: true,
                                isChecked: speaker.id === (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id),
                                onClick: () => {
                                    if (speaker.id !== (selectedSpeaker === null || selectedSpeaker === void 0 ? void 0 : selectedSpeaker.id)) {
                                        onSelectSpeaker(speaker);
                                    }
                                }
                            }))
                        },
                        text: selectedSpeaker.name
                    }]
            }
        });
    }
    if (microphones && selectedMicrophone && onSelectMicrophone && isSelectMicAllowed && primaryActionItem) {
        defaultMenuProps.items.push(primaryActionItem);
    }
    if (defaultMenuProps.items.length === 0) {
        // Avoids creating an empty context menu.
        return undefined;
    }
    return defaultMenuProps;
};
/**
 * A button to open a menu that controls device options.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const DevicesButton = (props) => {
    var _a, _b, _c;
    const { onRenderIcon } = props;
    const localeStrings = useLocale$1().strings.devicesButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const devicesButtonMenu = (_a = props.menuProps) !== null && _a !== void 0 ? _a : generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.menuStyles }), strings);
    const onRenderOptionsIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonOptions" });
    };
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { menuProps: devicesButtonMenu, menuIconProps: {
            hidden: true
        }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderOptionsIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'devicesButtonLabel' }));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$k = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const defaultLocalVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * A button to turn camera on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const CameraButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { localVideoViewOptions, onToggleCamera } = props;
    const [waitForCamera, setWaitForCamera] = React.useState(false);
    const localeStrings = useLocale$1().strings.cameraButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const disabled = props.disabled || waitForCamera;
    const onRenderCameraOnIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOn" });
    const onRenderCameraOffIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonCameraOff" });
    if (waitForCamera && strings.tooltipVideoLoadingContent) {
        strings.tooltipDisabledContent = strings.tooltipVideoLoadingContent;
    }
    const cameraOn = props.checked;
    const splitButtonAriaString = cameraOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isCameraOn) => {
        setAnnouncerString(!isCameraOn ? strings.cameraActionTurnedOffAnnouncement : strings.cameraActionTurnedOnAnnouncement);
    }, [strings.cameraActionTurnedOffAnnouncement, strings.cameraActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$k(void 0, void 0, void 0, function* () {
        // Throttle click on camera, need to await onToggleCamera then allow another click
        if (onToggleCamera) {
            setWaitForCamera(true);
            try {
                yield onToggleCamera(localVideoViewOptions !== null && localVideoViewOptions !== void 0 ? localVideoViewOptions : defaultLocalVideoViewOptions);
                // allows for the setting of narrator strings triggering the announcer when camera is turned on or off.
                toggleAnnouncerString(!cameraOn);
            }
            finally {
                setWaitForCamera(false);
            }
        }
    }), [cameraOn, localVideoViewOptions, onToggleCamera, toggleAnnouncerString]);
    const splitButtonMenuItems = [{
            key: 'cameraPrimaryAction',
            text: props.checked ? strings.onSplitButtonPrimaryActionCamera : strings.offSplitButtonPrimaryActionCamera,
            onClick: () => {
                onToggleClick();
            },
            iconProps: {
                iconName: props.checked ? 'SplitButtonPrimaryActionCameraOn' : 'SplitButtonPrimaryActionCameraOff',
                styles: {
                    root: {
                        lineHeight: 0
                    }
                }
            }
        }];
    const splitButtonPrimaryAction = {
        key: 'primaryAction',
        title: 'toggle camera',
        itemType: react.ContextualMenuItemType.Section,
        sectionProps: {
            topDivider: true,
            items: splitButtonMenuItems
        }
    };
    const splitButtonMenuProps = React.useMemo(() => (Object.assign(Object.assign({}, props.splitButtonMenuProps), { className: 'camera-split-button' })), [props.splitButtonMenuProps]);
    return React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement(Announcer$1, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, onClick: onToggleCamera ? onToggleClick : props.onClick, onRenderOnIcon: (_a = props.onRenderOnIcon) !== null && _a !== void 0 ? _a : onRenderCameraOnIcon, onRenderOffIcon: (_b = props.onRenderOffIcon) !== null && _b !== void 0 ? _b : onRenderCameraOffIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'cameraButtonLabel', menuProps: (_d = props.menuProps) !== null && _d !== void 0 ? _d : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_e = props.styles) === null || _e === void 0 ? void 0 : _e.menuStyles }), strings, splitButtonPrimaryAction) : undefined), menuIconProps: ((_f = props.menuIconProps) !== null && _f !== void 0 ? _f : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_g = props.split) !== null && _g !== void 0 ? _g : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.cameraButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined, splitButtonMenuProps: splitButtonMenuProps })));
};

// Copyright (c) Microsoft Corporation.
const mainDivStyle = {
    position: 'relative',
    height: '100%',
    width: '100%'
};
/**
 * A container for various buttons for call controls.
 *
 * Use with various call control buttons in this library, e.g., {@link CameraButton}, or your own instances of
 * {@link ControlBarButton} directly.
 *
 * @public
 */
const ControlBar = (props) => {
    const { styles, layout } = props;
    const theme = useTheme();
    const controlBarClassName = React.useMemo(() => {
        const controlBarStyle = controlBarStyles$1[layout !== null && layout !== void 0 ? layout : 'horizontal'];
        // if theme is dark and layout is floating then use palette.neutralQuaternaryAlt as background, otherwise use theme.palette.white
        const backgroundStyle = {
            background: isDarkThemed(theme) && (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? theme.palette.neutralQuaternaryAlt : theme.palette.white
        };
        const borderAndBoxShadowStyle = (layout === null || layout === void 0 ? void 0 : layout.startsWith('floating')) ? {
            boxShadow: theme.effects.elevation16,
            borderRadius: theme.effects.roundedCorner6
        } : {};
        // if rtl is true and layout is either floatingTop or floatingBottom then we need to override the transform-style property
        // to translate 50% to right instead of the left
        const transformOverrideStyle = theme.rtl && (layout === 'floatingTop' || layout === 'floatingBottom') ? {
            transform: 'translateX(50%)'
        } : {};
        return react.mergeStyles(controlBarStyle, backgroundStyle, borderAndBoxShadowStyle, transformOverrideStyle, styles === null || styles === void 0 ? void 0 : styles.root);
    }, [layout, styles === null || styles === void 0 ? void 0 : styles.root, theme]);
    return React__default['default'].createElement("div", { className: react.mergeStyles(mainDivStyle) },
        React__default['default'].createElement(react.Stack, { className: controlBarClassName }, props.children));
};

// Copyright (c) Microsoft Corporation.
const onRenderEndCallIcon = () => React__default['default'].createElement(react.Icon, { iconName: "ControlButtonEndCall" });
/**
 * A button to end an ongoing call.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const EndCallButton = (props) => {
    var _a, _b, _c;
    const { styles } = props;
    const localeStrings = useLocale$1().strings.endCallButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = useTheme();
    const isDarkTheme = isDarkThemed(theme);
    const componentStyles = react.concatStyleSets(isDarkTheme ? darkThemeCallButtonStyles : lightThemeCallButtonStyles, styles !== null && styles !== void 0 ? styles : {});
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: (_a = props.onHangUp) !== null && _a !== void 0 ? _a : props.onClick, styles: componentStyles, onRenderIcon: (_b = props.onRenderIcon) !== null && _b !== void 0 ? _b : onRenderEndCallIcon, strings: strings, labelKey: (_c = props.labelKey) !== null && _c !== void 0 ? _c : 'endCallButtonLabel' }));
};
// using media query to prevent windows from overwriting the button color
const darkThemeCallButtonStyles = {
    root: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        },
        ':focus::after': {
            outlineColor: `${darkTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    rootPressed: {
        color: darkTheme.callingPalette.iconWhite,
        background: darkTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    label: {
        color: darkTheme.callingPalette.iconWhite
    }
};
const lightThemeCallButtonStyles = {
    root: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        },
        ':focus::after': {
            outlineColor: `${lightTheme.callingPalette.iconWhite} !important`
        } // added !important to avoid override by FluentUI button styles
    },
    rootHovered: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    rootPressed: {
        color: lightTheme.callingPalette.iconWhite,
        background: lightTheme.callingPalette.callRed,
        '@media (forced-colors: active)': {
            forcedColorAdjust: 'none'
        }
    },
    label: {
        color: lightTheme.callingPalette.iconWhite
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$j = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * A button to turn microphone on / off.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const MicrophoneButton = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { onToggleMicrophone } = props;
    const localeStrings = useLocale$1().strings.microphoneButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const [announcerString, setAnnouncerString] = React.useState(undefined);
    const isSplit = (_a = props.split) !== null && _a !== void 0 ? _a : props.enableDeviceSelectionMenu;
    // The button should be disabled when there are no mics. However if the button is a split button, if there are
    // no mics but there are speakers, then only the primary part of the button should be disabled to allow for
    // speaker change.
    const primaryDisabled = props.primaryDisabled || (isSplit && !((_b = props.microphones) === null || _b === void 0 ? void 0 : _b.length) ? true : undefined);
    const disabled = props.disabled || isSplit && !((_c = props.microphones) === null || _c === void 0 ? void 0 : _c.length) && !((_d = props.speakers) === null || _d === void 0 ? void 0 : _d.length) || !isSplit && props.microphones && ((_e = props.microphones) === null || _e === void 0 ? void 0 : _e.length) === 0;
    const onRenderMicOnIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOn" });
    };
    const onRenderMicOffIcon = () => {
        return React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonMicOff" });
    };
    const isMicOn = props.checked;
    const splitButtonAriaString = isMicOn ? strings.onSplitButtonAriaLabel : strings.offSplitButtonAriaLabel;
    const toggleAnnouncerString = React.useCallback((isMicOn) => {
        setAnnouncerString(!isMicOn ? strings.microphoneActionTurnedOffAnnouncement : strings.microphoneActionTurnedOnAnnouncement);
    }, [strings.microphoneActionTurnedOffAnnouncement, strings.microphoneActionTurnedOnAnnouncement]);
    const onToggleClick = React.useCallback(() => __awaiter$j(void 0, void 0, void 0, function* () {
        if (onToggleMicrophone) {
            try {
                yield onToggleMicrophone();
                // allows for the setting of narrator strings triggering the announcer when microphone is turned on or off.
                toggleAnnouncerString(!isMicOn);
                // eslint-disable-next-line no-empty
            }
            finally { }
        }
    }), [isMicOn, onToggleMicrophone, toggleAnnouncerString]);
    /**
     * We need to also include the primary action of the button to the
     * split button for mobile devices.
     */
    const splitButtonPrimaryAction = {
        key: 'primaryAction',
        title: 'toggle mic',
        itemType: react.ContextualMenuItemType.Section,
        sectionProps: {
            topDivider: true,
            items: [{
                    key: 'microphonePrimaryAction',
                    text: props.checked ? strings.onSplitButtonMicrophonePrimaryAction : strings.offSplitButtonMicrophonePrimaryAction,
                    onClick: () => {
                        onToggleClick();
                    },
                    iconProps: {
                        iconName: props.checked ? 'SplitButtonPrimaryActionMicUnmuted' : 'SplitButtonPrimaryActionMicMuted',
                        styles: {
                            root: {
                                lineHeight: 0
                            }
                        }
                    }
                }]
        }
    };
    return React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement(Announcer$1, { announcementString: announcerString, ariaLive: 'polite' }),
        React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { onClick: props.onToggleMicrophone ? onToggleClick : props.onClick, onRenderOnIcon: (_f = props.onRenderOnIcon) !== null && _f !== void 0 ? _f : onRenderMicOnIcon, onRenderOffIcon: (_g = props.onRenderOffIcon) !== null && _g !== void 0 ? _g : onRenderMicOffIcon, strings: strings, labelKey: (_h = props.labelKey) !== null && _h !== void 0 ? _h : 'microphoneButtonLabel', menuProps: (_j = props.menuProps) !== null && _j !== void 0 ? _j : (props.enableDeviceSelectionMenu ? generateDefaultDeviceMenuProps(Object.assign(Object.assign({}, props), { styles: (_k = props.styles) === null || _k === void 0 ? void 0 : _k.menuStyles }), strings, splitButtonPrimaryAction) : undefined), menuIconProps: ((_l = props.menuIconProps) !== null && _l !== void 0 ? _l : !props.enableDeviceSelectionMenu) ? {
                hidden: true
            } : undefined, split: (_m = props.split) !== null && _m !== void 0 ? _m : props.enableDeviceSelectionMenu, "aria-roledescription": props.enableDeviceSelectionMenu ? strings.microphoneButtonSplitRoleDescription : undefined, splitButtonAriaLabel: props.enableDeviceSelectionMenu ? splitButtonAriaString : undefined, disabled: disabled, primaryDisabled: primaryDisabled })));
};

// Copyright (c) Microsoft Corporation.
/**
 * A button to show a menu with calling or chat participants.
 *
 * Can be used with {@link ControlBar}.
 *
 * This button contains dropdown menu items defined through its property `menuProps`. By default, it can display the number of remote participants with the full list
 * as sub-menu and an option to mute all participants, as well as a copy-to-clipboard button to copy the call invitation URL.
 * This `menuProps` can be fully redefined and its property is of type [IContextualMenuProps](https://developer.microsoft.com/fluentui#/controls/web/contextualmenu#IContextualMenuProps).
 *
 * @public
 */
const ParticipantsButton = (props) => {
    var _a, _b, _c, _d;
    const { callInvitationURL, styles, onMuteAll, onRenderIcon, onRenderParticipantList, participants, myUserId, excludeMe, onRenderParticipant, onRenderAvatar, onRemoveParticipant, onFetchParticipantMenuItems, showParticipantOverflowTooltip } = props;
    const disabled = props.disabled;
    const [copyInviteLinkAnnouncerStrings, setCopyInviteLinkAnnouncerStrings] = React.useState('');
    const onRenderPeopleIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: disabled, iconName: "ControlButtonParticipants" });
    const ids = useIdentifiers();
    const onMuteAllCallback = React.useCallback(() => {
        if (onMuteAll) {
            onMuteAll();
        }
    }, [onMuteAll]);
    const defaultParticipantList = React.useCallback(() => {
        var _a;
        return React__default['default'].createElement(ParticipantList, { participants: participants, myUserId: myUserId, excludeMe: excludeMe, onRenderParticipant: onRenderParticipant, onRenderAvatar: onRenderAvatar, onRemoveParticipant: onRemoveParticipant, onFetchParticipantMenuItems: onFetchParticipantMenuItems, styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, showParticipantOverflowTooltip: showParticipantOverflowTooltip });
    }, [excludeMe, myUserId, onRemoveParticipant, onRenderAvatar, onRenderParticipant, participants, (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.participantListStyles, onFetchParticipantMenuItems, showParticipantOverflowTooltip]);
    const onCopyCallback = React.useCallback(() => {
        if (callInvitationURL) {
            return copy__default['default'](callInvitationURL);
        }
        return false;
    }, [callInvitationURL]);
    const localeStrings = useLocale$1().strings.participantsButton;
    const strings = React.useMemo(() => (Object.assign(Object.assign({}, localeStrings), props.strings)), [localeStrings, props.strings]);
    const participantCount = participants.length;
    /**
     * sets the announcement string for when the link is copied.
     */
    const toggleAnnouncerString = React.useCallback(() => {
        setCopyInviteLinkAnnouncerStrings(strings.copyInviteLinkActionedAriaLabel);
        /**
         * Clears the announcer string after the user clicks the
         * copyInviteLink button allowing it to be re-announced.
         */
        setTimeout(() => {
            setCopyInviteLinkAnnouncerStrings('');
        }, 3000);
    }, [strings.copyInviteLinkActionedAriaLabel]);
    const generateDefaultParticipantsSubMenuProps = React.useCallback(() => {
        var _a;
        const items = [];
        if (participantCount > 0) {
            items.push({
                key: 'participantListMenuItemKey',
                onRender: onRenderParticipantList !== null && onRenderParticipantList !== void 0 ? onRenderParticipantList : defaultParticipantList
            });
            items.push({
                key: 'participantsDivider1',
                itemType: react.ContextualMenuItemType.Divider
            });
            if (onMuteAll) {
                items.push({
                    key: 'muteAllKey',
                    text: strings.muteAllButtonLabel,
                    title: strings.muteAllButtonLabel,
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles,
                    iconProps: {
                        iconName: 'MicOff2'
                    },
                    onClick: onMuteAllCallback
                });
            }
        }
        return items;
    }, [participantCount, onRenderParticipantList, defaultParticipantList, onMuteAll, strings.muteAllButtonLabel, (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles, onMuteAllCallback]);
    const defaultMenuProps = React.useMemo(() => {
        var _a, _b;
        const menuProps = {
            title: strings.menuHeader,
            ariaLabel: strings.menuHeader,
            styles: react.merge(participantsButtonMenuPropsStyle, styles === null || styles === void 0 ? void 0 : styles.menuStyles),
            items: [],
            calloutProps: {
                preventDismissOnEvent: _preventDismissOnEvent
            }
        };
        if (participantCount > 0) {
            const participantIds = participants.map(p => p.userId);
            let participantCountWithoutMe = participantIds.length;
            if (excludeMe) {
                participantCountWithoutMe -= 1;
            }
            menuProps.items.push({
                key: 'participantCountKey',
                name: _formatString(strings.participantsListButtonLabel, {
                    numParticipants: `${participantCountWithoutMe}`
                }),
                itemProps: {
                    styles: (_a = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _a === void 0 ? void 0 : _a.menuItemStyles
                },
                iconProps: {
                    iconName: 'People'
                },
                subMenuProps: {
                    items: generateDefaultParticipantsSubMenuProps(),
                    calloutProps: {
                        styles: {
                            root: {
                                // Confine the menu to the parents bounds.
                                // More info: https://github.com/microsoft/fluentui/issues/18835
                                maxWidth: '100%'
                            }
                        },
                        style: {
                            maxHeight: '20rem'
                        },
                        // Disable dismiss on resize to work around a couple Fluent UI bugs
                        // See reasoning in the props for the parent menu.
                        preventDismissOnEvent: _preventDismissOnEvent
                    }
                },
                'data-ui-id': ids.participantButtonPeopleMenuItem
            });
        }
        if (callInvitationURL) {
            menuProps.items.push({
                key: 'InviteLinkKey',
                name: strings.copyInviteLinkButtonLabel,
                title: strings.copyInviteLinkButtonLabel,
                itemProps: {
                    styles: (_b = styles === null || styles === void 0 ? void 0 : styles.menuStyles) === null || _b === void 0 ? void 0 : _b.menuItemStyles
                },
                iconProps: {
                    iconName: 'Link'
                },
                onClick: () => {
                    onCopyCallback();
                    toggleAnnouncerString();
                }
            });
        }
        return menuProps;
    }, [strings.menuHeader, strings.participantsListButtonLabel, strings.copyInviteLinkButtonLabel, styles === null || styles === void 0 ? void 0 : styles.menuStyles, participantCount, callInvitationURL, participants, excludeMe, ids.participantButtonPeopleMenuItem, generateDefaultParticipantsSubMenuProps, onCopyCallback, toggleAnnouncerString]);
    return React__default['default'].createElement(React__default['default'].Fragment, null,
        React__default['default'].createElement(Announcer$1, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
        React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { disabled: disabled, menuProps: (_c = props.menuProps) !== null && _c !== void 0 ? _c : defaultMenuProps, menuIconProps: {
                hidden: true
            }, onRenderIcon: onRenderIcon !== null && onRenderIcon !== void 0 ? onRenderIcon : onRenderPeopleIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'participantsButtonLabel' })));
};

// Copyright (c) Microsoft Corporation.
/**
 * A button to start / stop screen sharing.
 *
 * Can be used with {@link ControlBar}.
 *
 * @public
 */
const ScreenShareButton = (props) => {
    var _a, _b, _c, _d;
    const localeStrings = useLocale$1().strings.screenShareButton;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const theme = react.useTheme();
    const styles = screenshareButtonStyles(theme);
    const onRenderScreenShareOnIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStop" });
    const onRenderScreenShareOffIcon = () => React__default['default'].createElement(_HighContrastAwareIcon, { disabled: props.disabled, iconName: "ControlButtonScreenShareStart" });
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { className: react.mergeStyles(styles, props.styles), onClick: (_a = props.onToggleScreenShare) !== null && _a !== void 0 ? _a : props.onClick, onRenderOnIcon: (_b = props.onRenderOnIcon) !== null && _b !== void 0 ? _b : onRenderScreenShareOnIcon, onRenderOffIcon: (_c = props.onRenderOffIcon) !== null && _c !== void 0 ? _c : onRenderScreenShareOffIcon, strings: strings, labelKey: (_d = props.labelKey) !== null && _d !== void 0 ? _d : 'screenShareButtonLabel', disabled: props.disabled }));
};
const screenshareButtonStyles = (theme) => ({
    rootChecked: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        },
        // added !important to avoid override by FluentUI button styles
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    },
    rootCheckedHovered: {
        background: theme.palette.themePrimary,
        color: react.DefaultPalette.white,
        ':focus::after': {
            outlineColor: `${react.DefaultPalette.white} !important`
        },
        // added !important to avoid override by FluentUI button styles
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    },
    labelChecked: {
        color: react.DefaultPalette.white
    }
});

// Copyright (c) Microsoft Corporation.
/** @private */
const PictureInPictureInPicturePrimaryTile = (props) => {
    const boxShadow = useTheme().effects.elevation8;
    return React__default['default'].createElement(PictureInPictureInPictureTile, { styles: primaryTileStyles(props.orientation, boxShadow) }, props.children);
};
/** @private */
const PictureInPictureInPictureSecondaryTile = (props) => React__default['default'].createElement(PictureInPictureInPictureTile, { styles: secondaryTileStyles(props.orientation) }, props.children);
const PictureInPictureInPictureTile = (props) => React__default['default'].createElement(react.Stack, { styles: props.styles }, props.children);
const primaryTileStyles = react.memoizeFunction((orientation, themeElevation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '5.5rem' : '8rem',
        width: orientation === 'landscape' ? '8rem' : '5.5rem',
        boxShadow: themeElevation,
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));
const secondaryTileStyles = react.memoizeFunction((orientation) => ({
    root: {
        borderRadius: '0.25rem',
        height: orientation === 'landscape' ? '1.625rem' : '2rem',
        width: orientation === 'landscape' ? '2rem' : '1.625rem',
        // PiPiP tiles were not designed to host scrollable content. If removed check no scrollbar is showing in e2e tests
        overflow: 'hidden'
    }
}));

// Copyright (c) Microsoft Corporation.
/**
 * Component that displays a video feed for use as a Picture-in-Picture style component.
 * It contains a secondary video feed resulting in an inner Picture-in-Picture style feed.
 *
 * @remarks
 * The double nature of the Picture-in-Picture styles is where this component gets its name; Picture-in-Picture-in-Picture.
 *
 * @internal
 */
const _PictureInPictureInPicture = (props) => {
    return React__default['default'].createElement(PictureInPictureInPictureContainer, { onClick: props.onClick, primaryView: React__default['default'].createElement(PictureInPictureInPicturePrimaryTile, Object.assign({}, props.primaryTile)), secondaryView: props.secondaryTile && React__default['default'].createElement(PictureInPictureInPictureSecondaryTile, Object.assign({}, props.secondaryTile)), ariaLabel: props.strings.rootAriaLabel });
};
/**
 * Container for the picture in picture in picture component.
 * This governs positioning and floating of the secondary PiP.
 */
const PictureInPictureInPictureContainer = (props) => {
    const onKeyPress = (e) => props.onClick && submitWithKeyboard(e, props.onClick);
    return React__default['default'].createElement("aside", { style: tileContainerStyles, onClick: props.onClick, onKeyPress: onKeyPress, "aria-label": props.ariaLabel, tabIndex: props.onClick ? 0 : -1, "data-ui-id": "picture-in-picture-in-picture-root" },
        props.primaryView,
        React__default['default'].createElement("div", { style: secondaryTileFloatingStyles }, props.secondaryView));
};
const tileContainerStyles = {
    display: 'flex',
    width: 'min-content',
    position: 'relative',
    cursor: 'pointer'
};
const secondaryTileFloatingStyles = {
    // The secondary tile should float above the primary tile, aligned to the bottom right.
    position: 'absolute',
    bottom: '0.125rem',
    right: '0.125rem'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Return different conditions based on the current and previous state of recording and transcribing
 *
 * @param callRecordState - The current call record state: on, off, stopped
 * @param callTranscribeState - The current call transcribe state: on, off, stopped
 *
 * @remarks - The stopped state means: previously on but currently off
 *
 * @private
 */
const computeVariant = (callRecordState, callTranscribeState) => {
    if (callRecordState === 'on' && callTranscribeState === 'on') {
        return 'RECORDING_AND_TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'off') {
        return 'RECORDING_STARTED';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'on') {
        return 'TRANSCRIPTION_STARTED';
    }
    else if (callRecordState === 'on' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED_STILL_RECORDING';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'on') {
        return 'RECORDING_STOPPED_STILL_TRANSCRIBING';
    }
    else if (callRecordState === 'off' && callTranscribeState === 'stopped') {
        return 'TRANSCRIPTION_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'off') {
        return 'RECORDING_STOPPED';
    }
    else if (callRecordState === 'stopped' && callTranscribeState === 'stopped') {
        return 'RECORDING_AND_TRANSCRIPTION_STOPPED';
    }
    else {
        return 'NO_STATE';
    }
};

// Copyright (c) Microsoft Corporation.
/** @private */
function BannerMessage(props) {
    const { variant, strings } = props;
    switch (variant) {
        case 'TRANSCRIPTION_STOPPED_STILL_RECORDING':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionStopped),
                ` ${strings.complianceBannerNowOnlyRecording}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED_STILL_TRANSCRIBING':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingStopped),
                ` ${strings.complianceBannerNowOnlyTranscription}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_AND_TRANSCRIPTION_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingAndTranscriptionSaved),
                ` ${strings.complianceBannerRecordingAndTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_AND_TRANSCRIPTION_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingAndTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'RECORDING_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingSaving),
                ` ${strings.complianceBannerRecordingStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
        case 'RECORDING_STARTED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerRecordingStarted),
                ` ${strings.complianceBannerTranscriptionConsent}`,
                React__default['default'].createElement(PrivacyPolicy, { linkText: strings.privacyPolicy }));
        case 'TRANSCRIPTION_STOPPED':
            return React__default['default'].createElement(React__default['default'].Fragment, null,
                React__default['default'].createElement("b", null, strings.complianceBannerTranscriptionSaving),
                ` ${strings.complianceBannerTranscriptionStopped}`,
                React__default['default'].createElement(LearnMore, { linkText: strings.learnMore }));
    }
    return React__default['default'].createElement(React__default['default'].Fragment, null);
}
function PrivacyPolicy(props) {
    return React__default['default'].createElement(react.Link, { href: "https://privacy.microsoft.com/privacystatement#mainnoticetoendusersmodule", target: "_blank", underline: true }, props.linkText);
}
function LearnMore(props) {
    return React__default['default'].createElement(react.Link, { href: "https://support.microsoft.com/office/record-a-meeting-in-teams-34dfbe7f-b07d-4a27-b4c6-de62f1348c24", target: "_blank", underline: true }, props.linkText);
}

// Copyright (c) Microsoft Corporation.
const BANNER_OVERWRITE_DELAY_MS = 3000;
/**
 * Shows a {@link BannerMessage} in a {@link MessageBar} tracking `variant` internally.
 *
 * This component delays and combines frequent updates to `variant` such that:
 * - Updates that happen within {@link BANNER_OVERWRITE_DELAY_MS} are delayed.
 * - Once {@link BANNER_OVERWRITE_DELAY_MS} has passed since the last update, the _latest_ pending update is shown.
 *
 * This ensures that there is enough time for the user to see a banner message before it is overwritten.
 * In case of multiple delayed messages, the user always sees the final message as it reflects the final state
 * of recording and transcription.
 *
 * @private
 */
function DelayedUpdateBanner(props) {
    const { variant, lastUpdated: variantLastUpdated } = props.variant;
    // Tracks the variant that is currently visible in the UI.
    const [visible, setVisible] = React.useState({
        variant,
        lastUpdated: Date.now()
    });
    const pendingUpdateHandle = React.useRef(null);
    if (variant !== visible.variant && variantLastUpdated > visible.lastUpdated) {
        // Always clear pending updates.
        // We'll either update now, or schedule an update for later.
        if (pendingUpdateHandle.current) {
            clearTimeout(pendingUpdateHandle.current);
        }
        const now = Date.now();
        const timeToNextUpdate = BANNER_OVERWRITE_DELAY_MS - (now - visible.lastUpdated);
        if (variant === 'NO_STATE' || timeToNextUpdate <= 0) {
            setVisible({
                variant,
                lastUpdated: now
            });
        }
        else {
            pendingUpdateHandle.current = setTimeout(() => {
                // Set the actual update time, not the computed time when the update should happen.
                // The actual update might be later than we planned.
                setVisible({
                    variant,
                    lastUpdated: Date.now()
                });
            }, timeToNextUpdate);
        }
    }
    if (visible.variant === 'NO_STATE') {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    return React__default['default'].createElement(react.MessageBar, { messageBarType: react.MessageBarType.warning, onDismiss: () => {
            // when closing the banner, change variant to nostate and change stopped state to off state.
            // Reason: on banner close, going back to the default state.
            setVisible({
                variant: 'NO_STATE',
                lastUpdated: Date.now()
            });
            props.onDismiss();
        }, dismissButtonAriaLabel: props.strings.close },
        React__default['default'].createElement(BannerMessage, { variant: visible.variant, strings: props.strings }));
}

// Copyright (c) Microsoft Corporation.
/**
 * A component that displays banners to notify the user when call recording and
 * transcription is enabled or disabled in a call.
 *
 * This component implements a state machine that tracks the changes to call
 * recording and transcription state and shows the corresponding message.
 *
 * @internal
 */
const _ComplianceBanner = (props) => {
    const cachedProps = React.useRef({
        latestBooleanState: {
            callTranscribeState: false,
            callRecordState: false
        },
        latestStringState: {
            callTranscribeState: 'off',
            callRecordState: 'off'
        },
        lastUpdated: Date.now()
    });
    // Only update cached props and variant if there is _some_ change in the latest props.
    // This ensures that state machine is only updated if there is an actual change in the props.
    const shouldUpdateCached = props.callRecordState !== cachedProps.current.latestBooleanState.callRecordState || props.callTranscribeState !== cachedProps.current.latestBooleanState.callTranscribeState;
    // The following three operations must be performed in this exact order:
    // [1]: Update cached state to transition the state machine.
    if (shouldUpdateCached) {
        cachedProps.current = {
            latestBooleanState: props,
            latestStringState: {
                callRecordState: determineStates(cachedProps.current.latestStringState.callRecordState, props.callRecordState),
                callTranscribeState: determineStates(cachedProps.current.latestStringState.callTranscribeState, props.callTranscribeState)
            },
            lastUpdated: Date.now()
        };
    }
    // [2]: Compute the variant, using the transitioned state machine.
    const variant = computeVariant(cachedProps.current.latestStringState.callRecordState, cachedProps.current.latestStringState.callTranscribeState);
    // [3]: Transition the state machine again to deal with some end-states.
    if (shouldUpdateCached && cachedProps.current.latestStringState.callRecordState === 'stopped' && cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
        // When both states are stopped, after displaying message "RECORDING_AND_TRANSCRIPTION_STOPPED", change both states to off (going back to the default state).
        cachedProps.current.latestStringState.callRecordState = 'off';
        cachedProps.current.latestStringState.callTranscribeState = 'off';
    }
    return React__default['default'].createElement(DelayedUpdateBanner, { variant: {
            variant,
            lastUpdated: cachedProps.current.lastUpdated
        }, strings: props.strings, onDismiss: () => {
            if (cachedProps.current.latestStringState.callRecordState === 'stopped') {
                cachedProps.current.latestStringState.callRecordState = 'off';
            }
            if (cachedProps.current.latestStringState.callTranscribeState === 'stopped') {
                cachedProps.current.latestStringState.callTranscribeState = 'off';
            }
        } });
};
function determineStates(previous, current) {
    // if current state is on, then return on
    if (current) {
        return 'on';
    }
    // if current state is off
    else {
        // if previous state is on and current state is off, return stopped (on -> off)
        if (previous === 'on') {
            return 'stopped';
        }
        // otherwise remain previous state unchanged
        else {
            return previous;
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const checkIsSpeaking = (participant) => participant.isSpeaking && !participant.isMuted;

// Copyright (c) Microsoft Corporation.
/** @internal */
const _dominantSpeakersWithFlatId = (dominantSpeakers) => {
    var _a;
    return (_a = dominantSpeakers === null || dominantSpeakers === void 0 ? void 0 : dominantSpeakers.speakersList) === null || _a === void 0 ? void 0 : _a.map(toFlatCommunicationIdentifier);
};
/** @internal */
const _videoGalleryRemoteParticipantsMemo = (remoteParticipants) => {
    if (!remoteParticipants) {
        return [];
    }
    return memoizedAllConvertRemoteParticipant(memoizedFn => {
        return Object.values(remoteParticipants)
            /**
             * hiding participants who are inLobby, idle, or connecting in ACS clients till we can admit users through ACS clients.
             * phone users will be in the connecting state until they are connected to the call.
             */ .filter((participant) => {
            return !['InLobby', 'Idle', 'Connecting', 'Disconnected'].includes(participant.state) || participant.identifier.kind === 'phoneNumber';
        }).map((participant) => {
            const state = _isRingingPSTNParticipant(participant);
            return memoizedFn(toFlatCommunicationIdentifier(participant.identifier), participant.isMuted, checkIsSpeaking(participant), participant.videoStreams, state, participant.displayName);
        });
    });
};
const memoizedAllConvertRemoteParticipant = memoizeFnAll((userId, isMuted, isSpeaking, videoStreams, state, displayName) => {
    return convertRemoteParticipantToVideoGalleryRemoteParticipant(userId, isMuted, isSpeaking, videoStreams, state, displayName);
});
/** @private */
const convertRemoteParticipantToVideoGalleryRemoteParticipant = (userId, isMuted, isSpeaking, videoStreams, state, displayName) => {
    const rawVideoStreamsArray = Object.values(videoStreams);
    let videoStream = undefined;
    let screenShareStream = undefined;
    const sdkRemoteVideoStream = Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'Video' && i.isAvailable) || Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'Video');
    const sdkScreenShareStream = Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'ScreenSharing' && i.isAvailable) || Object.values(rawVideoStreamsArray).find(i => i.mediaStreamType === 'ScreenSharing');
    if (sdkRemoteVideoStream) {
        videoStream = convertRemoteVideoStreamToVideoGalleryStream(sdkRemoteVideoStream);
    }
    if (sdkScreenShareStream) {
        screenShareStream = convertRemoteVideoStreamToVideoGalleryStream(sdkScreenShareStream);
    }
    return {
        userId,
        displayName,
        isMuted,
        isSpeaking,
        videoStream,
        screenShareStream,
        isScreenSharingOn: screenShareStream !== undefined && screenShareStream.isAvailable
    };
};
const convertRemoteVideoStreamToVideoGalleryStream = (stream) => {
    var _a, _b;
    return {
        id: stream.id,
        isAvailable: stream.isAvailable,
        isMirrored: (_a = stream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = stream.view) === null || _b === void 0 ? void 0 : _b.target
    };
};
/** @private */
const memoizeLocalParticipant = memoizeOne__default['default']((identifier, displayName, isMuted, isScreenSharingOn, localVideoStream) => {
    var _a, _b;
    return ({
        userId: identifier,
        displayName: displayName !== null && displayName !== void 0 ? displayName : '',
        isMuted: isMuted,
        isScreenSharingOn: isScreenSharingOn,
        videoStream: {
            isAvailable: !!localVideoStream,
            isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
            renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
        }
    });
});

// Copyright (c) Microsoft Corporation.
/**
 * Provides data attributes to {@link VideoGallery} component.
 * @public
 */
const videoGallerySelector = reselect.createSelector([getScreenShareRemoteParticipant, getRemoteParticipants$1, getLocalVideoStreams$1, getIsMuted, getIsScreenSharingOn, getDisplayName$2, getIdentifier, getDominantSpeakers], (screenShareRemoteParticipantId, remoteParticipants, localVideoStreams, isMuted, isScreenSharingOn, displayName, identifier, dominantSpeakers) => {
    const screenShareRemoteParticipant = screenShareRemoteParticipantId && remoteParticipants ? remoteParticipants[screenShareRemoteParticipantId] : undefined;
    const localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    const dominantSpeakerIds = _dominantSpeakersWithFlatId(dominantSpeakers);
    dominantSpeakerIds === null || dominantSpeakerIds === void 0 ? void 0 : dominantSpeakerIds.forEach((speaker, idx) => idx);
    const noRemoteParticipants = [];
    return {
        screenShareParticipant: screenShareRemoteParticipant ? convertRemoteParticipantToVideoGalleryRemoteParticipant(toFlatCommunicationIdentifier(screenShareRemoteParticipant.identifier), screenShareRemoteParticipant.isMuted, checkIsSpeaking(screenShareRemoteParticipant), screenShareRemoteParticipant.videoStreams, screenShareRemoteParticipant.state, screenShareRemoteParticipant.displayName) : undefined,
        localParticipant: memoizeLocalParticipant(identifier, displayName, isMuted, isScreenSharingOn, localVideoStream),
        remoteParticipants: _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline$2(remoteParticipants ? Object.values(remoteParticipants) : noRemoteParticipants)),
        dominantSpeakers: dominantSpeakerIds
    };
});
const updateUserDisplayNamesTrampoline$2 = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const memoizedConvertAllremoteParticipants = memoizeFnAll((userId, displayName, state, isMuted, isScreenSharing, isSpeaking) => {
    return convertRemoteParticipantToParticipantListParticipant(userId, displayName, state, isMuted, isScreenSharing, isSpeaking);
});
const convertRemoteParticipantToParticipantListParticipant = (userId, displayName, state, isMuted, isScreenSharing, isSpeaking) => {
    const identifier = fromFlatCommunicationIdentifier(userId);
    return {
        userId,
        displayName,
        state,
        isMuted,
        isScreenSharing,
        isSpeaking,
        // ACS users can not remove Teams users.
        // Removing unknown types of users is undefined.
        isRemovable: communicationCommon.getIdentifierKind(identifier).kind === 'communicationUser' || communicationCommon.getIdentifierKind(identifier).kind === 'phoneNumber'
    };
};

// Copyright (c) Microsoft Corporation.
const convertRemoteParticipantsToParticipantListParticipants = (remoteParticipants) => {
    /* eslint-disable @typescript-eslint/explicit-function-return-type */
    const conversionCallback = memoizeFn => {
        return remoteParticipants
            /**
             * hiding participants who are inLobby, idle, or connecting in ACS clients till we can admit users through ACS clients.
             * phone users will be in the connecting state until they are connected to the call.
             */ .filter((participant) => {
            return !['InLobby', 'Idle', 'Connecting', 'Disconnected'].includes(participant.state) || participant.identifier.kind === 'phoneNumber';
        }).map((participant) => {
            const isScreenSharing = Object.values(participant.videoStreams).some(videoStream => videoStream.mediaStreamType === 'ScreenSharing' && videoStream.isAvailable);
            /**
             * We want to check the participant to see if they are a PSTN participant joining the call
             * and mapping their state to be 'Ringing'
             */
            const state = _isRingingPSTNParticipant(participant);
            return memoizeFn(toFlatCommunicationIdentifier(participant.identifier), participant.displayName, state, participant.isMuted, isScreenSharing, participant.isSpeaking);
        }).sort((a, b) => {
            var _a, _b;
            const nameA = ((_a = a.displayName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            const nameB = ((_b = b.displayName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    };
    return memoizedConvertAllremoteParticipants(conversionCallback);
};
/**
 * Selects data that drives {@link ParticipantList} component.
 *
 * @public
 */
const participantListSelector = reselect.createSelector([getIdentifier, getDisplayName$2, getRemoteParticipants$1, getIsScreenSharingOn, getIsMuted], (userId, displayName, remoteParticipants, isScreenSharingOn, isMuted) => {
    const participants = remoteParticipants ? convertRemoteParticipantsToParticipantListParticipants(updateUserDisplayNamesTrampoline$1(Object.values(remoteParticipants))) : [];
    participants.push({
        userId: userId,
        displayName: displayName,
        isScreenSharing: isScreenSharingOn,
        isMuted: isMuted,
        state: 'Connected',
        // Local participant can never remove themselves.
        isRemovable: false
    });
    return {
        participants: participants,
        myUserId: userId
    };
});
const updateUserDisplayNamesTrampoline$1 = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
/**
 * Selects data that drives {@link ParticipantsButton} component.
 *
 * @public
 */
const participantsButtonSelector = reselect.createSelector([participantListSelector], (participantListProps) => {
    return participantListProps;
});

/**
 * Create a set of default handlers for given component. Memoization is applied to the result. Multiple invocations with
 * the same arguments will return the same handler instances. DeclarativeCallAgent, DeclarativeDeviceManager, and
 * DeclarativeCall may be undefined. If undefined, their associated handlers will not be created and returned.
 *
 * @param callClient - StatefulCallClient returned from
 *   {@link @azure/communication-react#createStatefulCallClient}.
 * @param callAgent - Instance of {@link @azure/communication-calling#CallClient}.
 * @param deviceManager - Instance of {@link @azure/communication-calling#DeviceManager}.
 * @param call - Instance of {@link @azure/communication-calling#Call}.
 * @param _ - React component that you want to generate handlers for.
 *
 * @public
 */
const createDefaultCallingHandlersForComponent = (callClient, callAgent, deviceManager, call, _Component) => {
    if (!callAgent && !call && !deviceManager) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
    }
    if (callAgent && _isACSCallAgent() && (!call || call && _isACSCall())) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
    }
    throw new Error('CallAgent type and Call type are not compatible!');
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$3 = (component) => {
    var _a, _b, _c;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const deviceManager = useDeviceManager();
    const call = (_b = React.useContext(CallContext$1)) === null || _b === void 0 ? void 0 : _b.call;
    const callAgent = (_c = React.useContext(CallAgentContext)) === null || _c === void 0 ? void 0 : _c.callAgent;
    if (!callClient) {
        return undefined;
    }
    // Handle edge case, validate if call and callAgent are the same type (ACS/Teams)
    if (callAgent && _isTeamsCallAgent()) {
        if (call && !_isTeamsCall()) {
            throw new Error('A TeamsCall must be provided when callAgent is TeamsCallAgent');
        }
    }
    if (callAgent && _isACSCallAgent()) {
        if (call && !_isACSCall()) {
            throw new Error('A regular ACS Call must be provided when callAgent is regular CallAgent');
        }
    }
    return createDefaultCallingHandlersForComponent(callClient, callAgent, deviceManager, call);
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$3 = (selector, selectorProps) => {
    var _a, _b, _c;
    const callClient = (_a = React.useContext(CallClientContext)) === null || _a === void 0 ? void 0 : _a.callClient;
    const callId = (_c = (_b = React.useContext(CallContext$1)) === null || _b === void 0 ? void 0 : _b.call) === null || _c === void 0 ? void 0 : _c.id;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callIdConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(callClient && selector ? selector(callClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!callClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : callIdConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        callClient.onStateChange(onStateChange);
        return () => {
            callClient.offStateChange(onStateChange);
        };
    }, [callClient, selector, selectorProps, callIdConfigProps, mounted]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * Select the first 3 active errors from the state for the `ErrorBar` component.
 *
 * In case there are many errors, only the first three errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - `ErrorType` is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by `ErrorType`.
 *
 * @public
 */
const errorBarSelector$1 = reselect.createSelector([getLatestErrors$1, getDiagnostics, getDeviceManager$1, getEnvironmentInfo], (latestErrors, diagnostics, deviceManager, environmentInfo) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    const isSafari = () => {
        return /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);
    };
    const isMacOS = () => {
        return false;
    };
    // Errors reported via diagnostics are more reliable than from API method failures, so process those first.
    if (((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _a === void 0 ? void 0 : _a.value) === communicationCalling.DiagnosticQuality.Bad || ((_b = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReceiveQuality) === null || _b === void 0 ? void 0 : _b.value) === communicationCalling.DiagnosticQuality.Poor) {
        activeErrorMessages.push({
            type: 'callNetworkQualityLow'
        });
    }
    if (((_c = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noSpeakerDevicesEnumerated) === null || _c === void 0 ? void 0 : _c.value) === true) {
        activeErrorMessages.push({
            type: 'callNoSpeakerFound'
        });
    }
    if (((_d = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.noMicrophoneDevicesEnumerated) === null || _d === void 0 ? void 0 : _d.value) === true) {
        activeErrorMessages.push({
            type: 'callNoMicrophoneFound'
        });
    }
    if (((_e = deviceManager.deviceAccess) === null || _e === void 0 ? void 0 : _e.audio) === false && isSafari()) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDeniedSafari'
        });
    }
    if (((_f = deviceManager.deviceAccess) === null || _f === void 0 ? void 0 : _f.audio) === false && !isSafari()) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDenied'
        });
    }
    if (((_g = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) === null || _g === void 0 ? void 0 : _g.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsMicrophoneAccessDenied'
        });
    }
    else if (((_h = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphonePermissionDenied) === null || _h === void 0 ? void 0 : _h.value) === true) {
        activeErrorMessages.push({
            type: 'callMicrophoneAccessDenied'
        });
    }
    const microphoneMuteUnexpectedlyDiagnostic = (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneMuteUnexpectedly) || (diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.microphoneNotFunctioning);
    if (microphoneMuteUnexpectedlyDiagnostic) {
        if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that microphone stopped working and inform them to start microphone again
            activeErrorMessages.push({
                type: 'callMicrophoneMutedBySystem'
            });
        }
        else if (microphoneMuteUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that microphone recovered
            activeErrorMessages.push({
                type: 'callMicrophoneUnmutedBySystem'
            });
        }
    }
    const cameraStoppedUnexpectedlyDiagnostic = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraStoppedUnexpectedly;
    if (cameraStoppedUnexpectedlyDiagnostic) {
        if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Bad) {
            // Inform the user that camera stopped working and inform them to start video again
            activeErrorMessages.push({
                type: 'callVideoStoppedBySystem'
            });
        }
        else if (cameraStoppedUnexpectedlyDiagnostic.value === communicationCalling.DiagnosticQuality.Good) {
            // Inform the user that camera recovered
            activeErrorMessages.push({
                type: 'callVideoRecoveredBySystem'
            });
        }
    }
    if (((_j = deviceManager.deviceAccess) === null || _j === void 0 ? void 0 : _j.video) === false && isSafari()) {
        activeErrorMessages.push({
            type: 'callCameraAccessDeniedSafari'
        });
    }
    else if (((_k = deviceManager.deviceAccess) === null || _k === void 0 ? void 0 : _k.video) === false) {
        activeErrorMessages.push({
            type: 'callCameraAccessDenied'
        });
    }
    else {
        if (((_l = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraFreeze) === null || _l === void 0 ? void 0 : _l.value) === true) {
            activeErrorMessages.push({
                type: 'cameraFrozenForRemoteParticipants'
            });
        }
    }
    /**
     * show the Mac specific strings if the platform is detected as mac
     */
    if (((_m = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.cameraPermissionDenied) === null || _m === void 0 ? void 0 : _m.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsCameraAccessDenied'
        });
    }
    /**
     * This UFD only works on mac still so we should only see it fire on mac.
     */
    if (((_o = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) === null || _o === void 0 ? void 0 : _o.value) === true && isMacOS()) {
        activeErrorMessages.push({
            type: 'callMacOsScreenShareAccessDenied'
        });
    }
    else if (((_p = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.screenshareRecordingDisabled) === null || _p === void 0 ? void 0 : _p.value) === true) {
        activeErrorMessages.push({
            type: 'startScreenShareGeneric'
        });
    }
    // Prefer to show errors with privacy implications.
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopVideo', 'stopVideoGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.mute', 'muteGeneric');
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.stopScreenSharing', 'stopScreenShareGeneric');
    if (((_q = latestErrors['Call.startVideo']) === null || _q === void 0 ? void 0 : _q.message) === 'Call.startVideo: Video operation failure SourceUnavailableError') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'callCameraAlreadyInUse');
    }
    else if (((_r = latestErrors['Call.startVideo']) === null || _r === void 0 ? void 0 : _r.message) === 'Call.startVideo: Video operation failure permissionDeniedError') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'callCameraAccessDenied');
    }
    else {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.startVideo', 'startVideoGeneric');
    }
    appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'Call.unmute', 'unmuteGeneric');
    if (((_s = latestErrors['CallAgent.join']) === null || _s === void 0 ? void 0 : _s.message) === 'CallAgent.join: Invalid meeting link') {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallInvalidMeetingLink');
    }
    else {
        appendActiveErrorIfDefined(activeErrorMessages, latestErrors, 'CallAgent.join', 'failedToJoinCallGeneric');
    }
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount$1);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const appendActiveErrorIfDefined = (activeErrorMessages, latestErrors, target, activeErrorType) => {
    if (latestErrors[target] === undefined) {
        return;
    }
    activeErrorMessages.push({
        type: activeErrorType,
        timestamp: latestErrors[target].timestamp
    });
};
const maxErrorCount$1 = 3;

// Copyright (c) Microsoft Corporation.
const emptySelector = () => ({});
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const getSelector$1 = (component) => {
    return findSelector$1(component);
};
const findSelector$1 = (component) => {
    switch (component) {
        case VideoGallery:
            return videoGallerySelector;
        case MicrophoneButton:
            return microphoneButtonSelector;
        case CameraButton:
            return cameraButtonSelector;
        case ScreenShareButton:
            return screenShareButtonSelector;
        case DevicesButton:
            return devicesButtonSelector;
        case ParticipantList:
            return participantListSelector;
        case ParticipantsButton:
            return participantsButtonSelector;
        case EndCallButton:
            return emptySelector;
        case ErrorBar:
            return errorBarSelector$1;
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$i = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create the default implementation of {@link ChatHandlers}.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * Returned object is memoized to avoid rerenders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlers = memoizeOne__default['default']((chatClient, chatThreadClient) => {
    let messageIterator = undefined;
    let readReceiptIterator = undefined;
    return {
        onSendMessage: (content, options) => __awaiter$i(void 0, void 0, void 0, function* () {
            const sendMessageRequest = {
                content,
                senderDisplayName: chatClient.getState().displayName
            };
            yield chatThreadClient.sendMessage(sendMessageRequest, options);
        }),
        onUpdateMessage: (messageId, content, metadata, options) => __awaiter$i(void 0, void 0, void 0, function* () {
            const updatedMetadata = metadata ? Object.assign({}, metadata) : {};
            updatedMetadata['fileSharingMetadata'] = JSON.stringify((options === null || options === void 0 ? void 0 : options.attachedFilesMetadata) || []);
            yield chatThreadClient.updateMessage(messageId, {
                content,
                metadata: updatedMetadata
            });
        }),
        onDeleteMessage: (messageId) => __awaiter$i(void 0, void 0, void 0, function* () {
            yield chatThreadClient.deleteMessage(messageId);
        }),
        // This handler is designed for chatThread to consume
        onMessageSeen: (chatMessageId) => __awaiter$i(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendReadReceipt({
                chatMessageId
            });
        }),
        onTyping: () => __awaiter$i(void 0, void 0, void 0, function* () {
            yield chatThreadClient.sendTypingNotification();
        }),
        onRemoveParticipant: (userId) => __awaiter$i(void 0, void 0, void 0, function* () {
            yield chatThreadClient.removeParticipant(fromFlatCommunicationIdentifier(userId));
        }),
        updateThreadTopicName: (topicName) => __awaiter$i(void 0, void 0, void 0, function* () {
            yield chatThreadClient.updateTopic(topicName);
        }),
        onLoadPreviousChatMessages: (messagesToLoad) => __awaiter$i(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            if (messageIterator === undefined) {
                // Lazy definition so that errors in the method call are reported correctly.
                // Also allows recovery via retries in case of transient errors.
                messageIterator = chatThreadClient.listMessages({
                    maxPageSize: 50
                });
            }
            if (readReceiptIterator === undefined) {
                readReceiptIterator = chatThreadClient.listReadReceipts();
            }
            // get the earliest message time
            let remainingMessagesToGet = messagesToLoad;
            let isAllChatMessagesLoaded = false;
            let earliestTime = Number.MAX_SAFE_INTEGER;
            while (remainingMessagesToGet >= 1) {
                const message = yield messageIterator.next();
                if ((_a = message === null || message === void 0 ? void 0 : message.value) === null || _a === void 0 ? void 0 : _a.id) {
                    if (parseInt(message.value.id) < earliestTime) {
                        earliestTime = parseInt(message.value.id);
                    }
                }
                if (((_b = message.value) === null || _b === void 0 ? void 0 : _b.type) && message.value.type === 'text') {
                    remainingMessagesToGet--;
                }
                // We have traversed all messages in this thread
                if (message.done) {
                    isAllChatMessagesLoaded = true;
                    break;
                }
            }
            // keep fetching read receipts until read receipt time < earlist message time
            let readReceipt = yield readReceiptIterator.next();
            while (!readReceipt.done && parseInt((_c = readReceipt === null || readReceipt === void 0 ? void 0 : readReceipt.value) === null || _c === void 0 ? void 0 : _c.chatMessageId) >= earliestTime) {
                readReceipt = yield readReceiptIterator.next();
            }
            return isAllChatMessagesLoaded;
        })
    };
});
/**
 * Create a set of default handlers for given component.
 *
 * Returned object is memoized (with reference to the arguments) to avoid
 * renders when used as props for React Components.
 *
 * @public
 */
const createDefaultChatHandlersForComponent = (chatClient, chatThreadClient, _) => {
    return createDefaultChatHandlers(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link StatefulChatClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatClientProvider}.
 *
 * @public
 */
const ChatClientProvider = (props) => {
    return React__default['default'].createElement(ChatClientContext.Provider, { value: props.chatClient }, props.children);
};
/**
 * Hook to obtain {@link StatefulChatClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatClient = () => {
    const chatClient = React.useContext(ChatClientContext);
    if (!chatClient) {
        throw 'Please wrap components with ChatClientProvider and initialize a chat client before calling the hook!';
    }
    return chatClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatThreadClientContext = React.createContext(undefined);
/**
 * A {@link React.Context} that stores a {@link @azure/communication-chat#ChatThreadClient}.
 *
 * Chat components from this package must be wrapped with a {@link ChatThreadClientProvider}.
 *
 * @public
 */
const ChatThreadClientProvider = (props) => {
    return React__default['default'].createElement(ChatThreadClientContext.Provider, { value: props.chatThreadClient }, props.children);
};
/**
 * Hook to obtain {@link @azure/communication-chat#ChatThreadClient} from the provider.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useChatThreadClient = () => {
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient) {
        throw 'Please wrap components with ChatThreadClientProvider and initialize a chat thread client before calling the hook.';
    }
    return chatThreadClient;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a handler for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useHandlers$2 = (component) => {
    const chatClient = React.useContext(ChatClientContext);
    const chatThreadClient = React.useContext(ChatThreadClientContext);
    if (!chatThreadClient || !chatClient) {
        return undefined;
    }
    return createDefaultChatHandlersForComponent(chatClient, chatThreadClient);
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector$2 = (selector, selectorProps) => {
    var _a;
    const chatClient = React.useContext(ChatClientContext);
    const threadId = (_a = React.useContext(ChatThreadClientContext)) === null || _a === void 0 ? void 0 : _a.threadId;
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(chatClient && selector ? selector(chatClient.getState(), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps) : undefined);
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        if (!chatClient || !selector) {
            return;
        }
        const onStateChange = (state) => {
            const newProps = selector(state, selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        chatClient.onStateChange(onStateChange);
        return () => {
            chatClient.offStateChange(onStateChange);
        };
    }, [chatClient, selector, selectorProps, threadConfigProps]);
    return selector ? props : undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getUserId = (state) => toFlatCommunicationIdentifier(state.userId);
/**
 * @private
 */
const getDisplayName$1 = (state) => state.displayName;
/**
 * @private
 */
const getChatMessages = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages) || {}; };
/**
 * @private
 */
const getParticipants = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants) || {}; };
/**
 * @private
 */
const getReadReceipts = (state, props) => {
    var _a;
    return (_a = state.threads[props === null || props === void 0 ? void 0 : props.threadId]) === null || _a === void 0 ? void 0 : _a.readReceipts;
};
/**
 * @private
 */
const getIsLargeGroup = (state, props) => {
    var _a;
    const participants = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.participants;
    return !!participants && Object.values(participants).length > 20;
};
/**
 * @private
 */
const getLatestReadTime = (state, props) => { var _a; return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.latestReadTime) || new Date(0); };
/**
 * @private
 */
const getTypingIndicators = (state, props) => {
    var _a;
    return props.threadId && ((_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.typingIndicators) || [];
};
/**
 * @private
 */
const getLatestErrors = (state) => state.latestErrors;

// Copyright (c) Microsoft Corporation.
/**
 * Selector for {@link SendBox} component.
 *
 * @public
 */
const sendBoxSelector = reselect.createSelector([getUserId, getDisplayName$1], (userId, displayName) => ({
    displayName: displayName,
    userId: userId
}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS = 8000;
/**
 * @private
 */
const PARTICIPANTS_THRESHOLD = 20;
/**
 * @private
 */
const MINUTE_IN_MS = 1000 * 60;
/**
 * @private
 *
 * TODO: Import enum from @azure/communication-chat when ChatMessageType shows up in new release version
 * (or define our type to decouple)
 */
const ACSKnownMessageType = {
    text: 'text',
    html: 'html',
    richtextHtml: 'richtext/html',
    topicUpdated: 'topicUpdated',
    participantAdded: 'participantAdded',
    participantRemoved: 'participantRemoved'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const compareMessages = (firstMessage, secondMessage) => {
    if (firstMessage.createdOn === undefined) {
        return 1;
    }
    if (secondMessage.createdOn === undefined) {
        return -1;
    }
    const firstDate = new Date(firstMessage.createdOn).getTime();
    const secondDate = new Date(secondMessage.createdOn).getTime();
    // Workaround to get a stable order of message before we can get sequenceId from chat service.
    // MessageIds are generated by time order the message persist, a good candidate other than time
    const idDelta = firstMessage.messageId && secondMessage.messageId ? Number.parseInt(firstMessage.messageId) - Number.parseInt(secondMessage.messageId) : 0;
    return firstDate - secondDate === 0 ? idDelta : firstDate - secondDate;
};

/**
 * @private
 */
const updateMessagesWithAttached = (chatMessagesWithStatus) => {
    chatMessagesWithStatus.sort(compareMessages);
    chatMessagesWithStatus.forEach((message, index, messages) => {
        var _a, _b;
        if (message.messageType === 'chat') {
            /**
             * Attached === true means it is within a group of messages in the current order
             * Attached === top/bottom means it is on the top/bottom boundary
             * Attached === false means it is just a single message
             * A group of messages: continuous messages that belong to the same sender and not intercepted by other senders.
             */
            let attached = false;
            const previousMessage = index > 0 ? messages[index - 1] : undefined;
            const nextMessage = index === messages.length - 1 ? undefined : messages[index + 1];
            const previousSenderId = (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.messageType) === 'chat' ? previousMessage.senderId : undefined;
            const nextSenderId = (nextMessage === null || nextMessage === void 0 ? void 0 : nextMessage.messageType) === 'chat' ? nextMessage.senderId : undefined;
            const timediff = new Date((_a = message === null || message === void 0 ? void 0 : message.createdOn) !== null && _a !== void 0 ? _a : '').getTime() - new Date((_b = previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.createdOn) !== null && _b !== void 0 ? _b : '').getTime();
            const diffMins = Math.round(timediff / MINUTE_IN_MS); // minutes
            if (previousSenderId !== message.senderId) {
                attached = message.senderId === nextSenderId ? 'top' : false;
            }
            else if (diffMins && diffMins >= 5) {
                // if there are more than or equal to 5 mins time gap between messages do not attach and show time stamp
                attached = false;
            }
            else {
                attached = message.senderId === nextSenderId ? true : 'bottom';
            }
            message.attached = attached;
        }
    });
};

// Copyright (c) Microsoft Corporation.
const memoizedAllConvertChatMessage = memoizeFnAll((_key, chatMessage, userId, isSeen, isLargeGroup) => {
    const messageType = chatMessage.type.toLowerCase();
    if (messageType === ACSKnownMessageType.text || messageType === ACSKnownMessageType.richtextHtml || messageType === ACSKnownMessageType.html) {
        return convertToUiChatMessage(chatMessage, userId, isSeen, isLargeGroup);
    }
    else {
        return convertToUiSystemMessage(chatMessage);
    }
});
const processChatMessageContent = (message) => {
    var _a;
    return (_a = message.content) === null || _a === void 0 ? void 0 : _a.message;
};
const convertToUiChatMessage = (message, userId, isSeen, isLargeGroup) => {
    const messageSenderId = message.sender !== undefined ? toFlatCommunicationIdentifier(message.sender) : userId;
    return {
        messageType: 'chat',
        createdOn: message.createdOn,
        content: processChatMessageContent(message),
        contentType: sanitizedMessageContentType(message.type),
        status: !isLargeGroup && message.status === 'delivered' && isSeen ? 'seen' : message.status,
        senderDisplayName: message.senderDisplayName,
        senderId: messageSenderId,
        messageId: message.id,
        clientMessageId: message.clientMessageId,
        editedOn: message.editedOn,
        deletedOn: message.deletedOn,
        mine: messageSenderId === userId,
        metadata: message.metadata
    };
};
const convertToUiSystemMessage = (message) => {
    var _a, _b, _c, _d, _e;
    const systemMessageType = message.type;
    if (systemMessageType === 'participantAdded' || systemMessageType === 'participantRemoved') {
        return {
            messageType: 'system',
            systemMessageType,
            createdOn: message.createdOn,
            participants: (_c = (_b = (_a = message.content) === null || _a === void 0 ? void 0 : _a.participants) === null || _b === void 0 ? void 0 : _b.filter(participant => participant.displayName && participant.displayName !== '').map((participant) => ({
                userId: toFlatCommunicationIdentifier(participant.id),
                displayName: participant.displayName
            }))) !== null && _c !== void 0 ? _c : [],
            messageId: message.id,
            iconName: systemMessageType === 'participantAdded' ? 'PeopleAdd' : 'PeopleBlock'
        };
    }
    else {
        // Only topic updated type left, according to ACSKnown type
        return {
            messageType: 'system',
            systemMessageType: 'topicUpdated',
            createdOn: message.createdOn,
            topic: (_e = (_d = message.content) === null || _d === void 0 ? void 0 : _d.topic) !== null && _e !== void 0 ? _e : '',
            messageId: message.id,
            iconName: 'Edit'
        };
    }
};
/** Returns `true` if the message has participants and at least one participant has a display name. */
const hasValidParticipant = (chatMessage) => { var _a; return !!((_a = chatMessage.content) === null || _a === void 0 ? void 0 : _a.participants) && chatMessage.content.participants.some(p => !!p.displayName); };
/**
 * Selector for {@link MessageThread} component.
 *
 * @public
 */
const messageThreadSelector = reselect.createSelector([getUserId, getChatMessages, getLatestReadTime, getIsLargeGroup, getReadReceipts, getParticipants], (userId, chatMessages, latestReadTime, isLargeGroup, readReceipts, participants) => {
    // We can't get displayName in teams meeting interop for now, disable rr feature when it is teams interop
    const isTeamsInterop = Object.values(participants).find(p => 'microsoftTeamsUserId' in p.id) !== undefined;
    // get number of participants
    // filter out the non valid participants (no display name)
    // Read Receipt details will be disabled when participant count is 0
    const participantCount = isTeamsInterop ? undefined : Object.values(participants).filter(p => p.displayName && p.displayName !== '').length;
    // creating key value pairs of senderID: last read message information
    const readReceiptsBySenderId = {};
    // readReceiptsBySenderId[senderID] gets updated everytime a new message is read by this sender
    // in this way we can make sure that we are only saving the latest read message id and read on time for each sender
    readReceipts.filter(r => r.sender && toFlatCommunicationIdentifier(r.sender) !== userId).forEach(r => {
        var _a, _b;
        readReceiptsBySenderId[toFlatCommunicationIdentifier(r.sender)] = {
            lastReadMessage: r.chatMessageId,
            displayName: (_b = (_a = participants[toFlatCommunicationIdentifier(r.sender)]) === null || _a === void 0 ? void 0 : _a.displayName) !== null && _b !== void 0 ? _b : ''
        };
    });
    // A function takes parameter above and generate return value
    const convertedMessages = memoizedAllConvertChatMessage(memoizedFn => Object.values(chatMessages).filter(message => message.type.toLowerCase() === ACSKnownMessageType.text || message.type.toLowerCase() === ACSKnownMessageType.richtextHtml || message.type.toLowerCase() === ACSKnownMessageType.html || message.type === ACSKnownMessageType.participantAdded && hasValidParticipant(message) || message.type === ACSKnownMessageType.participantRemoved && hasValidParticipant(message) ||
        // TODO: Add support for topicUpdated system messages in MessageThread component.
        // message.type === ACSKnownMessageType.topicUpdated ||
        message.clientMessageId !== undefined).filter(isMessageValidToRender).map(message => {
        var _a;
        return memoizedFn((_a = message.id) !== null && _a !== void 0 ? _a : message.clientMessageId, message, userId, message.createdOn <= latestReadTime, isLargeGroup);
    }));
    updateMessagesWithAttached(convertedMessages);
    return {
        userId,
        showMessageStatus: true,
        messages: convertedMessages,
        participantCount,
        readReceiptsBySenderId
    };
});
const sanitizedMessageContentType = (type) => {
    const lowerCaseType = type.toLowerCase();
    return lowerCaseType === 'text' || lowerCaseType === 'html' || lowerCaseType === 'richtext/html' ? lowerCaseType : 'unknown';
};
const isMessageValidToRender = (message) => {
    var _a, _b;
    if (message.deletedOn) {
        return false;
    }
    if ((_a = message.metadata) === null || _a === void 0 ? void 0 : _a['fileSharingMetadata']) {
        return true;
    }
    return !!(message.content && ((_b = message.content) === null || _b === void 0 ? void 0 : _b.message) !== '');
};

// Copyright (c) Microsoft Corporation.
const filterTypingIndicators = (typingIndicators, userId) => {
    const filteredTypingIndicators = [];
    const seen = new Set();
    const date8SecondsAgo = new Date(Date.now() - MINIMUM_TYPING_INTERVAL_IN_MILLISECONDS);
    for (let i = typingIndicators.length - 1; i >= 0; i--) {
        const typingIndicator = typingIndicators[i];
        if (toFlatCommunicationIdentifier(typingIndicator.sender) === userId) {
            continue;
        }
        if (typingIndicator.receivedOn < date8SecondsAgo) {
            continue;
        }
        if (seen.has(toFlatCommunicationIdentifier(typingIndicator.sender))) {
            continue;
        }
        seen.add(toFlatCommunicationIdentifier(typingIndicator.sender));
        filteredTypingIndicators.push(typingIndicator);
    }
    return filteredTypingIndicators;
};
const convertSdkTypingIndicatorsToCommunicationParticipants = (typingIndicators, participants) => {
    return typingIndicators.map(typingIndicator => {
        var _a;
        return ({
            userId: toFlatCommunicationIdentifier(typingIndicator.sender),
            displayName: (_a = participants[toFlatCommunicationIdentifier(typingIndicator.sender)]) === null || _a === void 0 ? void 0 : _a.displayName
        });
    });
};
/**
 * Selector for {@link TypingIndicator} component.
 *
 * @public
 */
const typingIndicatorSelector = reselect.createSelector([getTypingIndicators, getParticipants, getUserId], (typingIndicators, participants, userId) => {
    // if the participant size reaches the threshold then return no typing users
    if (Object.values(participants).length >= PARTICIPANTS_THRESHOLD) {
        return {
            typingUsers: []
        };
    }
    // filter typing indicators to remove those that are from the duplicate users or current user as well as those older than a threshold
    const filteredTypingIndicators = filterTypingIndicators(typingIndicators, userId);
    const typingUsers = convertSdkTypingIndicatorsToCommunicationParticipants(filteredTypingIndicators, participants);
    return {
        typingUsers
    };
});

// Copyright (c) Microsoft Corporation.
const convertChatParticipantsToCommunicationParticipants = (chatParticipants) => {
    return chatParticipants.map((participant) => {
        return {
            userId: toFlatCommunicationIdentifier(participant.id),
            displayName: participant.displayName,
            // ACS users can not remove Teams users.
            // Removing phone numbers or unknown types of users is undefined.
            isRemovable: communicationCommon.getIdentifierKind(participant.id).kind === 'communicationUser'
        };
    });
};
/**
 * get the index of moderator to help updating its display name if they are the local user or removing them from list of participants otherwise
 */
const moderatorIndex = (participants) => {
    return participants.map(p => p.displayName).indexOf(undefined);
};
/**
 * Selector for {@link ParticipantList} component.
 *
 * @public
 */
const chatParticipantListSelector = reselect__namespace.createSelector([getUserId, getParticipants, getDisplayName$1], (userId, chatParticipants, displayName) => {
    let participants = convertChatParticipantsToCommunicationParticipants(Object.values(chatParticipants));
    if (0 !== participants.length) {
        const moderatorIdx = moderatorIndex(participants);
        if (-1 !== moderatorIdx) {
            const userIndex = participants.map(p => p.userId).indexOf(userId);
            if (moderatorIdx === userIndex) {
                participants[moderatorIdx].displayName = displayName;
            }
            else {
                participants = participants.filter(p => p.displayName);
            }
        }
    }
    return {
        myUserId: userId,
        participants: participants
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Select the first fiew active errors from the state for the {@link ErrorBar} component.
 *
 * In case there are many errors, only a few top errors are returned to avoid
 * filling up the UI with too many errors.
 *
 * Invariants:
 *   - {@link ErrorType} is never repeated in the returned errors.
 *   - Errors are returned in a fixed order by {@link ErrorType}.
 *
 * @public
 */
const errorBarSelector = reselect.createSelector([getLatestErrors], (latestErrors) => {
    var _a;
    // The order in which the errors are returned is significant: The `ErrorBar` shows errors on the UI in that order.
    // There are several options for the ordering:
    //   - Sorted by when the errors happened (latest first / oldest first).
    //   - Stable sort by error type.
    //
    // We chose to stable sort by error type: We intend to show only a small number of errors on the UI and we do not
    // have timestamps for errors.
    const activeErrorMessages = [];
    let specificSendMessageErrorSeen = false;
    {
        const error = latestUnableToReachChatServiceError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    {
        const error = latestAccessDeniedError(latestErrors);
        if (error !== undefined) {
            activeErrorMessages.push(error);
        }
    }
    const sendMessageError = latestErrors['ChatThreadClient.sendMessage'];
    {
        const error = latestNotInThisThreadError(latestErrors);
        if (error !== undefined) {
            if (sendMessageError !== undefined) {
                activeErrorMessages.push({
                    type: 'sendMessageNotInChatThread',
                    // Set the latest timestamp of all the errors that translated to an active error.
                    timestamp: sendMessageError.timestamp > ((_a = error.timestamp) !== null && _a !== void 0 ? _a : 0) ? sendMessageError.timestamp : error.timestamp
                });
                specificSendMessageErrorSeen = true;
            }
            else {
                activeErrorMessages.push(error);
            }
        }
    }
    if (!specificSendMessageErrorSeen && sendMessageError !== undefined) {
        activeErrorMessages.push({
            type: 'sendMessageGeneric',
            timestamp: sendMessageError.timestamp
        });
    }
    // We only return the first few errors to avoid filling up the UI with too many `MessageBar`s.
    activeErrorMessages.splice(maxErrorCount);
    return {
        activeErrorMessages: activeErrorMessages
    };
});
const maxErrorCount = 3;
const accessErrorTargets = ['ChatThreadClient.getProperties', 'ChatThreadClient.listMessages', 'ChatThreadClient.listParticipants', 'ChatThreadClient.sendMessage', 'ChatThreadClient.sendTypingNotification'];
const latestUnableToReachChatServiceError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'unableToReachChatService', (error) => {
        return !!error && !!error.innerError && error.innerError['code'] === 'REQUEST_SEND_ERROR';
    });
};
const latestAccessDeniedError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'accessDenied', (error) => {
        return !!error && !!error.innerError && error.innerError['statusCode'] === 401;
    });
};
const latestNotInThisThreadError = (latestErrors) => {
    return latestActiveErrorSatisfying(latestErrors, 'userNotInChatThread', (error) => {
        if (!error || !error.innerError) {
            return false;
        }
        // Explicitly ignore 400 REST error when listParticipants() is called and a BotContact MRI is found in the participants.
        // This check should be removed when the chat SDK has handled this issue. Note: The this does not stop the error being logged to the console.
        // To the best of our ability we have confirmed this to have no impact on the participantList returned (all valid participants are still returned), nor
        // does it have an impact on the participant list updating on other participants joining/leaving or on individual participant actions like removeParticipant.
        if (isErrorDueToBotContact(error)) {
            return false;
        }
        // Chat service returns 403 if a user has been removed from a thread.
        // Chat service returns either 400 or 404 if the thread ID is malformed, depending on how the thread ID is malformed.
        return [400, 403, 404].some(statusCode => error.innerError['statusCode'] === statusCode);
    });
};
const botContactMRIPrefix = '28:';
const isErrorDueToBotContact = (error) => error.innerError['statusCode'] === 400 && error.innerError.message.includes(`Identifier format is not supported (${botContactMRIPrefix}`);
const latestActiveErrorSatisfying = (errors, activeErrorType, predicate) => {
    const activeErrorMessages = [];
    for (const target of accessErrorTargets) {
        const error = errors[target];
        if (predicate(error)) {
            activeErrorMessages.push({
                type: activeErrorType,
                timestamp: error.timestamp
            });
        }
    }
    if (activeErrorMessages.length === 0) {
        return undefined;
    }
    // We're actually sure that both timestamps will always exist, because we set them above.
    activeErrorMessages.sort((a, b) => { var _a, _b, _c, _d; return ((_b = (_a = a.timestamp) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = b.timestamp) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0); });
    return activeErrorMessages[activeErrorMessages.length - 1];
};

// Copyright (c) Microsoft Corporation.
/**
 * Get the selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const getSelector = (component) => {
    return findSelector(component);
};
const findSelector = (component) => {
    switch (component) {
        case SendBox:
            return sendBoxSelector;
        case MessageThread:
            return messageThreadSelector;
        case TypingIndicator:
            return typingIndicatorSelector;
        case ParticipantList:
            return chatParticipantListSelector;
        case ErrorBar:
            return errorBarSelector;
    }
    return undefined;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error thrown from failed {@link StatefulChatClient} methods.
 *
 * @public
 */
class ChatError extends Error {
    constructor(target, innerError, timestamp) {
        super();
        this.target = target;
        this.innerError = innerError;
        // Testing note: It is easier to mock Date::now() than the Date() constructor.
        this.timestamp = timestamp !== null && timestamp !== void 0 ? timestamp : new Date(Date.now());
        this.name = 'ChatError';
        this.message = `${this.target}: ${this.innerError.message}`;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const Constants = {
    TYPING_INDICATOR_MAINTAIN_TIME: 8 * 1000,
    DUMMY_DATE: new Date(0)
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const chatStatefulLogger = logger.createClientLogger('communication-react:chat-stateful');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$h = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
produce.enableMapSet();
// Needed to generate state diff for verbose logging.
produce.enablePatches();
/**
 * @private
 */
class ChatContext$1 {
    constructor(maxListeners) {
        this._state = {
            userId: {
                id: ''
            },
            displayName: '',
            threads: {},
            latestErrors: {}
        };
        this._batchMode = false;
        this.typingIndicatorInterval = undefined;
        this._logger = logger.createClientLogger('communication-react:chat-context');
        this._emitter = new EventEmitter__default['default']();
        if (maxListeners) {
            this._emitter.setMaxListeners(maxListeners);
        }
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce__default['default'](this._state, modifier, (patches) => {
            if (logger.getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (!this._batchMode && this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    setThread(threadId, threadState) {
        this.modifyState((draft) => {
            draft.threads[threadId] = threadState;
        });
    }
    createThread(threadId, properties) {
        this.modifyState((draft) => {
            draft.threads[threadId] = {
                chatMessages: {},
                threadId: threadId,
                properties: properties,
                participants: {},
                readReceipts: [],
                typingIndicators: [],
                latestReadTime: new Date(0)
            };
        });
    }
    updateChatConfig(userId, displayName) {
        this.modifyState((draft) => {
            draft.displayName = displayName;
            draft.userId = userId;
        });
    }
    createThreadIfNotExist(threadId, properties) {
        const exists = Object.prototype.hasOwnProperty.call(this.getState().threads, threadId);
        if (!exists) {
            this.createThread(threadId, properties);
            return true;
        }
        return false;
    }
    updateThread(threadId, properties) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                thread.properties = properties;
            }
        });
    }
    updateThreadTopic(threadId, topic) {
        this.modifyState((draft) => {
            if (topic === undefined) {
                return;
            }
            const thread = draft.threads[threadId];
            if (thread && !thread.properties) {
                thread.properties = {
                    topic: topic
                };
            }
            else if (thread && thread.properties) {
                thread.properties.topic = topic;
            }
        });
    }
    deleteThread(threadId) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                delete draft.threads[threadId];
            }
        });
    }
    setChatMessages(threadId, messages) {
        this.modifyState((draft) => {
            const threadState = draft.threads[threadId];
            if (threadState) {
                threadState.chatMessages = messages;
            }
            // remove typing indicator when receive messages
            const thread = draft.threads[threadId];
            if (thread) {
                for (const message of Object.values(messages)) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            }
        });
    }
    updateChatMessageContent(threadId, messagesId, content) {
        this.modifyState((draft) => {
            var _a;
            const chatMessage = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[messagesId];
            if (chatMessage) {
                if (!chatMessage.content) {
                    chatMessage.content = {};
                }
                chatMessage.content.message = content;
            }
        });
    }
    deleteLocalMessage(threadId, localId) {
        let localMessageDeleted = false;
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            const message = chatMessages ? chatMessages[localId] : undefined;
            if (chatMessages && message && message.clientMessageId) {
                delete chatMessages[message.clientMessageId];
                localMessageDeleted = true;
            }
        });
        return localMessageDeleted;
    }
    deleteMessage(threadId, id) {
        this.modifyState((draft) => {
            var _a;
            const chatMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
            if (chatMessages) {
                delete chatMessages[id];
            }
        });
    }
    setParticipant(threadId, participant) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participants[toFlatCommunicationIdentifier(participant.id)] = participant;
            }
        });
    }
    setParticipants(threadId, participants) {
        this.modifyState((draft) => {
            var _a;
            const participantsMap = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participantsMap) {
                for (const participant of participants) {
                    participantsMap[toFlatCommunicationIdentifier(participant.id)] = participant;
                }
            }
        });
    }
    deleteParticipants(threadId, participantIds) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                participantIds.forEach(id => {
                    delete participants[toFlatCommunicationIdentifier(id)];
                });
            }
        });
    }
    deleteParticipant(threadId, participantId) {
        this.modifyState((draft) => {
            var _a;
            const participants = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.participants;
            if (participants) {
                delete participants[toFlatCommunicationIdentifier(participantId)];
            }
        });
    }
    addReadReceipt(threadId, readReceipt) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            const readReceipts = thread === null || thread === void 0 ? void 0 : thread.readReceipts;
            if (thread && readReceipts) {
                // TODO(prprabhu): Replace `this.getState()` with `draft`?
                if (readReceipt.sender !== this.getState().userId && thread.latestReadTime < readReceipt.readOn) {
                    thread.latestReadTime = readReceipt.readOn;
                }
                readReceipts.push(readReceipt);
            }
        });
    }
    startTypingIndicatorCleanUp() {
        if (this.typingIndicatorInterval) {
            return;
        }
        this.typingIndicatorInterval = window.setInterval(() => {
            let isTypingActive = false;
            this.modifyState((draft) => {
                for (const thread of Object.values(draft.threads)) {
                    const filteredTypingIndicators = thread.typingIndicators.filter(typingIndicator => {
                        const timeGap = Date.now() - typingIndicator.receivedOn.getTime();
                        return timeGap < Constants.TYPING_INDICATOR_MAINTAIN_TIME;
                    });
                    if (thread.typingIndicators.length !== filteredTypingIndicators.length) {
                        thread.typingIndicators = filteredTypingIndicators;
                    }
                    if (thread.typingIndicators.length > 0) {
                        isTypingActive = true;
                    }
                }
            });
            if (!isTypingActive && this.typingIndicatorInterval) {
                window.clearInterval(this.typingIndicatorInterval);
                this.typingIndicatorInterval = undefined;
            }
        }, 1000);
    }
    addTypingIndicator(threadId, typingIndicator) {
        this.modifyState((draft) => {
            const thread = draft.threads[threadId];
            if (thread) {
                const typingIndicators = thread.typingIndicators;
                typingIndicators.push(typingIndicator);
            }
        });
        // Make sure we only maintain a period of typing indicator for perf purposes
        this.startTypingIndicatorCleanUp();
    }
    setChatMessage(threadId, message) {
        const { id: messageId, clientMessageId } = message;
        if (messageId || clientMessageId) {
            this.modifyState((draft) => {
                var _a;
                const threadMessages = (_a = draft.threads[threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages;
                const isLocalIdInMap = threadMessages && clientMessageId && threadMessages[clientMessageId];
                const messageKey = !messageId || isLocalIdInMap ? clientMessageId : messageId;
                if (threadMessages && messageKey) {
                    threadMessages[messageKey] = message;
                }
                // remove typing indicator when receive a message from a user
                const thread = draft.threads[threadId];
                if (thread) {
                    this.filterTypingIndicatorForUser(thread, message.sender);
                }
            });
        }
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param f Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(f, target) {
        return (...args) => __awaiter$h(this, void 0, void 0, function* () {
            try {
                return yield f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param f Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws ChatError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(f, target) {
        return (...args) => {
            try {
                chatStatefulLogger.info(`Chat stateful client target function called: ${target}`);
                return f(...args);
            }
            catch (error) {
                const chatError = toChatError(target, error);
                this.setLatestError(target, chatError);
                throw chatError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
    // This is a mutating function, only use it inside of a produce() function
    filterTypingIndicatorForUser(thread, userId) {
        if (!userId) {
            return;
        }
        const typingIndicators = thread.typingIndicators;
        const userIdAsKey = toFlatCommunicationIdentifier(userId);
        const filteredTypingIndicators = typingIndicators.filter(typingIndicator => toFlatCommunicationIdentifier(typingIndicator.sender) !== userIdAsKey);
        if (filteredTypingIndicators.length !== typingIndicators.length) {
            thread.typingIndicators = filteredTypingIndicators;
        }
    }
    /**
     * Batch updates to minimize `stateChanged` events across related operations.
     *
     * - A maximum of one `stateChanged` event is emitted, at the end of the operations.
     * - No `stateChanged` event is emitted if the state did not change through the operations.
     * - In case of an exception, state is reset to the prior value and no `stateChanged` event is emitted.
     *
     * All operations finished in this batch should be synchronous.
     * This function is not reentrant -- do not call batch() from within another batch().
     */
    batch(operations) {
        if (this._batchMode) {
            throw new Error('batch() called from within another batch()');
        }
        this._batchMode = true;
        const priorState = this._state;
        try {
            operations();
            if (this._state !== priorState) {
                this._emitter.emit('stateChanged', this._state);
            }
        }
        catch (e) {
            this._state = priorState;
            if (logger.getLogLevel() === 'verbose') {
                this._logger.warning(`State rollback to: ${_safeJSONStringify(priorState)}`);
            }
            throw e;
        }
        finally {
            this._batchMode = false;
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
}
const toChatError = (target, error) => {
    if (error instanceof Error) {
        return new ChatError(target, error);
    }
    return new ChatError(target, new Error(`${error}`));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const convertChatMessage = (message, status = 'delivered', clientMessageId) => {
    return Object.assign(Object.assign({}, message), { clientMessageId: clientMessageId, status });
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$g = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues$1 = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
// TODO: When we can get messageId of event from SDK, remove this
// Maximum time to look back message list when we receive a system event
const maxSyncTimeInMs = 10 * 1000;
/**
 * @private
 */
class EventSubscriber {
    constructor(chatClient, chatContext) {
        this.convertEventToChatMessage = (event) => {
            return convertChatMessage({
                id: event.id,
                version: event.version,
                content: {
                    message: event.message
                },
                type: this.convertEventType(event.type),
                sender: event.sender,
                senderDisplayName: event.senderDisplayName,
                sequenceId: '',
                // Note: there is a bug in chatMessageReceived event that it is missing sequenceId
                createdOn: new Date(event.createdOn),
                editedOn: 'editedOn' in event ? event.editedOn : undefined,
                metadata: event.metadata
            });
        };
        // convert event type to chatMessage type, only possible type is 'html' and 'text' in chat event
        this.convertEventType = (type) => {
            const lowerCaseType = type.toLowerCase();
            if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
                return 'html';
            }
            else {
                return 'text';
            }
        };
        this.onChatMessageReceived = (event) => {
            var _a;
            // Today we are avoiding how to render these messages. In the future we can
            // remove this condition and handle this message appropriately.
            const messageEventType = event.type.toLowerCase();
            if (messageEventType !== 'text' && messageEventType !== 'richtext/html' && messageEventType !== 'html') {
                return;
            }
            const newMessage = this.convertEventToChatMessage(event);
            // Because of bug in chatMessageReceived event, if we already have that particular message in context, we want to
            // make sure to not overwrite the sequenceId when calling setChatMessage.
            const existingMessage = (_a = this.chatContext.getState().threads[event.threadId]) === null || _a === void 0 ? void 0 : _a.chatMessages[event.id];
            if (existingMessage) {
                newMessage.sequenceId = existingMessage.sequenceId;
            }
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setChatMessage(event.threadId, newMessage);
            });
        };
        this.onChatMessageDeleted = (event) => {
            this.chatContext.deleteMessage(event.threadId, event.id);
        };
        this.onChatMessageEdited = (event) => {
            const editedMessage = this.convertEventToChatMessage(event);
            this.chatContext.setChatMessage(event.threadId, convertChatMessage(editedMessage));
        };
        this.onParticipantsAdded = (event) => {
            const participantsToAdd = event.participantsAdded.map(participant => (Object.assign(Object.assign({}, participant), { shareHistoryTime: participant.shareHistoryTime ? new Date(participant.shareHistoryTime) : undefined })));
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.setParticipants(event.threadId, participantsToAdd);
            });
            this.fetchLastParticipantMessage(event.threadId, 'participantAdded');
        };
        // This is a temporary fix that no participant message is received for onChatMessageReceived event, which should be handled by JS SDK.
        // Without the temporary fix, there are missing 'participant joined' and 'participant left' system messages in the chat thread.
        this.fetchLastParticipantMessage = (threadId, actionType) => __awaiter$g(this, void 0, void 0, function* () {
            var e_1, _a;
            try {
                for (var _b = __asyncValues$1(this.chatClient.getChatThreadClient(threadId).listMessages({
                    startTime: new Date(Date.now() - maxSyncTimeInMs)
                })), _c; _c = yield _b.next(), !_c.done;) {
                    const message = _c.value;
                    if (message.type === actionType) {
                        this.chatContext.setChatMessage(threadId, Object.assign(Object.assign({}, message), { status: 'delivered' }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        this.onParticipantsRemoved = (event) => {
            const participantIds = event.participantsRemoved.map(participant => {
                return participant.id;
            });
            this.chatContext.deleteParticipants(event.threadId, participantIds);
            // If the current user is removed from the thread, do not fetch the last participant message
            // as they no longer have access to the thread.
            const currentUserId = toFlatCommunicationIdentifier(this.chatContext.getState().userId);
            const wasCurrentUserRemoved = participantIds.find(id => toFlatCommunicationIdentifier(id) === currentUserId);
            if (!wasCurrentUserRemoved) {
                this.fetchLastParticipantMessage(event.threadId, 'participantRemoved');
            }
        };
        this.onReadReceiptReceived = (event) => {
            const readReceipt = Object.assign(Object.assign({}, event), { sender: event.sender, readOn: new Date(event.readOn) });
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(event.threadId);
                this.chatContext.addReadReceipt(event.threadId, readReceipt);
            });
        };
        this.onTypingIndicatorReceived = (typingIndicator) => {
            this.chatContext.batch(() => {
                this.chatContext.createThreadIfNotExist(typingIndicator.threadId);
                this.chatContext.addTypingIndicator(typingIndicator.threadId, typingIndicator);
            });
        };
        this.onChatThreadCreated = (event) => {
            const properties = {
                topic: event.properties.topic
            };
            if (!this.chatContext.createThreadIfNotExist(event.threadId, properties)) {
                this.chatContext.updateThread(event.threadId, properties);
            }
        };
        this.onChatThreadDeleted = (event) => {
            this.chatContext.deleteThread(event.threadId);
        };
        this.onChatThreadPropertiesUpdated = (event) => {
            this.chatContext.updateThread(event.threadId, {
                topic: event.properties.topic
            });
        };
        this.subscribe = () => {
            this.chatClient.on('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.on('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.on('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.on('participantsAdded', this.onParticipantsAdded);
            this.chatClient.on('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.on('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.on('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.on('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.on('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.on('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.unsubscribe = () => {
            this.chatClient.off('chatMessageReceived', this.onChatMessageReceived);
            this.chatClient.off('chatMessageDeleted', this.onChatMessageDeleted);
            this.chatClient.off('chatMessageEdited', this.onChatMessageEdited);
            this.chatClient.off('participantsAdded', this.onParticipantsAdded);
            this.chatClient.off('participantsRemoved', this.onParticipantsRemoved);
            this.chatClient.off('readReceiptReceived', this.onReadReceiptReceived);
            this.chatClient.off('typingIndicatorReceived', this.onTypingIndicatorReceived);
            this.chatClient.off('chatThreadCreated', this.onChatThreadCreated);
            this.chatClient.off('chatThreadDeleted', this.onChatThreadDeleted);
            this.chatClient.off('chatThreadPropertiesUpdated', this.onChatThreadPropertiesUpdated);
        };
        this.chatClient = chatClient;
        this.chatContext = chatContext;
        this.subscribe();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$f = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Create a decorated iterator
 * returned iterators.
 *
 * @param iteratorCreator the function to create the original iterator
 * @param context chatContext
 * @param decorateFn the function for the decorating behavior
 */
const createDecoratedIterator = (iteratorCreator, context, decorateFn) => {
    return (...args) => {
        const threadsIterator = iteratorCreator(...args);
        return {
            next() {
                return __awaiter$f(this, void 0, void 0, function* () {
                    const result = yield threadsIterator.next();
                    if (!result.done && result.value) {
                        decorateFn(result.value, context);
                    }
                    return result;
                });
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = threadsIterator.byPage(settings);
                return {
                    next() {
                        return __awaiter$f(this, void 0, void 0, function* () {
                            const result = yield pages.next();
                            const page = result.value;
                            if (!result.done && result.value) {
                                context.batch(() => {
                                    for (const item of page) {
                                        decorateFn(item, context);
                                    }
                                });
                            }
                            return result;
                        });
                    },
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};
/**
 *
 * @param iteratorCreator Function that creates the base iteartor
 * @param context The ChatContext that stores all internal state.
 * @param target See {@link ChatContext.asyncTeeErrorToState}.
 * @returns A function to create an iterator that handles errors when iterting over the iterator from `iteratorCreator`.
 */
const createErrorHandlingIterator = (iteratorCreator, context, target) => {
    return (...args) => {
        const innerIter = iteratorCreator(...args);
        return {
            next: context.withAsyncErrorTeedToState(innerIter.next.bind(innerIter), target),
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                const pages = innerIter.byPage(settings);
                return {
                    next: context.withAsyncErrorTeedToState(pages.next.bind(pages), target),
                    [Symbol.asyncIterator]() {
                        return this;
                    }
                };
            }
        };
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListMessages = (chatThreadClient, context) => {
    const setMessage = (message, context) => {
        context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listMessages.bind(chatThreadClient), 'ChatThreadClient.listMessages'), context, 'ChatThreadClient.listMessages'), context, setMessage);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListReadReceipts = (chatThreadClient, context) => {
    const setReadReceipt = (readReceipt, context) => {
        context.addReadReceipt(chatThreadClient.threadId, Object.assign({}, readReceipt));
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listReadReceipts.bind(chatThreadClient), 'ChatThreadClient.listReadReceipts'), context, 'ChatThreadClient.listReadReceipts'), context, setReadReceipt);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListParticipants = (chatThreadClient, context) => {
    const setParticipant = (participant, context) => {
        context.setParticipant(chatThreadClient.threadId, participant);
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatThreadClient.listParticipants.bind(chatThreadClient), 'ChatThreadClient.listParticipants'), context, 'ChatThreadClient.listParticipants'), context, setParticipant);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$e = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ProxyChatThreadClient {
    constructor(context) {
        this._context = context;
    }
    get(chatThreadClient, prop) {
        switch (prop) {
            case 'listMessages':
                {
                    return createDecoratedListMessages(chatThreadClient, this._context);
                }
            case 'getMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const message = yield chatThreadClient.getMessage(...args);
                        this._context.setChatMessage(chatThreadClient.threadId, convertChatMessage(message));
                        return message;
                    }), 'ChatThreadClient.getMessage');
                }
            case 'sendMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        // Retry logic?
                        const [request, options] = args;
                        const { content } = request;
                        const clientMessageId = nanoid.nanoid(); // Generate a local short uuid for message
                        const newMessage = {
                            content: {
                                message: content
                            },
                            clientMessageId,
                            id: '',
                            type: 'text',
                            sequenceId: '',
                            version: '',
                            createdOn: new Date(),
                            status: 'sending',
                            senderDisplayName: this._context.getState().displayName,
                            sender: this._context.getState().userId,
                            metadata: options === null || options === void 0 ? void 0 : options.metadata
                        };
                        this._context.setChatMessage(chatThreadClient.threadId, newMessage);
                        let result = undefined;
                        try {
                            result = yield chatThreadClient.sendMessage(...args);
                        }
                        catch (e) {
                            this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { status: 'failed' }));
                            throw e;
                        }
                        if (result === null || result === void 0 ? void 0 : result.id) {
                            this._context.batch(() => {
                                if (!result) {
                                    return;
                                }
                                this._context.setChatMessage(chatThreadClient.threadId, Object.assign(Object.assign({}, newMessage), { clientMessageId: undefined, status: 'delivered', id: result.id }));
                                this._context.deleteLocalMessage(chatThreadClient.threadId, clientMessageId);
                            });
                        }
                        return result;
                    }), 'ChatThreadClient.sendMessage');
                }
            case 'addParticipants':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.addParticipants(...args);
                        const [addRequest] = args;
                        const participantsToAdd = addRequest.participants;
                        this._context.setParticipants(chatThreadClient.threadId, participantsToAdd);
                        return result;
                    }), 'ChatThreadClient.addParticipants');
                }
            case 'deleteMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        // DeleteMessage is able to either delete local one(for failed message) or synced message
                        const [messageId] = args;
                        if (this._context.deleteLocalMessage(chatThreadClient.threadId, messageId)) {
                            return {};
                        }
                        const result = yield chatThreadClient.deleteMessage(...args);
                        this._context.deleteMessage(chatThreadClient.threadId, messageId);
                        return result;
                    }), 'ChatThreadClient.deleteMessage');
                }
            case 'listParticipants':
                {
                    return createDecoratedListParticipants(chatThreadClient, this._context);
                }
            case 'listReadReceipts':
                {
                    return createDecoratedListReadReceipts(chatThreadClient, this._context);
                }
            case 'sendTypingNotification':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        return yield chatThreadClient.sendTypingNotification(...args);
                    }), 'ChatThreadClient.sendTypingNotification');
                }
            case 'removeParticipant':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.removeParticipant(...args);
                        const [removeIdentifier] = args;
                        this._context.deleteParticipant(chatThreadClient.threadId, communicationCommon.getIdentifierKind(removeIdentifier));
                        return result;
                    }), 'ChatThreadClient.removeParticipant');
                }
            case 'updateMessage':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateMessage(...args);
                        const [messageId, updateOption] = args;
                        this._context.updateChatMessageContent(chatThreadClient.threadId, messageId, updateOption === null || updateOption === void 0 ? void 0 : updateOption.content);
                        return result;
                    }), 'ChatThreadClient.updateMessage');
                }
            case 'updateTopic':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.updateTopic(...args);
                        const [topic] = args;
                        this._context.updateThreadTopic(chatThreadClient.threadId, topic);
                        return result;
                    }), 'ChatThreadClient.updateTopic');
                }
            case 'getProperties':
                {
                    return this._context.withAsyncErrorTeedToState((...args) => __awaiter$e(this, void 0, void 0, function* () {
                        const result = yield chatThreadClient.getProperties(...args);
                        this._context.updateThread(chatThreadClient.threadId, result);
                        return result;
                    }), 'ChatThreadClient.getProperties');
                }
            default:
                return Reflect.get(chatThreadClient, prop);
        }
    }
}
/**
 * @private
 */
const chatThreadClientDeclaratify = (chatThreadClient, context) => {
    context.createThreadIfNotExist(chatThreadClient.threadId);
    return new Proxy(chatThreadClient, new ProxyChatThreadClient(context));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const createDecoratedListThreads = (chatClient, context) => {
    const setThreadProperties = (chatThreadItem, context) => {
        const properties = {
            topic: chatThreadItem.topic
        };
        if (!context.createThreadIfNotExist(chatThreadItem.id, properties)) {
            context.updateThread(chatThreadItem.id, properties);
        }
    };
    return createDecoratedIterator(createErrorHandlingIterator(context.withErrorTeedToState(chatClient.listChatThreads.bind(chatClient), 'ChatClient.listChatThreads'), context, 'ChatClient.listChatThreads'), context, setThreadProperties);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$d = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const proxyChatClient = {
    get: function (chatClient, prop, receiver) {
        // skip receiver.context call to avoid recursive bugs
        if (prop === 'context') {
            return Reflect.get(chatClient, prop);
        }
        const context = receiver.context;
        switch (prop) {
            case 'createChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$d(this, void 0, void 0, function* () {
                            const result = yield chatClient.createChatThread(...args);
                            const thread = result.chatThread;
                            if (thread) {
                                const [request] = args;
                                context.createThread(thread.id, {
                                    topic: request.topic
                                });
                            }
                            return result;
                        });
                    }, 'ChatClient.createChatThread');
                }
            case 'deleteChatThread':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$d(this, void 0, void 0, function* () {
                            const result = yield chatClient.deleteChatThread(...args);
                            context.deleteThread(args[0]);
                            return result;
                        });
                    }, 'ChatClient.deleteChatThread');
                }
            case 'listChatThreads':
                {
                    return createDecoratedListThreads(chatClient, context);
                }
            case 'getChatThreadClient':
                {
                    return function (...args) {
                        const chatThreadClient = chatClient.getChatThreadClient(...args);
                        // TODO(prprabhu): Ensure that thread properties are fetched into the ChatContext at this point.
                        // A new thread might be created here, but the properties will never be fetched.
                        return chatThreadClientDeclaratify(chatThreadClient, context);
                    };
                }
            case 'startRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$d(this, void 0, void 0, function* () {
                            const ret = yield chatClient.startRealtimeNotifications(...args);
                            if (!receiver.eventSubscriber) {
                                receiver.eventSubscriber = new EventSubscriber(chatClient, context);
                            }
                            return ret;
                        });
                    }, 'ChatClient.startRealtimeNotifications');
                }
            case 'stopRealtimeNotifications':
                {
                    return context.withAsyncErrorTeedToState(function (...args) {
                        return __awaiter$d(this, void 0, void 0, function* () {
                            const ret = yield chatClient.stopRealtimeNotifications(...args);
                            if (receiver.eventSubscriber) {
                                receiver.eventSubscriber.unsubscribe();
                                receiver.eventSubscriber = undefined;
                            }
                            return ret;
                        });
                    }, 'ChatClient.stopRealtimeNotifications');
                }
            default:
                return Reflect.get(chatClient, prop);
        }
    }
};
/**
 * Creates a stateful ChatClient {@link StatefulChatClient} by proxying ChatClient
 * {@link @azure/communication-chat#ChatClient} with ProxyChatClient {@link ProxyChatClient} which then allows access
 * to state in a declarative way.
 *
 * @public
 */
const createStatefulChatClient = (args, options) => {
    chatStatefulLogger.info(`Creating chat stateful client using library version: ${_getApplicationId()}`);
    const tweakedOptions = Object.assign(Object.assign({}, options), { chatClientOptions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.chatClientOptions), { userAgentOptions: {
                userAgentPrefix: _getApplicationId()
            } }) });
    return _createStatefulChatClientWithDeps(new communicationChat.ChatClient(args.endpoint, args.credential, tweakedOptions.chatClientOptions), args, tweakedOptions);
};
/**
 * Internal implementation of {@link createStatefulChatClient} for dependency injection.
 *
 * Used by tests. Should not be exported out of this package.
 * @internal
 */
const _createStatefulChatClientWithDeps = (chatClient, args, options) => {
    const context = new ChatContext$1(options === null || options === void 0 ? void 0 : options.maxStateChangeListeners);
    let eventSubscriber;
    context.updateChatConfig(communicationCommon.getIdentifierKind(args.userId), args.displayName);
    const proxy = new Proxy(chatClient, proxyChatClient);
    Object.defineProperty(proxy, 'context', {
        configurable: false,
        get: () => context
    });
    Object.defineProperty(proxy, 'eventSubscriber', {
        configurable: false,
        get: () => eventSubscriber,
        set: (val) => {
            eventSubscriber = val;
        }
    });
    Object.defineProperty(proxy, 'getState', {
        configurable: false,
        value: () => context === null || context === void 0 ? void 0 : context.getState()
    });
    Object.defineProperty(proxy, 'onStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.onStateChange(handler)
    });
    Object.defineProperty(proxy, 'offStateChange', {
        configurable: false,
        value: (handler) => context === null || context === void 0 ? void 0 : context.offStateChange(handler)
    });
    return proxy;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$c = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (window && window.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
/**
 * Context of Chat, which is a centralized context for all state updates
 * @private
 */
class ChatContext {
    constructor(clientState, threadId) {
        this.emitter = new EventEmitter__default['default']();
        const thread = clientState.threads[threadId];
        this.threadId = threadId;
        if (!thread) {
            throw 'Cannot find threadId, please initialize thread before use!';
        }
        this.state = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setError(error) {
        this.setState(Object.assign(Object.assign({}, this.state), { error }));
    }
    updateClientState(clientState) {
        const thread = clientState.threads[this.threadId];
        if (!thread) {
            throw 'Cannot find threadId, please make sure thread state is still in Stateful ChatClient.';
        }
        let updatedState = {
            userId: clientState.userId,
            displayName: clientState.displayName,
            thread,
            latestErrors: clientState.latestErrors
        };
        this.setState(updatedState);
    }
}
/**
 * @private
 */
class AzureCommunicationChatAdapter {
    constructor(chatClient, chatThreadClient) {
        this.emitter = new EventEmitter__default['default']();
        this.bindAllPublicMethods();
        this.chatClient = chatClient;
        this.chatThreadClient = chatThreadClient;
        this.context = new ChatContext(chatClient.getState(), chatThreadClient.threadId);
        const onStateChange = (clientState) => {
            // unsubscribe when the instance gets disposed
            if (!this) {
                chatClient.offStateChange(onStateChange);
                return;
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createDefaultChatHandlers(chatClient, chatThreadClient);
        this.chatClient.onStateChange(onStateChange);
        this.subscribeAllEvents();
    }
    bindAllPublicMethods() {
        this.onStateChange = this.onStateChange.bind(this);
        this.offStateChange = this.offStateChange.bind(this);
        this.getState = this.getState.bind(this);
        this.dispose = this.dispose.bind(this);
        this.fetchInitialData = this.fetchInitialData.bind(this);
        this.sendMessage = this.sendMessage.bind(this);
        this.sendReadReceipt = this.sendReadReceipt.bind(this);
        this.sendTypingIndicator = this.sendTypingIndicator.bind(this);
        this.updateMessage = this.updateMessage.bind(this);
        this.deleteMessage = this.deleteMessage.bind(this);
        this.removeParticipant = this.removeParticipant.bind(this);
        this.setTopic = this.setTopic.bind(this);
        this.loadPreviousChatMessages = this.loadPreviousChatMessages.bind(this);
        this.on = this.on.bind(this);
        this.off = this.off.bind(this);
    }
    dispose() {
        this.unsubscribeAllEvents();
    }
    fetchInitialData() {
        return __awaiter$c(this, void 0, void 0, function* () {
            // If get properties fails we dont want to try to get the participants after.
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                var e_1, _a;
                yield this.chatThreadClient.getProperties();
                try {
                    // Fetch all participants who joined before the local user.
                    for (var _b = __asyncValues(this.chatThreadClient.listParticipants().byPage({
                        // Fetch 100 participants per page by default.
                        maxPageSize: 100
                        // eslint-disable-next-line curly
                    })), _c; _c = yield _b.next(), !_c.done;) {
                        const _page = _c.value;
                        ;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }));
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    sendMessage(content, options = {}) {
        return __awaiter$c(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                yield this.handlers.onSendMessage(content, options);
            }));
        });
    }
    sendReadReceipt(chatMessageId) {
        return __awaiter$c(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                yield this.handlers.onMessageSeen(chatMessageId);
            }));
        });
    }
    sendTypingIndicator() {
        return __awaiter$c(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                yield this.handlers.onTyping();
            }));
        });
    }
    removeParticipant(userId) {
        return __awaiter$c(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                yield this.handlers.onRemoveParticipant(userId);
            }));
        });
    }
    setTopic(topicName) {
        return __awaiter$c(this, void 0, void 0, function* () {
            yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                yield this.handlers.updateThreadTopicName(topicName);
            }));
        });
    }
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter$c(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                return yield this.handlers.onLoadPreviousChatMessages(messagesToLoad);
            }));
        });
    }
    updateMessage(messageId, content, metadata, options) {
        return __awaiter$c(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                return yield this.handlers.onUpdateMessage(messageId, content);
            }));
        });
    }
    deleteMessage(messageId) {
        return __awaiter$c(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$c(this, void 0, void 0, function* () {
                return yield this.handlers.onDeleteMessage(messageId);
            }));
        });
    }
    messageReceivedListener(event) {
        const isCurrentChatAdapterThread = event.threadId === this.chatThreadClient.threadId;
        if (!isCurrentChatAdapterThread) {
            return;
        }
        const message = convertEventToChatMessage(event);
        this.emitter.emit('messageReceived', {
            message
        });
        const currentUserId = toFlatCommunicationIdentifier(this.chatClient.getState().userId);
        if ((message === null || message === void 0 ? void 0 : message.sender) && toFlatCommunicationIdentifier(message.sender) === currentUserId) {
            this.emitter.emit('messageSent', {
                message
            });
        }
    }
    messageReadListener({ chatMessageId, recipient }) {
        const message = this.getState().thread.chatMessages[chatMessageId];
        if (message) {
            this.emitter.emit('messageRead', {
                message,
                readBy: recipient
            });
        }
    }
    participantsAddedListener({ addedBy, participantsAdded }) {
        this.emitter.emit('participantsAdded', {
            addedBy,
            participantsAdded
        });
    }
    participantsRemovedListener({ removedBy, participantsRemoved }) {
        this.emitter.emit('participantsRemoved', {
            removedBy,
            participantsRemoved
        });
    }
    chatThreadPropertiesUpdatedListener(event) {
        this.emitter.emit('topicChanged', {
            topic: event.properties.topic
        });
    }
    subscribeAllEvents() {
        this.chatClient.on('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.on('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.on('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.on('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.on('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    unsubscribeAllEvents() {
        this.chatClient.off('chatThreadPropertiesUpdated', this.chatThreadPropertiesUpdatedListener.bind(this));
        this.chatClient.off('participantsAdded', this.participantsAddedListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
        this.chatClient.off('chatMessageReceived', this.messageReceivedListener.bind(this));
        this.chatClient.off('readReceiptReceived', this.messageReadListener.bind(this));
        this.chatClient.off('participantsRemoved', this.participantsRemovedListener.bind(this));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$c(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isChatError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
}
const convertEventToChatMessage = (event) => {
    return {
        id: event.id,
        version: event.version,
        content: {
            message: event.message
        },
        type: convertEventType(event.type),
        sender: event.sender,
        senderDisplayName: event.senderDisplayName,
        sequenceId: '',
        createdOn: new Date(event.createdOn)
    };
};
// only text/html message type will be received from event
const convertEventType = (type) => {
    const lowerCaseType = type.toLowerCase();
    if (lowerCaseType === 'richtext/html' || lowerCaseType === 'html') {
        return 'html';
    }
    else {
        return 'text';
    }
};
/**
 * Create a {@link ChatAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link ChatAdapter} provided by this library.
 *
 * @public
 */
const createAzureCommunicationChatAdapter = ({ endpoint: endpointUrl, userId, displayName, credential, threadId }) => __awaiter$c(void 0, void 0, void 0, function* () {
    if (!_isValidIdentifier(userId)) {
        throw new Error('Provided userId is invalid. Please provide valid identifier object.');
    }
    const chatClient = createStatefulChatClient({
        userId,
        displayName,
        endpoint: endpointUrl,
        credential: credential
    });
    const chatThreadClient = yield chatClient.getChatThreadClient(threadId);
    yield chatClient.startRealtimeNotifications();
    const adapter = yield createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    return adapter;
});
/**
 * A custom React hook to simplify the creation of {@link ChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, threadId, userId } = args;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !threadId || !userId) {
            return;
        }
        (() => __awaiter$c(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationChatAdapter({
                credential,
                displayName,
                endpoint,
                threadId,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, threadId, userId]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$c(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link ChatAdapter} using the provided {@link StatefulChatClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient}.
 * Consider using {@link createAzureCommunicationChatAdapter} for a simpler API.
 *
 * @public
 */
function createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient) {
    return __awaiter$c(this, void 0, void 0, function* () {
        return new AzureCommunicationChatAdapter(chatClient, chatThreadClient);
    });
}
const isChatError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

var call$j={cameraLabel:"Camera",noCamerasLabel:"No cameras found",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",videoEffectsPaneTitle:"Effects",videoEffectsPaneBackgroundSelectionTitle:"Background",configurationPageVideoEffectsButtonLabel:"Effects",unableToStartVideoEffect:"Unable to apply video effect.",blurBackgroundEffectButtonLabel:"Blur",blurBackgroundTooltip:"Blur Background",removeBackgroundEffectButtonLabel:"None",removeBackgroundTooltip:"Remove Background",cameraOffBackgroundEffectWarningText:"Your camera is off. Turn on camera to see video effect.",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leavingCallTitle:"Leaving...",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",deniedPermissionToRoomDetails:"You do not have permission to join this room.",deniedPermissionToRoomTitle:"Permission denied to room",peopleButtonLabel:"People",peoplePaneTitle:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"Room ID provided is not valid.",roomNotFoundTitle:"Room not found",soundLabel:"Sound",noMicrophonesLabel:"No microphones found",noSpeakersLabel:"No speakers found",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling...",participantJoinedNoticeString:"{displayName} joined",twoParticipantJoinedNoticeString:"{displayName1} and {displayName2} have joined",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} and {displayName3} have joined",participantLeftNoticeString:"{displayName} left",twoParticipantLeftNoticeString:"{displayName1} and {displayName2} have left",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} and {displayName3} have left",unnamedParticipantString:"unnamed participant",manyUnnamedParticipantsJoined:"unnamed participant and {numOfParticipants} other participants joined",manyUnnamedParticipantsLeft:"unnamed participant and {numOfParticipants} other participants left",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants joined",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants left",liveCaptionsLabel:"Live captions",captionsSettingsLabel:"Caption settings",startCaptionsButtonOnLabel:"Turn on captions",startCaptionsButtonOffLabel:"Turn off captions",startCaptionsButtonTooltipOnContent:"Turn off captions",startCaptionsButtonTooltipOffContent:"Turn on captions",captionsSettingsModalTitle:"What language is being spoken?",captionsSettingsDropdownLabel:"Spoken language",captionsSettingsDropdownInfoText:"Language that everyone on this call is speaking.",captionsSettingsConfirmButtonLabel:"Confirm",captionsSettingsCancelButtonLabel:"Cancel",captionsSettingsModalAriaLabel:"Captions Setting Modal",captionsSettingsCloseModalButtonAriaLabel:"Close Captions Setting",captionsBannerMoreButtonCallingLabel:"More",captionsBannerMoreButtonTooltip:"More options",captionsAvailableLanguageStrings:{"ar-ae":"Arabic - U.A.E.","ar-sa":"Arabic - Saudi Arabia","da-dk":"Danish","de-de":"German - Germany","en-au":"English - Australia","en-ca":"English - Canada","en-gb":"English - United Kingdom","en-in":"English - India","en-nz":"English - New Zealand","en-us":"English - United States","es-es":"Spanish - Spain (Modern Sort)","es-mx":"Spanish - Mexico","fi-fi":"Finnish","fr-ca":"French - Canada","fr-fr":"French - France","hi-in":"Hindi","it-it":"Italian - Italy","ja-jp":"Japanese","ko-kr":"Korean","nb-no":"Norwegian (Bokmål)","nl-be":"Dutch - Belgium","nl-nl":"Dutch - Netherlands","pl-pl":"Polish","pt-br":"Portuguese - Brazil","ru-ru":"Russian","sv-se":"Swedish","zh-cn":"Chinese - People's Republic of China","zh-hk":"Chinese - Hong Kong SAR","cs-cz":"Czech","pt-pt":"Portuguese - Portugal","tr-tr":"Turkish","vi-vn":"Vietnamese","th-th":"Thai","he-il":"Hebrew","cy-gb":"Welsh","uk-ua":"Ukrainian","el-gr":"Greek","hu-hu":"Hungarian","ro-ro":"Romanian","sk-sk":"Slovak","zh-tw":"Chinese - Taiwan"},captionsBannerSpinnerText:"Starting captions...",transferPageTransferorText:"Transferring...",transferPageTransferTargetText:"Connecting...",transferPageUnknownTransferorDisplayName:"Unknown",transferPageUnknownTransferTargetDisplayName:"Unknown"};var chat$j={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$j={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",moreDrawerCaptionsMenuTitle:"Live captions",moreDrawerSpokenLanguageMenuTitle:"Spoken language",peopleButtonLabel:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_US = {call:call$j,chat:chat$j,callWithChat:callWithChat$j};

var call$i={cameraLabel:"Camera",noCamerasLabel:"No cameras found",cameraPermissionDenied:"Your browser is blocking access to your camera",cameraTurnedOff:"Your camera is turned off",chatButtonLabel:"Chat",close:"Close",complianceBannerNowOnlyRecording:"You are now only recording this meeting.",complianceBannerNowOnlyTranscription:"You are now only transcribing this meeting.",complianceBannerRecordingAndTranscriptionSaved:"Recording and transcription are being saved.",complianceBannerRecordingAndTranscriptionStarted:"Recording and transcription have started.",complianceBannerRecordingAndTranscriptionStopped:"Recording and transcription have stopped.",complianceBannerRecordingSaving:"Recording is being saved.",complianceBannerRecordingStarted:"Recording has started.",complianceBannerRecordingStopped:"Recording has stopped.",complianceBannerTranscriptionStarted:"Transcription has started.",complianceBannerTranscriptionConsent:"By joining, you are giving consent for this meeting to be transcribed.",complianceBannerTranscriptionSaving:"Transcription is being saved.",complianceBannerTranscriptionStopped:"Transcription has stopped.",configurationPageTitle:"Start a call",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",defaultPlaceHolder:"Select an option",dismissSidePaneButtonLabel:"Close",videoEffectsPaneTitle:"Effects",videoEffectsPaneBackgroundSelectionTitle:"Background",configurationPageVideoEffectsButtonLabel:"Effects",unableToStartVideoEffect:"Unable to apply video effect.",blurBackgroundEffectButtonLabel:"Blur",blurBackgroundTooltip:"Blur Background",removeBackgroundEffectButtonLabel:"None",removeBackgroundTooltip:"Remove Background",cameraOffBackgroundEffectWarningText:"Your camera is off. Turn on camera to see video effect.",failedToJoinCallDueToNoNetworkMoreDetails:"Call was disconnected due to a network issue. Check your connection and join again.",failedToJoinCallDueToNoNetworkTitle:"Call disconnected",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"You were not granted entry in the call. If this was a mistake, re-join the call.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Dismissed from lobby",learnMore:"Learn more",leavingCallTitle:"Leaving...",leftCallMoreDetails:"If this was a mistake, re-join the call.",leftCallTitle:"You left the call",lobbyScreenConnectingToCallTitle:"Joining call",lobbyScreenWaitingToBeAdmittedTitle:"Waiting to be admitted",microphonePermissionDenied:"Your browser is blocking access to your microphone",microphoneToggleInLobbyNotAllowed:"Cannot mute or unmute while in lobby.",mutedMessage:"You're muted",networkReconnectMoreDetails:"Looks like something went wrong. We're trying to get back into the call.",networkReconnectTitle:"Hold on",deniedPermissionToRoomDetails:"You do not have permission to join this room.",deniedPermissionToRoomTitle:"Permission denied to room",peopleButtonLabel:"People",peoplePaneTitle:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",privacyPolicy:"Privacy policy",rejoinCallButtonLabel:"Re-join call",removedFromCallMoreDetails:"Another participant removed you from the call.",removedFromCallTitle:"You were removed",removeMenuLabel:"Remove",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",roomNotFoundDetails:"Room ID provided is not valid.",roomNotFoundTitle:"Room not found",soundLabel:"Sound",noMicrophonesLabel:"No microphones found",noSpeakersLabel:"No speakers found",startCallButtonLabel:"Start call",openDialpadButtonLabel:"Dial phone number",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",moreButtonCallingLabel:"More",resumeCallButtonLabel:"Resume",resumingCallButtonLabel:"Resuming...",resumeCallButtonAriaLabel:"Resume call",resumingCallButtonAriaLabel:"Resume call",holdScreenLabel:"You're on hold",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number",outboundCallingNoticeString:"Calling...",participantJoinedNoticeString:"{displayName} joined",twoParticipantJoinedNoticeString:"{displayName1} and {displayName2} have joined",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} and {displayName3} have joined",participantLeftNoticeString:"{displayName} left",twoParticipantLeftNoticeString:"{displayName1} and {displayName2} have left",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} and {displayName3} have left",unnamedParticipantString:"unnamed participant",manyUnnamedParticipantsJoined:"unnamed participant and {numOfParticipants} other participants joined",manyUnnamedParticipantsLeft:"unnamed participant and {numOfParticipants} other participants left",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants joined",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} and {numOfParticipants} other participants left",liveCaptionsLabel:"Live captions",captionsSettingsLabel:"Caption settings",startCaptionsButtonOnLabel:"Turn on captions",startCaptionsButtonOffLabel:"Turn off captions",startCaptionsButtonTooltipOnContent:"Turn off captions",startCaptionsButtonTooltipOffContent:"Turn on captions",captionsSettingsModalTitle:"What language is being spoken?",captionsSettingsDropdownLabel:"Spoken language",captionsSettingsDropdownInfoText:"Language that everyone on this call is speaking.",captionsSettingsConfirmButtonLabel:"Confirm",captionsSettingsCancelButtonLabel:"Cancel",captionsSettingsModalAriaLabel:"Captions Setting Modal",captionsSettingsCloseModalButtonAriaLabel:"Close Captions Setting",captionsBannerMoreButtonCallingLabel:"More",captionsBannerMoreButtonTooltip:"More options",captionsAvailableLanguageStrings:{"ar-ae":"Arabic - U.A.E.","ar-sa":"Arabic - Saudi Arabia","da-dk":"Danish","de-de":"German - Germany","en-au":"English - Australia","en-ca":"English - Canada","en-gb":"English - United Kingdom","en-in":"English - India","en-nz":"English - New Zealand","en-us":"English - United States","es-es":"Spanish - Spain (Modern Sort)","es-mx":"Spanish - Mexico","fi-fi":"Finnish","fr-ca":"French - Canada","fr-fr":"French - France","hi-in":"Hindi","it-it":"Italian - Italy","ja-jp":"Japanese","ko-kr":"Korean","nb-no":"Norwegian (Bokmål)","nl-be":"Dutch - Belgium","nl-nl":"Dutch - Netherlands","pl-pl":"Polish","pt-br":"Portuguese - Brazil","ru-ru":"Russian","sv-se":"Swedish","zh-cn":"Chinese - People's Republic of China","zh-hk":"Chinese - Hong Kong SAR","cs-cz":"Czech","pt-pt":"Portuguese - Portugal","tr-tr":"Turkish","vi-vn":"Vietnamese","th-th":"Thai","he-il":"Hebrew","cy-gb":"Welsh","uk-ua":"Ukrainian","el-gr":"Greek","hu-hu":"Hungarian","ro-ro":"Romanian","sk-sk":"Slovak","zh-tw":"Chinese - Taiwan"},captionsBannerSpinnerText:"Starting captions...",transferPageTransferorText:"Transferring...",transferPageTransferTargetText:"Connecting...",transferPageUnknownTransferorDisplayName:"Unknown",transferPageUnknownTransferTargetDisplayName:"Unknown"};var chat$i={chatListHeader:"In this chat",uploadFile:"Upload File"};var callWithChat$i={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"New Message",chatButtonTooltipClosedWithMessageCount:"Show chat ({unreadMessagesCount} unread)",chatButtonTooltipClose:"Hide chat",chatButtonTooltipOpen:"Show chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copy invite link",copyInviteLinkActionedAriaLabel:"Invite link copied",dismissSidePaneButtonLabel:"Close",moreDrawerAudioDeviceMenuTitle:"Audio Device",moreDrawerButtonLabel:"More options",moreDrawerButtonTooltip:"More options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Speaker",moreDrawerCaptionsMenuTitle:"Live captions",moreDrawerSpokenLanguageMenuTitle:"Spoken language",peopleButtonLabel:"People",peopleButtonTooltipOpen:"Show participants",peopleButtonTooltipClose:"Hide participants",peoplePaneSubTitle:"In this call",peoplePaneTitle:"People",pictureInPictureTileAriaLabel:"Video Feeds. Click to return to call screen.",removeMenuLabel:"Remove",openDialpadButtonLabel:"Dial phone number",returnToCallButtonAriaDescription:"Return to Call",returnToCallButtonAriaLabel:"Back",peoplePaneAddPeopleButtonLabel:"Add People",dialpadStartCallButtonLabel:"Call",dialpadModalTitle:"Dial Phone Number",dialpadModalAriaLabel:"Dialpad",dialpadCloseModalButtonAriaLabel:"Close dialpad",openDtmfDialpadLabel:"Show dialpad",dtmfDialpadPlaceholderText:"Enter number"};var en_GB = {call:call$i,chat:chat$i,callWithChat:callWithChat$i};

var call$h={cameraLabel:"الكاميرا",noCamerasLabel:"لا توجد أي كاميرات",cameraPermissionDenied:"يقوم المستعرض بحظر الوصول إلى الكاميرا",cameraTurnedOff:"تم إيقاف تشغيل الكاميرا",chatButtonLabel:"دردشة",close:"إغلاق",complianceBannerNowOnlyRecording:"أنت الآن تسجل هذا الاجتماع فقط.",complianceBannerNowOnlyTranscription:"أنت الآن تقوم فقط بكتابة الحديث لهذا الاجتماع.",complianceBannerRecordingAndTranscriptionSaved:"يتم حفظ التسجيل وكتابة الحديث.",complianceBannerRecordingAndTranscriptionStarted:"بدء التسجيل والنسخ. ",complianceBannerRecordingAndTranscriptionStopped:"التسجيل وكتابة الحديث متوقفان.",complianceBannerRecordingSaving:"يتم حفظ التسجيل.",complianceBannerRecordingStarted:"تم بدء التسجيل.",complianceBannerRecordingStopped:"تم إيقاف التسجيل.",complianceBannerTranscriptionStarted:"كتابة الحديث مبدوءة.",complianceBannerTranscriptionConsent:"من خلال الانضمام، فأنت توافق على كتابة هذا الاجتماع.",complianceBannerTranscriptionSaving:"يتم حفظ كتابة الحديث.",complianceBannerTranscriptionStopped:"توقفت كتابة الحديث.",configurationPageTitle:"بدء مكالمة",copyInviteLinkButtonLabel:"نسخ ارتباط دعوة",copyInviteLinkActionedAriaLabel:"تم نسخ ارتباط الدعوة",defaultPlaceHolder:"تحديد خيار",dismissSidePaneButtonLabel:"إغلاق",videoEffectsPaneTitle:"التأثيرات",videoEffectsPaneBackgroundSelectionTitle:"الخلفية",configurationPageVideoEffectsButtonLabel:"التأثيرات",unableToStartVideoEffect:"يتعذر تطبيق تأثير الفيديو.",blurBackgroundEffectButtonLabel:"تمويه",blurBackgroundTooltip:"تمويه الخلفية",removeBackgroundEffectButtonLabel:"لا شيء",removeBackgroundTooltip:"إزالة الخلفية",cameraOffBackgroundEffectWarningText:"الكاميرا قيد الإيقاف. قم بتشغيل الكاميرا لمشاهدة تأثير الفيديو.",failedToJoinCallDueToNoNetworkMoreDetails:"تم قطع الاتصال بسبب مشكلة في الشبكة. تحقق من اتصالك وانضم مرة أخرى.",failedToJoinCallDueToNoNetworkTitle:"‏‏تم قطع اتصال المكالمة",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"لم يتم منحك إدخالا في المكالمة. إذا كان هذا خطأ، فعاود الانضمام إلى المكالمة.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"تم التجاهل من ساحة الانتظار",learnMore:"تعرّف على المزيد",leavingCallTitle:"تتم الآن المغادرة...",leftCallMoreDetails:"إذا كان هذا خطأ، فعاود الانضمام إلى المكالمة.",leftCallTitle:"قمت بمغادرة المكالمة",lobbyScreenConnectingToCallTitle:"جارٍ الانضمام إلى مكالمة",lobbyScreenWaitingToBeAdmittedTitle:"في انتظار السماح",microphonePermissionDenied:"يقوم المستعرض بحظر الوصول إلى الميكروفون",microphoneToggleInLobbyNotAllowed:"لا يمكن كتم الصوت أو إلغاء كتمه أثناء وجودك في ساحة الانتظار.",mutedMessage:"تم كتم صوتك",networkReconnectMoreDetails:"يبدو أنه قد حدث خطأ ما. نحاول معاودة الاتصال.",networkReconnectTitle:"انتظار",deniedPermissionToRoomDetails:"ليس لديك الإذن بالانضمام إلى هذه الغرفة.",deniedPermissionToRoomTitle:"تم رفض الإذن بالغرفة",peopleButtonLabel:"الأشخاص",peoplePaneTitle:"الأشخاص",peopleButtonTooltipOpen:"إظهار المشاركين",peopleButtonTooltipClose:"إخفاء المشاركين",peoplePaneSubTitle:"في هذه المكالمة",privacyPolicy:"نهج الخصوصية",rejoinCallButtonLabel:"الانضمام إلى المكالمة",removedFromCallMoreDetails:"قام مشارك آخر بإزالتك من المكالمة.",removedFromCallTitle:"تمت إزالتك",removeMenuLabel:"إزالة",returnToCallButtonAriaDescription:"رجوع إلى المكالمة",returnToCallButtonAriaLabel:"رجوع",roomNotFoundDetails:"معرف الغرفة الذي تم توفيره غير صالح.",roomNotFoundTitle:"لم يتم العثور على الغرفة",soundLabel:"صوت",noMicrophonesLabel:"لم يتم العثور على ميكروفونات",noSpeakersLabel:"لم يتم العثور على سماعات",startCallButtonLabel:"بدء مكالمة",openDialpadButtonLabel:"اطلب رقم الهاتف",peoplePaneAddPeopleButtonLabel:"إضافة أشخاص",dialpadStartCallButtonLabel:"مكالمة",dialpadModalTitle:"اطلب رقم الهاتف",dialpadModalAriaLabel:"لوحة الطلب",dialpadCloseModalButtonAriaLabel:"إغلاق لوحة الطلب",moreButtonCallingLabel:"المزيد",resumeCallButtonLabel:"استئناف",resumingCallButtonLabel:"يتم الآن الاستئناف...",resumeCallButtonAriaLabel:"استئناف المكالمة",resumingCallButtonAriaLabel:"استئناف المكالمة",holdScreenLabel:"أنت قيد الانتظار",openDtmfDialpadLabel:"عرض لوحة الطلب",dtmfDialpadPlaceholderText:"أدخل عدداً",outboundCallingNoticeString:"يتم الآن الاتصال...",participantJoinedNoticeString:"انضم {displayName}",twoParticipantJoinedNoticeString:"انضم {displayName1} و{displayName2}",threeParticipantJoinedNoticeString:"انضم {displayName1} و{displayName2} و{displayName3}",participantLeftNoticeString:"غادر {displayName}",twoParticipantLeftNoticeString:"غادر {displayName1} و{displayName2}",threeParticipantLeftNoticeString:"غادر {displayName1} و{displayName2} و{displayName3}",unnamedParticipantString:"مشارك غير مسمى",manyUnnamedParticipantsJoined:"انضم مشارك غير مسمى و{numOfParticipants} من المشاركين الآخرين",manyUnnamedParticipantsLeft:"غادر مشارك غير مسمى و{numOfParticipants} من المشاركين الآخرين",manyParticipantsJoined:"انضم {displayName1} {displayName2} {displayName3} {numOfParticipants} مشاركين آخرين",manyParticipantsLeft:"غادر {displayName1} {displayName2} {displayName3} والمشاركون الآخرون {numOfParticipants}",liveCaptionsLabel:"نص الكلام مباشرةً",captionsSettingsLabel:"إعدادات نص الكلام",startCaptionsButtonOnLabel:"تمكين نص الكلام",startCaptionsButtonOffLabel:"تعطيل نص الكلام",startCaptionsButtonTooltipOnContent:"تعطيل نص الكلام",startCaptionsButtonTooltipOffContent:"تمكين نص الكلام",captionsSettingsModalTitle:"ما اللغة التي يتم التحدث بها؟",captionsSettingsDropdownLabel:"اللغة المنطوقة",captionsSettingsDropdownInfoText:"اللغة التي يتحدث بها كل شخص في هذه المكالمة.",captionsSettingsConfirmButtonLabel:"تأكيد",captionsSettingsCancelButtonLabel:"إلغاء",captionsSettingsModalAriaLabel:"مربع حوار إعدادات نص الكلام المشروط",captionsSettingsCloseModalButtonAriaLabel:"إغلاق إعداد نص الكلام",captionsBannerMoreButtonCallingLabel:"المزيد",captionsBannerMoreButtonTooltip:"خيارات إضافية",captionsAvailableLanguageStrings:{"ar-ae":"العربية - الإمارات العربية المتحدة","ar-sa":"العربية - السعودية","da-dk":"الدانمركية","de-de":"الألمانية - ألمانيا","en-au":"الإنجليزية - أستراليا","en-ca":"الإنجليزية - كندا","en-gb":"الإنجليزية - المملكة المتحدة","en-in":"الإنجليزية - الهند","en-nz":"الإنجليزية - نيوزيلندا","en-us":"الإنجليزية - الولايات المتحدة","es-es":"الإسبانية - إسبانيا (فرز حديث)","es-mx":"الإسبانية - المكسيك","fi-fi":"الفنلندية","fr-ca":"الفرنسية - كندا","fr-fr":"الفرنسية - فرنسا","hi-in":"الهندية","it-it":"الإيطالية - إيطاليا","ja-jp":"اليابانية","ko-kr":"الكورية","nb-no":"النرويجية (بوكمال)","nl-be":"الهولندية - بلجيكا","nl-nl":"الهولندية - هولندا","pl-pl":"البولندية","pt-br":"البرتغالية - البرازيل","ru-ru":"الروسية","sv-se":"السويدية","zh-cn":"الصينية - جمهورية الصين الشعبية","zh-hk":"الصينية - منطقة هونغ كونغ الإدارية الخاصة","cs-cz":"التشيكية","pt-pt":"البرتغالية - البرتغال","tr-tr":"التركية","vi-vn":"الفيتنامية","th-th":"التايلاندية","he-il":"العبرية","cy-gb":"الويلزية","uk-ua":"الأوكرانية","el-gr":"اليونانية","hu-hu":"الهنغارية","ro-ro":"الرومانية","sk-sk":"السلوفاكية","zh-tw":"الصينية - تايوان"},captionsBannerSpinnerText:"يتم الآن بدء التسميات التوضيحية...",transferPageTransferorText:"يتم الآن التحويل...",transferPageTransferTargetText:"جارٍ الاتصال...",transferPageUnknownTransferorDisplayName:"غير معروف",transferPageUnknownTransferTargetDisplayName:"غير معروف"};var chat$h={chatListHeader:"في هذه الدردشة",uploadFile:"تحميل ملف"};var callWithChat$h={chatButtonLabel:"دردشة",chatButtonNewMessageNotificationLabel:"رسالة جديدة",chatButtonTooltipClosedWithMessageCount:"إظهار الدردشة ({unreadMessagesCount} غير مقروءة)",chatButtonTooltipClose:"إخفاء الدردشة",chatButtonTooltipOpen:"إظهار الدردشة",chatPaneTitle:"دردشة",copyInviteLinkButtonLabel:"نسخ ارتباط دعوة",copyInviteLinkActionedAriaLabel:"تم نسخ ارتباط الدعوة",dismissSidePaneButtonLabel:"إغلاق",moreDrawerAudioDeviceMenuTitle:"جهاز صوت",moreDrawerButtonLabel:"المزيد من الخيارات",moreDrawerButtonTooltip:"المزيد من الخيارات",moreDrawerMicrophoneMenuTitle:"الميكروفون",moreDrawerSpeakerMenuTitle:"مكبر الصوت",moreDrawerCaptionsMenuTitle:"نص الكلام مباشرةً",moreDrawerSpokenLanguageMenuTitle:"اللغة المنطوقة",peopleButtonLabel:"الأشخاص",peopleButtonTooltipOpen:"إظهار المشاركين",peopleButtonTooltipClose:"إخفاء المشاركين",peoplePaneSubTitle:"في هذه المكالمة",peoplePaneTitle:"الأشخاص",pictureInPictureTileAriaLabel:"موجزات الفيديو. انقر للعودة إلى شاشة المكالمة.",removeMenuLabel:"إزالة",openDialpadButtonLabel:"اطلب رقم الهاتف",returnToCallButtonAriaDescription:"رجوع إلى المكالمة",returnToCallButtonAriaLabel:"رجوع",peoplePaneAddPeopleButtonLabel:"إضافة أشخاص",dialpadStartCallButtonLabel:"مكالمة",dialpadModalTitle:"اطلب رقم الهاتف",dialpadModalAriaLabel:"لوحة الطلب",dialpadCloseModalButtonAriaLabel:"إغلاق لوحة الطلب",openDtmfDialpadLabel:"عرض لوحة الطلب",dtmfDialpadPlaceholderText:"أدخل عدداً"};var ar_SA = {call:call$h,chat:chat$h,callWithChat:callWithChat$h};

var call$g={cameraLabel:"Kamera",noCamerasLabel:"Keine Kameras gefunden",cameraPermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihre Kamera.",cameraTurnedOff:"Ihre Kamera ist deaktiviert.",chatButtonLabel:"Chat",close:"Schließen",complianceBannerNowOnlyRecording:"Sie zeichnen nun nur diese Besprechung auf.",complianceBannerNowOnlyTranscription:"Sie transkribieren diese Besprechung jetzt nur noch.",complianceBannerRecordingAndTranscriptionSaved:"Aufzeichnung und Transkription werden gespeichert.",complianceBannerRecordingAndTranscriptionStarted:"Die Aufzeichnung und Transkription haben begonnen.",complianceBannerRecordingAndTranscriptionStopped:"Die Aufzeichnung und Transkription wurden beendet.",complianceBannerRecordingSaving:"Aufzeichnung wird gespeichert.",complianceBannerRecordingStarted:"Die Aufzeichnung wurde gestartet.",complianceBannerRecordingStopped:"Aufzeichnung wurde beendet.",complianceBannerTranscriptionStarted:"Die Transkription hat begonnen.",complianceBannerTranscriptionConsent:"Durch Ihre Teilnahme stimmen Sie zu, dass diese Besprechung transkribiert wird.",complianceBannerTranscriptionSaving:"Die Transkription wird gespeichert.",complianceBannerTranscriptionStopped:"Die Transkription wurde beendet.",configurationPageTitle:"Einen Anruf beginnen",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",defaultPlaceHolder:"Option auswählen",dismissSidePaneButtonLabel:"Schließen",videoEffectsPaneTitle:"Effekte",videoEffectsPaneBackgroundSelectionTitle:"Hintergrund",configurationPageVideoEffectsButtonLabel:"Effekte",unableToStartVideoEffect:"Videoeffekt kann nicht angewendet werden.",blurBackgroundEffectButtonLabel:"Weichzeichnen",blurBackgroundTooltip:"Hintergrund weichzeichnen",removeBackgroundEffectButtonLabel:"Keine",removeBackgroundTooltip:"Hintergrund entfernen",cameraOffBackgroundEffectWarningText:"Ihre Kamera ist ausgeschaltet. Aktivieren Sie die Kamera, um den Videoeffekt anzuzeigen.",failedToJoinCallDueToNoNetworkMoreDetails:"Der Anruf wurde aufgrund eines Netzwerkproblems getrennt. Überprüfen Sie Ihre Verbindung, und treten Sie erneut bei.",failedToJoinCallDueToNoNetworkTitle:"Anruf unterbrochen",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Ihnen wurde keine Teilnahme am Anruf gewährt. Wenn dies ein Fehler war, treten Sie dem Anruf erneut bei.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Aus Wartebereich entlassen",learnMore:"Weitere Informationen",leavingCallTitle:"Verlässt Besprechung...",leftCallMoreDetails:"Wenn dies ein Fehler war, nehmen Sie erneut am Anruf teil.",leftCallTitle:"Sie haben den Anruf verlassen",lobbyScreenConnectingToCallTitle:"Teilnehmen am Anruf",lobbyScreenWaitingToBeAdmittedTitle:"Warten auf die Zulassung",microphonePermissionDenied:"Ihr Browser blockiert den Zugriff auf Ihr Mikrofon.",microphoneToggleInLobbyNotAllowed:"Stummschalten oder Aufheben der Stummschaltung im Wartebereich nicht zulässig.",mutedMessage:"Sie sind stummgeschaltet.",networkReconnectMoreDetails:"Offensichtlich ist etwas schief gegangen. Wir versuchen, Sie wieder mit dem Anruf zu verbinden.",networkReconnectTitle:"Einen Augenblick bitte",deniedPermissionToRoomDetails:"Sie sind nicht berechtigt, diesem Raum beizutreten.",deniedPermissionToRoomTitle:"Berechtigung für Raum verweigert",peopleButtonLabel:"Kontakte",peoplePaneTitle:"Kontakte",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf",privacyPolicy:"Datenschutzrichtlinie",rejoinCallButtonLabel:"Am Anruf erneut teilnehmen",removedFromCallMoreDetails:"Ein anderer Teilnehmer hat Sie aus dem Anruf entfernt.",removedFromCallTitle:"Sie wurden entfernt",removeMenuLabel:"Entfernen",returnToCallButtonAriaDescription:"Zurück zum Anruf",returnToCallButtonAriaLabel:"Zurück",roomNotFoundDetails:"Die angegebene Raum-ID ist ungültig.",roomNotFoundTitle:"Raum nicht gefunden",soundLabel:"Sound",noMicrophonesLabel:"Keine Mikrofone gefunden",noSpeakersLabel:"Keine Lautsprecher gefunden",startCallButtonLabel:"Anruf beginnen",openDialpadButtonLabel:"Telefonnummer wählen",peoplePaneAddPeopleButtonLabel:"Personen hinzufügen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer wählen",dialpadModalAriaLabel:"Wähltastatur",dialpadCloseModalButtonAriaLabel:"Wähltastatur schließen",moreButtonCallingLabel:"Mehr",resumeCallButtonLabel:"Fortsetzen",resumingCallButtonLabel:"Wird fortgesetzt…",resumeCallButtonAriaLabel:"Anruf fortsetzen",resumingCallButtonAriaLabel:"Anruf fortsetzen",holdScreenLabel:"Sie sind in der Warteschleife.",openDtmfDialpadLabel:"Wähltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben",outboundCallingNoticeString:"Anrufen...",participantJoinedNoticeString:"{displayName} ist beigetreten.",twoParticipantJoinedNoticeString:"{displayName1} und {displayName2} sind beigetreten.",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} und {displayName3} sind beigetreten.",participantLeftNoticeString:"{displayName} ist gegangen.",twoParticipantLeftNoticeString:"{displayName1} und {displayName2} sind gegangen.",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} und {displayName3} sind gegangen.",unnamedParticipantString:"unbenannter Teilnehmer",manyUnnamedParticipantsJoined:"unbenannter Teilnehmer und {numOfParticipants} weitere Teilnehmer sind beigetreten.",manyUnnamedParticipantsLeft:"unbenannter Teilnehmer und {numOfParticipants} weitere Teilnehmer sind gegangen.",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} und {numOfParticipants} anderen Teilnehmern sind beigetreten.",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} und {numOfParticipants} anderen Teilnehmer verlassen",liveCaptionsLabel:"Liveuntertitel",captionsSettingsLabel:"Untertiteleinstellungen",startCaptionsButtonOnLabel:"Beschriftungen aktivieren",startCaptionsButtonOffLabel:"Untertitel deaktivieren",startCaptionsButtonTooltipOnContent:"Untertitel deaktivieren",startCaptionsButtonTooltipOffContent:"Beschriftungen aktivieren",captionsSettingsModalTitle:"Welche Sprache wird gesprochen?",captionsSettingsDropdownLabel:"Gesprochene Sprache",captionsSettingsDropdownInfoText:"Sprache, die jeder in diesem Anruf spricht.",captionsSettingsConfirmButtonLabel:"Bestätigen",captionsSettingsCancelButtonLabel:"Abbrechen",captionsSettingsModalAriaLabel:"Untertiteleinstellung modal",captionsSettingsCloseModalButtonAriaLabel:"Einstellung „Untertitel“ schließen",captionsBannerMoreButtonCallingLabel:"Mehr",captionsBannerMoreButtonTooltip:"Weitere Optionen",captionsAvailableLanguageStrings:{"ar-ae":"Arabisch – Vereinigte Arabische Emirate","ar-sa":"Arabisch – Saudi-Arabien","da-dk":"Dänisch","de-de":"Deutsch – Deutschland","en-au":"Englisch – Australien","en-ca":"Englisch – Kanada","en-gb":"Englisch - Vereinigtes Königreich","en-in":"Englisch – Indien","en-nz":"Englisch – Neuseeland","en-us":"Englisch – USA","es-es":"Spanisch – Spanien (Moderne Sortierung)","es-mx":"Spanisch – Mexiko","fi-fi":"Finnisch","fr-ca":"Französisch – Kanada","fr-fr":"Französisch – Frankreich","hi-in":"Hindi","it-it":"Italienisch – Italien","ja-jp":"Japanisch","ko-kr":"Koreanisch","nb-no":"Norwegisch (Bokmål)","nl-be":"Niederländisch – Belgien","nl-nl":"Niederländisch – Niederlande","pl-pl":"Polnisch","pt-br":"Portugiesisch – Brasilien","ru-ru":"Russisch","sv-se":"Schwedisch","zh-cn":"Chinesisch – Volksrepublik China","zh-hk":"Chinesisch – Hongkong (SAR)","cs-cz":"Tschechisch","pt-pt":"Portugiesisch – Portugal","tr-tr":"Türkisch","vi-vn":"Vietnamesisch","th-th":"Thailändisch","he-il":"Hebräisch","cy-gb":"Walisisch","uk-ua":"Ukrainisch","el-gr":"Griechisch","hu-hu":"Ungarisch","ro-ro":"Rumänisch","sk-sk":"Slowakisch","zh-tw":"Chinesisch – Taiwan"},captionsBannerSpinnerText:"Untertitel werden gestartet...",transferPageTransferorText:"Übertragung...",transferPageTransferTargetText:"Verbindung wird hergestellt...",transferPageUnknownTransferorDisplayName:"Unbekannt",transferPageUnknownTransferTargetDisplayName:"Unbekannt"};var chat$g={chatListHeader:"In diesem Chat",uploadFile:"Datei hochladen"};var callWithChat$g={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Neue Nachricht",chatButtonTooltipClosedWithMessageCount:"Chat anzeigen ({unreadMessagesCount} ungelesen)",chatButtonTooltipClose:"Chat ausblenden",chatButtonTooltipOpen:"Chat anzeigen",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Einladungslink kopieren",copyInviteLinkActionedAriaLabel:"Gruppeneinladungslink kopiert",dismissSidePaneButtonLabel:"Schließen",moreDrawerAudioDeviceMenuTitle:"Audiogerät",moreDrawerButtonLabel:"Weitere Optionen",moreDrawerButtonTooltip:"Weitere Optionen",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Lautsprecher",moreDrawerCaptionsMenuTitle:"Liveuntertitel",moreDrawerSpokenLanguageMenuTitle:"Gesprochene Sprache",peopleButtonLabel:"Personen",peopleButtonTooltipOpen:"Teilnehmende anzeigen",peopleButtonTooltipClose:"Teilnehmende ausblenden",peoplePaneSubTitle:"In diesem Anruf",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klicken Sie hier, um zum Anrufbildschirm zurückzukehren.",removeMenuLabel:"Entfernen",openDialpadButtonLabel:"Telefonnummer wählen",returnToCallButtonAriaDescription:"Zurück zum Anruf",returnToCallButtonAriaLabel:"Zurück",peoplePaneAddPeopleButtonLabel:"Personen hinzufügen",dialpadStartCallButtonLabel:"Anrufen",dialpadModalTitle:"Telefonnummer wählen",dialpadModalAriaLabel:"Wähltastatur",dialpadCloseModalButtonAriaLabel:"Wähltastatur schließen",openDtmfDialpadLabel:"Wähltastatur anzeigen",dtmfDialpadPlaceholderText:"Nummer eingeben"};var de_DE = {call:call$g,chat:chat$g,callWithChat:callWithChat$g};

var call$f={cameraLabel:"Cámara",noCamerasLabel:"No se han encontrado cámaras",cameraPermissionDenied:"El explorador está bloqueando el acceso a la cámara",cameraTurnedOff:"La cámara está apagada",chatButtonLabel:"Chat",close:"Cerrar",complianceBannerNowOnlyRecording:"Solo está grabando esta reunión.",complianceBannerNowOnlyTranscription:"Solo está transcribiendo esta reunión.",complianceBannerRecordingAndTranscriptionSaved:"Se están guardando la grabación y la transcripción.",complianceBannerRecordingAndTranscriptionStarted:"Se han iniciado la grabación y la transcripción.",complianceBannerRecordingAndTranscriptionStopped:"Se han detenido la grabación y la transcripción.",complianceBannerRecordingSaving:"La grabación se está guardando.",complianceBannerRecordingStarted:"Se ha iniciado la grabación.",complianceBannerRecordingStopped:"La grabación se ha detenido.",complianceBannerTranscriptionStarted:"La transcripción se ha iniciado.",complianceBannerTranscriptionConsent:"Al unirse, da su consentimiento para que se transcriba esta reunión.",complianceBannerTranscriptionSaving:"Se está guardando la transcripción.",complianceBannerTranscriptionStopped:"La transcripción se ha detenido.",configurationPageTitle:"Iniciar una llamada",copyInviteLinkButtonLabel:"Copiar vínculo de invitación",copyInviteLinkActionedAriaLabel:"Vínculo de invitación copiado",defaultPlaceHolder:"Seleccionar una opción",dismissSidePaneButtonLabel:"Cerrar",videoEffectsPaneTitle:"Efectos",videoEffectsPaneBackgroundSelectionTitle:"Fondo",configurationPageVideoEffectsButtonLabel:"Efectos",unableToStartVideoEffect:"No se puede aplicar el efecto de vídeo.",blurBackgroundEffectButtonLabel:"Desenfoque",blurBackgroundTooltip:"Desenfocar fondo",removeBackgroundEffectButtonLabel:"Ninguno",removeBackgroundTooltip:"Quitar fondo",cameraOffBackgroundEffectWarningText:"La cámara está apagada. Enciende la cámara para ver el efecto de vídeo.",failedToJoinCallDueToNoNetworkMoreDetails:"Se desconectó la llamada debido a un problema de red. Compruebe la conexión y únase de nuevo.",failedToJoinCallDueToNoNetworkTitle:"Llamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"No se te concedió la entrada a la llamada. Si se trata de un error, vuelve a unirte.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rechazado de la sala de espera",learnMore:"Más información",leavingCallTitle:"Saliendo...",leftCallMoreDetails:"Si se trata de un error, vuelve a unirte a la llamada.",leftCallTitle:"Has abandonado la llamada",lobbyScreenConnectingToCallTitle:"Uniéndose a la llamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando a ser admitido",microphonePermissionDenied:"El explorador está bloqueando el acceso al micrófono",microphoneToggleInLobbyNotAllowed:"No se puede silenciar ni reactivar el audio mientras se está en la sala de espera.",mutedMessage:"Estás silenciado",networkReconnectMoreDetails:"Parece que hubo un problema. Estamos intentando reconectar la llamada.",networkReconnectTitle:"Espere",deniedPermissionToRoomDetails:"No tiene permiso para unirse a esta sala.",deniedPermissionToRoomTitle:"Permiso denegado a la sala",peopleButtonLabel:"Contactos",peoplePaneTitle:"Contactos",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada",privacyPolicy:"Directiva de privacidad",rejoinCallButtonLabel:"Volver a unirse a la llamada",removedFromCallMoreDetails:"Otro participante te ha eliminado de la llamada.",removedFromCallTitle:"Fuiste eliminado",removeMenuLabel:"Quitar",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",roomNotFoundDetails:"El id. de sala proporcionado no es válido.",roomNotFoundTitle:"No se ha encontrado la sala",soundLabel:"Sonido",noMicrophonesLabel:"No se han encontrado micrófonos",noSpeakersLabel:"No se han encontrado altavoces",startCallButtonLabel:"Iniciar llamada",openDialpadButtonLabel:"Marcar número de teléfono",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar número de teléfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",moreButtonCallingLabel:"Más",resumeCallButtonLabel:"Reanudar",resumingCallButtonLabel:"Reanudando…",resumeCallButtonAriaLabel:"Reanudar llamada",resumingCallButtonAriaLabel:"Reanudar llamada",holdScreenLabel:"Está en espera",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir número",outboundCallingNoticeString:"Llamando...",participantJoinedNoticeString:"{displayName} unido",twoParticipantJoinedNoticeString:"{displayName1} y {displayName2} se han unido",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} y {displayName3} se han unido",participantLeftNoticeString:"{displayName} se ha retirado",twoParticipantLeftNoticeString:"{displayName1} y {displayName2} se han retirado",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} y {displayName3} se han retirado",unnamedParticipantString:"participante sin nombre",manyUnnamedParticipantsJoined:"participante sin nombre y {numOfParticipants} participantes más se han unido",manyUnnamedParticipantsLeft:"participante sin nombre y {numOfParticipants} participantes más se han retirado",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} y {numOfParticipants} se han unido otros participantes",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} y {numOfParticipants} restantes",liveCaptionsLabel:"Subtítulos en directo",captionsSettingsLabel:"Configuración de subtítulos",startCaptionsButtonOnLabel:"Activar subtítulos",startCaptionsButtonOffLabel:"Desactivar subtítulos",startCaptionsButtonTooltipOnContent:"Desactivar subtítulos",startCaptionsButtonTooltipOffContent:"Activar subtítulos",captionsSettingsModalTitle:"¿Qué idioma se está hablando?",captionsSettingsDropdownLabel:"Idioma hablado",captionsSettingsDropdownInfoText:"Idioma en el que están hablando todos los usuarios de esta llamada.",captionsSettingsConfirmButtonLabel:"Confirmar",captionsSettingsCancelButtonLabel:"Cancelar",captionsSettingsModalAriaLabel:"Configuración modal de subtítulos",captionsSettingsCloseModalButtonAriaLabel:"Cerrar configuración de subtítulos",captionsBannerMoreButtonCallingLabel:"Más",captionsBannerMoreButtonTooltip:"Más opciones",captionsAvailableLanguageStrings:{"ar-ae":"Árabe - Emiratos Árabes Unidos","ar-sa":"Árabe - Arabia Saudí","da-dk":"Danés","de-de":"Alemán - Alemania","en-au":"Inglés - Australia","en-ca":"Inglés (Canadá)","en-gb":"Inglés - Reino Unido","en-in":"Inglés (India)","en-nz":"Inglés (Nueva Zelanda)","en-us":"Inglés - Estados Unidos","es-es":"Español - España (alfabetización internacional)","es-mx":"Español (México)","fi-fi":"Finés","fr-ca":"Francés (Canadá)","fr-fr":"Francés - Francia","hi-in":"Hindi","it-it":"Italiano (Italia)","ja-jp":"Japonés","ko-kr":"Coreano","nb-no":"Noruego (Bokmål)","nl-be":"Neerlandés - Bélgica","nl-nl":"Neerlandés (Países Bajos)","pl-pl":"Polaco","pt-br":"Portugués (Brasil)","ru-ru":"Ruso","sv-se":"Sueco","zh-cn":"Chino - República Popular China","zh-hk":"Chino - Hong Kong (RAE)","cs-cz":"Checo","pt-pt":"Portugués de Portugal","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Tailandés","he-il":"Hebreo","cy-gb":"Galés","uk-ua":"Ucraniano","el-gr":"Griego","hu-hu":"Húngaro","ro-ro":"Rumano","sk-sk":"Eslovaco","zh-tw":"Chino - Taiwán"},captionsBannerSpinnerText:"Iniciando subtítulos...",transferPageTransferorText:"Transfiriendo...",transferPageTransferTargetText:"Conectando...",transferPageUnknownTransferorDisplayName:"Desconocido",transferPageUnknownTransferTargetDisplayName:"Desconocido"};var chat$f={chatListHeader:"En este chat",uploadFile:"Subir archivo"};var callWithChat$f={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuevo mensaje",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} no leídos)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar vínculo de invitación",copyInviteLinkActionedAriaLabel:"Vínculo de invitación copiado",dismissSidePaneButtonLabel:"Cerrar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de audio",moreDrawerButtonLabel:"Más opciones",moreDrawerButtonTooltip:"Más opciones",moreDrawerMicrophoneMenuTitle:"Micrófono",moreDrawerSpeakerMenuTitle:"Altavoz",moreDrawerCaptionsMenuTitle:"Subtítulos en directo",moreDrawerSpokenLanguageMenuTitle:"Idioma hablado",peopleButtonLabel:"Contactos",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"En esta llamada",peoplePaneTitle:"Contactos",pictureInPictureTileAriaLabel:"Fuentes de vídeo. Hacer clic para volver a la pantalla de la llamada.",removeMenuLabel:"Quitar",openDialpadButtonLabel:"Marcar número de teléfono",returnToCallButtonAriaDescription:"Volver a llamada",returnToCallButtonAriaLabel:"Volver",peoplePaneAddPeopleButtonLabel:"Agregar contactos",dialpadStartCallButtonLabel:"Llamar",dialpadModalTitle:"Marcar número de teléfono",dialpadModalAriaLabel:"Teclado de marcado",dialpadCloseModalButtonAriaLabel:"Cerrar teclado de marcado",openDtmfDialpadLabel:"Mostrar teclado de marcado",dtmfDialpadPlaceholderText:"Introducir número"};var es_ES = {call:call$f,chat:chat$f,callWithChat:callWithChat$f};

var call$e={cameraLabel:"Kamera",noCamerasLabel:"Kameroita ei löytynyt",cameraPermissionDenied:"Selaimesi estää kameran käytön",cameraTurnedOff:"Kamerasi on pois käytöstä",chatButtonLabel:"Keskustelu",close:"Sulje",complianceBannerNowOnlyRecording:"Tallennetta ollaan luomassa vain tästä kokouksesta.",complianceBannerNowOnlyTranscription:"Transkriptiota ollaan luomassa vain tästä kokouksesta.",complianceBannerRecordingAndTranscriptionSaved:"Tallennusta ja transkriptiota tallennetaan.",complianceBannerRecordingAndTranscriptionStarted:"Tallentaminen ja litterointi on aloitettu.",complianceBannerRecordingAndTranscriptionStopped:"Tallentaminen ja litterointi on pysäytetty.",complianceBannerRecordingSaving:"Tallennetta tallennetaan.",complianceBannerRecordingStarted:"Tallentaminen on aloitettu.",complianceBannerRecordingStopped:"Tallentaminen on pysäytetty.",complianceBannerTranscriptionStarted:"Transkriptio on aloitettu.",complianceBannerTranscriptionConsent:"Liittymällä annat suostumuksesi kokouksen litteroimiseen.",complianceBannerTranscriptionSaving:"Transkriptiota tallennetaan.",complianceBannerTranscriptionStopped:"Transkriptio on pysäytetty.",configurationPageTitle:"Aloita puhelu",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu",defaultPlaceHolder:"Valitse vaihtoehto",dismissSidePaneButtonLabel:"Sulje",videoEffectsPaneTitle:"Tehosteet",videoEffectsPaneBackgroundSelectionTitle:"Tausta",configurationPageVideoEffectsButtonLabel:"Tehosteet",unableToStartVideoEffect:"Videotehosteen käyttäminen ei onnistu.",blurBackgroundEffectButtonLabel:"Sumenna",blurBackgroundTooltip:"Sumenna tausta",removeBackgroundEffectButtonLabel:"Ei mitään",removeBackgroundTooltip:"Poista tausta",cameraOffBackgroundEffectWarningText:"Kamera ei ole käytössä. Ota kamera käyttöön nähdäksesi videotehosteen.",failedToJoinCallDueToNoNetworkMoreDetails:"Puhelu katkaistiin verkko-ongelman vuoksi. Tarkista yhteys ja liity uudelleen.",failedToJoinCallDueToNoNetworkTitle:"Puhelu on katkennut",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Sinulle ei myönnetty puheluun merkintää. Jos tämä oli virhe, liity puheluun uudelleen.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Poistettu odotustilasta",learnMore:"Lisätietoja",leavingCallTitle:"Poistumassa...",leftCallMoreDetails:"Jos tämä oli virhe, liity puheluun uudelleen.",leftCallTitle:"Poistuit puhelusta",lobbyScreenConnectingToCallTitle:"Liitytään puheluun",lobbyScreenWaitingToBeAdmittedTitle:"Odotetaan hyväksymistä mukaan kokoukseen",microphonePermissionDenied:"Selaimesi estää mikrofonin käytön",microphoneToggleInLobbyNotAllowed:"Mykistämistoimintoa ei voi käyttää odotustilassa.",mutedMessage:"Mikrofonisi on mykistetty",networkReconnectMoreDetails:"Vaikuttaa siltä, että tapahtui virhe. Sinua yritetään saada takaisin mukaan puheluun.",networkReconnectTitle:"Odota",deniedPermissionToRoomDetails:"Sinulla ei ole oikeutta liittyä tähän ryhmään.",deniedPermissionToRoomTitle:"Lupaa tilan käyttöön ei myönnetty",peopleButtonLabel:"Ihmiset",peoplePaneTitle:"Ihmiset",peopleButtonTooltipOpen:"Näytä osallistujat",peopleButtonTooltipClose:"Piilota osallistujat",peoplePaneSubTitle:"Tässä puhelussa",privacyPolicy:"Tietosuojakäytännöt",rejoinCallButtonLabel:"Liity uudelleen puheluun",removedFromCallMoreDetails:"Toinen osallistuja poisti sinut puhelusta.",removedFromCallTitle:"Sinut on poistettu",removeMenuLabel:"Poista",returnToCallButtonAriaDescription:"Palaa puheluun",returnToCallButtonAriaLabel:"Takaisin",roomNotFoundDetails:"Annettu tilan tunnus ei kelpaa.",roomNotFoundTitle:"Tilaa ei löytynyt",soundLabel:"Ääni",noMicrophonesLabel:"Mikrofoneja ei löytynyt",noSpeakersLabel:"Kaiuttimia ei löytynyt",startCallButtonLabel:"Aloita puhelu",openDialpadButtonLabel:"Valitse puhelinnumero",peoplePaneAddPeopleButtonLabel:"Lisää ihmisiä",dialpadStartCallButtonLabel:"Soita",dialpadModalTitle:"Valitse puhelinnumero",dialpadModalAriaLabel:"Valintapaneeli",dialpadCloseModalButtonAriaLabel:"Sulje valintapaneeli",moreButtonCallingLabel:"Lisää",resumeCallButtonLabel:"Jatka",resumingCallButtonLabel:"Jatketaan...",resumeCallButtonAriaLabel:"Jatka puhelua",resumingCallButtonAriaLabel:"Jatka puhelua",holdScreenLabel:"Olet pidossa",openDtmfDialpadLabel:"Näytä valintapaneeli",dtmfDialpadPlaceholderText:"Syötä numero",outboundCallingNoticeString:"Soitetaan...",participantJoinedNoticeString:"{displayName} liittyi",twoParticipantJoinedNoticeString:"{displayName1} ja {displayName2} ovat liittyneet",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} ja {displayName3} ovat liittyneet",participantLeftNoticeString:"{displayName} poistui",twoParticipantLeftNoticeString:"{displayName1} ja {displayName2} ovat poistuneet",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} ja {displayName3} ovat poistuneet",unnamedParticipantString:"nimetön osallistuja",manyUnnamedParticipantsJoined:"nimetön osallistuja ja {numOfParticipants} muuta osallistujaa liittyi",manyUnnamedParticipantsLeft:"nimetön osallistuja ja {numOfParticipants} muuta osallistujaa poistuivat",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} ja {numOfParticipants} muuta osallistujaa liittyivät",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} ja {numOfParticipants} muuta osallistujaa poistuivat",liveCaptionsLabel:"Live-tekstitykset",captionsSettingsLabel:"Tekstitysasetukset",startCaptionsButtonOnLabel:"Ota tekstitykset käyttöön",startCaptionsButtonOffLabel:"Poista tekstitykset käytöstä",startCaptionsButtonTooltipOnContent:"Poista tekstitykset käytöstä",startCaptionsButtonTooltipOffContent:"Ota tekstitykset käyttöön",captionsSettingsModalTitle:"Mitä kieltä puhutaan?",captionsSettingsDropdownLabel:"Puhuttu kieli",captionsSettingsDropdownInfoText:"Kieli, jota kaikki tähän puheluun osallistuvat puhuvat.",captionsSettingsConfirmButtonLabel:"Vahvista",captionsSettingsCancelButtonLabel:"Peruuta",captionsSettingsModalAriaLabel:"Tekstitysasetus, modaalinen valintaikkuna",captionsSettingsCloseModalButtonAriaLabel:"Sulje tekstitysasetus",captionsBannerMoreButtonCallingLabel:"Lisää",captionsBannerMoreButtonTooltip:"Lisää vaihtoehtoja",captionsAvailableLanguageStrings:{"ar-ae":"arabia – Arabiemiirikunnat","ar-sa":"arabia – Saudi-Arabia","da-dk":"tanska","de-de":"saksa – Saksa","en-au":"englanti – Australia","en-ca":"englanti – Kanada","en-gb":"englanti – Yhdistynyt kuningaskunta","en-in":"englanti – Intia","en-nz":"englanti – Uusi-Seelanti","en-us":"englanti – Yhdysvallat","es-es":"espanja – Espanja (nykykieli)","es-mx":"espanja – Meksiko","fi-fi":"suomi","fr-ca":"ranska – Kanada","fr-fr":"ranska – Ranska","hi-in":"hindi","it-it":"italia – Italia","ja-jp":"japani","ko-kr":"korea","nb-no":"norja (bokmål)","nl-be":"hollanti – Belgia","nl-nl":"hollanti – Alankomaat","pl-pl":"puola","pt-br":"portugali – Brasilia","ru-ru":"venäjä","sv-se":"ruotsi","zh-cn":"kiina – Kiinan kansantasavalta","zh-hk":"kiina – Hongkong, erityishallintoalue","cs-cz":"tšekki","pt-pt":"portugali – Portugali","tr-tr":"turkki","vi-vn":"vietnam","th-th":"thai","he-il":"heprea","cy-gb":"kymri","uk-ua":"ukraina","el-gr":"kreikka","hu-hu":"unkari","ro-ro":"romania","sk-sk":"slovakki","zh-tw":"kiina – Taiwan"},captionsBannerSpinnerText:"Aloitetaan tekstitystä...",transferPageTransferorText:"Siirretään...",transferPageTransferTargetText:"Yhdistetään...",transferPageUnknownTransferorDisplayName:"Tuntematon",transferPageUnknownTransferTargetDisplayName:"Tuntematon"};var chat$e={chatListHeader:"Tässä keskustelussa",uploadFile:"Lataa tiedosto palvelimeen"};var callWithChat$e={chatButtonLabel:"Keskustelu",chatButtonNewMessageNotificationLabel:"Uusi viesti",chatButtonTooltipClosedWithMessageCount:"Näytä keskustelu ({unreadMessagesCount} lukematonta viestiä)",chatButtonTooltipClose:"Piilota keskustelu",chatButtonTooltipOpen:"Näytä keskustelu",chatPaneTitle:"Keskustelu",copyInviteLinkButtonLabel:"Kopioi kutsulinkki",copyInviteLinkActionedAriaLabel:"Kutsulinkki kopioitu",dismissSidePaneButtonLabel:"Sulje",moreDrawerAudioDeviceMenuTitle:"Äänilaite",moreDrawerButtonLabel:"Lisää vaihtoehtoja",moreDrawerButtonTooltip:"Lisää vaihtoehtoja",moreDrawerMicrophoneMenuTitle:"Mikrofoni",moreDrawerSpeakerMenuTitle:"Kaiutin",moreDrawerCaptionsMenuTitle:"Live-tekstitykset",moreDrawerSpokenLanguageMenuTitle:"Puhuttu kieli",peopleButtonLabel:"Ihmiset",peopleButtonTooltipOpen:"Näytä osallistujat",peopleButtonTooltipClose:"Piilota osallistujat",peoplePaneSubTitle:"Tässä puhelussa",peoplePaneTitle:"Ihmiset",pictureInPictureTileAriaLabel:"Videosyötteet. Palaa puhelunäyttöön napsauttamalla.",removeMenuLabel:"Poista",openDialpadButtonLabel:"Valitse puhelinnumero",returnToCallButtonAriaDescription:"Palaa puheluun",returnToCallButtonAriaLabel:"Takaisin",peoplePaneAddPeopleButtonLabel:"Lisää ihmisiä",dialpadStartCallButtonLabel:"Soita",dialpadModalTitle:"Valitse puhelinnumero",dialpadModalAriaLabel:"Valintapaneeli",dialpadCloseModalButtonAriaLabel:"Sulje valintapaneeli",openDtmfDialpadLabel:"Näytä valintapaneeli",dtmfDialpadPlaceholderText:"Syötä numero"};var fi_FI = {call:call$e,chat:chat$e,callWithChat:callWithChat$e};

var call$d={cameraLabel:"Appareil photo",noCamerasLabel:"Aucune caméra trouvée",cameraPermissionDenied:"Votre navigateur bloque l’accès à votre caméra",cameraTurnedOff:"Votre caméra est désactivée",chatButtonLabel:"Conversation",close:"Fermer",complianceBannerNowOnlyRecording:"Vous n’enregistrez désormais que cette réunion.",complianceBannerNowOnlyTranscription:"À présent, vous ne transcrivez que cette réunion.",complianceBannerRecordingAndTranscriptionSaved:"Sauvegarde en cours de l’enregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStarted:"Démarrage de l’enregistrement et de la transcription.",complianceBannerRecordingAndTranscriptionStopped:"L’enregistrement et la transcription ont pris fin.",complianceBannerRecordingSaving:"Sauvegarde en cours de l'enregistrement.",complianceBannerRecordingStarted:"L’enregistrement a démarré.",complianceBannerRecordingStopped:"L’enregistrement a pris fin.",complianceBannerTranscriptionStarted:"Démarrage de la transcription.",complianceBannerTranscriptionConsent:"En participant, vous autorisez la transcription de cette réunion.",complianceBannerTranscriptionSaving:"Sauvegarde en cours de la transcription.",complianceBannerTranscriptionStopped:"La transcription a pris fin.",configurationPageTitle:"Lancer un appel",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien d’invitation a été copié.",defaultPlaceHolder:"Sélectionnez une option",dismissSidePaneButtonLabel:"Fermer",videoEffectsPaneTitle:"Effets",videoEffectsPaneBackgroundSelectionTitle:"Arrière-plan",configurationPageVideoEffectsButtonLabel:"Effets",unableToStartVideoEffect:"Impossible d’appliquer l’effet vidéo.",blurBackgroundEffectButtonLabel:"Flouter",blurBackgroundTooltip:"Flouter l'arrière-plan",removeBackgroundEffectButtonLabel:"Aucun",removeBackgroundTooltip:"Supprimer l’arrière-plan",cameraOffBackgroundEffectWarningText:"Votre caméra est désactivée. Activez la caméra pour voir l’effet vidéo.",failedToJoinCallDueToNoNetworkMoreDetails:"L’appel a été déconnecté en raison d’un problème réseau. Vérifiez votre connexion et rejoignez-la à nouveau.",failedToJoinCallDueToNoNetworkTitle:"Appel déconnecté",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Vous n’avez pas reçu d’entrée dans l’appel. S’il s’agissait d’une erreur, rejoignez à nouveau l’appel.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Rejeté de la salle d’attente",learnMore:"En savoir plus",leavingCallTitle:"Quitter...",leftCallMoreDetails:"S’il s’agissait d’une erreur, rejoignez à nouveau l’appel.",leftCallTitle:"Vous avez quitté l’appel.",lobbyScreenConnectingToCallTitle:"Connexion à l'appel",lobbyScreenWaitingToBeAdmittedTitle:"En attente d’admission",microphonePermissionDenied:"Votre navigateur bloque l’accès à votre micro",microphoneToggleInLobbyNotAllowed:"Impossible de désactiver ou d’activer le son dans la salle d’attente.",mutedMessage:"Le son de votre micro est désactivé.",networkReconnectMoreDetails:"On dirait qu'une erreur est survenue. Nous tentons de vous reconnecter à l’appel.",networkReconnectTitle:"Patience",deniedPermissionToRoomDetails:"Vous n’êtes pas autorisé à rejoindre cette salle.",deniedPermissionToRoomTitle:"Autorisation refusée pour la salle",peopleButtonLabel:"Personnes",peoplePaneTitle:"Personnes",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Dans cet appel",privacyPolicy:"Politique de confidentialité",rejoinCallButtonLabel:"Rejoindre l’appel à nouveau.",removedFromCallMoreDetails:"Un autre participant vous a supprimé de l’appel.",removedFromCallTitle:"Vous avez été supprimé.",removeMenuLabel:"Supprimer",returnToCallButtonAriaDescription:"Revenir à l’appel",returnToCallButtonAriaLabel:"Précédent",roomNotFoundDetails:"L’ID de salle fourni n’est pas valide.",roomNotFoundTitle:"Salle introuvable",soundLabel:"Son",noMicrophonesLabel:"Aucun microphone trouvé",noSpeakersLabel:"Aucun haut-parleur trouvé",startCallButtonLabel:"Lancer l'appel",openDialpadButtonLabel:"Composer le numéro de téléphone",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numéro de téléphone",dialpadModalAriaLabel:"Pavé numérique",dialpadCloseModalButtonAriaLabel:"Fermer le pavé numérique",moreButtonCallingLabel:"Plus",resumeCallButtonLabel:"Reprendre",resumingCallButtonLabel:"Reprise...",resumeCallButtonAriaLabel:"Reprendre l’appel",resumingCallButtonAriaLabel:"Reprendre l’appel",holdScreenLabel:"Vous avez été mis(e) en attente.",openDtmfDialpadLabel:"Afficher le pavé numérique",dtmfDialpadPlaceholderText:"Saisir un numéro",outboundCallingNoticeString:"Appel en cours...",participantJoinedNoticeString:"{displayName} a rejoint",twoParticipantJoinedNoticeString:"{displayName1} et {displayName2} ont rejoint",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} et {displayName3} ont rejoint",participantLeftNoticeString:"{displayName} a quitté",twoParticipantLeftNoticeString:"{displayName1} et {displayName2} sont partis",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} et {displayName3} ont quitté",unnamedParticipantString:"participant sans nom",manyUnnamedParticipantsJoined:"participant sans nom et {numOfParticipants} autres participants ont rejoint",manyUnnamedParticipantsLeft:"participant sans nom et {numOfParticipants} autres participants ont quitté",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} et {numOfParticipants} autres participants ont rejoint",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} et {numOfParticipants} autres participants restants",liveCaptionsLabel:"Sous-titres en direct",captionsSettingsLabel:"Paramètres de sous-titres",startCaptionsButtonOnLabel:"Activer les sous-titres",startCaptionsButtonOffLabel:"Désactiver les sous-titres",startCaptionsButtonTooltipOnContent:"Désactiver les sous-titres",startCaptionsButtonTooltipOffContent:"Activer les sous-titres",captionsSettingsModalTitle:"Quelle est la langue parlée ?",captionsSettingsDropdownLabel:"Langue parlée",captionsSettingsDropdownInfoText:"Langue parlée par tous les participants à cet appel.",captionsSettingsConfirmButtonLabel:"Confirmer",captionsSettingsCancelButtonLabel:"Annuler",captionsSettingsModalAriaLabel:"Paramétrage des légendes Modal",captionsSettingsCloseModalButtonAriaLabel:"Paramètres de fermeture des sous-titres",captionsBannerMoreButtonCallingLabel:"Plus",captionsBannerMoreButtonTooltip:"Autres options",captionsAvailableLanguageStrings:{"ar-ae":"Arabe – E.A.U.","ar-sa":"Arabe – Arabie saoudite","da-dk":"Danois","de-de":"Allemand – Allemagne","en-au":"Anglais – Australie","en-ca":"Anglais – Canada","en-gb":"Anglais – Royaume-Uni","en-in":"Anglais – Inde","en-nz":"Anglais – Nouvelle-Zélande","en-us":"Anglais – États-Unis","es-es":"Espagnol – Espagne (tri moderne)","es-mx":"Espagnol – Mexique","fi-fi":"Finnois","fr-ca":"Français – Canada","fr-fr":"Français – France","hi-in":"Hindi","it-it":"Italien – Italie","ja-jp":"Japonais","ko-kr":"Coréen","nb-no":"Norvégien (Bokmål)","nl-be":"Néerlandais – Belgique","nl-nl":"Néerlandais – Pays-Bas","pl-pl":"Polonais","pt-br":"Portugais – Brésil","ru-ru":"Russe","sv-se":"Suédois","zh-cn":"Chinois – République populaire de Chine","zh-hk":"Chinois – Hong Kong SAR","cs-cz":"Tchèque","pt-pt":"Portugais – Portugal","tr-tr":"Turc","vi-vn":"Vietnamien","th-th":"Thaï","he-il":"Hébreu","cy-gb":"Gallois","uk-ua":"Ukrainien","el-gr":"Grec","hu-hu":"Hongrois","ro-ro":"Roumain","sk-sk":"Slovaque","zh-tw":"Chinois – Taiwan"},captionsBannerSpinnerText:"Démarrage des sous-titres...",transferPageTransferorText:"Transfert en cours...",transferPageTransferTargetText:"Connexion en cours...",transferPageUnknownTransferorDisplayName:"Inconnu",transferPageUnknownTransferTargetDisplayName:"Inconnu"};var chat$d={chatListHeader:"Dans cette conversation",uploadFile:"Charger un fichier"};var callWithChat$d={chatButtonLabel:"Clavardage",chatButtonNewMessageNotificationLabel:"Nouveau message",chatButtonTooltipClosedWithMessageCount:"Afficher la conversation ({unreadMessagesCount} non lu)",chatButtonTooltipClose:"Masquer la conversation",chatButtonTooltipOpen:"Afficher la conversation",chatPaneTitle:"Clavardage",copyInviteLinkButtonLabel:"Copier le lien d'invitation",copyInviteLinkActionedAriaLabel:"Le lien d’invitation a été copié.",dismissSidePaneButtonLabel:"Fermer",moreDrawerAudioDeviceMenuTitle:"Périphérique audio",moreDrawerButtonLabel:"Autres options",moreDrawerButtonTooltip:"Autres options",moreDrawerMicrophoneMenuTitle:"Microphone",moreDrawerSpeakerMenuTitle:"Haut-parleur",moreDrawerCaptionsMenuTitle:"Sous-titres en direct",moreDrawerSpokenLanguageMenuTitle:"Langue parlée",peopleButtonLabel:"Personnes",peopleButtonTooltipOpen:"Afficher les participants",peopleButtonTooltipClose:"Masquer les participants",peoplePaneSubTitle:"Pendant cet appel",peoplePaneTitle:"Personnes",pictureInPictureTileAriaLabel:"Flux vidéo. Cliquez pour revenir à l’écran d’appel.",removeMenuLabel:"Supprimer",openDialpadButtonLabel:"Composer le numéro de téléphone",returnToCallButtonAriaDescription:"Revenir à l’appel",returnToCallButtonAriaLabel:"Précédent",peoplePaneAddPeopleButtonLabel:"Ajouter des personnes",dialpadStartCallButtonLabel:"Appeler",dialpadModalTitle:"Composer le numéro de téléphone",dialpadModalAriaLabel:"Pavé numérique",dialpadCloseModalButtonAriaLabel:"Fermer le pavé numérique",openDtmfDialpadLabel:"Afficher le pavé numérique",dtmfDialpadPlaceholderText:"Saisir un numéro"};var fr_FR = {call:call$d,chat:chat$d,callWithChat:callWithChat$d};

var call$c={cameraLabel:"מצלמה",noCamerasLabel:"לא נמצאו מצלמות",cameraPermissionDenied:"הדפדפן שלך חוסם את הגישה למצלמה שלך",cameraTurnedOff:"המצלמה שלך כבויה",chatButtonLabel:"צ'אט",close:"סגור",complianceBannerNowOnlyRecording:"אתה כעת רק מקליט את הפגישה.",complianceBannerNowOnlyTranscription:"אתה רק מתעתק את הפגישה כעת.",complianceBannerRecordingAndTranscriptionSaved:"ההקלטה והתמלול בתהליך שמירה.",complianceBannerRecordingAndTranscriptionStarted:"הקלטה ותמלול התחילו.",complianceBannerRecordingAndTranscriptionStopped:"ההקלטה והתמלול הופסקו.",complianceBannerRecordingSaving:"ההקלטה נשמרת.",complianceBannerRecordingStarted:"ההקלטה התחילה.",complianceBannerRecordingStopped:"ההקלטה הופסקה.",complianceBannerTranscriptionStarted:"התמלול התחיל.",complianceBannerTranscriptionConsent:"על-ידי הצטרפות, אתה נותן הסכמה לתעתק פגישה זו.",complianceBannerTranscriptionSaving:"מתבצע תהליך שמירה של התמלול.",complianceBannerTranscriptionStopped:"התמלול הופסק.",configurationPageTitle:"התחל שיחה",copyInviteLinkButtonLabel:"העתק קישור להזמנה",copyInviteLinkActionedAriaLabel:"קישור ההזמנה הועתק",defaultPlaceHolder:"בחר אפשרות",dismissSidePaneButtonLabel:"סגור",videoEffectsPaneTitle:"אפקטים",videoEffectsPaneBackgroundSelectionTitle:"רקע",configurationPageVideoEffectsButtonLabel:"אפקטים",unableToStartVideoEffect:"לא ניתן להחיל אפקט וידאו.",blurBackgroundEffectButtonLabel:"טשטוש",blurBackgroundTooltip:"טשטש רקע",removeBackgroundEffectButtonLabel:"ללא",removeBackgroundTooltip:"הסר רקע",cameraOffBackgroundEffectWarningText:"המצלמה שלך כבויה. הפעל מצלמה כדי לראות את אפקט הווידאו.",failedToJoinCallDueToNoNetworkMoreDetails:"השיחה נותקה עקב בעיית רשת. בדוק את החיבור שלך והצטרף שוב.",failedToJoinCallDueToNoNetworkTitle:"‏‏השיחה נותקה",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"לא הוענקה לך כניסה בשיחה. אם זו היתה טעות, הצטרף מחדש לשיחה.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"הוצא מחדר הכניסה",learnMore:"למידע נוסף",leavingCallTitle:"עוזב...",leftCallMoreDetails:"אם זו היתה טעות, הצטרף מחדש לשיחה.",leftCallTitle:"עזבת את הצ'אט",lobbyScreenConnectingToCallTitle:"מצטרף לשיחה",lobbyScreenWaitingToBeAdmittedTitle:"ממתין לאישור כניסה",microphonePermissionDenied:"הדפדפן שלך חוסם את הגישה למיקרופון שלך",microphoneToggleInLobbyNotAllowed:"אין אפשרות להשתיק או לבטל השתקה בחדר הכניסה.",mutedMessage:"אתה מושתק",networkReconnectMoreDetails:"נראה שמשהו השתבש. אנו מנסים להיכנס שוב לשיחה.",networkReconnectTitle:"המתן",deniedPermissionToRoomDetails:"אין לך הרשאה להצטרף לחדר זה.",deniedPermissionToRoomTitle:"ההרשאה לחדר נדחתה",peopleButtonLabel:"אנשים",peoplePaneTitle:"אנשים",peopleButtonTooltipOpen:"הצג משתתפים",peopleButtonTooltipClose:"הסתר משתתפים",peoplePaneSubTitle:"בשיחה זו",privacyPolicy:"מדיניות פרטיות",rejoinCallButtonLabel:"הצטרף לשיחה מחדש",removedFromCallMoreDetails:"משתתף אחר הסיר אותך מהשיחה.",removedFromCallTitle:"הוסרת",removeMenuLabel:"הסר",returnToCallButtonAriaDescription:"חזור לשיחה",returnToCallButtonAriaLabel:"הקודם",roomNotFoundDetails:"מזהה החדר שסופק אינו חוקי.",roomNotFoundTitle:"החדר לא נמצא",soundLabel:"צליל",noMicrophonesLabel:"לא נמצאו מיקרופונים",noSpeakersLabel:"לא נמצאו רמקולים",startCallButtonLabel:"התחל שיחה",openDialpadButtonLabel:"חייג למספר הטלפון",peoplePaneAddPeopleButtonLabel:"הוסף אנשים",dialpadStartCallButtonLabel:"שיחה",dialpadModalTitle:"חייג למספר הטלפון",dialpadModalAriaLabel:"לוח חיוג",dialpadCloseModalButtonAriaLabel:"סגור לוח חיוג",moreButtonCallingLabel:"עוד",resumeCallButtonLabel:"המשך",resumingCallButtonLabel:"מחדש...",resumeCallButtonAriaLabel:"חדש שיחה",resumingCallButtonAriaLabel:"חדש שיחה",holdScreenLabel:"אתה בהמתנה",openDtmfDialpadLabel:"הצג לוח חיוג",dtmfDialpadPlaceholderText:"הזן מספר",outboundCallingNoticeString:"מתקשר...",participantJoinedNoticeString:"{displayName} הצטרף/ה",twoParticipantJoinedNoticeString:"{displayName1} ו{displayName2} הצטרפו",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} ו{displayName3} עזבו",participantLeftNoticeString:"{displayName} עזב/ה",twoParticipantLeftNoticeString:"{displayName1} ו{displayName2} עזבו",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} ו{displayName3} עזבו",unnamedParticipantString:"משתתף/ת ללא שם",manyUnnamedParticipantsJoined:"משתתף/ת ללא שם ו{numOfParticipants} משתתפים אחרים הצטרפו",manyUnnamedParticipantsLeft:"משתתף/ת ללא שם ו{numOfParticipants} משתתפים אחרים",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} ו{numOfParticipants} משתתפים אחרים הצטרפו",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} ו{numOfParticipants} משתתפים אחרים נותרו",liveCaptionsLabel:"כתוביות חיות",captionsSettingsLabel:"הגדרות כתוביות",startCaptionsButtonOnLabel:"הפעל כתוביות",startCaptionsButtonOffLabel:"כבה כתוביות",startCaptionsButtonTooltipOnContent:"כבה כתוביות",startCaptionsButtonTooltipOffContent:"הפעל כתוביות",captionsSettingsModalTitle:"איזו שפה מדוברת?",captionsSettingsDropdownLabel:"שפה מדוברת",captionsSettingsDropdownInfoText:"השפה שכולם בשיחה זו מדברים.",captionsSettingsConfirmButtonLabel:"אשר",captionsSettingsCancelButtonLabel:"ביטול",captionsSettingsModalAriaLabel:"מודאל הגדרת כתוביות",captionsSettingsCloseModalButtonAriaLabel:"סגור הגדרת כתוביות",captionsBannerMoreButtonCallingLabel:"עוד",captionsBannerMoreButtonTooltip:"אפשרויות נוספות",captionsAvailableLanguageStrings:{"ar-ae":"ערבית - איחוד האמירויות","ar-sa":"ערבית - ערב הסעודית","da-dk":"דנית","de-de":"גרמנית - גרמניה","en-au":"אנגלית - אוסטרליה","en-ca":"אנגלית - קנדה","en-gb":"אנגלית - בריטניה","en-in":"אנגלית - הודו","en-nz":"אנגלית - ניו זילנד","en-us":"אנגלית - ארצות הברית","es-es":"ספרדית - ספרד (ספרדית מודרנית)","es-mx":"ספרדית - מקסיקו","fi-fi":"פינית","fr-ca":"צרפתית - קנדה","fr-fr":"צרפתית - צרפת","hi-in":"הינדי","it-it":"איטלקית - איטליה","ja-jp":"יפנית","ko-kr":"קוריאנית","nb-no":"נורווגית (בוּקמוֹל)","nl-be":"הולנדית - בלגיה","nl-nl":"הולנדית - הולנד","pl-pl":"פולנית","pt-br":"פורטוגזית - ברזיל","ru-ru":"רוסית","sv-se":"שוודית","zh-cn":"סינית - הרפובליקה העממית של סין","zh-hk":"סינית - הונג קונג","cs-cz":"צ׳כית","pt-pt":"פורטוגזית - פורטוגל","tr-tr":"טורקית","vi-vn":"וייטנאמית","th-th":"תאית","he-il":"עברית","cy-gb":"וולשית","uk-ua":"אוקראינית","el-gr":"יוונית","hu-hu":"הונגרית","ro-ro":"רומנית","sk-sk":"סלובקית","zh-tw":"סינית - טייוואן"},captionsBannerSpinnerText:"מאתחל כתוביות...",transferPageTransferorText:"מעביר...",transferPageTransferTargetText:"מתחבר...",transferPageUnknownTransferorDisplayName:"לא ידוע",transferPageUnknownTransferTargetDisplayName:"לא ידוע"};var chat$c={chatListHeader:"בצ'אט זה",uploadFile:"העלה קובץ"};var callWithChat$c={chatButtonLabel:"צ'אט",chatButtonNewMessageNotificationLabel:"הודעה חדשה",chatButtonTooltipClosedWithMessageCount:"הצג צ'אט ({unreadMessagesCount} שלא נקראו)",chatButtonTooltipClose:"הסתר צ׳אט",chatButtonTooltipOpen:"הצג צ'אט",chatPaneTitle:"צ'אט",copyInviteLinkButtonLabel:"העתק קישור להזמנה",copyInviteLinkActionedAriaLabel:"קישור ההזמנה הועתק",dismissSidePaneButtonLabel:"סגור",moreDrawerAudioDeviceMenuTitle:"התקן שמע",moreDrawerButtonLabel:"אפשרויות נוספות",moreDrawerButtonTooltip:"אפשרויות נוספות",moreDrawerMicrophoneMenuTitle:"מיקרופון",moreDrawerSpeakerMenuTitle:"רמקול",moreDrawerCaptionsMenuTitle:"כתוביות חיות",moreDrawerSpokenLanguageMenuTitle:"שפה מדוברת",peopleButtonLabel:"אנשים",peopleButtonTooltipOpen:"הצג משתתפים",peopleButtonTooltipClose:"הסתר משתתפים",peoplePaneSubTitle:"בשיחה זו",peoplePaneTitle:"אנשים",pictureInPictureTileAriaLabel:"הזנות וידאו. לחץ כדי לחזור למסך השיחה.",removeMenuLabel:"הסר",openDialpadButtonLabel:"חייג למספר הטלפון",returnToCallButtonAriaDescription:"חזור לשיחה",returnToCallButtonAriaLabel:"הקודם",peoplePaneAddPeopleButtonLabel:"הוסף אנשים",dialpadStartCallButtonLabel:"שיחה",dialpadModalTitle:"חייג למספר הטלפון",dialpadModalAriaLabel:"לוח חיוג",dialpadCloseModalButtonAriaLabel:"סגור לוח חיוג",openDtmfDialpadLabel:"הצג לוח חיוג",dtmfDialpadPlaceholderText:"הזן מספר"};var he_IL = {call:call$c,chat:chat$c,callWithChat:callWithChat$c};

var call$b={cameraLabel:"Fotocamera",noCamerasLabel:"Nessuna fotocamera trovata",cameraPermissionDenied:"Il browser blocca l'accesso alla fotocamera",cameraTurnedOff:"La videocamera è disabilitata",chatButtonLabel:"Chat",close:"Chiudi",complianceBannerNowOnlyRecording:"È in corso la registrazione solo di questa riunione.",complianceBannerNowOnlyTranscription:"È in corso la trascrizione solo di questa riunione.",complianceBannerRecordingAndTranscriptionSaved:"È in corso il salvataggio della registrazione e della trascrizione.",complianceBannerRecordingAndTranscriptionStarted:"Registrazione e trascrizione avviate.",complianceBannerRecordingAndTranscriptionStopped:"Registrazione e trascrizione interrotte.",complianceBannerRecordingSaving:"Salvataggio della registrazione in corso.",complianceBannerRecordingStarted:"Registrazione avviata.",complianceBannerRecordingStopped:"Registrazione arrestata.",complianceBannerTranscriptionStarted:"Trascrizione avviata.",complianceBannerTranscriptionConsent:"Partecipando, fornisci il consenso per la trascrizione di questa riunione.",complianceBannerTranscriptionSaving:"È in corso il salvataggio della trascrizione.",complianceBannerTranscriptionStopped:"Trascrizione interrotta.",configurationPageTitle:"Avvia una chiamata",copyInviteLinkButtonLabel:"Copia il collegamento dell’invito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",defaultPlaceHolder:"Seleziona un'opzione",dismissSidePaneButtonLabel:"Chiudi",videoEffectsPaneTitle:"Effetti",videoEffectsPaneBackgroundSelectionTitle:"In background",configurationPageVideoEffectsButtonLabel:"Effetti",unableToStartVideoEffect:"Non è possibile applicare l'effetto video.",blurBackgroundEffectButtonLabel:"Sfocatura",blurBackgroundTooltip:"Sfoca sfondo",removeBackgroundEffectButtonLabel:"Nessuno",removeBackgroundTooltip:"Rimuovi sfondo",cameraOffBackgroundEffectWarningText:"La fotocamera è disattivata. Attiva la fotocamera per vedere l'effetto video.",failedToJoinCallDueToNoNetworkMoreDetails:"La chiamata è stata disconnessa a causa di un problema di rete. Controlla la connessione e partecipa di nuovo.",failedToJoinCallDueToNoNetworkTitle:"Chiamata interrotta",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Non ti è stato concesso l’accesso alla chiamata. Se si è trattato di un errore, partecipa di nuovo alla chiamata.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorato dalla sala di attesa",learnMore:"Ulteriori informazioni",leavingCallTitle:"In uscita...",leftCallMoreDetails:"Se si è trattato di un errore, partecipa di nuovo alla chiamata.",leftCallTitle:"Hai abbandonato la chiamata",lobbyScreenConnectingToCallTitle:"Partecipazione alla chiamata",lobbyScreenWaitingToBeAdmittedTitle:"In attesa di essere ammessi",microphonePermissionDenied:"Il browser blocca l'accesso al microfono",microphoneToggleInLobbyNotAllowed:"Impossibile attivare o disattivare l'audio nella sala di attesa.",mutedMessage:"L'audio è disattivato.",networkReconnectMoreDetails:"Sembra si sia verificato un errore. Stiamo cercando di ristabilire la connessione alla chiamata.",networkReconnectTitle:"Attendi",deniedPermissionToRoomDetails:"Non si dispone dell'autorizzazione per partecipare a questa stanza.",deniedPermissionToRoomTitle:"Autorizzazione negata alla stanza",peopleButtonLabel:"Persone",peoplePaneTitle:"Persone",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata",privacyPolicy:"Informativa sulla privacy",rejoinCallButtonLabel:"Partecipa alla chiamata",removedFromCallMoreDetails:"Un altro partecipante ti ha rimosso dalla chiamata.",removedFromCallTitle:"Sei stato rimosso",removeMenuLabel:"Rimuovi",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",roomNotFoundDetails:"L'ID sala specificato non è valido.",roomNotFoundTitle:"La stanza non è stata trovata",soundLabel:"Suono",noMicrophonesLabel:"Nessun microfono trovato",noSpeakersLabel:"Nessun altoparlante trovato",startCallButtonLabel:"Avvia chiamata",openDialpadButtonLabel:"Componi il numero di telefono",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",moreButtonCallingLabel:"Altro",resumeCallButtonLabel:"Riprendi",resumingCallButtonLabel:"Ripresa in corso...",resumeCallButtonAriaLabel:"Riprendi chiamata",resumingCallButtonAriaLabel:"Riprendi chiamata",holdScreenLabel:"In attesa.",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero",outboundCallingNoticeString:"Chiamata in corso...",participantJoinedNoticeString:"{displayName} si è unito alla riunione",twoParticipantJoinedNoticeString:"{displayName1} e {displayName2} si sono uniti alla riunione",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} e {displayName3} si sono uniti alla riunione",participantLeftNoticeString:"{displayName} è uscito dalla riunione",twoParticipantLeftNoticeString:"{displayName1} e {displayName2} sono usciti dalla riunione",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} e {displayName3} sono usciti dalla riunione",unnamedParticipantString:"partecipante senza nome",manyUnnamedParticipantsJoined:"partecipante senza nome e {numOfParticipants} altri partecipanti si sono uniti alla riunione",manyUnnamedParticipantsLeft:"partecipante senza nome e {numOfParticipants} altri partecipanti sono usciti dalla riunione",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} altri partecipanti si sono uniti",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} altri partecipanti rimasti",liveCaptionsLabel:"Sottotitoli in tempo reale",captionsSettingsLabel:"Impostazioni sottotitoli",startCaptionsButtonOnLabel:"Attiva i sottotitoli",startCaptionsButtonOffLabel:"Disabilita sottotitoli",startCaptionsButtonTooltipOnContent:"Disabilita sottotitoli",startCaptionsButtonTooltipOffContent:"Attiva i sottotitoli",captionsSettingsModalTitle:"Che lingua si parla?",captionsSettingsDropdownLabel:"Lingua parlata",captionsSettingsDropdownInfoText:"La lingua che parlano tutti i partecipanti a questa chiamata.",captionsSettingsConfirmButtonLabel:"Conferma",captionsSettingsCancelButtonLabel:"Annulla",captionsSettingsModalAriaLabel:"Finestra modale impostazioni sottotitoli",captionsSettingsCloseModalButtonAriaLabel:"Chiudi impostazione sottotitoli",captionsBannerMoreButtonCallingLabel:"Altro",captionsBannerMoreButtonTooltip:"Altre opzioni",captionsAvailableLanguageStrings:{"ar-ae":"Arabo - Emirati Arabi Uniti","ar-sa":"Arabo - Arabia Saudita","da-dk":"Danese","de-de":"Tedesco - Germania","en-au":"Inglese - Australia","en-ca":"Inglese - Canada","en-gb":"Inglese - Regno Unito","en-in":"Inglese - India","en-nz":"Inglese - Nuova Zelanda","en-us":"Inglese - Stati Uniti","es-es":"Spagnolo - Spagna (ordinamento moderno)","es-mx":"Spagnolo - Messico","fi-fi":"Finlandese","fr-ca":"Francese - Canada","fr-fr":"Francese - Francia","hi-in":"Hindi","it-it":"Italiano - Italia","ja-jp":"Giapponese","ko-kr":"Coreano","nb-no":"Norvegese (Bokmål)","nl-be":"Olandese - Belgio","nl-nl":"Olandese - Paesi Bassi","pl-pl":"Polacco","pt-br":"Portoghese - Brasile","ru-ru":"Russo","sv-se":"Svedese","zh-cn":"Cinese - Repubblica popolare cinese","zh-hk":"Cinese - Hong Kong R.A.S.","cs-cz":"Ceco","pt-pt":"Portoghese - Portogallo","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Thailandese","he-il":"Ebraico","cy-gb":"Gallese","uk-ua":"Ucraino","el-gr":"Greco","hu-hu":"Ungherese","ro-ro":"Rumeno","sk-sk":"Slovacco","zh-tw":"Cinese - Taiwan"},captionsBannerSpinnerText:"Avvio dei sottotitoli in corso...",transferPageTransferorText:"Trasferimento in corso...",transferPageTransferTargetText:"Connessione in corso...",transferPageUnknownTransferorDisplayName:"Sconosciuto",transferPageUnknownTransferTargetDisplayName:"Sconosciuto"};var chat$b={chatListHeader:"In questa chat",uploadFile:"Carica file"};var callWithChat$b={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nuovo messaggio",chatButtonTooltipClosedWithMessageCount:"Mostra chat ({unreadMessagesCount} non letto)",chatButtonTooltipClose:"Nascondi chat",chatButtonTooltipOpen:"Mostra chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copia il collegamento dell’invito",copyInviteLinkActionedAriaLabel:"Collegamento di invito copiato",dismissSidePaneButtonLabel:"Chiudi",moreDrawerAudioDeviceMenuTitle:"Dispositivo audio",moreDrawerButtonLabel:"Altre opzioni",moreDrawerButtonTooltip:"Altre opzioni",moreDrawerMicrophoneMenuTitle:"Microfono",moreDrawerSpeakerMenuTitle:"Altoparlante",moreDrawerCaptionsMenuTitle:"Sottotitoli in tempo reale",moreDrawerSpokenLanguageMenuTitle:"Lingua parlata",peopleButtonLabel:"Persone",peopleButtonTooltipOpen:"Mostra partecipanti",peopleButtonTooltipClose:"Nascondi partecipanti",peoplePaneSubTitle:"In questa chiamata",peoplePaneTitle:"Persone",pictureInPictureTileAriaLabel:"Feed video. Fare clic per tornare alla schermata della chiamata.",removeMenuLabel:"Rimuovi",openDialpadButtonLabel:"Componi il numero di telefono",returnToCallButtonAriaDescription:"Torna alla chiamata",returnToCallButtonAriaLabel:"Indietro",peoplePaneAddPeopleButtonLabel:"Aggiungi persone",dialpadStartCallButtonLabel:"Chiamata",dialpadModalTitle:"Componi il numero di telefono",dialpadModalAriaLabel:"Tastiera",dialpadCloseModalButtonAriaLabel:"Chiudi tastiera",openDtmfDialpadLabel:"Mostra tastiera",dtmfDialpadPlaceholderText:"Immetti il numero"};var it_IT = {call:call$b,chat:chat$b,callWithChat:callWithChat$b};

var call$a={cameraLabel:"カメラ",noCamerasLabel:"カメラが見つかりません",cameraPermissionDenied:"お使いのブラウザーがカメラへのアクセスをブロックしています",cameraTurnedOff:"カメラはオフになっています",chatButtonLabel:"チャット",close:"閉じる",complianceBannerNowOnlyRecording:"今はこの会議の録画のみを行っています。",complianceBannerNowOnlyTranscription:"この会議のトランスクリプトを作成しています。",complianceBannerRecordingAndTranscriptionSaved:"レコーディングとトランスクリプトを保存されました。",complianceBannerRecordingAndTranscriptionStarted:"レコーディングとトランスクリプトが開始されました。",complianceBannerRecordingAndTranscriptionStopped:"レコーディングとトランスクリプトを停止しました。",complianceBannerRecordingSaving:"レコーディングを保存しています。",complianceBannerRecordingStarted:"レコーディングを開始しました。",complianceBannerRecordingStopped:"レコーディングを停止しました。",complianceBannerTranscriptionStarted:"トランスクリプトが開始しました。",complianceBannerTranscriptionConsent:"参加すると、この会議のトランスクリプトの作成に同意したことになります。",complianceBannerTranscriptionSaving:"トランスクリプトを保存されました。",complianceBannerTranscriptionStopped:"トランスクリプトが停止しました。",configurationPageTitle:"通話を開始",copyInviteLinkButtonLabel:"招待用のリンクをコピー",copyInviteLinkActionedAriaLabel:"招待用のリンクがコピーされました",defaultPlaceHolder:"オプションを選択する",dismissSidePaneButtonLabel:"閉じる",videoEffectsPaneTitle:"効果",videoEffectsPaneBackgroundSelectionTitle:"バックグラウンド",configurationPageVideoEffectsButtonLabel:"効果",unableToStartVideoEffect:"ビデオ効果を適用できません。",blurBackgroundEffectButtonLabel:"ぼかし",blurBackgroundTooltip:"背景をぼかす",removeBackgroundEffectButtonLabel:"なし",removeBackgroundTooltip:"背景の削除",cameraOffBackgroundEffectWarningText:"カメラがオフになっています。カメラをオンにすると、ビデオ効果が表示されます。",failedToJoinCallDueToNoNetworkMoreDetails:"ネットワークの問題により、通話が切断されました。接続を確認して、もう一度参加してください。",failedToJoinCallDueToNoNetworkTitle:"通話が切断されました",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"通話のエントリが許可されませんでした。これが間違いだった場合は、通話に再参加してください。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"ロビーから消去しました",learnMore:"詳細情報",leavingCallTitle:"退出中...",leftCallMoreDetails:"これが間違いだった場合は、通話に再度参加してください。",leftCallTitle:"通話を終了しました",lobbyScreenConnectingToCallTitle:"通話に参加中",lobbyScreenWaitingToBeAdmittedTitle:"承認待機中",microphonePermissionDenied:"お使いのブラウザーがマイクへのアクセスをブロックしています",microphoneToggleInLobbyNotAllowed:"ロビーにいる間はミュートまたはミュート解除できません。",mutedMessage:"ミュートになっています",networkReconnectMoreDetails:"問題が発生したようです。通話に戻ろうとしています。",networkReconnectTitle:"お待ちください",deniedPermissionToRoomDetails:"このルームに参加するためのアクセス許可がありません。",deniedPermissionToRoomTitle:"ルームによるアクセス拒否",peopleButtonLabel:"連絡先",peoplePaneTitle:"連絡先",peopleButtonTooltipOpen:"参加者を表示",peopleButtonTooltipClose:"参加者を非表示",peoplePaneSubTitle:"通話中",privacyPolicy:"プライバシー ポリシー",rejoinCallButtonLabel:"通話に再度参加",removedFromCallMoreDetails:"別の参加者があなたを通話から削除しました。",removedFromCallTitle:"削除されました",removeMenuLabel:"削除",returnToCallButtonAriaDescription:"通話に戻る",returnToCallButtonAriaLabel:"戻る",roomNotFoundDetails:"指定されたルーム ID が無効です。",roomNotFoundTitle:"ルームが見つかりません",soundLabel:"音声",noMicrophonesLabel:"マイクが見つかりません",noSpeakersLabel:"話者が見つかりません",startCallButtonLabel:"通話を開始",openDialpadButtonLabel:"電話番号をダイヤルする",peoplePaneAddPeopleButtonLabel:"ユーザーの追加",dialpadStartCallButtonLabel:"通話",dialpadModalTitle:"電話番号をダイヤルする",dialpadModalAriaLabel:"ダイヤルパッド",dialpadCloseModalButtonAriaLabel:"ダイヤルパッドを閉じる",moreButtonCallingLabel:"その他",resumeCallButtonLabel:"再開",resumingCallButtonLabel:"再開しています...",resumeCallButtonAriaLabel:"通話の再開",resumingCallButtonAriaLabel:"通話の再開",holdScreenLabel:"保留中です",openDtmfDialpadLabel:"ダイヤルパッドを表示",dtmfDialpadPlaceholderText:"番号を入力してください",outboundCallingNoticeString:"呼び出し中。。。",participantJoinedNoticeString:"{displayName} が参加しました",twoParticipantJoinedNoticeString:"{displayName1} さんと {displayName2} さんが参加しました",threeParticipantJoinedNoticeString:"{displayName1} さん, {displayName2} さんと {displayName3} さんが参加しました",participantLeftNoticeString:"{displayName} さんが退出しました",twoParticipantLeftNoticeString:"{displayName1} さんと {displayName2} さんが退出しました",threeParticipantLeftNoticeString:"{displayName1} さん, {displayName2} さんと {displayName3} さんが退出しました",unnamedParticipantString:"名前のない参加者",manyUnnamedParticipantsJoined:"名前のない参加者と他の参加者 {numOfParticipants} 人が参加しました",manyUnnamedParticipantsLeft:"名前のない参加者と他の参加者 {numOfParticipants} 人が退出しました",manyParticipantsJoined:"{displayName1}、{displayName2}、{displayName3}、その他の参加者{numOfParticipants}参加しました",manyParticipantsLeft:"{displayName1}、{displayName2}、{displayName3}、その他の参加者{numOfParticipants}退出しました",liveCaptionsLabel:"ライブ キャプション",captionsSettingsLabel:"字幕の設定",startCaptionsButtonOnLabel:"キャプションをオンにする",startCaptionsButtonOffLabel:"キャプションをオフにする",startCaptionsButtonTooltipOnContent:"キャプションをオフにする",startCaptionsButtonTooltipOffContent:"キャプションをオンにする",captionsSettingsModalTitle:"どの言語が話されていますか?",captionsSettingsDropdownLabel:"音声言語",captionsSettingsDropdownInfoText:"この通話の全員が話している言語です。",captionsSettingsConfirmButtonLabel:"確認",captionsSettingsCancelButtonLabel:"キャンセル",captionsSettingsModalAriaLabel:"字幕設定モーダル",captionsSettingsCloseModalButtonAriaLabel:"字幕設定を閉じる",captionsBannerMoreButtonCallingLabel:"その他",captionsBannerMoreButtonTooltip:"その他のオプション",captionsAvailableLanguageStrings:{"ar-ae":"アラビア語 - U.A.E.","ar-sa":"アラビア語 - サウジアラビア","da-dk":"デンマーク語","de-de":"ドイツ語 - ドイツ","en-au":"英語 - オーストラリア","en-ca":"英語 - カナダ","en-gb":"英語 - イギリス","en-in":"英語 - インド","en-nz":"英語 - ニュージーランド","en-us":"英語 - 米国","es-es":"スペイン語 - スペイン (モダン)","es-mx":"スペイン語 - メキシコ","fi-fi":"フィンランド語","fr-ca":"フランス語 - カナダ","fr-fr":"フランス語 - フランス","hi-in":"ヒンディー語","it-it":"イタリア語 - イタリア","ja-jp":"日本語","ko-kr":"韓国語","nb-no":"ノルウェー語 (ブークモール)","nl-be":"オランダ語 - ベルギー","nl-nl":"オランダ語 - オランダ","pl-pl":"ポーランド語","pt-br":"ポルトガル語 - ブラジル","ru-ru":"ロシア語","sv-se":"スウェーデン語","zh-cn":"中国語 - 中国","zh-hk":"中国語 - 香港特別行政区","cs-cz":"チェコ語","pt-pt":"ポルトガル語 - ポルトガル","tr-tr":"トルコ語","vi-vn":"ベトナム語","th-th":"タイ語","he-il":"ヘブライ語","cy-gb":"ウェールズ語","uk-ua":"ウクライナ語","el-gr":"ギリシャ語","hu-hu":"ハンガリー語","ro-ro":"ルーマニア語","sk-sk":"スロバキア語","zh-tw":"中国語 - 台湾"},captionsBannerSpinnerText:"キャプションを開始しています...",transferPageTransferorText:"転送しています...",transferPageTransferTargetText:"接続中...",transferPageUnknownTransferorDisplayName:"不明",transferPageUnknownTransferTargetDisplayName:"不明"};var chat$a={chatListHeader:"このチャット内",uploadFile:"ファイルのアップロード"};var callWithChat$a={chatButtonLabel:"チャット",chatButtonNewMessageNotificationLabel:"新規メッセージ",chatButtonTooltipClosedWithMessageCount:"チャットを表示する ({unreadMessagesCount} 件の未読)",chatButtonTooltipClose:"チャットを非表示",chatButtonTooltipOpen:"チャットを表示",chatPaneTitle:"チャット",copyInviteLinkButtonLabel:"招待用のリンクをコピー",copyInviteLinkActionedAriaLabel:"招待用のリンクがコピーされました",dismissSidePaneButtonLabel:"閉じる",moreDrawerAudioDeviceMenuTitle:"オーディオ デバイス",moreDrawerButtonLabel:"その他のオプション",moreDrawerButtonTooltip:"その他のオプション",moreDrawerMicrophoneMenuTitle:"マイク",moreDrawerSpeakerMenuTitle:"スピーカー",moreDrawerCaptionsMenuTitle:"ライブ キャプション",moreDrawerSpokenLanguageMenuTitle:"音声言語",peopleButtonLabel:"ユーザー",peopleButtonTooltipOpen:"参加者を表示",peopleButtonTooltipClose:"参加者を非表示",peoplePaneSubTitle:"この通話で",peoplePaneTitle:"ユーザー",pictureInPictureTileAriaLabel:"ビデオ フィード。 クリックすると通話画面に戻ります。",removeMenuLabel:"削除",openDialpadButtonLabel:"電話番号をダイヤルする",returnToCallButtonAriaDescription:"通話に戻る",returnToCallButtonAriaLabel:"戻る",peoplePaneAddPeopleButtonLabel:"ユーザーの追加",dialpadStartCallButtonLabel:"通話",dialpadModalTitle:"電話番号をダイヤルする",dialpadModalAriaLabel:"ダイヤルパッド",dialpadCloseModalButtonAriaLabel:"ダイヤルパッドを閉じる",openDtmfDialpadLabel:"ダイヤルパッドを表示",dtmfDialpadPlaceholderText:"番号を入力してください"};var ja_JP = {call:call$a,chat:chat$a,callWithChat:callWithChat$a};

var call$9={cameraLabel:"카메라",noCamerasLabel:"카메라를 찾을 수 없음",cameraPermissionDenied:"브라우저에서 카메라에 대한 액세스를 차단하고 있습니다.",cameraTurnedOff:"카메라가 꺼져 있음",chatButtonLabel:"채팅",close:"닫기",complianceBannerNowOnlyRecording:"이제 이 모임의 녹음/녹화만 진행합니다.",complianceBannerNowOnlyTranscription:"이제 이 모임의 전사만 진행합니다.",complianceBannerRecordingAndTranscriptionSaved:"녹음/녹화와 전사를 저장하는 중입니다.",complianceBannerRecordingAndTranscriptionStarted:"녹음/녹화와 전사를 시작했습니다.",complianceBannerRecordingAndTranscriptionStopped:"녹음/녹화와 전사를 중단했습니다.",complianceBannerRecordingSaving:"녹음/녹화를 저장하는 중입니다.",complianceBannerRecordingStarted:"녹음/녹화를 시작했습니다.",complianceBannerRecordingStopped:"녹음/녹화를 중단했습니다.",complianceBannerTranscriptionStarted:"전사를 시작했습니다.",complianceBannerTranscriptionConsent:"참가하면 이 모임이 전사되는 것에 동의하게 됩니다.",complianceBannerTranscriptionSaving:"전사를 저장하는 중입니다.",complianceBannerTranscriptionStopped:"전사를 중단했습니다.",configurationPageTitle:"통화 시작",copyInviteLinkButtonLabel:"초대 링크 복사",copyInviteLinkActionedAriaLabel:"초대 링크를 복사함",defaultPlaceHolder:"옵션 선택",dismissSidePaneButtonLabel:"닫기",videoEffectsPaneTitle:"효과",videoEffectsPaneBackgroundSelectionTitle:"백그라운드",configurationPageVideoEffectsButtonLabel:"효과",unableToStartVideoEffect:"비디오 효과를 적용할 수 없습니다.",blurBackgroundEffectButtonLabel:"흐리기",blurBackgroundTooltip:"배경 흐리게",removeBackgroundEffectButtonLabel:"없음",removeBackgroundTooltip:"배경 제거",cameraOffBackgroundEffectWarningText:"카메라가 꺼져 있습니다. 비디오 효과를 보려면 카메라를 켜세요.",failedToJoinCallDueToNoNetworkMoreDetails:"네트워크 문제로 인해 통화 연결이 끊어졌습니다. 연결을 확인하고 다시 참가하세요.",failedToJoinCallDueToNoNetworkTitle:"통화 연결 끊김",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"통화에 참가할 수 있는 권한이 없습니다. 실수라면 통화에 다시 참가하세요.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"대기실에서 해제됐습니다.",learnMore:"자세한 정보",leavingCallTitle:"종료 중...",leftCallMoreDetails:"실수라면 통화에 다시 참가하세요.",leftCallTitle:"통화를 종료했습니다.",lobbyScreenConnectingToCallTitle:"통화에 참가",lobbyScreenWaitingToBeAdmittedTitle:"승인을 기다리는 중",microphonePermissionDenied:"브라우저에서 마이크에 대한 액세스를 차단하고 있습니다.",microphoneToggleInLobbyNotAllowed:"대기실에 있는 동안에는 음소거하거나 음소거를 해제할 수 없습니다.",mutedMessage:"음소거 되었습니다.",networkReconnectMoreDetails:"문제가 발생한 것 같습니다. 통화에 다시 연결하려고 합니다.",networkReconnectTitle:"잠시만",deniedPermissionToRoomDetails:"이 채팅방에 참가할 수 있는 권한이 없습니다.",deniedPermissionToRoomTitle:"회의실에 대한 사용 권한이 거부됨",peopleButtonLabel:"사용자",peoplePaneTitle:"사용자",peopleButtonTooltipOpen:"참가자 표시",peopleButtonTooltipClose:"참가자 숨기기",peoplePaneSubTitle:"이 통화에서",privacyPolicy:"개인 정보 취급 방침",rejoinCallButtonLabel:"통화 다시 참가",removedFromCallMoreDetails:"다른 참가자가 귀하를 통화에서 제거했습니다.",removedFromCallTitle:"통화에서 제거됐습니다.",removeMenuLabel:"제거",returnToCallButtonAriaDescription:"통화로 돌아가기",returnToCallButtonAriaLabel:"뒤로",roomNotFoundDetails:"제공된 회의실 ID가 잘못되었습니다.",roomNotFoundTitle:"회의실을 찾을 수 없음",soundLabel:"소리",noMicrophonesLabel:"마이크를 찾을 수 없음",noSpeakersLabel:"스피커를 찾을 수 없음",startCallButtonLabel:"통화 시작",openDialpadButtonLabel:"전화 번호 전화 걸기",peoplePaneAddPeopleButtonLabel:"사용자 추가",dialpadStartCallButtonLabel:"통화",dialpadModalTitle:"전화 번호 전화 걸기",dialpadModalAriaLabel:"다이얼패드",dialpadCloseModalButtonAriaLabel:"다이얼패드 닫기",moreButtonCallingLabel:"기타",resumeCallButtonLabel:"계속",resumingCallButtonLabel:"다시 시작 중...",resumeCallButtonAriaLabel:"통화 다시 시작",resumingCallButtonAriaLabel:"통화 계속하기",holdScreenLabel:"대기 중입니다.",openDtmfDialpadLabel:"다이얼패드 표시",dtmfDialpadPlaceholderText:"번호 입력",outboundCallingNoticeString:"전화 거는 중...",participantJoinedNoticeString:"{displayName} 님이 참가",twoParticipantJoinedNoticeString:"{displayName1} 및 {displayName2} 님이 참가",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} 및 {displayName3} 님이 참가",participantLeftNoticeString:"{displayName} 님이 떠남",twoParticipantLeftNoticeString:"{displayName1} 및 {displayName2} 님이 떠남",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} 및 {displayName3} 님이 떠남",unnamedParticipantString:"명명되지 않은 참가자",manyUnnamedParticipantsJoined:"명명되지 않은 참가자 및 {numOfParticipants}명의 다른 참가자가 참가",manyUnnamedParticipantsLeft:"명명되지 않은 참가자 및 {numOfParticipants}명의 다른 참가자가 떠남",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} 및 {numOfParticipants} 다른 참가자가 참가했습니다.",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} 및 다른 참가자 {numOfParticipants} 남음",liveCaptionsLabel:"라이브 캡션",captionsSettingsLabel:"캡션 설정",startCaptionsButtonOnLabel:"캡션 켜기",startCaptionsButtonOffLabel:"캡션 끄기",startCaptionsButtonTooltipOnContent:"캡션 끄기",startCaptionsButtonTooltipOffContent:"캡션 켜기",captionsSettingsModalTitle:"어떤 언어를 사용 중입니까?",captionsSettingsDropdownLabel:"음성 언어",captionsSettingsDropdownInfoText:"이 통화의 모든 사람이 말하는 언어입니다.",captionsSettingsConfirmButtonLabel:"확인하기",captionsSettingsCancelButtonLabel:"취소하기",captionsSettingsModalAriaLabel:"캡션 설정 모달",captionsSettingsCloseModalButtonAriaLabel:"캡션 설정 닫기",captionsBannerMoreButtonCallingLabel:"기타",captionsBannerMoreButtonTooltip:"기타 옵션",captionsAvailableLanguageStrings:{"ar-ae":"아랍어 - 아랍에미리트","ar-sa":"아라비아어 - 사우디 아라비아","da-dk":"덴마크어","de-de":"독일어 - 독일","en-au":"영어 - 오스트레일리아","en-ca":"영어 - 캐나다","en-gb":"영어 - 영국","en-in":"영어 - 인도","en-nz":"영어 - 뉴질랜드","en-us":"영어 - 미국","es-es":"스페인어 - 스페인(현대 정렬)","es-mx":"스페인어 - 멕시코","fi-fi":"핀란드어","fr-ca":"프랑스어 - 캐나다","fr-fr":"프랑스어 - 프랑스","hi-in":"힌디어","it-it":"이탈리아어 - 이탈리아","ja-jp":"일본어","ko-kr":"한국어","nb-no":"노르웨이어(복말)","nl-be":"네덜란드어 - 벨기에","nl-nl":"네덜란드어 - 네덜란드","pl-pl":"폴란드어","pt-br":"포르투갈어 - 브라질","ru-ru":"러시아어","sv-se":"스웨덴어","zh-cn":"중국어 - 중국","zh-hk":"중국어 - 홍콩 특별 행정구","cs-cz":"체코어","pt-pt":"포르투갈어 - 포르투갈","tr-tr":"터키어","vi-vn":"베트남어","th-th":"태국어","he-il":"히브리어","cy-gb":"웨일스어","uk-ua":"우크라이나어","el-gr":"그리스어","hu-hu":"헝가리어","ro-ro":"루마니아어","sk-sk":"슬로바키아어","zh-tw":"중국어 - 대만"},captionsBannerSpinnerText:"캡션을 시작하는 중...",transferPageTransferorText:"전송 중...",transferPageTransferTargetText:"연결 중...",transferPageUnknownTransferorDisplayName:"알 수 없음",transferPageUnknownTransferTargetDisplayName:"알 수 없음"};var chat$9={chatListHeader:"채팅 참가자",uploadFile:"파일 업로드"};var callWithChat$9={chatButtonLabel:"채팅",chatButtonNewMessageNotificationLabel:"새 메시지",chatButtonTooltipClosedWithMessageCount:"채팅 표시({unreadMessagesCount} 읽지 않음)",chatButtonTooltipClose:"채팅 숨기기",chatButtonTooltipOpen:"채팅 표시",chatPaneTitle:"채팅",copyInviteLinkButtonLabel:"초대 링크 복사",copyInviteLinkActionedAriaLabel:"초대 링크를 복사함",dismissSidePaneButtonLabel:"닫기",moreDrawerAudioDeviceMenuTitle:"오디오 장치",moreDrawerButtonLabel:"기타 옵션",moreDrawerButtonTooltip:"기타 옵션",moreDrawerMicrophoneMenuTitle:"마이크",moreDrawerSpeakerMenuTitle:"발화자",moreDrawerCaptionsMenuTitle:"라이브 캡션",moreDrawerSpokenLanguageMenuTitle:"음성 언어",peopleButtonLabel:"사용자",peopleButtonTooltipOpen:"참가자 표시",peopleButtonTooltipClose:"참가자 숨기기",peoplePaneSubTitle:"이 통화에서",peoplePaneTitle:"사용자",pictureInPictureTileAriaLabel:"비디오 피드입니다. 클릭하면 통화 화면으로 돌아갑니다.",removeMenuLabel:"제거",openDialpadButtonLabel:"전화 번호 전화 걸기",returnToCallButtonAriaDescription:"통화로 돌아가기",returnToCallButtonAriaLabel:"뒤로",peoplePaneAddPeopleButtonLabel:"사용자 추가",dialpadStartCallButtonLabel:"통화",dialpadModalTitle:"전화 번호 전화 걸기",dialpadModalAriaLabel:"다이얼패드",dialpadCloseModalButtonAriaLabel:"다이얼패드 닫기",openDtmfDialpadLabel:"다이얼패드 표시",dtmfDialpadPlaceholderText:"번호 입력"};var ko_KR = {call:call$9,chat:chat$9,callWithChat:callWithChat$9};

var call$8={cameraLabel:"Kamera",noCamerasLabel:"Fant ingen kameraer",cameraPermissionDenied:"Nettleseren blokkerer tilgang til kameraet",cameraTurnedOff:"Kameraet er slått av",chatButtonLabel:"Chat",close:"Lukk",complianceBannerNowOnlyRecording:"Du tar nå bare opp dette møtet.",complianceBannerNowOnlyTranscription:"Du transkriberer nå bare dette møtet.",complianceBannerRecordingAndTranscriptionSaved:"Opptak og transkripsjon lagres.",complianceBannerRecordingAndTranscriptionStarted:"Opptak og transkripsjon har startet.",complianceBannerRecordingAndTranscriptionStopped:"Innspilling og transkripsjon har stoppet.",complianceBannerRecordingSaving:"Opptaket blir lagret.",complianceBannerRecordingStarted:"Innspillingen er startet.",complianceBannerRecordingStopped:"Opptaket har stoppet.",complianceBannerTranscriptionStarted:"Transkripsjon har startet.",complianceBannerTranscriptionConsent:"Ved å bli med gir du samtykke til at dette møtet kan transkriberes.",complianceBannerTranscriptionSaving:"Transkripsjonen blir lagret.",complianceBannerTranscriptionStopped:"Transkripsjon er stoppet.",configurationPageTitle:"Start en samtale",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert",defaultPlaceHolder:"Velg et alternativ",dismissSidePaneButtonLabel:"Lukk",videoEffectsPaneTitle:"Effekter",videoEffectsPaneBackgroundSelectionTitle:"Bakgrunn",configurationPageVideoEffectsButtonLabel:"Effekter",unableToStartVideoEffect:"Kan ikke bruke videoeffekt.",blurBackgroundEffectButtonLabel:"Uskarp bakgrunn",blurBackgroundTooltip:"Gjør bakgrunnen uskarp",removeBackgroundEffectButtonLabel:"Ingen",removeBackgroundTooltip:"Fjern bakgrunnen",cameraOffBackgroundEffectWarningText:"Kameraet er av. Slå på kameraet for å se videoeffekten.",failedToJoinCallDueToNoNetworkMoreDetails:"Samtalen ble frakoblet på grunn av et nettverksproblem. Kontroller tilkoblingen og bli med på nytt.",failedToJoinCallDueToNoNetworkTitle:"Samtale frakoblet",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Du ble ikke gitt adgang i samtalen. Hvis dette var en feil, må du bli med i samtalen på nytt.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Avvist fra lobbyen",learnMore:"Mer informasjon",leavingCallTitle:"Forlater...",leftCallMoreDetails:"Hvis dette var en feil, må du bli med i samtalen på nytt.",leftCallTitle:"Du forlot samtalen",lobbyScreenConnectingToCallTitle:"Blir med i samtalen",lobbyScreenWaitingToBeAdmittedTitle:"Venter på å bli sluppet inn",microphonePermissionDenied:"Nettleseren blokkerer tilgang til mikrofonen",microphoneToggleInLobbyNotAllowed:"Kan ikke dempe eller oppheve demping i lobbyen.",mutedMessage:"Du er dempet.",networkReconnectMoreDetails:"Det ser ut til at noe gikk galt. Vi prøver å gå tilbake til samtalen.",networkReconnectTitle:"Vent litt",deniedPermissionToRoomDetails:"Du har ikke tillatelse til å bli med i dette rommet.",deniedPermissionToRoomTitle:"Tillatelsen er avslått for rommet",peopleButtonLabel:"Personer",peoplePaneTitle:"Personer",peopleButtonTooltipOpen:"Vis deltakere",peopleButtonTooltipClose:"Skjul deltakere",peoplePaneSubTitle:"I denne samtalen",privacyPolicy:"Personvernerklæring",rejoinCallButtonLabel:"Bli med i samtale på nytt",removedFromCallMoreDetails:"En annen deltaker fjernet deg fra samtalen.",removedFromCallTitle:"Du ble fjernet",removeMenuLabel:"Fjern",returnToCallButtonAriaDescription:"Gå tilbake til samtale",returnToCallButtonAriaLabel:"Tilbake",roomNotFoundDetails:"Angitt rom-ID er ikke gyldig.",roomNotFoundTitle:"Finner ikke rommet",soundLabel:"Lyd",noMicrophonesLabel:"Fant ingen mikrofoner",noSpeakersLabel:"Fant ingen høyttalere",startCallButtonLabel:"Start samtale",openDialpadButtonLabel:"Slå telefonnummeret",peoplePaneAddPeopleButtonLabel:"Legg til personer",dialpadStartCallButtonLabel:"Ringe",dialpadModalTitle:"Slå telefonnummeret",dialpadModalAriaLabel:"Numerisk tastatur",dialpadCloseModalButtonAriaLabel:"Lukk numerisk tastatur",moreButtonCallingLabel:"Mer",resumeCallButtonLabel:"Fortsett",resumingCallButtonLabel:"Gjenopptar …",resumeCallButtonAriaLabel:"Fortsett samtale",resumingCallButtonAriaLabel:"Fortsett samtale",holdScreenLabel:"Du er satt på vent",openDtmfDialpadLabel:"Vis numerisk tastatur",dtmfDialpadPlaceholderText:"Skriv inn nummer",outboundCallingNoticeString:"Ringer …",participantJoinedNoticeString:"{displayName} ble med",twoParticipantJoinedNoticeString:"{displayName1} og {displayName2} har blitt med",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} og {displayName3} har blitt med",participantLeftNoticeString:"{displayName} igjen",twoParticipantLeftNoticeString:"{displayName1} og {displayName2} har forlatt",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} og {displayName3} har forlatt",unnamedParticipantString:"deltaker uten navn",manyUnnamedParticipantsJoined:"deltaker uten navn og {numOfParticipants} andre deltakere ble med",manyUnnamedParticipantsLeft:"deltaker uten navn og {numOfParticipants} andre deltakere igjen",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} og {numOfParticipants} andre deltakere ble med",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} og {numOfParticipants} andre deltakere igjen",liveCaptionsLabel:"Undertekster",captionsSettingsLabel:"Innstillinger for undertekster",startCaptionsButtonOnLabel:"Slå på undertekster",startCaptionsButtonOffLabel:"Deaktiver undertekster",startCaptionsButtonTooltipOnContent:"Deaktiver undertekster",startCaptionsButtonTooltipOffContent:"Slå på undertekster",captionsSettingsModalTitle:"Hvilket språk snakkes?",captionsSettingsDropdownLabel:"Talespråk",captionsSettingsDropdownInfoText:"Språket som alle i denne samtalen snakker.",captionsSettingsConfirmButtonLabel:"Bekreft",captionsSettingsCancelButtonLabel:"Avbryt",captionsSettingsModalAriaLabel:"Sperre for innstillinger for undertekster",captionsSettingsCloseModalButtonAriaLabel:"Lukk innstilling for undertekster",captionsBannerMoreButtonCallingLabel:"Mer",captionsBannerMoreButtonTooltip:"Flere alternativer",captionsAvailableLanguageStrings:{"ar-ae":"Arabisk – De forente arabiske emirater","ar-sa":"Arabisk – Saudi-Arabia","da-dk":"Dansk","de-de":"Tysk – Tyskland","en-au":"Engelsk – Australia","en-ca":"Engelsk – Canada","en-gb":"Engelsk – Storbritannia","en-in":"Engelsk – India","en-nz":"Engelsk – New Zealand","en-us":"Engelsk – USA","es-es":"Spansk – Spania (moderne)","es-mx":"Spansk – Mexico","fi-fi":"Finsk","fr-ca":"Fransk – Canada","fr-fr":"Fransk – Frankrike","hi-in":"Hindi","it-it":"Italiensk – Italia","ja-jp":"Japansk","ko-kr":"Koreansk","nb-no":"Norsk (bokmål)","nl-be":"Nederlandsk – Belgia","nl-nl":"Nederlandsk – Nederland","pl-pl":"Polsk","pt-br":"Portugisisk – Brasil","ru-ru":"Russisk","sv-se":"Svensk","zh-cn":"Kinesisk – Folkerepublikken Kina","zh-hk":"Kinesisk – Hongkong SAR","cs-cz":"Tsjekkisk","pt-pt":"Portugisisk – Portugal","tr-tr":"Tyrkisk","vi-vn":"Vietnamesisk","th-th":"Thai","he-il":"Hebraisk","cy-gb":"Walisisk","uk-ua":"Ukrainsk","el-gr":"Gresk","hu-hu":"Ungarsk","ro-ro":"Rumensk","sk-sk":"Slovakisk","zh-tw":"Kinesisk – Taiwan"},captionsBannerSpinnerText:"Starter teksting...",transferPageTransferorText:"Overfører...",transferPageTransferTargetText:"Kobler til...",transferPageUnknownTransferorDisplayName:"Ukjent",transferPageUnknownTransferTargetDisplayName:"Ukjent"};var chat$8={chatListHeader:"I denne chatten",uploadFile:"Last opp fil"};var callWithChat$8={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Ny melding",chatButtonTooltipClosedWithMessageCount:"Vis chat ({unreadMessagesCount} ulest)",chatButtonTooltipClose:"Skjul chat",chatButtonTooltipOpen:"Vis chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Kopier invitasjonskobling",copyInviteLinkActionedAriaLabel:"Invitasjonskobling er kopiert",dismissSidePaneButtonLabel:"Lukk",moreDrawerAudioDeviceMenuTitle:"Lydenhet",moreDrawerButtonLabel:"Flere alternativer",moreDrawerButtonTooltip:"Flere alternativer",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Høyttaler",moreDrawerCaptionsMenuTitle:"Undertekster",moreDrawerSpokenLanguageMenuTitle:"Talespråk",peopleButtonLabel:"Personer",peopleButtonTooltipOpen:"Vis deltakere",peopleButtonTooltipClose:"Skjul deltakere",peoplePaneSubTitle:"I denne samtalen",peoplePaneTitle:"Personer",pictureInPictureTileAriaLabel:"Videofeeder. Klikk for å gå tilbake til samtaleskjermen.",removeMenuLabel:"Fjern",openDialpadButtonLabel:"Slå telefonnummeret",returnToCallButtonAriaDescription:"Gå tilbake til samtale",returnToCallButtonAriaLabel:"Tilbake",peoplePaneAddPeopleButtonLabel:"Legg til personer",dialpadStartCallButtonLabel:"Ringe",dialpadModalTitle:"Slå telefonnummeret",dialpadModalAriaLabel:"Numerisk tastatur",dialpadCloseModalButtonAriaLabel:"Lukk numerisk tastatur",openDtmfDialpadLabel:"Vis numerisk tastatur",dtmfDialpadPlaceholderText:"Skriv inn nummer"};var nb_NO = {call:call$8,chat:chat$8,callWithChat:callWithChat$8};

var call$7={cameraLabel:"Camera",noCamerasLabel:"Geen camera's gevonden",cameraPermissionDenied:"Uw browser blokkeert de toegang tot uw camera",cameraTurnedOff:"Camera is uitgeschakeld",chatButtonLabel:"Chatten",close:"Sluiten",complianceBannerNowOnlyRecording:"U bent nu alleen deze vergadering aan het opnemen.",complianceBannerNowOnlyTranscription:"U bent nu alleen deze vergadering aan het transcriberen.",complianceBannerRecordingAndTranscriptionSaved:"Opname en transcriptie worden opgeslagen.",complianceBannerRecordingAndTranscriptionStarted:"Opname en transcriptie zijn gestart.",complianceBannerRecordingAndTranscriptionStopped:"Opname en transcriptie zijn gestopt.",complianceBannerRecordingSaving:"De opname wordt opgeslagen.",complianceBannerRecordingStarted:"De opname is gestart.",complianceBannerRecordingStopped:"De opname is gestopt.",complianceBannerTranscriptionStarted:"Transcriptie is gestart.",complianceBannerTranscriptionConsent:"Door deel te nemen, geeft u toestemming voor het transcriberen van deze vergadering.",complianceBannerTranscriptionSaving:"Transcriptie wordt opgeslagen.",complianceBannerTranscriptionStopped:"Transcriptie is gestopt.",configurationPageTitle:"Een oproep starten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiëren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",defaultPlaceHolder:"Een optie selecteren",dismissSidePaneButtonLabel:"Sluiten",videoEffectsPaneTitle:"Effecten",videoEffectsPaneBackgroundSelectionTitle:"Achtergrond",configurationPageVideoEffectsButtonLabel:"Effecten",unableToStartVideoEffect:"Kan video-effect niet toepassen.",blurBackgroundEffectButtonLabel:"Vervagen",blurBackgroundTooltip:"Achtergrond vervagen",removeBackgroundEffectButtonLabel:"Geen",removeBackgroundTooltip:"Achtergrond verwijderen",cameraOffBackgroundEffectWarningText:"Uw camera is uitgeschakeld. Schakel de camera in om het video-effect te zien.",failedToJoinCallDueToNoNetworkMoreDetails:"De verbinding is verbroken vanwege een netwerkprobleem. Controleer de verbinding en neem opnieuw deel.",failedToJoinCallDueToNoNetworkTitle:"Verbinding verbroken",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"U hebt geen toegang gekregen in het gesprek. Als dit een fout is, neemt u opnieuw deel aan het gesprek.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Verwijderd uit lobby",learnMore:"Meer informatie",leavingCallTitle:"Verlaten...",leftCallMoreDetails:"Als dit een vergissing was, neemt u opnieuw deel aan het gesprek.",leftCallTitle:"U hebt het gesprek verlaten",lobbyScreenConnectingToCallTitle:"Deelnemen aan oproep",lobbyScreenWaitingToBeAdmittedTitle:"Wachten om te worden toegelaten",microphonePermissionDenied:"Uw browser blokkeert de toegang tot uw microfoon",microphoneToggleInLobbyNotAllowed:"Kan niet dempen of dempen opheffen in de lobby.",mutedMessage:"Uw geluid is gedempt",networkReconnectMoreDetails:"Er is iets misgegaan. We proberen terug te gaan naar het gesprek.",networkReconnectTitle:"Wacht even",deniedPermissionToRoomDetails:"U bent niet gemachtigd om deel te nemen aan deze ruimte.",deniedPermissionToRoomTitle:"Machtiging voor de ruimte is geweigerd",peopleButtonLabel:"Personen",peoplePaneTitle:"Personen",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek",privacyPolicy:"Privacybeleid",rejoinCallButtonLabel:"Opnieuw deelnemen aan gesprek",removedFromCallMoreDetails:"Een andere deelnemer heeft u uit het gesprek verwijderd.",removedFromCallTitle:"U bent verwijderd",removeMenuLabel:"Verwijderen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",roomNotFoundDetails:"De opgegeven ruimte-id is niet geldig.",roomNotFoundTitle:"Ruimte niet gevonden",soundLabel:"Geluid",noMicrophonesLabel:"Geen microfoons gevonden",noSpeakersLabel:"Geen luidsprekers gevonden",startCallButtonLabel:"Gesprek starten",openDialpadButtonLabel:"Telefoonnummer kiezen",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",moreButtonCallingLabel:"Meer",resumeCallButtonLabel:"Hervatten",resumingCallButtonLabel:"Hervatten...",resumeCallButtonAriaLabel:"Gesprek hervatten",resumingCallButtonAriaLabel:"Gesprek hervatten",holdScreenLabel:"U staat in de wacht",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren",outboundCallingNoticeString:"Bellen...",participantJoinedNoticeString:"{displayName} neemt deel",twoParticipantJoinedNoticeString:"{displayName1} en {displayName2} nemen deel",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} en {displayName3} nemen deel",participantLeftNoticeString:"{displayName} is vertrokken",twoParticipantLeftNoticeString:"{displayName1} en {displayName2} zijn vertrokken",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} en {displayName3} zijn vertrokken",unnamedParticipantString:"naamloze deelnemer",manyUnnamedParticipantsJoined:"naamloze deelnemer en {numOfParticipants} andere deelnemers nemen deel",manyUnnamedParticipantsLeft:"naamloze deelnemer en {numOfParticipants} andere deelnemers zijn vertrokken",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} en {numOfParticipants} andere deelnemers",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} en {numOfParticipants} andere deelnemers resterend",liveCaptionsLabel:"Liveondertitels",captionsSettingsLabel:"Instellingen voor ondertiteling",startCaptionsButtonOnLabel:"Bijschriften inschakelen",startCaptionsButtonOffLabel:"Ondertitels uitschakelen",startCaptionsButtonTooltipOnContent:"Ondertitels uitschakelen",startCaptionsButtonTooltipOffContent:"Bijschriften inschakelen",captionsSettingsModalTitle:"Welke taal wordt er gesproken?",captionsSettingsDropdownLabel:"Gesproken taal",captionsSettingsDropdownInfoText:"Taal die iedereen in dit gesprek spreekt.",captionsSettingsConfirmButtonLabel:"Bevestigen",captionsSettingsCancelButtonLabel:"Annuleren",captionsSettingsModalAriaLabel:"Bijschriften instellen modaal",captionsSettingsCloseModalButtonAriaLabel:"Instelling voor ondertiteling sluiten",captionsBannerMoreButtonCallingLabel:"Meer",captionsBannerMoreButtonTooltip:"Meer opties",captionsAvailableLanguageStrings:{"ar-ae":"Arabisch - Verenigde Arabische Emiraten","ar-sa":"Arabisch - Saudi-Arabië","da-dk":"Deens","de-de":"Duits - Duitsland","en-au":"Engels - Australië","en-ca":"Engels - Canada","en-gb":"Engels - Verenigd Koninkrijk","en-in":"Engels - India","en-nz":"Engels - Nieuw-Zeeland","en-us":"Engels - Verenigde Staten","es-es":"Spaans - Spanje (modern)","es-mx":"Spaans - Mexico","fi-fi":"Fins","fr-ca":"Frans - Canada","fr-fr":"Frans - Frankrijk","hi-in":"Hindi","it-it":"Italiaans - Italië","ja-jp":"Japans","ko-kr":"Koreaans","nb-no":"Noors (Bokmål)","nl-be":"Nederlands - België","nl-nl":"Nederlands - Nederland","pl-pl":"Pools","pt-br":"Portugees - Brazilië","ru-ru":"Russisch","sv-se":"Zweeds","zh-cn":"Chinees (Volksrepubliek China)","zh-hk":"Chinees - Hongkong SAR","cs-cz":"Tsjechisch","pt-pt":"Portugees - Portugal","tr-tr":"Turks","vi-vn":"Vietnamees","th-th":"Thai","he-il":"Hebreeuws","cy-gb":"Welsh","uk-ua":"Oekraïens","el-gr":"Grieks","hu-hu":"Hongaars","ro-ro":"Roemeens","sk-sk":"Slowaaks","zh-tw":"Chinees - Taiwan"},captionsBannerSpinnerText:"Ondertitels starten...",transferPageTransferorText:"Doorverbinden...",transferPageTransferTargetText:"Verbinding maken...",transferPageUnknownTransferorDisplayName:"Onbekend",transferPageUnknownTransferTargetDisplayName:"Onbekend"};var chat$7={chatListHeader:"In deze chat",uploadFile:"Bestand uploaden"};var callWithChat$7={chatButtonLabel:"Chatten",chatButtonNewMessageNotificationLabel:"Nieuw bericht",chatButtonTooltipClosedWithMessageCount:"Chat weergeven ({unreadMessagesCount} ongelezen)",chatButtonTooltipClose:"Chat verbergen",chatButtonTooltipOpen:"Chat weergeven",chatPaneTitle:"Chatten",copyInviteLinkButtonLabel:"Uitnodigingskoppeling kopiëren",copyInviteLinkActionedAriaLabel:"Uitnodigingskoppeling gekopieerd",dismissSidePaneButtonLabel:"Sluiten",moreDrawerAudioDeviceMenuTitle:"Audioapparaat",moreDrawerButtonLabel:"Meer opties",moreDrawerButtonTooltip:"Meer opties",moreDrawerMicrophoneMenuTitle:"Microfoon",moreDrawerSpeakerMenuTitle:"Luidspreker",moreDrawerCaptionsMenuTitle:"Liveondertitels",moreDrawerSpokenLanguageMenuTitle:"Gesproken taal",peopleButtonLabel:"Personen",peopleButtonTooltipOpen:"Deelnemers weergeven",peopleButtonTooltipClose:"Deelnemers verbergen",peoplePaneSubTitle:"In dit gesprek",peoplePaneTitle:"Personen",pictureInPictureTileAriaLabel:"Videofeeds. Klik om terug te keren naar het oproepscherm.",removeMenuLabel:"Verwijderen",openDialpadButtonLabel:"Telefoonnummer kiezen",returnToCallButtonAriaDescription:"Terug naar gesprek",returnToCallButtonAriaLabel:"Terug",peoplePaneAddPeopleButtonLabel:"Personen toevoegen",dialpadStartCallButtonLabel:"Bellen",dialpadModalTitle:"Telefoonnummer kiezen",dialpadModalAriaLabel:"Telefoonkiezer",dialpadCloseModalButtonAriaLabel:"Toetsenblok sluiten",openDtmfDialpadLabel:"Toetsenblok weergeven",dtmfDialpadPlaceholderText:"Nummer invoeren"};var nl_NL = {call:call$7,chat:chat$7,callWithChat:callWithChat$7};

var call$6={cameraLabel:"Kamera",noCamerasLabel:"Nie znaleziono żadnej kamery",cameraPermissionDenied:"Przeglądarka blokuje dostęp do kamery",cameraTurnedOff:"Twoja kamera jest wyłączona",chatButtonLabel:"Czat",close:"Zamknij",complianceBannerNowOnlyRecording:"W tej chwili tylko Ty nagrywasz to spotkanie.",complianceBannerNowOnlyTranscription:"W tej chwili tylko Ty transkrybujesz to spotkanie.",complianceBannerRecordingAndTranscriptionSaved:"Trwa zapisywanie nagrania i transkrypcji.",complianceBannerRecordingAndTranscriptionStarted:"Rozpoczęto nagrywanie i transkrypcję.",complianceBannerRecordingAndTranscriptionStopped:"Zatrzymano nagrywanie i transkrypcję.",complianceBannerRecordingSaving:"Trwa zapisywanie nagrania.",complianceBannerRecordingStarted:"Rozpoczęto nagrywanie.",complianceBannerRecordingStopped:"Nagranie zostało zatrzymane.",complianceBannerTranscriptionStarted:"Rozpoczęto transkrypcję.",complianceBannerTranscriptionConsent:"Dołączając, wyrażasz zgodę na transkrypcję tego spotkania.",complianceBannerTranscriptionSaving:"Trwa zapisywanie transkrypcji.",complianceBannerTranscriptionStopped:"Zakończono transkrypcję.",configurationPageTitle:"Rozpocznij rozmowę",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia",defaultPlaceHolder:"Wybierz opcję",dismissSidePaneButtonLabel:"Zamknij",videoEffectsPaneTitle:"Efekty",videoEffectsPaneBackgroundSelectionTitle:"Tło",configurationPageVideoEffectsButtonLabel:"Efekty",unableToStartVideoEffect:"Nie można zastosować efektu wideo.",blurBackgroundEffectButtonLabel:"Rozmycie",blurBackgroundTooltip:"Rozmyj tło",removeBackgroundEffectButtonLabel:"Brak",removeBackgroundTooltip:"Usuń tło",cameraOffBackgroundEffectWarningText:"Kamera jest wyłączona. Włącz kamerę, aby zobaczyć efekt wideo.",failedToJoinCallDueToNoNetworkMoreDetails:"Połączenie zostało rozłączone z powodu problemu z siecią. Sprawdź połączenie i dołącz ponownie.",failedToJoinCallDueToNoNetworkTitle:"Rozmowa została rozłączona",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Nie udzielono Ci dostępu do rozmowy. Jeśli to pomyłka, dołącz ponownie do rozmowy.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Odrzucono z poczekalni",learnMore:"Dowiedz się więcej",leavingCallTitle:"Opuszczanie…",leftCallMoreDetails:"Jeśli to pomyłka, dołącz ponownie do rozmowy.",leftCallTitle:"Opuszczono rozmowę",lobbyScreenConnectingToCallTitle:"Dołączanie do rozmowy",lobbyScreenWaitingToBeAdmittedTitle:"Oczekiwanie na przyjęcie",microphonePermissionDenied:"Twoja przeglądarka blokuje dostęp do mikrofonu",microphoneToggleInLobbyNotAllowed:"Nie można wyciszyć ani wyłączyć wyciszenia w poczekalni.",mutedMessage:"Wyciszenie jest włączone",networkReconnectMoreDetails:"Wygląda na to, że wystąpił problem. Próbujemy wrócić do rozmowy.",networkReconnectTitle:"Czekaj",deniedPermissionToRoomDetails:"Nie masz uprawnień do dołączenia do tego pokoju.",deniedPermissionToRoomTitle:"Odmowa uprawnień do pokoju",peopleButtonLabel:"Osoby",peoplePaneTitle:"Osoby",peopleButtonTooltipOpen:"Pokaż uczestników",peopleButtonTooltipClose:"Ukryj uczestników",peoplePaneSubTitle:"W tej rozmowie",privacyPolicy:"Zasady ochrony prywatności",rejoinCallButtonLabel:"Dołącz ponownie do rozmowy",removedFromCallMoreDetails:"Inny uczestnik usunął Cię z rozmowy.",removedFromCallTitle:"Usunięto Cię",removeMenuLabel:"Usuń",returnToCallButtonAriaDescription:"Wróć do rozmowy",returnToCallButtonAriaLabel:"Wstecz",roomNotFoundDetails:"Podany identyfikator pokoju jest nieprawidłowy.",roomNotFoundTitle:"Nie znaleziono pokoju",soundLabel:"Dźwięk",noMicrophonesLabel:"Nie znaleziono mikrofonów",noSpeakersLabel:"Nie znaleziono głośników",startCallButtonLabel:"Zadzwoń",openDialpadButtonLabel:"Wybierz numer telefonu",peoplePaneAddPeopleButtonLabel:"Dodaj osoby",dialpadStartCallButtonLabel:"Zadzwoń",dialpadModalTitle:"Wybieranie numeru telefonu",dialpadModalAriaLabel:"Klawiatura numeryczna",dialpadCloseModalButtonAriaLabel:"Zamknij klawiaturę numeryczną",moreButtonCallingLabel:"Więcej",resumeCallButtonLabel:"Wznów",resumingCallButtonLabel:"Trwa wznawianie...",resumeCallButtonAriaLabel:"Wznów połączenie",resumingCallButtonAriaLabel:"Wznów połączenie",holdScreenLabel:"Połączenie zostało zawieszone.",openDtmfDialpadLabel:"Pokaż klawiaturę numeryczną",dtmfDialpadPlaceholderText:"Wprowadź numer",outboundCallingNoticeString:"Trwa łączenie…",participantJoinedNoticeString:"użytkownik {displayName} dołączył",twoParticipantJoinedNoticeString:"użytkownicy {displayName1} i {displayName2} dołączyli",threeParticipantJoinedNoticeString:"użytkownicy {displayName1}, {displayName2} i {displayName3} dołączyli",participantLeftNoticeString:"uczestnik {displayName} opuścił",twoParticipantLeftNoticeString:"uczestnicy {displayName1} i {displayName2} opuścili",threeParticipantLeftNoticeString:"uczestnicy {displayName1}, {displayName2} i {displayName3} opuścili",unnamedParticipantString:"uczestnik bez nazwy",manyUnnamedParticipantsJoined:"uczestnik bez nazwy i {numOfParticipants} innych uczestników dołączyli",manyUnnamedParticipantsLeft:"uczestnik bez nazwy i {numOfParticipants} innych uczestników opuścili",manyParticipantsJoined:"dołączono {displayName1}, {displayName2}, {displayName3} i {numOfParticipants} innych uczestników",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} i {numOfParticipants} innych uczestników pozostało",liveCaptionsLabel:"Napisy na żywo",captionsSettingsLabel:"Ustawienia napisów",startCaptionsButtonOnLabel:"Włącz podpisy",startCaptionsButtonOffLabel:"Wyłącz podpisy",startCaptionsButtonTooltipOnContent:"Wyłącz podpisy",startCaptionsButtonTooltipOffContent:"Włącz podpisy",captionsSettingsModalTitle:"W jakim języku jest mówiony?",captionsSettingsDropdownLabel:"Język mówiony",captionsSettingsDropdownInfoText:"Język, w którym mówią wszyscy uczestnicy tej rozmowy.",captionsSettingsConfirmButtonLabel:"Potwierdź",captionsSettingsCancelButtonLabel:"Anuluj",captionsSettingsModalAriaLabel:"Modalne ustawianie podpisów",captionsSettingsCloseModalButtonAriaLabel:"Ustawienie podpisów",captionsBannerMoreButtonCallingLabel:"Więcej",captionsBannerMoreButtonTooltip:"Więcej opcji",captionsAvailableLanguageStrings:{"ar-ae":"arabski — Zjednoczone Emiraty Arabskie","ar-sa":"arabski — Arabia Saudyjska","da-dk":"duński","de-de":"niemiecki — Niemcy","en-au":"angielski — Australia","en-ca":"angielski — Kanada","en-gb":"angielski — Zjednoczone Królestwo","en-in":"angielski — Indie","en-nz":"angielski — Nowa Zelandia","en-us":"angielski — Stany Zjednoczone","es-es":"hiszpański — Hiszpania (nowoczesny)","es-mx":"hiszpański — Meksyk","fi-fi":"fiński","fr-ca":"francuski — Kanada","fr-fr":"francuski — Francja","hi-in":"hindi","it-it":"włoski — Włochy","ja-jp":"japoński","ko-kr":"koreański","nb-no":"norweski (Bokmål)","nl-be":"niderlandzki — Belgia","nl-nl":"niderlandzki — Holandia","pl-pl":"polski","pt-br":"portugalski (Brazylia)","ru-ru":"rosyjski","sv-se":"szwedzki","zh-cn":"chiński (Chińska Republika Ludowa)","zh-hk":"chiński — Hongkong SAR","cs-cz":"czeski","pt-pt":"portugalski (Portugalia)","tr-tr":"turecki","vi-vn":"wietnamski","th-th":"tajski","he-il":"hebrajski","cy-gb":"walijski","uk-ua":"ukraiński","el-gr":"grecki","hu-hu":"węgierski","ro-ro":"rumuński","sk-sk":"słowacki","zh-tw":"chiński — Tajwan"},captionsBannerSpinnerText:"Trwa uruchamianie napisów...",transferPageTransferorText:"Trwa przełączanie...",transferPageTransferTargetText:"Trwa łączenie...",transferPageUnknownTransferorDisplayName:"Nieznany",transferPageUnknownTransferTargetDisplayName:"Nieznany"};var chat$6={chatListHeader:"W tym czacie",uploadFile:"Przekazywanie pliku"};var callWithChat$6={chatButtonLabel:"Czat",chatButtonNewMessageNotificationLabel:"Nowa wiadomość",chatButtonTooltipClosedWithMessageCount:"Pokaż czat (nieprzeczytane: {unreadMessagesCount})",chatButtonTooltipClose:"Ukryj czat",chatButtonTooltipOpen:"Pokaż czat",chatPaneTitle:"Czat",copyInviteLinkButtonLabel:"Kopiuj link do zaproszenia",copyInviteLinkActionedAriaLabel:"Skopiowano link do zaproszenia",dismissSidePaneButtonLabel:"Zamknij",moreDrawerAudioDeviceMenuTitle:"Urządzenie audio",moreDrawerButtonLabel:"Więcej opcji",moreDrawerButtonTooltip:"Więcej opcji",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Głośnik",moreDrawerCaptionsMenuTitle:"Napisy na żywo",moreDrawerSpokenLanguageMenuTitle:"Język mówiony",peopleButtonLabel:"Osoby",peopleButtonTooltipOpen:"Pokaż uczestników",peopleButtonTooltipClose:"Ukryj uczestników",peoplePaneSubTitle:"W tej rozmowie",peoplePaneTitle:"Osoby",pictureInPictureTileAriaLabel:"Kanały wideo. Kliknij, aby powrócić do ekranu rozmowy.",removeMenuLabel:"Usuń",openDialpadButtonLabel:"Wybierz numer telefonu",returnToCallButtonAriaDescription:"Wróć do rozmowy",returnToCallButtonAriaLabel:"Wstecz",peoplePaneAddPeopleButtonLabel:"Dodaj osoby",dialpadStartCallButtonLabel:"Zadzwoń",dialpadModalTitle:"Wybieranie numeru telefonu",dialpadModalAriaLabel:"Klawiatura numeryczna",dialpadCloseModalButtonAriaLabel:"Zamknij klawiaturę numeryczną",openDtmfDialpadLabel:"Pokaż klawiaturę numeryczną",dtmfDialpadPlaceholderText:"Wprowadź numer"};var pl_PL = {call:call$6,chat:chat$6,callWithChat:callWithChat$6};

var call$5={cameraLabel:"Câmera",noCamerasLabel:"Nenhuma câmera encontrada",cameraPermissionDenied:"Seu navegador está bloqueando o acesso à câmera",cameraTurnedOff:"Sua câmera está desativada",chatButtonLabel:"Chat",close:"Fechar",complianceBannerNowOnlyRecording:"Você agora está apenas gravando esta reunião.",complianceBannerNowOnlyTranscription:"Você agora está apenas transcrevendo esta reunião.",complianceBannerRecordingAndTranscriptionSaved:"A gravação e a transcrição estão sendo salvas.",complianceBannerRecordingAndTranscriptionStarted:"A gravação e a transcrição foram iniciadas.",complianceBannerRecordingAndTranscriptionStopped:"A gravação e a transcrição foram interrompidas.",complianceBannerRecordingSaving:"A gravação está sendo salva.",complianceBannerRecordingStarted:"A gravação foi iniciada.",complianceBannerRecordingStopped:"A gravação foi interrompida.",complianceBannerTranscriptionStarted:"A transcrição foi iniciada.",complianceBannerTranscriptionConsent:"Ao ingressar, você está dando consentimento para que esta reunião seja transcrita.",complianceBannerTranscriptionSaving:"A transcrição está sendo salva.",complianceBannerTranscriptionStopped:"A transcrição foi interrompida.",configurationPageTitle:"Iniciar uma chamada",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",defaultPlaceHolder:"Selecionar uma opção",dismissSidePaneButtonLabel:"Fechar",videoEffectsPaneTitle:"Efeitos",videoEffectsPaneBackgroundSelectionTitle:"Tela de fundo",configurationPageVideoEffectsButtonLabel:"Efeitos",unableToStartVideoEffect:"Não é possível aplicar o efeito de vídeo.",blurBackgroundEffectButtonLabel:"Desfoque",blurBackgroundTooltip:"Desfocar a Tela de fundo",removeBackgroundEffectButtonLabel:"Nenhum",removeBackgroundTooltip:"Remover Tela de fundo",cameraOffBackgroundEffectWarningText:"A câmera está desligada. Ligue a câmera para ver o efeito de vídeo.",failedToJoinCallDueToNoNetworkMoreDetails:"A chamada foi desconectada devido a um problema de rede. Verifique sua conexão e ingresse novamente.",failedToJoinCallDueToNoNetworkTitle:"Chamada desconectada",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Você não recebeu entrada na chamada. Se isso foi um erro, ingresse novamente na chamada.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Ignorado do lobby",learnMore:"Saber mais",leavingCallTitle:"Saindo...",leftCallMoreDetails:"Se isso foi um erro, ingresse novamente na chamada.",leftCallTitle:"Você saiu da chamada",lobbyScreenConnectingToCallTitle:"Ingressando na chamada",lobbyScreenWaitingToBeAdmittedTitle:"Esperando para ser admitido",microphonePermissionDenied:"Seu navegador está bloqueando o acesso ao microfone",microphoneToggleInLobbyNotAllowed:"Não é possível ativar ou desativar mudo enquanto estiver no lobby.",mutedMessage:"Você está com o mudo ativado",networkReconnectMoreDetails:"Parece que algo deu errado. Estamos tentando retornar à chamada.",networkReconnectTitle:"Em espera",deniedPermissionToRoomDetails:"Você não tem permissão para ingressar nesta sala.",deniedPermissionToRoomTitle:"Permissão negada para a sala",peopleButtonLabel:"Pessoas",peoplePaneTitle:"Pessoas",peopleButtonTooltipOpen:"Mostrar participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nesta chamada",privacyPolicy:"Política de privacidade",rejoinCallButtonLabel:"Reingressar na chamada",removedFromCallMoreDetails:"Outro participante removeu você da chamada.",removedFromCallTitle:"Você foi removido",removeMenuLabel:"Remover",returnToCallButtonAriaDescription:"Retornar à Chamada",returnToCallButtonAriaLabel:"Voltar",roomNotFoundDetails:"A ID da sala fornecida não é válida.",roomNotFoundTitle:"Sala não encontrada",soundLabel:"Som",noMicrophonesLabel:"Nenhum microfone encontrado",noSpeakersLabel:"Nenhum alto-falante encontrado",startCallButtonLabel:"Iniciar chamada",openDialpadButtonLabel:"Número de telefone de discagem",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Número de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",moreButtonCallingLabel:"Mais",resumeCallButtonLabel:"Retomar",resumingCallButtonLabel:"Retomando…",resumeCallButtonAriaLabel:"Retomar chamada",resumingCallButtonAriaLabel:"Retomar chamada",holdScreenLabel:"Você está em espera",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o número",outboundCallingNoticeString:"Chamando...",participantJoinedNoticeString:"{displayName} ingressou",twoParticipantJoinedNoticeString:"{displayName1} e {displayName2} ingressaram",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} e {displayName3} ingressaram",participantLeftNoticeString:"{displayName} saiu",twoParticipantLeftNoticeString:"{displayName1} e {displayName2} saíram",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} e {displayName3} saíram",unnamedParticipantString:"participante sem nome",manyUnnamedParticipantsJoined:"participante sem nome e outros {numOfParticipants} participantes ingressaram",manyUnnamedParticipantsLeft:"participante sem nome e outros {numOfParticipants} participantes saíram",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} outros participantes ingressaram",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} e {numOfParticipants} outros participantes saíram",liveCaptionsLabel:"Legendas ao Vivo",captionsSettingsLabel:"Configurações de legenda",startCaptionsButtonOnLabel:"Ativar legendas",startCaptionsButtonOffLabel:"Desativar legendas",startCaptionsButtonTooltipOnContent:"Desativar legendas",startCaptionsButtonTooltipOffContent:"Ativar legendas",captionsSettingsModalTitle:"Qual idioma está sendo falado?",captionsSettingsDropdownLabel:"Idioma falado",captionsSettingsDropdownInfoText:"Idioma que todos nesta chamada estão falando.",captionsSettingsConfirmButtonLabel:"Confirmar",captionsSettingsCancelButtonLabel:"Cancelar",captionsSettingsModalAriaLabel:"Configuração de Legendas Modal",captionsSettingsCloseModalButtonAriaLabel:"Fechar Configuração de Legendas",captionsBannerMoreButtonCallingLabel:"Mais",captionsBannerMoreButtonTooltip:"Mais opções",captionsAvailableLanguageStrings:{"ar-ae":"Árabe - Emirados Árabes Unidos","ar-sa":"Árabe - Arábia Saudita","da-dk":"Dinamarquês","de-de":"Alemão - Alemanha","en-au":"Inglês - Austrália","en-ca":"Inglês - Canadá","en-gb":"Inglês - Reino Unido","en-in":"Inglês - Índia","en-nz":"Inglês - Nova Zelândia","en-us":"Inglês - Estados Unidos","es-es":"Espanhol - Espanha (Moderno)","es-mx":"Espanhol - México","fi-fi":"Finlandês","fr-ca":"Francês - Canadá","fr-fr":"Francês - França","hi-in":"Híndi","it-it":"Italiano - Itália","ja-jp":"Japonês","ko-kr":"Coreano","nb-no":"Norueguês (Bokmål)","nl-be":"Holandês - Bélgica","nl-nl":"Holandês - Países Baixos","pl-pl":"Polonês","pt-br":"Português - Brasil","ru-ru":"Russo","sv-se":"Sueco","zh-cn":"Chinês - República Popular da China","zh-hk":"Chinês - RAE de Hong Kong","cs-cz":"Tcheco","pt-pt":"Português - Portugal","tr-tr":"Turco","vi-vn":"Vietnamita","th-th":"Tailandês","he-il":"Hebraico","cy-gb":"Galês","uk-ua":"Ucraniano","el-gr":"Grego","hu-hu":"Húngaro","ro-ro":"Romeno","sk-sk":"Eslovaco","zh-tw":"Chinês - Taiwan"},captionsBannerSpinnerText:"Iniciando legendas...",transferPageTransferorText:"Transferindo...",transferPageTransferTargetText:"Conectando...",transferPageUnknownTransferorDisplayName:"Desconhecido",transferPageUnknownTransferTargetDisplayName:"Desconhecido"};var chat$5={chatListHeader:"Neste chat",uploadFile:"Carregar Arquivo"};var callWithChat$5={chatButtonLabel:"Chat",chatButtonNewMessageNotificationLabel:"Nova mensagem",chatButtonTooltipClosedWithMessageCount:"Mostrar chat ({unreadMessagesCount} não lido)",chatButtonTooltipClose:"Ocultar chat",chatButtonTooltipOpen:"Mostrar chat",chatPaneTitle:"Chat",copyInviteLinkButtonLabel:"Copiar o link de convite",copyInviteLinkActionedAriaLabel:"Link de convite copiado",dismissSidePaneButtonLabel:"Fechar",moreDrawerAudioDeviceMenuTitle:"Dispositivo de Áudio",moreDrawerButtonLabel:"Mais opções",moreDrawerButtonTooltip:"Mais opções",moreDrawerMicrophoneMenuTitle:"Microfone",moreDrawerSpeakerMenuTitle:"Alto-falante",moreDrawerCaptionsMenuTitle:"Legendas ao Vivo",moreDrawerSpokenLanguageMenuTitle:"Idioma falado",peopleButtonLabel:"Pessoas",peopleButtonTooltipOpen:"Mostrar Participantes",peopleButtonTooltipClose:"Ocultar participantes",peoplePaneSubTitle:"Nesta chamada",peoplePaneTitle:"Pessoas",pictureInPictureTileAriaLabel:"Feeds de vídeo. Clique para retornar à tela de chamada.",removeMenuLabel:"Remover",openDialpadButtonLabel:"Número de telefone de discagem",returnToCallButtonAriaDescription:"Retornar à Chamada",returnToCallButtonAriaLabel:"Voltar",peoplePaneAddPeopleButtonLabel:"Adicionar Pessoas",dialpadStartCallButtonLabel:"Chamar",dialpadModalTitle:"Número de Telefone de Discagem",dialpadModalAriaLabel:"Teclado de discagem",dialpadCloseModalButtonAriaLabel:"Fechar teclado",openDtmfDialpadLabel:"Mostrar teclado de discagem",dtmfDialpadPlaceholderText:"Digite o número"};var pt_BR = {call:call$5,chat:chat$5,callWithChat:callWithChat$5};

var call$4={cameraLabel:"Камера",noCamerasLabel:"Камеры не найдены",cameraPermissionDenied:"Браузер блокирует доступ к вашей камере",cameraTurnedOff:"Камера выключена",chatButtonLabel:"Чат",close:"Закрыть",complianceBannerNowOnlyRecording:"Сейчас для этого собрания ведется только запись.",complianceBannerNowOnlyTranscription:"Сейчас для этого собрания ведется только транскрибирование.",complianceBannerRecordingAndTranscriptionSaved:"Сохранение записи и транскрибирования.",complianceBannerRecordingAndTranscriptionStarted:"Начата запись и транскрибирование.",complianceBannerRecordingAndTranscriptionStopped:"Запись и транскрибирование остановлены.",complianceBannerRecordingSaving:"Сохранение записи.",complianceBannerRecordingStarted:"Запись начата.",complianceBannerRecordingStopped:"Запись остановлена.",complianceBannerTranscriptionStarted:"Транскрибирование запущено.",complianceBannerTranscriptionConsent:"Присоединяясь, вы даете согласие на транскрибирование этого собрания.",complianceBannerTranscriptionSaving:"Сохранение транскрибирования.",complianceBannerTranscriptionStopped:"Транскрибирование остановлено.",configurationPageTitle:"Позвонить",copyInviteLinkButtonLabel:"Копировать ссылку с приглашением",copyInviteLinkActionedAriaLabel:"Ссылка на приглашение в группу скопирована",defaultPlaceHolder:"Выберите один из вариантов",dismissSidePaneButtonLabel:"Закрыть",videoEffectsPaneTitle:"Эффекты",videoEffectsPaneBackgroundSelectionTitle:"Фон",configurationPageVideoEffectsButtonLabel:"Эффекты",unableToStartVideoEffect:"Не удалось применить эффект видео.",blurBackgroundEffectButtonLabel:"Размытие",blurBackgroundTooltip:"Размытие фона",removeBackgroundEffectButtonLabel:"Нет",removeBackgroundTooltip:"Удалить фон",cameraOffBackgroundEffectWarningText:"Камера выключена. Включите камеру, чтобы увидеть видеоэффект.",failedToJoinCallDueToNoNetworkMoreDetails:"Звонок был отключен из-за проблемы с сетью. Проверьте подключение и присоединитесь еще раз.",failedToJoinCallDueToNoNetworkTitle:"Вызов прерван",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Вам не предоставили доступ к беседе. Если это произошло по ошибке, заново присоединитесь к беседе.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Вы были удалены из \"зала ожидания\"",learnMore:"Подробнее",leavingCallTitle:"Выход...",leftCallMoreDetails:"Если это произошло по ошибке, заново присоединитесь к беседе.",leftCallTitle:"Вы покинули беседу",lobbyScreenConnectingToCallTitle:"Подключение к звонку",lobbyScreenWaitingToBeAdmittedTitle:"Ожидание допуска",microphonePermissionDenied:"Браузер блокирует доступ к вашему микрофону",microphoneToggleInLobbyNotAllowed:"Невозможно отключить или включить звук, находясь в \"зале ожидания\".",mutedMessage:"Ваш звук отключен",networkReconnectMoreDetails:"Похоже, что-то пошло не так. Мы пытаемся вернуться к звонку.",networkReconnectTitle:"Подождите",deniedPermissionToRoomDetails:"У вас нет разрешения на присоединение к этой комнате.",deniedPermissionToRoomTitle:"Отказано в разрешении для помещения",peopleButtonLabel:"Люди",peoplePaneTitle:"Люди",peopleButtonTooltipOpen:"Показать участников",peopleButtonTooltipClose:"Скрыть участников",peoplePaneSubTitle:"В этом звонке",privacyPolicy:"Политика конфиденциальности",rejoinCallButtonLabel:"Повторно присоединиться к звонку",removedFromCallMoreDetails:"Другой участник удалил вас из беседы.",removedFromCallTitle:"Вы были удалены",removeMenuLabel:"Удалить",returnToCallButtonAriaDescription:"Вернуться к звонку",returnToCallButtonAriaLabel:"Назад",roomNotFoundDetails:"Указан недопустимый идентификатор помещения.",roomNotFoundTitle:"Помещение не найдено",soundLabel:"Звук",noMicrophonesLabel:"Микрофоны не найдены",noSpeakersLabel:"Динамики не найдены",startCallButtonLabel:"Начать звонок",openDialpadButtonLabel:"Набрать номер телефона",peoplePaneAddPeopleButtonLabel:"Добавить людей",dialpadStartCallButtonLabel:"Позвонить",dialpadModalTitle:"Набор номера телефона",dialpadModalAriaLabel:"Панель набора номера",dialpadCloseModalButtonAriaLabel:"Закрыть панель набора номера",moreButtonCallingLabel:"Дополнительно",resumeCallButtonLabel:"Возобновить",resumingCallButtonLabel:"Возобновление…",resumeCallButtonAriaLabel:"Возобновить звонок",resumingCallButtonAriaLabel:"Возобновить вызов",holdScreenLabel:"Ваш звонок на удержании",openDtmfDialpadLabel:"Показать панель набора номера",dtmfDialpadPlaceholderText:"Введите номер",outboundCallingNoticeString:"Выполняется вызов...",participantJoinedNoticeString:"Пользователь {displayName} присоединился",twoParticipantJoinedNoticeString:"{displayName1} и {displayName2} присоединились",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} и {displayName3} присоединились",participantLeftNoticeString:"Пользователь {displayName} ушел",twoParticipantLeftNoticeString:"{displayName1} и {displayName2} ушли",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} и {displayName3} ушли",unnamedParticipantString:"участник без имени",manyUnnamedParticipantsJoined:"участник без имени и еще {numOfParticipants} участников присоединились",manyUnnamedParticipantsLeft:"участник без имени и еще {numOfParticipants} участников ушли",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} и {numOfParticipants} других участников",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} и {numOfParticipants} других участников",liveCaptionsLabel:"Автоматические субтитры",captionsSettingsLabel:"Параметры субтитров",startCaptionsButtonOnLabel:"Включить автоматические субтитры",startCaptionsButtonOffLabel:"Отключить автоматические субтитры",startCaptionsButtonTooltipOnContent:"Отключить автоматические субтитры",startCaptionsButtonTooltipOffContent:"Включить автоматические субтитры",captionsSettingsModalTitle:"На каком языке говорят?",captionsSettingsDropdownLabel:"Язык речи",captionsSettingsDropdownInfoText:"Язык, на котором говорят все участники звонка.",captionsSettingsConfirmButtonLabel:"Подтвердить",captionsSettingsCancelButtonLabel:"Отменить",captionsSettingsModalAriaLabel:"Модальное окно параметров субтитров",captionsSettingsCloseModalButtonAriaLabel:"Закрыть параметры субтитров",captionsBannerMoreButtonCallingLabel:"Дополнительно",captionsBannerMoreButtonTooltip:"Дополнительные параметры",captionsAvailableLanguageStrings:{"ar-ae":"Арабский (ОАЭ)","ar-sa":"Арабский (Саудовская Аравия)","da-dk":"Датский","de-de":"Немецкий (Германия)","en-au":"Английский (Австралия)","en-ca":"Английский (Канада)","en-gb":"Английский (Соединенное Королевство)","en-in":"Английский (Индия)","en-nz":"Английский (Новая Зеландия)","en-us":"Английский (США)","es-es":"Испанский (Испания), современная сортировка","es-mx":"Испанский (Мексика)","fi-fi":"Финский","fr-ca":"Французский (Канада)","fr-fr":"Французский (Франция)","hi-in":"Хинди","it-it":"Итальянский (Италия)","ja-jp":"Японский","ko-kr":"Корейский","nb-no":"Норвежский (букмол)","nl-be":"Нидерландский (Бельгия)","nl-nl":"Нидерландский — Нидерланды","pl-pl":"Польский","pt-br":"Португальский (Бразилия)","ru-ru":"Русский","sv-se":"Шведский","zh-cn":"Китайский (Китайская Народная Республика)","zh-hk":"Китайский (Гонконг, САР)","cs-cz":"Чешский","pt-pt":"Португальский (Португалия)","tr-tr":"Турецкий","vi-vn":"Вьетнамский","th-th":"Тайский","he-il":"Иврит","cy-gb":"Валлийский","uk-ua":"Украинский","el-gr":"Греческий","hu-hu":"Венгерский","ro-ro":"Румынский","sk-sk":"Словацкий","zh-tw":"Китайский (Тайвань)"},captionsBannerSpinnerText:"Запуск субтитров...",transferPageTransferorText:"Идет переключение...",transferPageTransferTargetText:"Подключение...",transferPageUnknownTransferorDisplayName:"Неизвестно",transferPageUnknownTransferTargetDisplayName:"Неизвестно"};var chat$4={chatListHeader:"В этом чате",uploadFile:"Отправить файл"};var callWithChat$4={chatButtonLabel:"Чат",chatButtonNewMessageNotificationLabel:"Новое сообщение",chatButtonTooltipClosedWithMessageCount:"Показать чат (непрочитано: {unreadMessagesCount})",chatButtonTooltipClose:"Скрыть чат",chatButtonTooltipOpen:"Показать чат",chatPaneTitle:"Чат",copyInviteLinkButtonLabel:"Копировать ссылку с приглашением",copyInviteLinkActionedAriaLabel:"Ссылка на приглашение в группу скопирована",dismissSidePaneButtonLabel:"Закрыть",moreDrawerAudioDeviceMenuTitle:"Звуковое устройство",moreDrawerButtonLabel:"Дополнительные параметры",moreDrawerButtonTooltip:"Дополнительные параметры",moreDrawerMicrophoneMenuTitle:"Микрофон",moreDrawerSpeakerMenuTitle:"Динамик",moreDrawerCaptionsMenuTitle:"Автоматические субтитры",moreDrawerSpokenLanguageMenuTitle:"Язык речи",peopleButtonLabel:"Люди",peopleButtonTooltipOpen:"Показать участников",peopleButtonTooltipClose:"Скрыть участников",peoplePaneSubTitle:"В этом звонке",peoplePaneTitle:"Люди",pictureInPictureTileAriaLabel:"Ленты видео. Щелкните, чтобы вернуться на экран вызова.",removeMenuLabel:"Удалить",openDialpadButtonLabel:"Набрать номер телефона",returnToCallButtonAriaDescription:"Вернуться к звонку",returnToCallButtonAriaLabel:"Назад",peoplePaneAddPeopleButtonLabel:"Добавить людей",dialpadStartCallButtonLabel:"Позвонить",dialpadModalTitle:"Набор номера телефона",dialpadModalAriaLabel:"Панель набора номера",dialpadCloseModalButtonAriaLabel:"Закрыть панель набора номера",openDtmfDialpadLabel:"Показать панель набора номера",dtmfDialpadPlaceholderText:"Введите номер"};var ru_RU = {call:call$4,chat:chat$4,callWithChat:callWithChat$4};

var call$3={cameraLabel:"Kamera",noCamerasLabel:"Ingen kamera hittades",cameraPermissionDenied:"Din webbläsare blockerar åtkomsten till kameran",cameraTurnedOff:"Din kamera är avstängd",chatButtonLabel:"Chatt",close:"Stäng",complianceBannerNowOnlyRecording:"Du spelar nu bara in det här mötet.",complianceBannerNowOnlyTranscription:"Nu transkriberar du bara det här mötet.",complianceBannerRecordingAndTranscriptionSaved:"Inspelning och transkription sparas.",complianceBannerRecordingAndTranscriptionStarted:"Inspelning och avskrift har startats.",complianceBannerRecordingAndTranscriptionStopped:"Inspelning och avskrift har avslutats.",complianceBannerRecordingSaving:"Inspelningen sparas.",complianceBannerRecordingStarted:"Inspelningen har startat.",complianceBannerRecordingStopped:"Inspelningen har stoppats.",complianceBannerTranscriptionStarted:"Transkriptionen har startat.",complianceBannerTranscriptionConsent:"Genom att ansluta ger du ditt medgivande för att det här mötet ska transkriberas.",complianceBannerTranscriptionSaving:"Transkriptionen sparas.",complianceBannerTranscriptionStopped:"Avskriften har avslutats.",configurationPageTitle:"Starta ett samtal",copyInviteLinkButtonLabel:"Kopiera inbjudningslänk",copyInviteLinkActionedAriaLabel:"Inbjudningslänken har kopierats",defaultPlaceHolder:"Välj ett alternativ",dismissSidePaneButtonLabel:"Stäng",videoEffectsPaneTitle:"Effekter",videoEffectsPaneBackgroundSelectionTitle:"Bakgrund",configurationPageVideoEffectsButtonLabel:"Effekter",unableToStartVideoEffect:"Det går inte att tillämpa videoeffekten.",blurBackgroundEffectButtonLabel:"Oskärpa",blurBackgroundTooltip:"Gör bakgrunden oskarp",removeBackgroundEffectButtonLabel:"Ingen",removeBackgroundTooltip:"Ta bort bakgrund",cameraOffBackgroundEffectWarningText:"Kameran är avstängd. Aktivera kameran för att se videoeffekten.",failedToJoinCallDueToNoNetworkMoreDetails:"Samtalet kopplades från på grund av ett nätverksproblem. Kontrollera anslutningen och anslut igen.",failedToJoinCallDueToNoNetworkTitle:"Samtalet har kopplats från",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Du har inte beviljats något bidrag i samtalet. Om det var ett misstag ansluter du till samtalet igen.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Avvisad från lobbyn",learnMore:"Mer information",leavingCallTitle:"Lämnar…",leftCallMoreDetails:"Anslut till samtalet igen om det var ett misstag.",leftCallTitle:"Du lämnade samtalet",lobbyScreenConnectingToCallTitle:"Ansluter till samtalet",lobbyScreenWaitingToBeAdmittedTitle:"Väntar på att bli insläst",microphonePermissionDenied:"Din webbläsare blockerar åtkomsten till mikrofonen",microphoneToggleInLobbyNotAllowed:"Det går inte att stänga av ljudet eller slå på ljudet i lobbyn.",mutedMessage:"Din mikrofon har stängts av",networkReconnectMoreDetails:"Något verkar ha gått fel. Vi försöker komma in i samtalet igen.",networkReconnectTitle:"Vänta",deniedPermissionToRoomDetails:"Du har inte behörighet att ansluta till det här rummet.",deniedPermissionToRoomTitle:"Behörighet nekad till rum",peopleButtonLabel:"Personer",peoplePaneTitle:"Personer",peopleButtonTooltipOpen:"Visa deltagare",peopleButtonTooltipClose:"Dölj deltagare",peoplePaneSubTitle:"I det här samtalet",privacyPolicy:"Sekretesspolicy",rejoinCallButtonLabel:"Anslut till samtal igen",removedFromCallMoreDetails:"En annan deltagare tog bort dig från samtalet.",removedFromCallTitle:"Du har tagits bort",removeMenuLabel:"Ta bort",returnToCallButtonAriaDescription:"Återgå till samtal",returnToCallButtonAriaLabel:"Tillbaka",roomNotFoundDetails:"Det angivna rums-ID:t är inte giltigt.",roomNotFoundTitle:"Rummet hittades inte",soundLabel:"Ljud",noMicrophonesLabel:"Inga mikrofoner hittades",noSpeakersLabel:"Inga högtalare hittades",startCallButtonLabel:"Starta samtal",openDialpadButtonLabel:"Ring telefonnummer",peoplePaneAddPeopleButtonLabel:"Lägg till personer",dialpadStartCallButtonLabel:"Ringa upp",dialpadModalTitle:"Ring telefonnummer",dialpadModalAriaLabel:"Knappsats",dialpadCloseModalButtonAriaLabel:"Stäng knappsats",moreButtonCallingLabel:"Mer",resumeCallButtonLabel:"Återuppta",resumingCallButtonLabel:"Återupptar",resumeCallButtonAriaLabel:"Återuppta samtal",resumingCallButtonAriaLabel:"Återuppta samtal",holdScreenLabel:"Du är parkerad",openDtmfDialpadLabel:"Visa knappsats",dtmfDialpadPlaceholderText:"Ange nummer",outboundCallingNoticeString:"Ringer...",participantJoinedNoticeString:"{displayName} har anslutits",twoParticipantJoinedNoticeString:"{displayName1} och {displayName2} har anslutit",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} och {displayName3} gick med",participantLeftNoticeString:"{displayName} kvar",twoParticipantLeftNoticeString:"{displayName1} och {displayName2} har lämnat",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} och {displayName3} har lämnat",unnamedParticipantString:"namnlös deltagare",manyUnnamedParticipantsJoined:"namnlös deltagare och {numOfParticipants} andra deltagare gick med",manyUnnamedParticipantsLeft:"namnlös deltagare och {numOfParticipants} andra deltagare kvar",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} och {numOfParticipants} andra deltagare har anslutit",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} och {numOfParticipants} andra deltagare har lämnat",liveCaptionsLabel:"Liveundertexter",captionsSettingsLabel:"Inställningar för undertexter",startCaptionsButtonOnLabel:"Aktivera undertexter",startCaptionsButtonOffLabel:"Stäng av undertexter",startCaptionsButtonTooltipOnContent:"Stäng av undertexter",startCaptionsButtonTooltipOffContent:"Aktivera undertexter",captionsSettingsModalTitle:"Vilket språk talas?",captionsSettingsDropdownLabel:"Talat språk",captionsSettingsDropdownInfoText:"Språk som alla i det här samtalet talar.",captionsSettingsConfirmButtonLabel:"Bekräfta",captionsSettingsCancelButtonLabel:"Avbryt",captionsSettingsModalAriaLabel:"Modalt fönster för inställning av undertexter",captionsSettingsCloseModalButtonAriaLabel:"Stäng inställningar för undertexter",captionsBannerMoreButtonCallingLabel:"Mer",captionsBannerMoreButtonTooltip:"Fler alternativ",captionsAvailableLanguageStrings:{"ar-ae":"Arabiska – Förenade Arabemiraten","ar-sa":"Arabiska – Saudiarabien","da-dk":"Danska","de-de":"Tyska – Tyskland","en-au":"Engelska – Australien","en-ca":"Engelska – Kanada","en-gb":"Engelska – Storbritannien","en-in":"Engelska – Indien","en-nz":"Engelska – Nya Zeeland","en-us":"Engelska – USA","es-es":"Spanska – Spanien (modern sortering)","es-mx":"Spanska – Mexiko","fi-fi":"Finska","fr-ca":"Franska – Kanada","fr-fr":"Franska – Frankrike","hi-in":"Hindi","it-it":"Italienska – Italien","ja-jp":"Japanska","ko-kr":"Koreanska","nb-no":"Norska (bokmål)","nl-be":"Nederländska – Belgien","nl-nl":"Nederländska -–Nederländerna","pl-pl":"Polska","pt-br":"Portugisiska – Brasilien","ru-ru":"Ryska","sv-se":"Svenska","zh-cn":"Kinesiska (Kina),","zh-hk":"Kinesiska – Hongkong SAR","cs-cz":"Tjeckiska","pt-pt":"Portugisiska – Portugal","tr-tr":"Turkiska","vi-vn":"Vietnamesiska","th-th":"Thailändska","he-il":"Hebreiska","cy-gb":"Walesiska","uk-ua":"Ukrainska","el-gr":"Grekiska","hu-hu":"Ungerska","ro-ro":"Rumänska","sk-sk":"Slovakiska","zh-tw":"Kinesiska – Taiwan"},captionsBannerSpinnerText:"Startar undertexter ...",transferPageTransferorText:"Överför...",transferPageTransferTargetText:"Ansluter...",transferPageUnknownTransferorDisplayName:"Okänd",transferPageUnknownTransferTargetDisplayName:"Okänd"};var chat$3={chatListHeader:"I den här chatten",uploadFile:"Ladda upp fil"};var callWithChat$3={chatButtonLabel:"Chatt",chatButtonNewMessageNotificationLabel:"Nytt meddelande",chatButtonTooltipClosedWithMessageCount:"Visa chatt ({unreadMessagesCount} oläst)",chatButtonTooltipClose:"Dölj chatt",chatButtonTooltipOpen:"Visa chatt",chatPaneTitle:"Chatt",copyInviteLinkButtonLabel:"Kopiera inbjudningslänk",copyInviteLinkActionedAriaLabel:"Inbjudningslänken har kopierats",dismissSidePaneButtonLabel:"Stäng",moreDrawerAudioDeviceMenuTitle:"Ljudenhet",moreDrawerButtonLabel:"Fler alternativ",moreDrawerButtonTooltip:"Fler alternativ",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Högtalare",moreDrawerCaptionsMenuTitle:"Liveundertexter",moreDrawerSpokenLanguageMenuTitle:"Talat språk",peopleButtonLabel:"Personer",peopleButtonTooltipOpen:"Visa deltagare",peopleButtonTooltipClose:"Dölj deltagare",peoplePaneSubTitle:"I det här samtalet",peoplePaneTitle:"Personer",pictureInPictureTileAriaLabel:"Videofeeds. Klicka för att återgå till samtalsskärmen.",removeMenuLabel:"Ta bort",openDialpadButtonLabel:"Ring telefonnummer",returnToCallButtonAriaDescription:"Återgå till samtal",returnToCallButtonAriaLabel:"Tillbaka",peoplePaneAddPeopleButtonLabel:"Lägg till personer",dialpadStartCallButtonLabel:"Ringa upp",dialpadModalTitle:"Ring telefonnummer",dialpadModalAriaLabel:"Knappsats",dialpadCloseModalButtonAriaLabel:"Stäng knappsats",openDtmfDialpadLabel:"Visa knappsats",dtmfDialpadPlaceholderText:"Ange nummer"};var sv_SE = {call:call$3,chat:chat$3,callWithChat:callWithChat$3};

var call$2={cameraLabel:"Kamera",noCamerasLabel:"Kamera bulunamadı",cameraPermissionDenied:"Tarayıcınız kameranıza erişimi engelliyor",cameraTurnedOff:"Kameranız kapatıldı",chatButtonLabel:"Sohbet",close:"Kapat",complianceBannerNowOnlyRecording:"Şu anda yalnızca bu toplantıyı kaydediyorsunuz.",complianceBannerNowOnlyTranscription:"Şu anda yalnızca bu toplantının dökümünü oluşturuyorsunuz.",complianceBannerRecordingAndTranscriptionSaved:"Kayıt ve döküm kaydediliyor.",complianceBannerRecordingAndTranscriptionStarted:"Kayıt ve döküm başlatıldı.",complianceBannerRecordingAndTranscriptionStopped:"Kayıt ve döküm durduruldu.",complianceBannerRecordingSaving:"Kayıt kaydediliyor.",complianceBannerRecordingStarted:"Kayıt başladı.",complianceBannerRecordingStopped:"Kayıt durduruldu.",complianceBannerTranscriptionStarted:"Döküm başlatıldı.",complianceBannerTranscriptionConsent:"Katılarak bu toplantının dökümünün çıkarılmasına onay verirsiniz.",complianceBannerTranscriptionSaving:"Döküm kaydediliyor.",complianceBannerTranscriptionStopped:"Döküm durduruldu.",configurationPageTitle:"Arama başlatın",copyInviteLinkButtonLabel:"Davet bağlantısını kopyala",copyInviteLinkActionedAriaLabel:"Davet bağlantısı kopyalandı",defaultPlaceHolder:"Bir seçenek belirleyin",dismissSidePaneButtonLabel:"Kapat",videoEffectsPaneTitle:"Efektler",videoEffectsPaneBackgroundSelectionTitle:"Arka plan",configurationPageVideoEffectsButtonLabel:"Efektler",unableToStartVideoEffect:"Video efekti uygulanamıyor.",blurBackgroundEffectButtonLabel:"Bulanıklaştır",blurBackgroundTooltip:"Arka Planı Bulanıklaştır",removeBackgroundEffectButtonLabel:"Seçilmedi",removeBackgroundTooltip:"Arka Planı Kaldır",cameraOffBackgroundEffectWarningText:"Kameranız kapalı. Video efektini görmek için kamerayı açın.",failedToJoinCallDueToNoNetworkMoreDetails:"Bir ağ sorunu nedeniyle arama bağlantısı kesildi. Bağlantınızı kontrol edin ve yeniden katılın.",failedToJoinCallDueToNoNetworkTitle:"Arama kesildi",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"Aramaya katılmanıza izin verilmedi. Bu işlem yanlışlıkla yapıldıysa aramaya yeniden katılın.",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"Lobiden çıkarıldı",learnMore:"Daha fazla bilgi edinin",leavingCallTitle:"Ayrılıyor...",leftCallMoreDetails:"Bu bir hataysa aramaya yeniden katılın.",leftCallTitle:"Aramadan ayrıldınız",lobbyScreenConnectingToCallTitle:"Aramaya katılıyorsunuz",lobbyScreenWaitingToBeAdmittedTitle:"Kabul edilmeyi bekliyor",microphonePermissionDenied:"Tarayıcınız mikrofonunuza erişimi engelliyor",microphoneToggleInLobbyNotAllowed:"Lobideyken sesi kapatılamaz veya açılamaz.",mutedMessage:"Sesiniz kapatıldı",networkReconnectMoreDetails:"Bir sorun oluştu gibi görünüyor. Çağrıya geri alınmaya çalışılıyor.",networkReconnectTitle:"Bekleyin",deniedPermissionToRoomDetails:"Bu odaya katılma izniniz yok.",deniedPermissionToRoomTitle:"Odaya izin verilmedi",peopleButtonLabel:"Kişiler",peoplePaneTitle:"Kişiler",peopleButtonTooltipOpen:"Katılımcıları göster",peopleButtonTooltipClose:"Katılımcıları gizle",peoplePaneSubTitle:"Bu aramada",privacyPolicy:"Gizlilik ilkesi",rejoinCallButtonLabel:"Çağrıya yeniden katıl",removedFromCallMoreDetails:"Başka bir katılımcı sizi aramadan çıkardı.",removedFromCallTitle:"Çıkarıldınız",removeMenuLabel:"Kaldır",returnToCallButtonAriaDescription:"Aramaya Dön",returnToCallButtonAriaLabel:"Geri",roomNotFoundDetails:"Sağlanan oda kimliği geçerli değil.",roomNotFoundTitle:"Oda bulunamadı",soundLabel:"Ses",noMicrophonesLabel:"Mikrofon bulunamadı",noSpeakersLabel:"Hoparlör bulunamadı",startCallButtonLabel:"Arama başlat",openDialpadButtonLabel:"Telefon numarasını çevir",peoplePaneAddPeopleButtonLabel:"Kişi Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasını Çevir",dialpadModalAriaLabel:"Tuş takımı",dialpadCloseModalButtonAriaLabel:"Tuş takımını kapat",moreButtonCallingLabel:"Diğer",resumeCallButtonLabel:"Devam edin",resumingCallButtonLabel:"Devam ediyor...",resumeCallButtonAriaLabel:"Görüşmeye devam edin",resumingCallButtonAriaLabel:"Görüşmeye devam edin",holdScreenLabel:"Beklemeye alındınız",openDtmfDialpadLabel:"Tuş takımını göster",dtmfDialpadPlaceholderText:"Numara girin",outboundCallingNoticeString:"Aranıyor...",participantJoinedNoticeString:"{displayName} katıldı",twoParticipantJoinedNoticeString:"{displayName1} ve {displayName2} katıldı",threeParticipantJoinedNoticeString:"{displayName1}, {displayName2} ve {displayName3} katıldı",participantLeftNoticeString:"{displayName} ayrıldı",twoParticipantLeftNoticeString:"{displayName1} ve {displayName2} ayrıldı",threeParticipantLeftNoticeString:"{displayName1}, {displayName2} ve {displayName3} ayrıldı",unnamedParticipantString:"adsız katılımcı",manyUnnamedParticipantsJoined:"adsız katılımcı ve {numOfParticipants} katılımcı katıldı",manyUnnamedParticipantsLeft:"adsız katılımcı ve {numOfParticipants} katılımcı ayrıldı",manyParticipantsJoined:"{displayName1}, {displayName2}, {displayName3} ve {numOfParticipants} katılımcı katıldı",manyParticipantsLeft:"{displayName1}, {displayName2}, {displayName3} ve {numOfParticipants} katılımcı kaldı",liveCaptionsLabel:"Açıklamalı canlı alt yazılar",captionsSettingsLabel:"Açıklamalı alt yazı ayarları",startCaptionsButtonOnLabel:"Açıklamalı alt yazıları açma",startCaptionsButtonOffLabel:"Açıklamalı alt yazıları kapat",startCaptionsButtonTooltipOnContent:"Açıklamalı alt yazıları kapat",startCaptionsButtonTooltipOffContent:"Açıklamalı alt yazıları açma",captionsSettingsModalTitle:"Hangi dil konuşuluyor?",captionsSettingsDropdownLabel:"Konuşulan dil",captionsSettingsDropdownInfoText:"Bu çağrıdaki herkesin konuşma dili.",captionsSettingsConfirmButtonLabel:"Onayla",captionsSettingsCancelButtonLabel:"İptal",captionsSettingsModalAriaLabel:"Açıklamalı Alt Yazı Ayarı Kalıcı",captionsSettingsCloseModalButtonAriaLabel:"Açıklamalı Alt Yazı Ayarını Kapat",captionsBannerMoreButtonCallingLabel:"Diğer",captionsBannerMoreButtonTooltip:"Diğer seçenekler",captionsAvailableLanguageStrings:{"ar-ae":"Arapça - BAE","ar-sa":"Arapça - Suudi Arabistan","da-dk":"Danca","de-de":"Almanca - Almanya","en-au":"İngilizce - Avustralya","en-ca":"İngilizce - Kanada","en-gb":"İngilizce - Birleşik Krallık","en-in":"İngilizce - Hindistan","en-nz":"İngilizce - Yeni Zelanda","en-us":"İngilizce - ABD","es-es":"İspanyolca - İspanya (Modern)","es-mx":"İspanyolca - Meksika","fi-fi":"Fince","fr-ca":"Fransızca - Kanada","fr-fr":"Fransızca - Fransa","hi-in":"Hintçe","it-it":"İtalyanca - İtalya","ja-jp":"Japonca","ko-kr":"Korece","nb-no":"Norveççe (Bokmål)","nl-be":"Hollanda dili - Belçika","nl-nl":"Felemenkçe - Hollanda","pl-pl":"Lehçe","pt-br":"Portekizce - Brezilya","ru-ru":"Rusça","sv-se":"İsveççe","zh-cn":"Çince - Çin Halk Cumhuriyeti","zh-hk":"Çince - Hong Kong ÖİB","cs-cz":"Çekçe","pt-pt":"Portekizce - Portekiz","tr-tr":"Türkçe","vi-vn":"Vietnamca","th-th":"Tayca","he-il":"İbranice","cy-gb":"Galce","uk-ua":"Ukraynaca","el-gr":"Yunanca","hu-hu":"Macarca","ro-ro":"Rumence","sk-sk":"Slovakça","zh-tw":"Çince - Tayvan"},captionsBannerSpinnerText:"Alt yazılar başlatılıyor...",transferPageTransferorText:"Aktarılıyor...",transferPageTransferTargetText:"Bağlanıyor...",transferPageUnknownTransferorDisplayName:"Bilinmiyor",transferPageUnknownTransferTargetDisplayName:"Bilinmiyor"};var chat$2={chatListHeader:"Bu sohbette",uploadFile:"Dosyayı Karşıya Yükle"};var callWithChat$2={chatButtonLabel:"Sohbet",chatButtonNewMessageNotificationLabel:"Yeni İleti",chatButtonTooltipClosedWithMessageCount:"Sohbeti göster ({unreadMessagesCount} okunmamış)",chatButtonTooltipClose:"Sohbeti gizle",chatButtonTooltipOpen:"Sohbeti göster",chatPaneTitle:"Sohbet",copyInviteLinkButtonLabel:"Davet bağlantısını kopyala",copyInviteLinkActionedAriaLabel:"Davet bağlantısı kopyalandı",dismissSidePaneButtonLabel:"Kapat",moreDrawerAudioDeviceMenuTitle:"Ses Cihazı",moreDrawerButtonLabel:"Diğer seçenekler",moreDrawerButtonTooltip:"Diğer seçenekler",moreDrawerMicrophoneMenuTitle:"Mikrofon",moreDrawerSpeakerMenuTitle:"Hoparlör",moreDrawerCaptionsMenuTitle:"Açıklamalı canlı alt yazılar",moreDrawerSpokenLanguageMenuTitle:"Konuşulan dil",peopleButtonLabel:"Kişiler",peopleButtonTooltipOpen:"Katılımcıları göster",peopleButtonTooltipClose:"Katılımcıları gizle",peoplePaneSubTitle:"Bu aramada",peoplePaneTitle:"Kişiler",pictureInPictureTileAriaLabel:"Video Akışları. Çağrı ekranına dönmek için tıklayın.",removeMenuLabel:"Kaldır",openDialpadButtonLabel:"Telefon numarasını çevir",returnToCallButtonAriaDescription:"Aramaya Dön",returnToCallButtonAriaLabel:"Geri",peoplePaneAddPeopleButtonLabel:"Kişi Ekle",dialpadStartCallButtonLabel:"Ara",dialpadModalTitle:"Telefon Numarasını Çevir",dialpadModalAriaLabel:"Tuş takımı",dialpadCloseModalButtonAriaLabel:"Tuş takımını kapat",openDtmfDialpadLabel:"Tuş takımını göster",dtmfDialpadPlaceholderText:"Numara girin"};var tr_TR = {call:call$2,chat:chat$2,callWithChat:callWithChat$2};

var call$1={cameraLabel:"照相机",noCamerasLabel:"未找到摄像头",cameraPermissionDenied:"你的浏览器正在阻止对相机的访问",cameraTurnedOff:"你的相机已关闭",chatButtonLabel:"聊天",close:"关闭",complianceBannerNowOnlyRecording:"现在仅录制此会议。",complianceBannerNowOnlyTranscription:"现在仅听录此会议。",complianceBannerRecordingAndTranscriptionSaved:"正在保存录制和听录。",complianceBannerRecordingAndTranscriptionStarted:"录制和听录已开始。",complianceBannerRecordingAndTranscriptionStopped:"录制和听录已停止。",complianceBannerRecordingSaving:"正在保存录制。",complianceBannerRecordingStarted:"录制已开始。",complianceBannerRecordingStopped:"录制已停止。",complianceBannerTranscriptionStarted:"听录已开始。",complianceBannerTranscriptionConsent:"加入即表示你同意转录此会议。",complianceBannerTranscriptionSaving:"正在保存听录。",complianceBannerTranscriptionStopped:"听录已停止。",configurationPageTitle:"开始通话",copyInviteLinkButtonLabel:"复制邀请链接",copyInviteLinkActionedAriaLabel:"已复制邀请链接",defaultPlaceHolder:"选择一个选项",dismissSidePaneButtonLabel:"关闭",videoEffectsPaneTitle:"效果",videoEffectsPaneBackgroundSelectionTitle:"背景",configurationPageVideoEffectsButtonLabel:"效果",unableToStartVideoEffect:"无法应用视频效果。",blurBackgroundEffectButtonLabel:"模糊",blurBackgroundTooltip:"模糊背景",removeBackgroundEffectButtonLabel:"无",removeBackgroundTooltip:"删除背景",cameraOffBackgroundEffectWarningText:"你的相机已关闭。打开相机以查看视频效果。",failedToJoinCallDueToNoNetworkMoreDetails:"由于网络问题，呼叫已断开连接。请检查你的连接，然后重新加入。",failedToJoinCallDueToNoNetworkTitle:"通话已断开",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"未在通话中向你授予条目。如果这是一个错误，请重新加入呼叫。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"已从大厅中关闭",learnMore:"了解详细信息",leavingCallTitle:"正在退出...",leftCallMoreDetails:"如果这是一个错误，请重新加入呼叫。",leftCallTitle:"你已离开通话",lobbyScreenConnectingToCallTitle:"加入通话",lobbyScreenWaitingToBeAdmittedTitle:"正在等待被拒绝",microphonePermissionDenied:"你的浏览器正在阻止对麦克风的访问",microphoneToggleInLobbyNotAllowed:"在大厅中时无法静音或取消静音。",mutedMessage:"你已静音",networkReconnectMoreDetails:"似乎出现了问题。我们正在努力恢复通话。",networkReconnectTitle:"稍等",deniedPermissionToRoomDetails:"你没有加入此聊天室的权限。",deniedPermissionToRoomTitle:"已拒绝对会议室的权限",peopleButtonLabel:"人员",peoplePaneTitle:"人员",peopleButtonTooltipOpen:"显示参与者",peopleButtonTooltipClose:"隐藏参与者",peoplePaneSubTitle:"在此通话中",privacyPolicy:"隐私策略",rejoinCallButtonLabel:"重新加入呼叫",removedFromCallMoreDetails:"另一名参与者已将你从通话中删除。",removedFromCallTitle:"你已被删除",removeMenuLabel:"删除",returnToCallButtonAriaDescription:"返回通话",returnToCallButtonAriaLabel:"返回",roomNotFoundDetails:"提供的会议室 ID 无效。",roomNotFoundTitle:"未找到会议室。",soundLabel:"声音",noMicrophonesLabel:"未找到麦克风",noSpeakersLabel:"未找到扬声器",startCallButtonLabel:"开始通话",openDialpadButtonLabel:"拨打电话号码",peoplePaneAddPeopleButtonLabel:"添加人员",dialpadStartCallButtonLabel:"呼叫",dialpadModalTitle:"拨打电话号码",dialpadModalAriaLabel:"拨号盘",dialpadCloseModalButtonAriaLabel:"关闭拨号盘",moreButtonCallingLabel:"更多",resumeCallButtonLabel:"恢复",resumingCallButtonLabel:"正在恢复...",resumeCallButtonAriaLabel:"继续呼叫",resumingCallButtonAriaLabel:"继续通话",holdScreenLabel:"你的通话处于保留状态",openDtmfDialpadLabel:"显示拨号盘",dtmfDialpadPlaceholderText:"输入号码",outboundCallingNoticeString:"正在呼叫...",participantJoinedNoticeString:"{displayName} 已加入",twoParticipantJoinedNoticeString:"{displayName1} 和 {displayName2} 已加入",threeParticipantJoinedNoticeString:"{displayName1}、{displayName2} 和 {displayName3} 已加入",participantLeftNoticeString:"{displayName} 已离开",twoParticipantLeftNoticeString:"{displayName1} 和 {displayName2} 已离开",threeParticipantLeftNoticeString:"{displayName1}、{displayName2} 和 {displayName3} 已离开",unnamedParticipantString:"未命名的参与者",manyUnnamedParticipantsJoined:"未命名的参与者和其他 {numOfParticipants} 名参与者已加入",manyUnnamedParticipantsLeft:"未命名的参与者和其他 {numOfParticipants} 名参与者已离开",manyParticipantsJoined:"{displayName1}、{displayName2}、{displayName3}和其他{numOfParticipants}位参与者已加入",manyParticipantsLeft:"{displayName1}、{displayName2}、{displayName3}和其他{numOfParticipants}位参与者已离开",liveCaptionsLabel:"实时辅助字幕",captionsSettingsLabel:"字幕设置",startCaptionsButtonOnLabel:"开启字幕",startCaptionsButtonOffLabel:"关闭辅助字幕",startCaptionsButtonTooltipOnContent:"关闭辅助字幕",startCaptionsButtonTooltipOffContent:"开启字幕",captionsSettingsModalTitle:"正在使用哪种语言?",captionsSettingsDropdownLabel:"口述语言",captionsSettingsDropdownInfoText:"此通话中的每个人都在讲的语言。",captionsSettingsConfirmButtonLabel:"确认",captionsSettingsCancelButtonLabel:"取消",captionsSettingsModalAriaLabel:"字幕设置模式",captionsSettingsCloseModalButtonAriaLabel:"关闭字幕设置",captionsBannerMoreButtonCallingLabel:"更多",captionsBannerMoreButtonTooltip:"更多选项",captionsAvailableLanguageStrings:{"ar-ae":"阿拉伯语 - 阿拉伯联合酋长国","ar-sa":"阿拉伯语 - 沙特阿拉伯","da-dk":"丹麦语","de-de":"德语 - 德国","en-au":"英语 - 澳大利亚","en-ca":"英语 - 加拿大","en-gb":"英语 - 英国","en-in":"英语 - 印度","en-nz":"英语 - 新西兰","en-us":"英语 - 美国","es-es":"西班牙语 - 西班牙(现代风格)","es-mx":"西班牙语 - 墨西哥","fi-fi":"芬兰语","fr-ca":"法语 - 加拿大","fr-fr":"法语 - 法国","hi-in":"印地语","it-it":"意大利语–意大利","ja-jp":"日语","ko-kr":"朝鲜语","nb-no":"挪威语(博克马尔语)","nl-be":"荷兰语 - 比利时","nl-nl":"荷兰语 – 荷兰","pl-pl":"波兰语","pt-br":"葡萄牙语 - 巴西","ru-ru":"俄语","sv-se":"瑞典语","zh-cn":"中文 - 中华人民共和国","zh-hk":"中文 - 香港特别行政区","cs-cz":"捷克语","pt-pt":"葡萄牙语 - 葡萄牙","tr-tr":"土耳其语","vi-vn":"越南语","th-th":"泰语","he-il":"希伯来语","cy-gb":"威尔士语","uk-ua":"乌克兰语","el-gr":"希腊语","hu-hu":"匈牙利语","ro-ro":"罗马尼亚语","sk-sk":"斯洛伐克语","zh-tw":"中文 – 台湾"},captionsBannerSpinnerText:"正在启动字幕...",transferPageTransferorText:"正在转接...",transferPageTransferTargetText:"正在连接...",transferPageUnknownTransferorDisplayName:"未知",transferPageUnknownTransferTargetDisplayName:"未知"};var chat$1={chatListHeader:"在此聊天中",uploadFile:"上传文件"};var callWithChat$1={chatButtonLabel:"聊天",chatButtonNewMessageNotificationLabel:"新建消息",chatButtonTooltipClosedWithMessageCount:"显示聊天({unreadMessagesCount} 条未读)",chatButtonTooltipClose:"隐藏聊天",chatButtonTooltipOpen:"显示聊天",chatPaneTitle:"聊天",copyInviteLinkButtonLabel:"复制邀请链接",copyInviteLinkActionedAriaLabel:"已复制邀请链接",dismissSidePaneButtonLabel:"关闭",moreDrawerAudioDeviceMenuTitle:"音频设备",moreDrawerButtonLabel:"更多选项",moreDrawerButtonTooltip:"更多选项",moreDrawerMicrophoneMenuTitle:"麦克风",moreDrawerSpeakerMenuTitle:"扬声器",moreDrawerCaptionsMenuTitle:"实时辅助字幕",moreDrawerSpokenLanguageMenuTitle:"口述语言",peopleButtonLabel:"人员",peopleButtonTooltipOpen:"显示参与者",peopleButtonTooltipClose:"隐藏参与者",peoplePaneSubTitle:"在此通话中",peoplePaneTitle:"人员",pictureInPictureTileAriaLabel:"视频源。单击以返回到通话屏幕。",removeMenuLabel:"删除",openDialpadButtonLabel:"拨打电话号码",returnToCallButtonAriaDescription:"返回通话",returnToCallButtonAriaLabel:"返回",peoplePaneAddPeopleButtonLabel:"添加人员",dialpadStartCallButtonLabel:"呼叫",dialpadModalTitle:"拨打电话号码",dialpadModalAriaLabel:"拨号盘",dialpadCloseModalButtonAriaLabel:"关闭拨号盘",openDtmfDialpadLabel:"显示拨号盘",dtmfDialpadPlaceholderText:"输入号码"};var zh_CN = {call:call$1,chat:chat$1,callWithChat:callWithChat$1};

var call={cameraLabel:"相機",noCamerasLabel:"找不到相機",cameraPermissionDenied:"您的瀏覽器禁止存取您的相機",cameraTurnedOff:"您的相機已關閉",chatButtonLabel:"聊天",close:"關閉",complianceBannerNowOnlyRecording:"您現在只會錄製此會議。",complianceBannerNowOnlyTranscription:"您現在只會轉錄此會議。",complianceBannerRecordingAndTranscriptionSaved:"正在儲存錄製和轉錄。",complianceBannerRecordingAndTranscriptionStarted:"已開始錄製並進行轉錄。",complianceBannerRecordingAndTranscriptionStopped:"已停止錄製與轉錄。",complianceBannerRecordingSaving:"正在儲存錄製內容。",complianceBannerRecordingStarted:"已開始錄製。",complianceBannerRecordingStopped:"已停止錄製。",complianceBannerTranscriptionStarted:"已開始轉錄。",complianceBannerTranscriptionConsent:"一旦加入，即表示您同意轉譯此會議。",complianceBannerTranscriptionSaving:"正在儲存轉錄。",complianceBannerTranscriptionStopped:"已停止轉錄。",configurationPageTitle:"開始通話",copyInviteLinkButtonLabel:"複製邀請連結",copyInviteLinkActionedAriaLabel:"已複製邀請連結",defaultPlaceHolder:"選取選項",dismissSidePaneButtonLabel:"關閉",videoEffectsPaneTitle:"效果",videoEffectsPaneBackgroundSelectionTitle:"背景",configurationPageVideoEffectsButtonLabel:"效果",unableToStartVideoEffect:"無法套用視訊效果。",blurBackgroundEffectButtonLabel:"模糊",blurBackgroundTooltip:"模糊背景",removeBackgroundEffectButtonLabel:"無",removeBackgroundTooltip:"移除背景",cameraOffBackgroundEffectWarningText:"您的相機已關閉。開啟相機以查看影片效果。",failedToJoinCallDueToNoNetworkMoreDetails:"由於網路問題，通話已中斷連線。檢查您的連線並再次加入。",failedToJoinCallDueToNoNetworkTitle:"通話已斷線",failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails:"您未被授予加入通話的權限。如果有誤，請重新加入通話。",failedToJoinTeamsMeetingReasonAccessDeniedTitle:"已從大廳關閉",learnMore:"深入了解",leavingCallTitle:"正在離開...",leftCallMoreDetails:"如果有誤，請重新加入通話。",leftCallTitle:"您已離開通話",lobbyScreenConnectingToCallTitle:"正在加入通話",lobbyScreenWaitingToBeAdmittedTitle:"正在等候認可",microphonePermissionDenied:"您的瀏覽器禁止存取您的麥克風",microphoneToggleInLobbyNotAllowed:"無法在大廳中靜音或取消靜音。",mutedMessage:"您已設為靜音",networkReconnectMoreDetails:"似乎發生錯誤。我們正在嘗試讓您返回通話。",networkReconnectTitle:"請稍候",deniedPermissionToRoomDetails:"您沒有加入此會議室的權限。",deniedPermissionToRoomTitle:"會議室權限遭拒絕",peopleButtonLabel:"人員",peoplePaneTitle:"人員",peopleButtonTooltipOpen:"顯示參與者",peopleButtonTooltipClose:"隱藏參與者",peoplePaneSubTitle:"在此通話中",privacyPolicy:"隱私權原則",rejoinCallButtonLabel:"重新加入通話",removedFromCallMoreDetails:"另一名參與者已將您自通話中移除。",removedFromCallTitle:"您已遭移除",removeMenuLabel:"移除",returnToCallButtonAriaDescription:"返回通話",returnToCallButtonAriaLabel:"返回",roomNotFoundDetails:"提供的會議室識別碼無效。",roomNotFoundTitle:"找不到會議室",soundLabel:"音效",noMicrophonesLabel:"找不到麥克風",noSpeakersLabel:"找不到喇叭",startCallButtonLabel:"開始通話",openDialpadButtonLabel:"撥打電話號碼",peoplePaneAddPeopleButtonLabel:"新增人員",dialpadStartCallButtonLabel:"通話",dialpadModalTitle:"撥打電話號碼",dialpadModalAriaLabel:"撥號鍵台",dialpadCloseModalButtonAriaLabel:"關閉撥號鍵台",moreButtonCallingLabel:"其他",resumeCallButtonLabel:"繼續",resumingCallButtonLabel:"正在繼續...",resumeCallButtonAriaLabel:"繼續通話",resumingCallButtonAriaLabel:"繼續通話",holdScreenLabel:"您的通話已保留",openDtmfDialpadLabel:"顯示撥號盤",dtmfDialpadPlaceholderText:"輸入號碼",outboundCallingNoticeString:"撥號中...",participantJoinedNoticeString:"{displayName} 已加入",twoParticipantJoinedNoticeString:"{displayName1} 和 {displayName2} 已加入",threeParticipantJoinedNoticeString:"{displayName1}、{displayName2} 和 {displayName3} 已加入",participantLeftNoticeString:"{displayName} 已離開",twoParticipantLeftNoticeString:"{displayName1} 和 {displayName2} 已離開",threeParticipantLeftNoticeString:"{displayName1}、{displayName2} 和 {displayName3} 已離開",unnamedParticipantString:"未命名的參與者",manyUnnamedParticipantsJoined:"未命名的參與者和 {numOfParticipants} 個其他參與者已加入",manyUnnamedParticipantsLeft:"未命名的參與者和 {numOfParticipants} 個其他參與者已離開",manyParticipantsJoined:"{displayName1}、{displayName2}、{displayName3}和其他{numOfParticipants}位參與者已加入",manyParticipantsLeft:"{displayName1}、{displayName2}、{displayName3}和其他{numOfParticipants}位參與者",liveCaptionsLabel:"即時字幕",captionsSettingsLabel:"字幕設定",startCaptionsButtonOnLabel:"開啟字幕",startCaptionsButtonOffLabel:"關閉字幕",startCaptionsButtonTooltipOnContent:"關閉字幕",startCaptionsButtonTooltipOffContent:"開啟字幕",captionsSettingsModalTitle:"正在使用何種語言?",captionsSettingsDropdownLabel:"口語語言",captionsSettingsDropdownInfoText:"此通話中的每個人在說的語言。",captionsSettingsConfirmButtonLabel:"確認",captionsSettingsCancelButtonLabel:"取消",captionsSettingsModalAriaLabel:"字幕設定模式",captionsSettingsCloseModalButtonAriaLabel:"關閉字幕設定",captionsBannerMoreButtonCallingLabel:"其他",captionsBannerMoreButtonTooltip:"更多選項",captionsAvailableLanguageStrings:{"ar-ae":"阿拉伯文 - 阿拉伯聯合大公國","ar-sa":"阿拉伯文 - 沙烏地阿拉伯","da-dk":"丹麥文","de-de":"德文 - 德國","en-au":"英文 - 澳大利亞","en-ca":"英文 - 加拿大","en-gb":"英文 - 英國","en-in":"英文 - 印度","en-nz":"英文 - 紐西蘭","en-us":"英文 - 美國","es-es":"西班牙文 - 西班牙 (現代排序)","es-mx":"西班牙文 - 墨西哥","fi-fi":"芬蘭文","fr-ca":"法文 - 加拿大","fr-fr":"法文 - 法國","hi-in":"印地文","it-it":"義大利文 - 義大利","ja-jp":"日文","ko-kr":"韓文","nb-no":"挪威文 (巴克摩)","nl-be":"荷蘭文 - 比利時","nl-nl":"荷蘭文 - 荷蘭","pl-pl":"波蘭文","pt-br":"葡萄牙文 - 巴西","ru-ru":"俄文","sv-se":"瑞典文","zh-cn":"中文 - 中華人民共和國","zh-hk":"中文 - 香港特別行政區","cs-cz":"捷克文","pt-pt":"葡萄牙文 - 葡萄牙","tr-tr":"土耳其文","vi-vn":"越南文","th-th":"泰文","he-il":"希伯來文","cy-gb":"威爾斯文","uk-ua":"烏克蘭文","el-gr":"希臘文","hu-hu":"匈牙利文","ro-ro":"羅馬尼亞文","sk-sk":"斯洛伐克文","zh-tw":"中文 - 台灣"},captionsBannerSpinnerText:"正在啟動輔助字幕...",transferPageTransferorText:"正在轉接...",transferPageTransferTargetText:"正在連線...",transferPageUnknownTransferorDisplayName:"未知",transferPageUnknownTransferTargetDisplayName:"未知"};var chat={chatListHeader:"在此聊天中",uploadFile:"上傳檔案"};var callWithChat={chatButtonLabel:"聊天",chatButtonNewMessageNotificationLabel:"新訊息",chatButtonTooltipClosedWithMessageCount:"顯示聊天 ({unreadMessagesCount} 個未讀取)",chatButtonTooltipClose:"隱藏聊天",chatButtonTooltipOpen:"顯示聊天",chatPaneTitle:"聊天",copyInviteLinkButtonLabel:"複製邀請連結",copyInviteLinkActionedAriaLabel:"已複製邀請連結",dismissSidePaneButtonLabel:"關閉",moreDrawerAudioDeviceMenuTitle:"音訊裝置",moreDrawerButtonLabel:"更多選項",moreDrawerButtonTooltip:"更多選項",moreDrawerMicrophoneMenuTitle:"麥克風",moreDrawerSpeakerMenuTitle:"揚聲器",moreDrawerCaptionsMenuTitle:"即時字幕",moreDrawerSpokenLanguageMenuTitle:"口語語言",peopleButtonLabel:"人員",peopleButtonTooltipOpen:"顯示參與者",peopleButtonTooltipClose:"隱藏參與者",peoplePaneSubTitle:"在此通話中",peoplePaneTitle:"人員",pictureInPictureTileAriaLabel:"影片摘要。按一下以返回通話畫面。",removeMenuLabel:"移除",openDialpadButtonLabel:"撥打電話號碼",returnToCallButtonAriaDescription:"返回通話",returnToCallButtonAriaLabel:"返回",peoplePaneAddPeopleButtonLabel:"新增人員",dialpadStartCallButtonLabel:"通話",dialpadModalTitle:"撥打電話號碼",dialpadModalAriaLabel:"撥號鍵台",dialpadCloseModalButtonAriaLabel:"關閉撥號鍵台",openDtmfDialpadLabel:"顯示撥號盤",dtmfDialpadPlaceholderText:"輸入號碼"};var zh_TW = {call:call,chat:chat,callWithChat:callWithChat};

// Copyright (c) Microsoft Corporation.
const createCompositeStrings = (localizedStrings) => {
    const strings = Object.assign({}, en_US);
    Object.keys(localizedStrings).forEach((key) => {
        strings[key] = Object.assign(Object.assign({}, strings[key]), localizedStrings[key]);
    });
    return strings;
};
/**
 * Locale for English (US)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_US = {
    component: COMPONENT_LOCALE_EN_US,
    strings: en_US
};
/**
 * Locale for English (British)
 *
 * @public
 */
const COMPOSITE_LOCALE_EN_GB = {
    component: COMPONENT_LOCALE_EN_GB,
    strings: createCompositeStrings(en_GB)
};
/**
 * Locale for Arabic (Saudi Arabia)
 *
 * @public
 */
const COMPOSITE_LOCALE_AR_SA = {
    component: COMPONENT_LOCALE_AR_SA,
    strings: createCompositeStrings(ar_SA)
};
/**
 * Locale for German (Germany)
 *
 * @public
 */
const COMPOSITE_LOCALE_DE_DE = {
    component: COMPONENT_LOCALE_DE_DE,
    strings: createCompositeStrings(de_DE)
};
/**
 * Locale for Spanish (Spain)
 *
 * @public
 */
const COMPOSITE_LOCALE_ES_ES = {
    component: COMPONENT_LOCALE_ES_ES,
    strings: createCompositeStrings(es_ES)
};
/**
 * Locale for Finnish (Finland)
 *
 * @public
 */
const COMPOSITE_LOCALE_FI_FI = {
    component: COMPONENT_LOCALE_FI_FI,
    strings: createCompositeStrings(fi_FI)
};
/**
 * Locale for French (France)
 *
 * @public
 */
const COMPOSITE_LOCALE_FR_FR = {
    component: COMPONENT_LOCALE_FR_FR,
    strings: createCompositeStrings(fr_FR)
};
/**
 * Locale for Hebrew (Israel)
 *
 * @public
 */
const COMPOSITE_LOCALE_HE_IL = {
    component: COMPONENT_LOCALE_HE_IL,
    strings: createCompositeStrings(he_IL)
};
/**
 * Locale for Italian (Italy)
 *
 * @public
 */
const COMPOSITE_LOCALE_IT_IT = {
    component: COMPONENT_LOCALE_IT_IT,
    strings: createCompositeStrings(it_IT)
};
/**
 * Locale for Japanese (Japan)
 *
 * @public
 */
const COMPOSITE_LOCALE_JA_JP = {
    component: COMPONENT_LOCALE_JA_JP,
    strings: createCompositeStrings(ja_JP)
};
/**
 * Locale for Korean (South Korea)
 *
 * @public
 */
const COMPOSITE_LOCALE_KO_KR = {
    component: COMPONENT_LOCALE_KO_KR,
    strings: createCompositeStrings(ko_KR)
};
/**
 * Locale for Norwegian Bokmål (Norway)
 *
 * @public
 */
const COMPOSITE_LOCALE_NB_NO = {
    component: COMPONENT_LOCALE_NB_NO,
    strings: createCompositeStrings(nb_NO)
};
/**
 * Locale for Dutch (Netherlands)
 *
 * @public
 */
const COMPOSITE_LOCALE_NL_NL = {
    component: COMPONENT_LOCALE_NL_NL,
    strings: createCompositeStrings(nl_NL)
};
/**
 * Locale for Polish (Poland)
 *
 * @public
 */
const COMPOSITE_LOCALE_PL_PL = {
    component: COMPONENT_LOCALE_PL_PL,
    strings: createCompositeStrings(pl_PL)
};
/**
 * Locale for Portuguese (Brazil)
 *
 * @public
 */
const COMPOSITE_LOCALE_PT_BR = {
    component: COMPONENT_LOCALE_PT_BR,
    strings: createCompositeStrings(pt_BR)
};
/**
 * Locale for Russian (Russia)
 *
 * @public
 */
const COMPOSITE_LOCALE_RU_RU = {
    component: COMPONENT_LOCALE_RU_RU,
    strings: createCompositeStrings(ru_RU)
};
/**
 * Locale for Swedish (Sweden)
 *
 * @public
 */
const COMPOSITE_LOCALE_SV_SE = {
    component: COMPONENT_LOCALE_SV_SE,
    strings: createCompositeStrings(sv_SE)
};
/**
 * Locale for Turkish (Turkey)
 *
 * @public
 */
const COMPOSITE_LOCALE_TR_TR = {
    component: COMPONENT_LOCALE_TR_TR,
    strings: createCompositeStrings(tr_TR)
};
/**
 * Locale for Chinese (Mainland China)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_CN = {
    component: COMPONENT_LOCALE_ZH_CN,
    strings: createCompositeStrings(zh_CN)
};
/**
 * Locale for Chinese (Taiwan)
 *
 * @public
 */
const COMPOSITE_LOCALE_ZH_TW = {
    component: COMPONENT_LOCALE_ZH_TW,
    strings: createCompositeStrings(zh_TW)
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for providing localized strings to components
 *
 * @private
 */
const LocaleContext = React.createContext(COMPOSITE_LOCALE_EN_US);
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const LocalizationProvider = (props) => {
    const { locale, children } = props;
    return React__default['default'].createElement(LocaleContext.Provider, { value: locale },
        React__default['default'].createElement(LocalizationProvider$1, { locale: locale.component }, children));
};
/**
 * @private
 */
const useLocale = () => React.useContext(LocaleContext);

// Copyright (c) Microsoft Corporation.
const SpinnerIcon = () => React__default['default'].createElement(react.Spinner, { size: react.SpinnerSize.large });
/**
 * The default set of icons used by the composites directly (i.e. not via the components defined in this library).
 *
 * @public
 */
const COMPOSITE_ONLY_ICONS = {
    ChevronLeft: undefined,
    Link: undefined,
    LobbyScreenConnectingToCall: React__default['default'].createElement(SpinnerIcon, null),
    LobbyScreenWaitingToBeAdmitted: React__default['default'].createElement(SpinnerIcon, null),
    LocalDeviceSettingsCamera: React__default['default'].createElement(reactIcons.Video20Filled, null),
    LocalDeviceSettingsMic: React__default['default'].createElement(reactIcons.Mic20Filled, null),
    LocalDeviceSettingsSpeaker: React__default['default'].createElement(reactIcons.Speaker220Filled, null),
    LocalPreviewPlaceholder: React__default['default'].createElement(reactIcons.VideoOff20Filled, null),
    LocalCameraSwitch: React__default['default'].createElement(reactIcons.CameraSwitch24Regular, null),
    ControlBarChatButtonActive: React__default['default'].createElement(reactIcons.Chat20Filled, null),
    ControlBarChatButtonInactive: React__default['default'].createElement(reactIcons.Chat20Regular, null),
    ControlBarPeopleButton: React__default['default'].createElement(reactIcons.People20Regular, null),
    MoreDrawerMicrophones: React__default['default'].createElement(reactIcons.Mic20Regular, null),
    MoreDrawerPeople: React__default['default'].createElement(reactIcons.People20Regular, null),
    MoreDrawerSpeakers: React__default['default'].createElement(reactIcons.Speaker220Regular, null),
    MoreDrawerSelectedMicrophone: React__default['default'].createElement(reactIcons.Mic20Filled, null),
    MoreDrawerSelectedSpeaker: React__default['default'].createElement(reactIcons.Speaker220Filled, null),
    Muted: React__default['default'].createElement(reactIcons.MicOff20Filled, null),
    NetworkReconnectIcon: React__default['default'].createElement(reactIcons.CallMissed20Filled, null),
    NoticePageAccessDeniedTeamsMeeting: React__default['default'].createElement(reactIcons.PersonDelete20Filled, null),
    NoticePageJoinCallFailedDueToNoNetwork: React__default['default'].createElement(reactIcons.WifiWarning20Filled, null),
    NoticePageLeftCall: React__default['default'].createElement(reactIcons.CallEnd20Filled, null),
    NoticePageRemovedFromCall: React__default['default'].createElement(reactIcons.Info20Filled, null)
};
/**
 * The default set of icons that are available to used in the Composites.
 *
 * @public
 */
const DEFAULT_COMPOSITE_ICONS = Object.assign(Object.assign({}, DEFAULT_COMPONENT_ICONS), COMPOSITE_ONLY_ICONS);
/**
 * Icon wrapper to use when including customizable icons inside the CallComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallCompositeIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({}, props));
/**
 * Icon wrapper to use when including customizable icons inside the CallWithChatComposite.
 * This wrapper ensures the icon name is being type-checked helping ensure no typos
 * and ensure that icon is customizable through the composite API.
 *
 * @private
 */
const CallWithChatCompositeIcon = (props) => React__default['default'].createElement(react.FontIcon, Object.assign({}, props));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const globalLayerHostStyle = {
    position: 'fixed',
    zIndex: 1000000,
    inset: '0px',
    visibility: 'hidden'
};

// Copyright (c) Microsoft Corporation.
/**
 * A base provider {@link React.Context} to wrap components with other required providers
 * (e.g. icons, FluentThemeProvider, LocalizationProvider).
 *
 * Required providers are only wrapped once, with all other instances only passing children.
 *
 * @private
 */
const BaseProvider = (props) => {
    const { fluentTheme, rtl, locale } = props;
    const globalLayerHostId = reactHooks.useId('composite-global-hostId');
    /**
     * Pass only the children if we previously registered icons, and have previously wrapped the children in
     * FluentThemeProvider and LocalizationProvider
     */
    const alreadyWrapped = useBase();
    if (alreadyWrapped) {
        return React__default['default'].createElement(React__default['default'].Fragment, null, props.children);
    }
    /**
     * Before registering fluent icons, we should check DEFAULT_COMPOSITE_ICONS and strip out the key value pairs where value is undefined
     */
    const iconsToRegister = {};
    Object.entries(DEFAULT_COMPOSITE_ICONS).forEach(([key, value]) => {
        if (value) {
            iconsToRegister[key] = value;
        }
    });
    /**
     * We register the default icon mappings merged with custom icons provided through props
     * to ensure all icons render correctly.
     */
    react.registerIcons({
        icons: Object.assign(Object.assign({}, iconsToRegister), props.icons)
    });
    // we use Customizer to override default LayerHost injected to <body />
    // which stop polluting global dom tree and increase compatibility with react-full-screen
    const CompositeElement = React__default['default'].createElement(FluentThemeProvider, { fluentTheme: fluentTheme, rtl: rtl },
        React__default['default'].createElement("meta", { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" }),
        React__default['default'].createElement(react.Customizer, { scopedSettings: {
                Layer: {
                    hostId: globalLayerHostId
                }
            } },
            React__default['default'].createElement(WithBackgroundColor, null, props.children)),
        React__default['default'].createElement(react.LayerHost, { id: globalLayerHostId, className: react.mergeStyles(globalLayerHostStyle) }));
    const localizedElement = locale ? LocalizationProvider({
        locale,
        children: CompositeElement
    }) : CompositeElement;
    return React__default['default'].createElement(BaseContext.Provider, { value: true }, localizedElement);
};
/**
 * @private
 */
const BaseContext = React.createContext(false);
/**
 * @private
 */
const useBase = () => React.useContext(BaseContext);
/**
 * @private
 * Provides a wrapper with a background color to ensure that composites always have a background color.
 * This is necessary to ensure that composites are not transparent,
 * and the background color of it's parent elements doesn't show through the composite.
 */
const WithBackgroundColor = (props) => {
    const { children } = props;
    const theme = react.useTheme();
    const className = react.mergeStyles({
        background: theme.semanticColors.bodyBackground,
        height: '100%',
        width: '100%',
        position: 'relative'
    });
    return React__default['default'].createElement(react.Stack, { className: className }, children);
};

// Copyright (c) Microsoft Corporation.
const ChatAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const ChatAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(ChatAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter$1 = () => {
    const adapter = React.useContext(ChatAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
const MESSAGE_THREAD_WIDTH = '41.25rem';
/**
 * @private
 * z-index to ensure that chat container has lower z-index than participant pane
 */
const CHAT_CONTAINER_ZINDEX = 1;
/**
 * @private
 */
const chatScreenContainerStyle = react.mergeStyles({
    height: '100%',
    width: '100%',
    minHeight: '13rem',
    minWidth: '17.5rem'
});
/**
 * @private
 */
const chatContainer = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    '*::-webkit-scrollbar': {
        width: '0.3rem',
        height: '0.3rem'
    },
    '.scroll::-webkit-scrollbar-track': {
        background: 'rgba(150, 150, 150)',
        borderRadius: '0.3rem'
    },
    '*::-webkit-scrollbar-thumb': {
        borderRadius: '10px',
        background: 'rgba(150, 150, 150)'
    }
});
/**
 * @private
 */
const chatArea = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'auto',
    position: 'relative' // Ensure that the absolute children components are positioned relative to the chat area
});
/**
 * @private
 */
const chatWrapper = react.mergeStyles({
    height: '100%',
    width: '100%',
    overflow: 'hidden',
    zIndex: CHAT_CONTAINER_ZINDEX
});
/**
 * @private
 */
const chatHeaderContainerStyle = react.mergeStyles({
    width: '100%',
    paddingLeft: '1.5rem',
    paddingRight: '1.5rem',
    '@media screen and (max-width: 25rem)': {
        paddingLeft: '5%',
        paddingRight: '5%'
    },
    borderBottom: '0.063rem solid #DDDDDD'
});
/**
 * @private
 */
const topicNameLabelStyle = react.mergeStyles({
    fontSize: '1.1rem',
    lineHeight: '2.5rem',
    fontWeight: 600,
    marginRight: '0.125rem',
    textOverflow: 'ellipsis',
    overflowY: 'hidden'
});
/**
 * @private
 */
const messageThreadChatCompositeStyles = react.memoizeFunction((background) => ({
    root: {
        maxWidth: MESSAGE_THREAD_WIDTH
    },
    chatContainer: {
        background: background
    }
}));
/**
 * @private
 */
const typingIndicatorContainerStyles = {
    padding: '0rem 0.25rem'
};
/**
 * @private
 */
const sendboxContainerStyles = {
    maxWidth: MESSAGE_THREAD_WIDTH,
    width: '100%',
    alignSelf: 'center'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$b = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * An Avatar component made using the `Persona` component.
 * It allows you to specify a `userId` and a `dataProvider` to retrieve the `AvatarPersonaData`.
 * Read more about `Persona` component at https://developer.microsoft.com/fluentui#/controls/web/persona
 *
 * @private
 */
const AvatarPersona = (props) => {
    var _a, _b, _c, _d, _e, _f;
    const { userId, dataProvider, text, imageUrl, imageInitials, initialsColor, initialsTextColor, showOverflowTooltip } = props;
    const [data, setData] = React.useState();
    React.useEffect(() => {
        (() => __awaiter$b(void 0, void 0, void 0, function* () {
            if (dataProvider && userId) {
                const newData = yield dataProvider(userId);
                if (avatarDeepDifferenceCheck(data, newData)) {
                    setData(newData);
                }
            }
        }))();
    }, [data, dataProvider, userId]);
    return React__default['default'].createElement(react.Persona, Object.assign({}, props, { text: (_a = data === null || data === void 0 ? void 0 : data.text) !== null && _a !== void 0 ? _a : text, imageUrl: (_b = data === null || data === void 0 ? void 0 : data.imageUrl) !== null && _b !== void 0 ? _b : imageUrl, imageInitials: (_c = data === null || data === void 0 ? void 0 : data.imageInitials) !== null && _c !== void 0 ? _c : imageInitials, initialsColor: (_d = data === null || data === void 0 ? void 0 : data.initialsColor) !== null && _d !== void 0 ? _d : initialsColor, initialsTextColor: (_f = (_e = data === null || data === void 0 ? void 0 : data.initialsTextColor) !== null && _e !== void 0 ? _e : initialsTextColor) !== null && _f !== void 0 ? _f : 'white', 
        // default disable tooltip unless specified
        showOverflowTooltip: showOverflowTooltip !== null && showOverflowTooltip !== void 0 ? showOverflowTooltip : false }));
};
const avatarDeepDifferenceCheck = (currentData, newData) => {
    return (currentData === null || currentData === void 0 ? void 0 : currentData.text) !== (newData === null || newData === void 0 ? void 0 : newData.text) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageUrl) !== (newData === null || newData === void 0 ? void 0 : newData.imageUrl) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsColor) || (currentData === null || currentData === void 0 ? void 0 : currentData.imageInitials) !== (newData === null || newData === void 0 ? void 0 : newData.imageInitials) || (currentData === null || currentData === void 0 ? void 0 : currentData.initialsTextColor) !== (newData === null || newData === void 0 ? void 0 : newData.initialsTextColor);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatHeader = (props) => {
    return React__default['default'].createElement(react.Stack, { className: chatHeaderContainerStyle, horizontal: true },
        React__default['default'].createElement(react.Stack.Item, { align: "center" },
            React__default['default'].createElement("div", { className: topicNameLabelStyle }, props.topic)));
};
const getTopicName = (state, props) => {
    var _a, _b;
    return ((_b = (_a = state.threads[props.threadId]) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.topic) || '';
};
/**
 * @private
 */
const getHeaderProps = reselect__namespace.createSelector([getTopicName], (topic) => {
    return {
        topic: topic
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * A wrapper to return {@link FileUploadButton} component conditionally.
 * It will return `<></>` for stable builds.
 * @internal
 */
const FileUploadButtonWrapper = (props) => {
    return React__default['default'].createElement(React__default['default'].Fragment, null);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector$1 = (selector, selectorProps) => {
    return useSelectorWithAdaptation$1(selector, adaptCompositeState$1, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation$1 = (selector, adaptState, selectorProps) => {
    const adapter = useAdapter$1();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const threadId = adapter.getState().thread.threadId;
    const threadConfigProps = React.useMemo(() => ({
        threadId
    }), [threadId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : threadConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, threadConfigProps]);
    return props;
};
const memoizeState$1 = memoizeOne__default['default']((userId, displayName, threads, latestErrors) => ({
    userId,
    displayName,
    threads,
    latestErrors
}));
const memoizeThreads = memoizeOne__default['default']((thread) => ({
    [thread.threadId]: thread
}));
const adaptCompositeState$1 = (compositeState) => {
    return memoizeState$1(compositeState.userId, compositeState.displayName, memoizeThreads(compositeState.thread), (
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in ChatErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-chat.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers$1 = (_component) => {
    return createCompositeHandlers$1(useAdapter$1());
};
const createCompositeHandlers$1 = memoizeOne__default['default']((adapter) => ({
    onSendMessage: adapter.sendMessage,
    onLoadPreviousChatMessages: adapter.loadPreviousChatMessages,
    onMessageSeen: adapter.sendReadReceipt,
    onTyping: adapter.sendTypingIndicator,
    onRemoveParticipant: adapter.removeParticipant,
    updateThreadTopicName: adapter.setTopic,
    onUpdateMessage: adapter.updateMessage,
    onDeleteMessage: adapter.deleteMessage
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const usePropsFor$2 = (component) => {
    const selector = getSelector(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector$1(selector)), useHandlers$1());
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const sidePaneContainerStyles = {
    root: {
        height: '100%',
        padding: '0.5rem 0.25rem',
        width: '21.5rem'
    }
};
/**
 * @private
 */
({
    root: Object.assign(Object.assign({}, sidePaneContainerStyles), { display: 'none' })
});
/**
 * @private
 */
const sidePaneHeaderStyles = {
    root: {
        lineHeight: '1.25rem',
        padding: '0.25rem',
        fontWeight: '600'
    }
};
/**
 * @private
 */
const sidePaneHeaderContainerStyles = {
    root: {
        margin: '0 0.25rem'
    }
};
/**
 * @private
 */
const paneBodyContainer = {
    root: {
        flexDirection: 'column',
        display: 'flex'
    }
};
/**
 * @private
 */
const scrollableContainer = {
    root: {
        flexBasis: '0',
        flexGrow: '1',
        overflowY: 'auto'
    }
};
/**
 * @private
 */
const scrollableContainerContents = {
    root: {
        flexGrow: '1',
        flexBasis: '0',
        maxWidth: '100%',
        // Create a new stacking context so that `pipStyles` can set zIndex above the container.
        position: 'relative'
    }
};
/**
 * @private
 */
const containerContextStyles = {
    root: {
        position: 'absolute',
        height: '100%',
        width: '100%'
    }
};
/**
 * @private
 */
const peoplePaneContainerTokens = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListContainerPadding = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const participantListStack = react.mergeStyles({
    height: '100%'
});
/**
 * @private
 */
const participantListContainerStyle = react.mergeStyles({
    height: '100%',
    overflowY: 'auto',
    overflowX: 'hidden'
});
/**
 * @private
 */
const participantListStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem'
        }
    }
};
/**
 * @private
 */
const participantListMobileStyle = {
    root: {
        padding: '0rem'
    },
    participantItemStyles: {
        root: {
            padding: '0.5rem 1rem'
        }
    }
};
/**
 * @private
 */
const displayNameStyles = {
    root: {
        padding: '0.5rem',
        textOverflow: 'ellipsis',
        overflow: 'hidden'
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$a = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, options, styles, fileSharing, formFactor } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    const adapter = useAdapter$1();
    const theme = useTheme();
    React.useEffect(() => {
        // Initial data should be always fetched by the composite(or external caller) instead of the adapter
        const fetchData = () => __awaiter$a(void 0, void 0, void 0, function* () {
            // Fetch initial data for adapter
            yield adapter.fetchInitialData();
            // Fetch initial set of messages. Without fetching messages here, if the Composite's adapter is changed the message thread does not load new messages.
            yield adapter.loadPreviousChatMessages(defaultNumberOfChatMessagesToReload);
        });
        fetchData();
    }, [adapter]);
    const messageThreadProps = usePropsFor$2(MessageThread);
    const sendBoxProps = usePropsFor$2(SendBox);
    const typingIndicatorProps = usePropsFor$2(TypingIndicator);
    const headerProps = useAdaptedSelector$1(getHeaderProps);
    const errorBarProps = usePropsFor$2(ErrorBar);
    const onRenderAvatarCallback = React.useCallback((userId, defaultOptions) => {
        return React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData }));
    }, [onFetchAvatarPersonaData]);
    const messageThreadStyles = Object.assign({}, messageThreadChatCompositeStyles(theme.semanticColors.bodyBackground), styles === null || styles === void 0 ? void 0 : styles.messageThread);
    const typingIndicatorStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    const sendBoxStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.sendBox);
    const userId = toFlatCommunicationIdentifier(adapter.getState().userId);
    const fileUploadButtonOnChange = React.useCallback((files) => {
        if (!files) {
            return;
        }
    }, [adapter, fileSharing, userId]);
    const AttachFileButton = React.useCallback(() => {
        if (!(fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler)) {
            return null;
        }
        return React__default['default'].createElement(FileUploadButtonWrapper, { accept: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, multiple: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, onChange: fileUploadButtonOnChange });
    }, [fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler, fileUploadButtonOnChange]);
    return React__default['default'].createElement(react.Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React__default['default'].createElement(ChatHeader, Object.assign({}, headerProps)),
        React__default['default'].createElement(react.Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React__default['default'].createElement(react.Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React__default['default'].createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React__default['default'].createElement(react.Stack, { className: react.mergeStyles(sendboxContainerStyles) },
                    React__default['default'].createElement("div", { className: react.mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? onRenderTypingIndicator(typingIndicatorProps.typingUsers) : React__default['default'].createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles }))),
                    React__default['default'].createElement(react.Stack, { horizontal: formFactor === 'mobile' },
                        formFactor === 'mobile' && React__default['default'].createElement(react.Stack, { verticalAlign: "center" },
                            React__default['default'].createElement(AttachFileButton, null)),
                        React__default['default'].createElement(react.Stack, { grow: true },
                            React__default['default'].createElement(SendBox, Object.assign({}, sendBoxProps, { autoFocus: options === null || options === void 0 ? void 0 : options.autoFocus, styles: sendBoxStyles }))),
                        formFactor !== 'mobile' && React__default['default'].createElement(AttachFileButton, null))))));
};

// Copyright (c) Microsoft Corporation.
/**
 * A customizable UI composite for the chat experience.
 *
 * @remarks Chat composite min width and height are respectively 17.5rem and 20rem (280px and 320px, with default rem at 16px)
 *
 * @public
 */
const ChatComposite = (props) => {
    const { adapter, options, onFetchAvatarPersonaData, onRenderTypingIndicator, onRenderMessage, onFetchParticipantMenuItems } = props;
    const formFactor = props['formFactor'] || 'desktop';
    /**
     * @TODO Remove this function and pass the props directly when file-sharing is promoted to stable.
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const fileSharingOptions = () => {
        return {};
    };
    return React__default['default'].createElement("div", { className: chatScreenContainerStyle },
        React__default['default'].createElement(BaseProvider, Object.assign({}, props),
            React__default['default'].createElement(ChatAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(ChatScreen, Object.assign({ formFactor: formFactor, options: options, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onRenderTypingIndicator: onRenderTypingIndicator, onRenderMessage: onRenderMessage, onFetchParticipantMenuItems: onFetchParticipantMenuItems }, fileSharingOptions())))));
};

// Copyright (c) Microsoft Corporation.
const CallAdapterContext = React.createContext(undefined);
/**
 * @private
 */
const CallAdapterProvider = (props) => {
    const { adapter } = props;
    return React__default['default'].createElement(CallAdapterContext.Provider, { value: adapter }, props.children);
};
/**
 * @private
 */
const useAdapter = () => {
    const adapter = React.useContext(CallAdapterContext);
    if (!adapter) {
        throw 'Cannot find adapter please initialize before usage.';
    }
    return adapter;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @private */
const containerDivStyles = {
    position: 'relative',
    width: '100%',
    height: '100%'
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This minimum width is to make sure the side pane does not overlap with the composite when the screen is narrow.
 *
 * @private
 */
const compositeMinWidthRem = 30;

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useAdaptedSelector = (selector, selectorProps) => {
    return useSelectorWithAdaptation(selector, adaptCompositeState, selectorProps);
};
/**
 * @private
 */
const useSelectorWithAdaptation = (selector, adaptState, selectorProps) => {
    var _a;
    const adapter = useAdapter();
    // Keeps track of whether the current component is mounted or not. If it has unmounted, make sure we do not modify the
    // state or it will cause React warnings in the console. https://skype.visualstudio.com/SPOOL/_workitems/edit/2453212
    const mounted = React.useRef(false);
    React.useEffect(() => {
        mounted.current = true;
        return () => {
            mounted.current = false;
        };
    });
    const callId = (_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.id;
    const callConfigProps = React.useMemo(() => ({
        callId
    }), [callId]);
    const [props, setProps] = React.useState(selector(adaptState(adapter.getState()), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps));
    const propRef = React.useRef(props);
    propRef.current = props;
    React.useEffect(() => {
        const onStateChange = (state) => {
            if (!mounted.current) {
                return;
            }
            const newProps = selector(adaptState(state), selectorProps !== null && selectorProps !== void 0 ? selectorProps : callConfigProps);
            if (propRef.current !== newProps) {
                setProps(newProps);
            }
        };
        adapter.onStateChange(onStateChange);
        return () => {
            adapter.offStateChange(onStateChange);
        };
    }, [adaptState, adapter, selector, selectorProps, callConfigProps]);
    return props;
};
const memoizeState = memoizeOne__default['default']((userId, deviceManager, calls, latestErrors, displayName, alternateCallerId, environmentInfo) => ({
    userId,
    incomingCalls: {},
    incomingCallsEnded: {},
    callsEnded: {},
    deviceManager,
    callAgent: {
        displayName
    },
    calls,
    latestErrors
}));
const memoizeCalls = memoizeOne__default['default']((call) => call ? {
    [call.id]: call
} : {});
const adaptCompositeState = (compositeState) => {
    return memoizeState(compositeState.userId, compositeState.devices, memoizeCalls(compositeState.call), (
    // This is an unsafe type expansion.
    // compositeState.latestErrors can contain properties that are not valid in CallErrors.
    //
    // But there is no way to check for valid property names at runtime:
    // - The set of valid property names is built from types in the @azure/communication-calling.
    //   Thus we don't have a literal array of allowed strings at runtime.
    // - Due to minification / uglification, the property names from the objects at runtime can't be used
    //   to compare against permissible values inferred from the types.
    //
    // This is not a huge problem -- it simply means that our adapted selector will include some extra operations
    // that are unknown to the UI component and data binding libraries. Generic handling of the errors (e.g.,
    // just displaying them in some UI surface) will continue to work for these operations. Handling of
    // specific operations (e.g., acting on errors related to permission issues) will ignore these operations.
    compositeState.latestErrors), compositeState.displayName);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Subset of CallCompositePages that represent an end call state.
 * @private
 */
const END_CALL_PAGES = ['accessDeniedTeamsMeeting', 'joinCallFailedDueToNoNetwork', 'leftCall', 'removedFromCall'];

// Copyright (c) Microsoft Corporation.
const ACCESS_DENIED_TEAMS_MEETING_SUB_CODE = 5854;
const REMOTE_PSTN_USER_HUNG_UP = 560000;
const REMOVED_FROM_CALL_SUB_CODES = [5000, 5300, REMOTE_PSTN_USER_HUNG_UP];
/**
 * @private
 */
const isCameraOn = (state) => {
    if (state.call) {
        const stream = state.call.localVideoStreams.find(stream => stream.mediaStreamType === 'Video');
        return !!stream;
    }
    else {
        if (state.devices.selectedCamera) {
            const previewOn = _isPreviewOn(state.devices);
            return previewOn;
        }
    }
    return false;
};
/**
 * Reduce the set of call controls visible on mobile.
 * For example do not show screenshare button.
 *
 * @private
 */
const reduceCallControlsForMobile = (callControlOptions) => {
    if (callControlOptions === false) {
        return false;
    }
    // Ensure call controls a valid object.
    const reduceCallControlOptions = callControlOptions === true ? {} : callControlOptions || {};
    // Set to compressed mode when composite is optimized for mobile
    reduceCallControlOptions.displayType = 'compact';
    // Do not show screen share button when composite is optimized for mobile unless the developer
    // has explicitly opted in.
    if (reduceCallControlOptions.screenShareButton !== true) {
        reduceCallControlOptions.screenShareButton = false;
    }
    return reduceCallControlOptions;
};
var CallEndReasons;
(function (CallEndReasons) {
    CallEndReasons[CallEndReasons["LEFT_CALL"] = 0] = "LEFT_CALL";
    CallEndReasons[CallEndReasons["ACCESS_DENIED"] = 1] = "ACCESS_DENIED";
    CallEndReasons[CallEndReasons["REMOVED_FROM_CALL"] = 2] = "REMOVED_FROM_CALL";
    CallEndReasons[CallEndReasons["ROOM_NOT_FOUND"] = 3] = "ROOM_NOT_FOUND";
    CallEndReasons[CallEndReasons["DENIED_PERMISSION_TO_ROOM"] = 4] = "DENIED_PERMISSION_TO_ROOM";
})(CallEndReasons || (CallEndReasons = {}));
const getCallEndReason = (call) => {
    var _a, _b, _c;
    const remoteParticipantsEndedArray = Array.from(Object.values(call.remoteParticipantsEnded));
    /**
     * Handle the special case in a PSTN call where removing the last user kicks the caller out of the call.
     * The code and subcode is the same as when a user is removed from a teams interop call.
     * Hence, we look at the last remote participant removed to determine if the last participant removed was a phone number.
     * If yes, the caller was kicked out of the call, but we need to show them that they left the call.
     * Note: This check will only work for 1:1 PSTN Calls. The subcode is different for 1:N PSTN calls, and we do not need to handle that case.
     */
    if (remoteParticipantsEndedArray.length === 1 && communicationCommon.isPhoneNumberIdentifier(remoteParticipantsEndedArray[0].identifier) && ((_a = call.callEndReason) === null || _a === void 0 ? void 0 : _a.subCode) !== REMOTE_PSTN_USER_HUNG_UP) {
        return CallEndReasons.LEFT_CALL;
    }
    if (((_b = call.callEndReason) === null || _b === void 0 ? void 0 : _b.subCode) && call.callEndReason.subCode === ACCESS_DENIED_TEAMS_MEETING_SUB_CODE) {
        return CallEndReasons.ACCESS_DENIED;
    }
    if (((_c = call.callEndReason) === null || _c === void 0 ? void 0 : _c.subCode) && REMOVED_FROM_CALL_SUB_CODES.includes(call.callEndReason.subCode)) {
        return CallEndReasons.REMOVED_FROM_CALL;
    }
    if (call.callEndReason) {
        // No error codes match, assume the user simply left the call regularly
        return CallEndReasons.LEFT_CALL;
    }
    throw new Error('No matching call end reason');
};
/**
 * Get the current call composite page based on the current call composite state
 *
 * @param Call - The current call state
 * @param previousCall - The state of the most recent previous call that has ended.
 *
 * @remarks - The previousCall state is needed to determine if the call has ended.
 * When the call ends a new call object is created, and so we must lookback at the
 * previous call state to understand how the call has ended. If there is no previous
 * call we know that this is a fresh call and can display the configuration page.
 *
 * @private
 */
const getCallCompositePage = (call, previousCall, unsupportedBrowserInfo, transferCall) => {
    if (call) {
        // Must check for ongoing call *before* looking at any previous calls.
        // If the composite completes one call and joins another, the previous calls
        // will be populated, but not relevant for determining the page.
        // `_isInLobbyOrConnecting` needs to be checked first because `_isInCall` also returns true when call is in lobby.
        if (_isInLobbyOrConnecting(call === null || call === void 0 ? void 0 : call.state)) {
            return 'lobby';
            // `LocalHold` needs to be checked before `isInCall` since it is also a state that's considered in call.
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'LocalHold') {
            return 'call';
        }
        else if ((call === null || call === void 0 ? void 0 : call.state) === 'Disconnecting') {
            return 'leaving';
        }
        else if (_isInCall(call === null || call === void 0 ? void 0 : call.state)) {
            return 'call';
        }
        else {
            // When the call object has been constructed after clicking , but before 'connecting' has been
            // set on the call object, we continue to show the configuration screen.
            // The call object does not correctly reflect local device state until `call.state` moves to `connecting`.
            // Moving to the 'lobby' page too soon leads to components that depend on the `call` object to show incorrect
            // transitional state.
            return 'configuration';
        }
    }
    if (previousCall) {
        const reason = getCallEndReason(previousCall);
        switch (reason) {
            case CallEndReasons.ACCESS_DENIED:
                return 'accessDeniedTeamsMeeting';
            case CallEndReasons.REMOVED_FROM_CALL:
                return 'removedFromCall';
            case CallEndReasons.LEFT_CALL:
                if (previousCall.diagnostics.network.latest.noNetwork) {
                    return 'joinCallFailedDueToNoNetwork';
                }
                return 'leftCall';
        }
    }
    // No call state - show starting page (configuration)
    return 'configuration';
};
/** @private */
const IsCallEndedPage = (page) => END_CALL_PAGES.includes(page);
/**
 * Creates a new call control options object and sets the correct values for disabling
 * the buttons provided in the `disabledControls` array.
 * Returns a new object without changing the original object.
 * @param callControlOptions options for the call control component that need to be modified.
 * @param disabledControls An array of controls to disable.
 * @returns a copy of callControlOptions with disabledControls disabled
 * @private
 */
const disableCallControls = (callControlOptions, disabledControls) => {
    var _a;
    if (callControlOptions === false) {
        return false;
    }
    // Ensure we clone the prop if it is an object to ensure we do not mutate the original prop.
    let newOptions = (_a = (callControlOptions instanceof Object ? Object.assign({}, callControlOptions) : callControlOptions)) !== null && _a !== void 0 ? _a : {};
    if (newOptions === true || newOptions === undefined) {
        newOptions = disabledControls.reduce((acc, key) => {
            acc[key] = {
                disabled: true
            };
            return acc;
        }, {});
    }
    else {
        disabledControls.forEach(key => {
            if (newOptions[key] !== false) {
                newOptions[key] = {
                    disabled: true
                };
            }
        });
    }
    return newOptions;
};
/**
 * Check if a disabled object is provided for a button and returns if the button is disabled.
 * A button is only disabled if is explicitly set to disabled.
 *
 * @param option
 * @returns whether a button is disabled
 * @private
 */
const isDisabled$2 = (option) => {
    if (option === undefined || typeof option === 'boolean') {
        return false;
    }
    return option.disabled;
};
/**
 * @private
 * This is the util function to create a participant modifier for remote participantList
 * It memoize previous original participant items and only update the changed participant
 * It takes in one modifier function to generate one single participant object, it returns undefined if the object keeps unmodified
 */
const createParticipantModifier = (createModifiedParticipant) => {
    let previousParticipantState = undefined;
    let modifiedParticipants = {};
    const memoizedParticipants = {};
    return (state) => {
        var _a, _b, _c, _d;
        // if root state is the same, we don't need to update the participants
        if (((_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants) !== previousParticipantState) {
            modifiedParticipants = {};
            const originalParticipants = (_b = state.call) === null || _b === void 0 ? void 0 : _b.remoteParticipants;
            for (const key in originalParticipants) {
                const modifiedParticipant = createModifiedParticipant(key, originalParticipants[key]);
                if (modifiedParticipant === undefined) {
                    modifiedParticipants[key] = originalParticipants[key];
                    continue;
                }
                // Generate the new item if original cached item has been changed
                if (((_c = memoizedParticipants[key]) === null || _c === void 0 ? void 0 : _c.originalRef) !== originalParticipants[key]) {
                    memoizedParticipants[key] = {
                        newParticipant: modifiedParticipant,
                        originalRef: originalParticipants[key]
                    };
                }
                // the modified participant is always coming from the memoized cache, whether is was refreshed
                // from the previous closure or not
                modifiedParticipants[key] = memoizedParticipants[key].newParticipant;
            }
            previousParticipantState = (_d = state.call) === null || _d === void 0 ? void 0 : _d.remoteParticipants;
        }
        return Object.assign(Object.assign({}, state), { call: state.call ? Object.assign(Object.assign({}, state.call), { remoteParticipants: modifiedParticipants }) : undefined });
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$9 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const useHandlers = (_component) => {
    return createCompositeHandlers(useAdapter());
};
const createCompositeHandlers = memoizeOne__default['default']((adapter) => ({
    onCreateLocalStreamView: (options) => __awaiter$9(void 0, void 0, void 0, function* () {
        return yield adapter.createStreamView(undefined, options);
    }),
    onCreateRemoteStreamView: (userId, options) => __awaiter$9(void 0, void 0, void 0, function* () {
        return yield adapter.createStreamView(userId, options);
    }),
    onHangUp: (forEveryone) => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.leaveCall(forEveryone);
    }),
    onRemoveParticipant: (userId) => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.removeParticipant(userId);
    }),
    onSelectCamera: (deviceInfo, options) => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.setCamera(deviceInfo, options);
    }),
    onSelectMicrophone: (deviceInfo) => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.setMicrophone(deviceInfo);
    }),
    onSelectSpeaker: (deviceInfo) => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.setSpeaker(deviceInfo);
    }),
    onStartCall: (participants, options) => {
        const rawIds = participants.map(participant => toFlatCommunicationIdentifier(participant));
        return adapter.startCall(rawIds, options);
    },
    onStartScreenShare: () => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.startScreenShare();
    }),
    onStopScreenShare: () => __awaiter$9(void 0, void 0, void 0, function* () {
        yield adapter.stopScreenShare();
    }),
    onToggleCamera: (options) => __awaiter$9(void 0, void 0, void 0, function* () {
        isCameraOn(adapter.getState()) ? yield adapter.stopCamera() : yield adapter.startCamera(options);
    }),
    onToggleMicrophone: () => __awaiter$9(void 0, void 0, void 0, function* () {
        var _a;
        return ((_a = adapter.getState().call) === null || _a === void 0 ? void 0 : _a.isMuted) ? yield adapter.unmute() : yield adapter.mute();
    }),
    onToggleScreenShare: () => __awaiter$9(void 0, void 0, void 0, function* () {
        var _b;
        return ((_b = adapter.getState().call) === null || _b === void 0 ? void 0 : _b.isScreenSharingOn) ? yield adapter.stopScreenShare() : yield adapter.startScreenShare();
    }),
    onStartLocalVideo: () => __awaiter$9(void 0, void 0, void 0, function* () {
        if (adapter.getState().call) {
            return adapter.startCamera();
        }
    }),
    onDisposeLocalStreamView: () => __awaiter$9(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView();
    }),
    onDisposeRemoteStreamView: (userId) => __awaiter$9(void 0, void 0, void 0, function* () {
        return adapter.disposeStreamView(userId);
    })
}));

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
const usePropsFor$1 = (component) => {
    const selector = getSelector$1(component);
    if (!selector) {
        throw new Error("Can't find the selector for component, please check supported component list");
    }
    return Object.assign(Object.assign({}, useAdaptedSelector(selector)), useHandlers());
};

// Copyright (c) Microsoft Corporation.
const MINIMUM_TOUCH_TARGET_HEIGHT_REM = 3;
/**
 * @private
 */
const groupCallLeaveButtonStyle = {
    root: {
        border: '0.125rem',
        borderRadius: 2,
        height: '2.1875rem',
        width: '6.5625rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * @private
 */
const groupCallLeaveButtonCompressedStyle = {
    root: {
        border: '0',
        borderRadius: '0.5rem'
    },
    flexContainer: {
        flexFlow: 'row'
    }
};
/**
 * Styles that can be applied to ensure flyout items have the minimum touch target size.
 *
 * @private
 */
const buttonFlyoutIncreasedSizeStyles = {
    root: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    linkContent: {
        height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        lineHeight: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`,
        maxHeight: 'unset'
    },
    icon: {
        maxHeight: 'unset',
        textAlign: 'center'
    }
};
/**
 * @private
 */
const participantButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles,
        participantListStyles: {
            participantItemStyles: {
                root: {
                    height: `${MINIMUM_TOUCH_TARGET_HEIGHT_REM}rem`
                },
                participantSubMenuItemsStyles: buttonFlyoutIncreasedSizeStyles
            }
        }
    }
};
/**
 * @private
 */
const devicesButtonWithIncreasedTouchTargets = {
    menuStyles: {
        menuItemStyles: buttonFlyoutIncreasedSizeStyles
    }
};
/**
 * @private
 */
const controlButtonBaseStyle = {
    label: {
        minWidth: '2.25rem'
    }
};
/**
 * @private
 */
const concatButtonBaseStyles = (...styles) => {
    let result = controlButtonBaseStyle;
    styles.forEach(style => {
        result = react.concatStyleSets(result, style);
    });
    return result;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const Camera = (props) => {
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    return React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-camera-button" }, cameraButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disabled: cameraButtonProps.disabled || props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const generateCustomControlBarButtons$1 = (onFetchCustomButtonProps, displayType) => {
    const response = {
        primary: undefined,
        overflow: undefined,
        secondary: undefined
    };
    if (!onFetchCustomButtonProps) {
        return response;
    }
    const allButtonProps = onFetchCustomButtonProps.map(f => f({
        displayType
    }));
    for (const key in response) {
        response[key] = React__default['default'].createElement(React__default['default'].Fragment, null, allButtonProps.filter(buttonProps => buttonProps.placement === key).map((buttonProps, i) => { var _a; return React__default['default'].createElement(ControlBarButton, { ariaDescription: buttonProps.ariaDescription, ariaLabel: buttonProps.ariaLabel, disabled: buttonProps.disabled, id: buttonProps.id, key: (_a = buttonProps.key) !== null && _a !== void 0 ? _a : `${buttonProps.placement}_${i}`, onClick: buttonProps.onItemClick, onRenderIcon: () => { var _a; return React__default['default'].createElement(react.Icon, { iconName: (_a = buttonProps.iconName) !== null && _a !== void 0 ? _a : 'ControlButtonOptions' }); }, showLabel: buttonProps.showLabel, text: buttonProps.text, styles: buttonProps.styles }); }));
    }
    return response;
};
/** @private */
const onFetchCustomButtonPropsTrampoline$1 = (options) => {
    var _a;
    let response = undefined;
    response = (_a = options) === null || _a === void 0 ? void 0 : _a.onFetchCustomButtonProps;
    return response;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const Devices = (props) => {
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const augmentedDeviceButtonProps = React.useMemo(() => (Object.assign({}, devicesButtonProps)), [devicesButtonProps]);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? devicesButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    return React__default['default'].createElement(DevicesButton
    /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */ , Object.assign({ 
        /* By setting `persistMenu?` to true, we prevent options menu from getting hidden every time a participant joins or leaves. */ persistMenu: true }, augmentedDeviceButtonProps, { showLabel: props.displayType !== 'compact', styles: styles, "data-ui-id": "calling-composite-devices-button", disabled: props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const EndCall = (props) => {
    const compactMode = props.displayType === 'compact';
    const hangUpButtonProps = usePropsFor$1(EndCallButton);
    const styles = React.useMemo(() => { var _a; return react.concatStyleSets(compactMode ? groupCallLeaveButtonCompressedStyle : groupCallLeaveButtonStyle, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [compactMode, props.styles]);
    return React__default['default'].createElement(EndCallButton, Object.assign({ "data-ui-id": "call-composite-hangup-button" }, hangUpButtonProps, { styles: styles, showLabel: !compactMode }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const useSelector$1 = (selector, selectorProps) => {
    // use selector with no adaptation
    return useSelectorWithAdaptation(selector, state => state, selectorProps);
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const getDisplayName = (state) => state.displayName;
/**
 * @private
 */
const getCallStatus = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None'; };
/**
 * @private
 */
const getDeviceManager = (state) => state.devices;
/**
 * @private
 */
const getIsScreenShareOn = (state) => { var _a, _b; return (_b = (_a = state.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) !== null && _b !== void 0 ? _b : false; };
/**
 * @private
 */
const getIsPreviewCameraOn = (state) => _isPreviewOn(state.devices);
/**
 * @private
 */
const getPage = (state) => state.page;
/**
 * @private
 */
const getLocalMicrophoneEnabled = (state) => state.isLocalPreviewMicrophoneEnabled;
/**
 * @private
 */
const getLocalVideoStreams = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.localVideoStreams; };
/**
 * @private
 */
const getIsTranscriptionActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.transcription.isTranscriptionActive); };
/**
 * @private
 */
const getIsRecordingActive = (state) => { var _a; return !!((_a = state.call) === null || _a === void 0 ? void 0 : _a.recording.isRecordingActive); };
/**
 * @private
 */
const getUserFacingDiagnostics = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.diagnostics; };
/**
 * @private
 */
const getDominantSpeakerInfo = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.dominantSpeakers; };
/**
 * @private
 */
const getRemoteParticipants = (state) => { var _a; return (_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants; };

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const Microphone = (props) => {
    const microphoneButtonProps = usePropsFor$1(MicrophoneButton);
    const callStatus = useSelector$1(getCallStatus);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const strings = useLocale().strings.call;
    /**
     * When call is in Lobby, microphone button should be disabled.
     * This is due to to headless limitation where a call can not be muted/unmuted in lobby.
     */
    if (_isInLobbyOrConnecting(callStatus)) {
        microphoneButtonProps.disabled = true;
        // Lobby page should show the microphone status that was set on the local preview/configuration
        // page until the user successfully joins the call.
        microphoneButtonProps.checked = isLocalMicrophoneEnabled;
    }
    const microphoneButtonStrings = _isInLobbyOrConnecting(callStatus) ? {
        strings: {
            tooltipOffContent: strings.microphoneToggleInLobbyNotAllowed,
            tooltipOnContent: strings.microphoneToggleInLobbyNotAllowed
        }
    } : {};
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    // tab focus on MicrophoneButton on page load
    return React__default['default'].createElement(MicrophoneButton, Object.assign({ "data-ui-id": "call-composite-microphone-button" }, microphoneButtonProps, { showLabel: props.displayType !== 'compact', styles: styles }, microphoneButtonStrings, { enableDeviceSelectionMenu: props.splitButtonsForDeviceSelection, disabled: microphoneButtonProps.disabled || props.disabled }));
};

// Copyright (c) Microsoft Corporation.
/** @private */
const Participants = (props) => {
    const participantsButtonProps = usePropsFor$1(ParticipantsButton);
    const participantsButtonStyles = React.useMemo(() => { var _a; return concatButtonBaseStyles(props.increaseFlyoutItemSize ? participantButtonWithIncreasedTouchTargets : {}, (_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.increaseFlyoutItemSize, props.styles]);
    return React__default['default'].createElement(ParticipantsButton, Object.assign({ "data-ui-id": "call-composite-participants-button" }, participantsButtonProps, { showLabel: props.displayType !== 'compact', callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, disabled: isDisabled$1(props.option) || props.disabled, styles: participantsButtonStyles, showParticipantOverflowTooltip: !props.isMobile }));
};
const isDisabled$1 = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const ScreenShare = (props) => {
    const screenShareButtonProps = usePropsFor$1(ScreenShareButton);
    const styles = React.useMemo(() => { var _a; return concatButtonBaseStyles((_a = props.styles) !== null && _a !== void 0 ? _a : {}); }, [props.styles]);
    const screenShareButtonDisabled = () => {
        return isDisabled(props.option);
    };
    return React__default['default'].createElement(ScreenShareButton, Object.assign({ "data-ui-id": "call-composite-screenshare-button" }, screenShareButtonProps, { showLabel: props.displayType !== 'compact', disabled: screenShareButtonDisabled() || props.disabled, styles: styles }));
};
const isDisabled = (option) => {
    if (option === undefined || option === true || option === false) {
        return false;
    }
    return option.disabled;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @private */
const controlBarContainerStyles = {
    paddingTop: '0.25rem',
    paddingBottom: '0.25rem',
    // @TODO: this should be exposed through a custom CallComposite Theme API that extends the fluent theme with semantic values
    boxShadow: `
    0px 6.400000095367432px 14.399999618530273px 0px #00000021;
    0px 1.2000000476837158px 3.5999999046325684px 0px #0000001A;
  `
};

// Copyright (c) Microsoft Corporation.
const VIDEO_GALLERY_Z_INDEX = 1;
// The control bar must be in a higher z-band than the video gallery so the drop shadow appears on top of the video gallery
/** @private */
const CONTROL_BAR_Z_INDEX = VIDEO_GALLERY_Z_INDEX + 1;
// The notification container should be in the highest z-band to ensure it shows on top of all other content.
const NOTIFICATION_CONTAINER_Z_INDEX = Math.max(CONTROL_BAR_Z_INDEX, VIDEO_GALLERY_Z_INDEX) + 1;
/** @private */
const DRAWER_Z_INDEX = NOTIFICATION_CONTAINER_Z_INDEX + 1;
/**
 * @private
 */
const callControlsContainerStyles = react.mergeStyles(controlBarContainerStyles, {
    zIndex: CONTROL_BAR_Z_INDEX
});
const containerStyle$2 = {
    width: '100%',
    position: 'relative',
    minHeight: '13rem' // linked to minimum space allocated to media gallery
};
/**
 * @private
 */
const containerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '30rem' }));
/**
 * @private
 */
const containerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, containerStyle$2), { minWidth: '17.5rem' }));
/**
 * @private
 */
const galleryParentContainerStyles = (backgroundColor) => ({
    root: {
        zIndex: VIDEO_GALLERY_Z_INDEX,
        width: '100%',
        background: backgroundColor
    }
});
/**
 * @private
 */
const mediaGalleryContainerStyles$1 = {
    root: {
        height: '100%'
    }
};
/**
 * @private
 */
const notificationsContainerStyles = {
    root: {
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        padding: '1rem',
        zIndex: NOTIFICATION_CONTAINER_Z_INDEX,
        pointerEvents: 'none' // to allow the operation of controls underneath the notification container
    }
};
/**
 * @private
 */
const bannerNotificationStyles = {
    root: {
        pointerEvents: 'auto' // to allow the dismissal or error and warning bars in the notification container
    }
};
/**
 * @private
 */
const callArrangementContainerStyles = {
    root: {
        width: '100%',
        height: '100%',
        flexDirection: 'column-reverse' // to allow first initial keyboard focus on ControlBar
    }
};

// Copyright (c) Microsoft Corporation.
// Enforce a background color on control bar to ensure it matches the composite background color.
const controlBarStyles = react.memoizeFunction((background) => ({
    root: {
        background: background
    }
}));
/**
 * @private
 */
const CallControls = (props) => {
    const options = React.useMemo(() => typeof props.options === 'boolean' ? {} : props.options, [props.options]);
    const theme = react.useTheme();
    const customButtons = React.useMemo(() => generateCustomControlBarButtons$1(onFetchCustomButtonPropsTrampoline$1(options), options === null || options === void 0 ? void 0 : options.displayType), [options]);
    // when props.options is false then we want to hide the whole control bar.
    if (props.options === false) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    let screenShareButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.screenShareButton);
    let microphoneButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.microphoneButton);
    let cameraButtonIsEnabled = isEnabled$2(options === null || options === void 0 ? void 0 : options.cameraButton);
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "center", className: callControlsContainerStyles },
        React__default['default'].createElement(react.Stack.Item, null,
            React__default['default'].createElement(ControlBar, { layout: "horizontal", styles: controlBarStyles(theme.semanticColors.bodyBackground) },
                microphoneButtonIsEnabled && React__default['default'].createElement(Microphone, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.microphoneButton) }),
                cameraButtonIsEnabled && React__default['default'].createElement(Camera, { displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.cameraButton) }),
                screenShareButtonIsEnabled && React__default['default'].createElement(ScreenShare, { option: options === null || options === void 0 ? void 0 : options.screenShareButton, displayType: options === null || options === void 0 ? void 0 : options.displayType, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.screenShareButton) }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.participantsButton) && React__default['default'].createElement(Participants, { option: options === null || options === void 0 ? void 0 : options.participantsButton, callInvitationURL: props.callInvitationURL, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, isMobile: props.isMobile, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.participantsButton) }),
                isEnabled$2(options === null || options === void 0 ? void 0 : options.devicesButton) && React__default['default'].createElement(Devices, { displayType: options === null || options === void 0 ? void 0 : options.displayType, increaseFlyoutItemSize: props.increaseFlyoutItemSize, disabled: isDisabled$2(options === null || options === void 0 ? void 0 : options.devicesButton) }),
                customButtons['primary'],
                isEnabled$2(options === null || options === void 0 ? void 0 : options.endCallButton) && React__default['default'].createElement(EndCall, { displayType: options === null || options === void 0 ? void 0 : options.displayType }))));
};
const isEnabled$2 = (option) => option !== false;

// Copyright (c) Microsoft Corporation.
const icon$1 = () => React__default['default'].createElement(CallCompositeIcon, { iconName: 'ControlBarPeopleButton' });
/**
 * @private
 */
const PeopleButton = (props) => {
    const { strings, onRenderOnIcon, onRenderOffIcon, onClick } = props;
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { strings: strings, labelKey: 'peopleButtonLabelKey', onRenderOnIcon: onRenderOnIcon !== null && onRenderOnIcon !== void 0 ? onRenderOnIcon : icon$1, onRenderOffIcon: onRenderOffIcon !== null && onRenderOffIcon !== void 0 ? onRenderOffIcon : icon$1, onClick: onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
/**
 * The hook to bypass limitation of conditional build for CallWithChatComposite
 * Remove this and use useLocale() instead when merge CallWithChatComposite from beta
 *
 * @private
 */
const useCallWithChatCompositeStrings = () => {
    const locale = useLocale();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return locale.strings.callWithChat;
};

// Copyright (c) Microsoft Corporation.
const icon = () => React__default['default'].createElement(reactIcons.MoreHorizontal20Filled, { key: 'chatOnIconKey', primaryFill: "currentColor" });
/**
 * @private
 */
const MoreButton = (props) => {
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'optionsButtonLabelKey', showLabel: props.showLabel, onRenderOnIcon: icon, onRenderOffIcon: icon, onClick: props.onClick, "data-ui-id": props['data-ui-id'] }));
};

// Copyright (c) Microsoft Corporation.
/**
 * Max number of Custom Buttons in primary and secondary ControlBar
 * Does not include existing buttons in the controlBar.
 *
 * @private
 */
const CUSTOM_BUTTON_OPTIONS = {
    MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS: 3,
    MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS: 1,
    MAX_SECONDARY_DESKTOP_CUSTOM_BUTTONS: 2
};
/** @private */
const generateCustomCallControlBarButton = (onFetchCustomButtonProps, displayType) => {
    const allButtonProps = onFetchCustomButtonProps === null || onFetchCustomButtonProps === void 0 ? void 0 : onFetchCustomButtonProps.map(callback => callback({
        displayType
    }));
    return {
        primary: generateCustomControlBarButtons('primary', allButtonProps),
        secondary: generateCustomControlBarButtons('secondary', allButtonProps),
        overflow: generateCustomControlBarButtons('overflow', allButtonProps)
    };
};
/** @private */
const generateCustomControlBarButtons = (placement, customButtons) => customButtons ? customButtons.filter(buttonProps => buttonProps.placement === placement).map((buttonProps, i) => internalProps => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (buttonProps['onRenderButton']) {
        return buttonProps['onRenderButton'](internalProps);
    }
    return React__default['default'].createElement(ControlBarButton, { ariaDescription: (_a = buttonProps.ariaDescription) !== null && _a !== void 0 ? _a : internalProps.ariaDescription, ariaLabel: (_b = buttonProps.ariaLabel) !== null && _b !== void 0 ? _b : internalProps.ariaLabel, disabled: (_c = buttonProps.disabled) !== null && _c !== void 0 ? _c : internalProps.disabled, id: (_d = buttonProps.id) !== null && _d !== void 0 ? _d : internalProps.id, key: (_e = buttonProps.key) !== null && _e !== void 0 ? _e : `${buttonProps.placement}_${i}`, onClick: (_f = buttonProps.onItemClick) !== null && _f !== void 0 ? _f : internalProps.onClick, onRenderIcon: () => { var _a, _b, _c; return React__default['default'].createElement(react.Icon, { iconName: (_c = (_a = buttonProps.iconName) !== null && _a !== void 0 ? _a : (_b = internalProps.iconProps) === null || _b === void 0 ? void 0 : _b.iconName) !== null && _c !== void 0 ? _c : 'ControlButtonOptions' }); }, showLabel: (_g = buttonProps.showLabel) !== null && _g !== void 0 ? _g : internalProps.showLabel, text: (_h = buttonProps.text) !== null && _h !== void 0 ? _h : internalProps.text, styles: react.mergeStyleSets(internalProps.styles, buttonProps.styles) });
}) : [];
/** @private */
const onFetchCustomButtonPropsTrampoline = (options) => {
    var _a;
    let response = undefined;
    response = (_a = options) === null || _a === void 0 ? void 0 : _a.onFetchCustomButtonProps;
    return response;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 *  hidden button to set first tab keypress focus on a specific grouping.
 *  On mount, button is autofocused then immediately hidden
 */
const HiddenFocusStartPoint = () => {
    const [isMounted, setIsMounted] = React.useState(false);
    React.useEffect(() => {
        setIsMounted(true);
    }, []);
    return React__default['default'].createElement(react.DefaultButton, { autoFocus: true, ariaHidden: true, styles: isMounted ? invisibleHiddenFocusStartPoint : hiddenFocusStartPointStyles, tabIndex: -1 });
};
/** @private */
const hiddenFocusStartPointStyles = {
    root: {
        width: '0',
        height: '0',
        margin: '0',
        minHeight: '0',
        minWidth: '0',
        maxHeight: '0',
        maxWidth: '0',
        opacity: '0',
        outline: 'none',
        padding: '0',
        position: 'absolute'
    }
};
/** @private */
const invisibleHiddenFocusStartPoint = {
    root: {
        display: 'none'
    }
};

// Copyright (c) Microsoft Corporation.
const inferCommonCallControlOptions = (mobileView, commonCallControlOptions) => {
    if (commonCallControlOptions === false) {
        return false;
    }
    const options = commonCallControlOptions === true || commonCallControlOptions === undefined ? {} : commonCallControlOptions;
    if (mobileView) {
        // Set to compressed mode when composite is optimized for mobile
        options.displayType = 'compact';
        // Do not show screen share button when composite is optimized for mobile unless the developer
        // has explicitly opted in.
        if (options.screenShareButton !== true) {
            options.screenShareButton = false;
        }
    }
    return options;
};
/**
 * @private
 */
const CommonCallControlBar = (props) => {
    var _a, _b;
    const theme = react.useTheme();
    const rtl = theme.rtl;
    const controlBarContainerRef = React.useRef(null);
    const sidepaneControlsRef = React.useRef(null);
    const controlBarSizeRef = React.useRef(null);
    const [controlBarButtonsWidth, setControlBarButtonsWidth] = React.useState(0);
    const [panelsButtonsWidth, setPanelsButtonsWidth] = React.useState(0);
    const [controlBarContainerWidth, setControlBarContainerWidth] = React.useState(0);
    const [totalButtonsWidth, setTotalButtonsWidth] = React.useState(0);
    const [isOutOfSpace, setIsOutOfSpace] = React.useState(false);
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const options = inferCommonCallControlOptions(props.mobileView, props.callControls);
    const handleResize = React.useCallback(() => {
        setControlBarButtonsWidth(controlBarContainerRef.current ? controlBarContainerRef.current.offsetWidth : 0);
        setPanelsButtonsWidth(sidepaneControlsRef.current ? sidepaneControlsRef.current.offsetWidth : 0);
        setControlBarContainerWidth(controlBarSizeRef.current ? controlBarSizeRef.current.offsetWidth : 0);
    }, []);
    // on load set inital width
    React.useEffect(() => {
        setControlBarButtonsWidth(controlBarContainerRef.current ? controlBarContainerRef.current.offsetWidth : 0);
        setPanelsButtonsWidth(sidepaneControlsRef.current ? sidepaneControlsRef.current.offsetWidth : 0);
        setControlBarContainerWidth(controlBarSizeRef.current ? controlBarSizeRef.current.offsetWidth : 0);
    }, []);
    // get the current width of control bar buttons and panel control buttons when browser size change
    React.useEffect(() => {
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [handleResize]);
    /* when size change, reset total buttons width and compare with the control bar container width
    if the total width of those buttons exceed container width, do not center the control bar buttons based on parent container width
    Instead let them take up the remaining white space on the left */
    React.useEffect(() => {
        // white space on the left when control bar buttons are centered based on container width + control bar buttons width + panel control buttons width
        setTotalButtonsWidth((controlBarContainerWidth - controlBarButtonsWidth) / 2 + controlBarButtonsWidth + panelsButtonsWidth);
    }, [controlBarButtonsWidth, panelsButtonsWidth, controlBarContainerWidth]);
    React.useEffect(() => {
        setIsOutOfSpace(totalButtonsWidth > controlBarContainerWidth);
    }, [totalButtonsWidth, controlBarContainerWidth]);
    const peopleButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.peopleButtonLabel,
        tooltipOffContent: callWithChatStrings.peopleButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.peopleButtonTooltipClose
    }), [callWithChatStrings]);
    const moreButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.moreDrawerButtonLabel,
        tooltipContent: callWithChatStrings.moreDrawerButtonTooltip
    }), [callWithChatStrings]);
    const centerContainerStyles = React.useMemo(() => {
        const styles = !props.mobileView ? desktopControlBarStyles : {};
        return react.mergeStyleSets(styles, {
            root: {
                // Enforce a background color on control bar to ensure it matches the composite background color.
                background: theme.semanticColors.bodyBackground
            }
        });
    }, [props.mobileView, theme.semanticColors.bodyBackground]);
    const screenShareButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopScreenShareButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const commonButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const endCallButtonStyles = React.useMemo(() => !props.mobileView ? getDesktopEndCallButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const controlBarWrapperDesktopStyles = React.useMemo(
    // only center control bar buttons based on parent container if there are enough space on the screen and not mobile
    () => !props.mobileView && !isOutOfSpace ? rtl ? wrapperDesktopRtlStyles : wrapperDesktopStyles : {}, [props.mobileView, rtl, isOutOfSpace]);
    // only center control bar buttons based on parent container if there are enough space on the screen and not mobile
    const controlBarDesktopContainerStyles = React.useMemo(() => !props.mobileView && !isOutOfSpace ? {
        position: 'relative',
        minHeight: '4.5rem',
        width: '100%'
    } : {}, [props.mobileView, isOutOfSpace]);
    const customButtons = React.useMemo(() => generateCustomCallControlBarButton(onFetchCustomButtonPropsTrampoline(options !== false ? options : undefined), options !== false ? options === null || options === void 0 ? void 0 : options.displayType : undefined), [options]);
    // when options is false then we want to hide the whole control bar.
    if (options === false) {
        return React__default['default'].createElement(React__default['default'].Fragment, null);
    }
    const sideButtonsPresent = isEnabled$1(options.peopleButton) || isEnabled$1(options.chatButton) || customButtons['secondary'] !== undefined;
    let screenShareButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.screenShareButton);
    let microphoneButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.microphoneButton);
    let cameraButtonIsEnabled = isEnabled$1(options === null || options === void 0 ? void 0 : options.cameraButton);
    return React__default['default'].createElement("div", { ref: controlBarSizeRef },
        React__default['default'].createElement(CallAdapterProvider, { adapter: props.callAdapter }),
        React__default['default'].createElement(react.Stack, { horizontal: true, reversed: !props.mobileView && !isOutOfSpace, horizontalAlign: "space-between", className: react.mergeStyles(callControlsContainerStyles, controlBarContainerStyles, controlBarDesktopContainerStyles) },
            React__default['default'].createElement(react.Stack.Item, { grow: true, className: react.mergeStyles(controlBarWrapperDesktopStyles) },
                React__default['default'].createElement(CallAdapterProvider, { adapter: props.callAdapter },
                    React__default['default'].createElement(react.Stack, { horizontalAlign: "center" },
                        React__default['default'].createElement(HiddenFocusStartPoint, null),
                        React__default['default'].createElement(react.Stack.Item, null,
                            React__default['default'].createElement("div", { ref: controlBarContainerRef },
                                React__default['default'].createElement(ControlBar, { layout: "horizontal", styles: centerContainerStyles },
                                    microphoneButtonIsEnabled && React__default['default'].createElement(Microphone, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                                    cameraButtonIsEnabled && React__default['default'].createElement(Camera, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                                    screenShareButtonIsEnabled && React__default['default'].createElement(ScreenShare, { option: options.screenShareButton, displayType: options.displayType, styles: screenShareButtonStyles }), (_a = customButtons['primary']) === null || _a === void 0 ? void 0 :
                                    _a.slice(0, props.mobileView ? CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_MOBILE_CUSTOM_BUTTONS : CUSTOM_BUTTON_OPTIONS.MAX_PRIMARY_DESKTOP_CUSTOM_BUTTONS).map((CustomButton, i) => {
                                        return React__default['default'].createElement(CustomButton, { key: `primary-custom-button-${i}`, styles: commonButtonStyles, showLabel: options.displayType !== 'compact' });
                                    }),
                                    props.mobileView && React__default['default'].createElement(MoreButton, { "data-ui-id": "common-call-composite-more-button", strings: moreButtonStrings, onClick: props.onMoreButtonClicked, disabled: props.disableButtonsForLobbyPage }),
                                    React__default['default'].createElement(EndCall, { displayType: "compact", styles: endCallButtonStyles }))))))),
            !props.mobileView && sideButtonsPresent && React__default['default'].createElement(react.Stack.Item, null,
                React__default['default'].createElement("div", { ref: sidepaneControlsRef },
                    React__default['default'].createElement(react.Stack, { horizontal: true, className: !props.mobileView ? react.mergeStyles(desktopButtonContainerStyle) : undefined },
                        isEnabled$1(options === null || options === void 0 ? void 0 : options.peopleButton) && React__default['default'].createElement(PeopleButton, { checked: props.peopleButtonChecked, ariaLabel: peopleButtonStrings === null || peopleButtonStrings === void 0 ? void 0 : peopleButtonStrings.label, showLabel: options.displayType !== 'compact', onClick: props.onPeopleButtonClicked, "data-ui-id": "common-call-composite-people-button", disabled: props.disableButtonsForLobbyPage || props.disableButtonsForHoldScreen || isDisabled$2(options.peopleButton), strings: peopleButtonStrings, styles: commonButtonStyles }), (_b = customButtons['secondary']) === null || _b === void 0 ? void 0 :
                        _b.slice(0, CUSTOM_BUTTON_OPTIONS.MAX_SECONDARY_DESKTOP_CUSTOM_BUTTONS).map((CustomButton, i) => {
                            return React__default['default'].createElement(CustomButton, { key: `secondary-custom-button-${i}`, styles: commonButtonStyles, showLabel: options.displayType !== 'compact' });
                        }))))));
};
const desktopButtonContainerStyle = {
    padding: '0.75rem',
    columnGap: '0.5rem'
};
const desktopControlBarStyles = {
    root: desktopButtonContainerStyle
};
const wrapperDesktopStyles = {
    position: 'absolute',
    left: '50%',
    transform: 'translate(-50%, 0)'
};
const wrapperDesktopRtlStyles = {
    position: 'absolute',
    right: '50%',
    transform: 'translate(-50%, 0)'
};
/** @private */
const getDesktopCommonButtonStyles = (theme) => ({
    root: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderRadius: theme.effects.roundedCorner4,
        minHeight: '2.5rem',
        maxWidth: '12rem' // allot extra space than the regular ControlBarButton. This is to give extra room to have the icon beside the text.
    },
    flexContainer: {
        display: 'flex',
        flexFlow: 'row nowrap'
    },
    textContainer: {
        // Override the default so that label doesn't introduce a new block.
        display: 'inline',
        // Ensure width is set to permit child to show ellipsis when there is a label that is too long
        maxWidth: '100%'
    },
    label: {
        fontSize: theme.fonts.medium.fontSize,
        // Ensure there is enough space between the icon and text to allow for the unread messages badge in the chat button
        marginLeft: '0.625rem',
        // Ensure letters that go above and below the standard text line like 'g', 'y', 'j' are not clipped
        lineHeight: '1.5rem',
        // Do not allow very long button texts to ruin the control bar experience, instead ensure long text is truncated and shows ellipsis
        display: 'block',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden'
    },
    splitButtonMenuButton: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderTopRightRadius: theme.effects.roundedCorner4,
        borderBottomRightRadius: theme.effects.roundedCorner4,
        borderTopLeftRadius: '0',
        borderBottomLeftRadius: '0'
    },
    splitButtonMenuButtonChecked: {
        // Default colors the menu half similarly for :hover and when button is checked.
        // To align with how the left-half is styled, override the checked style.
        background: 'none'
    }
});
const getDesktopScreenShareButtonStyles = (theme) => {
    const overrideStyles = {
        border: 'none',
        background: theme.palette.themePrimary,
        color: theme.palette.white,
        '* > svg': {
            fill: theme.palette.white
        },
        '@media (forced-colors: active)': {
            border: '1px solid',
            borderColor: theme.palette.black
        }
    };
    const overrides = {
        rootChecked: overrideStyles,
        rootCheckedHovered: overrideStyles
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const getDesktopEndCallButtonStyles = (theme) => {
    const overrides = {
        root: {
            // Suppress border around the dark-red button.
            border: 'none'
        },
        rootFocused: {
            '@media (forced-colors: active)': {
                background: 'highlight',
                border: '1px solid'
            }
        },
        icon: {
            '@media (forced-colors: active)': {
                ':focused': {
                    color: theme.palette.white
                }
            }
        }
    };
    return react.concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const isEnabled$1 = (option) => option !== false;

// Copyright (c) Microsoft Corporation.
/**
 * Notify the user that they're muted.
 */
function MutedNotification(props) {
    const locale = useLocale();
    const theme = react.useTheme();
    return React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "center", className: react.mergeStyles(props.speakingWhileMuted === true ? isSpeakingAndMutedAnimationStyles : isNotSpeakingAndMutedAnimationStyles) },
        React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(stackStyle(theme)) },
            React__default['default'].createElement(CallCompositeIcon, { iconName: "Muted", className: react.mergeStyles(iconStyle(theme)) }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(textStyle(theme)), "aria-live": 'polite' }, locale.strings.call.mutedMessage)));
}
const stackStyle = (theme) => {
    return {
        background: theme.palette.black,
        gap: `1rem`,
        padding: `1rem`,
        borderRadius: theme.effects.roundedCorner4,
        width: 'fit-content',
        opacity: 0.8
    };
};
const iconStyle = (theme) => {
    return {
        color: theme.palette.white,
        maxHeight: '1.25rem'
    };
};
const textStyle = (theme) => {
    return {
        color: theme.palette.white,
        fontSize: `1rem`
    };
};
const isSpeakingAndMutedAnimationStyles = Object.assign({}, react.AnimationStyles.fadeIn100);
const isNotSpeakingAndMutedAnimationStyles = Object.assign(Object.assign({}, react.AnimationStyles.fadeOut200), { display: 'none' });

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const callStatusSelector = reselect.createSelector([getCallStatus, getIsScreenShareOn], (callStatus, isScreenShareOn) => {
    return {
        callStatus,
        isScreenShareOn
    };
});

// Copyright (c) Microsoft Corporation.
const inferCallWithChatControlOptions = (callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    return options;
};
/** @private */
const MoreDrawer = (props) => {
    var _a, _b;
    const drawerMenuItems = [];
    const { speakers, onSelectSpeaker, onLightDismiss } = props;
    const onSpeakerItemClick = React.useCallback((_ev, itemKey) => {
        const selected = speakers === null || speakers === void 0 ? void 0 : speakers.find(speaker => speaker.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectSpeaker(selected);
        }
        onLightDismiss();
    }, [speakers, onSelectSpeaker, onLightDismiss]);
    const drawerSelectionOptions = inferCallWithChatControlOptions(props.callControls);
    if (props.speakers && props.speakers.length > 0) {
        drawerMenuItems.push({
            itemKey: 'speakers',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.speakerMenuTitle,
            iconProps: {
                iconName: 'MoreDrawerSpeakers'
            },
            subMenuProps: props.speakers.map(speaker => ({
                itemKey: speaker.id,
                iconProps: {
                    iconName: isDeviceSelected(speaker, props.selectedSpeaker) ? 'MoreDrawerSelectedSpeaker' : 'MoreDrawerSpeakers'
                },
                text: speaker.name,
                onItemClick: onSpeakerItemClick,
                secondaryIconProps: isDeviceSelected(speaker, props.selectedSpeaker) ? {
                    iconName: 'Accept'
                } : undefined
            })),
            secondaryText: (_a = props.selectedSpeaker) === null || _a === void 0 ? void 0 : _a.name
        });
    }
    const { microphones, onSelectMicrophone } = props;
    const onMicrophoneItemClick = React.useCallback((_ev, itemKey) => {
        const selected = microphones === null || microphones === void 0 ? void 0 : microphones.find(mic => mic.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectMicrophone(selected);
        }
        onLightDismiss();
    }, [microphones, onSelectMicrophone, onLightDismiss]);
    if (props.microphones && props.microphones.length > 0) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = props.speakers && props.speakers.length > 0;
        const itemKey = speakersAvailable ? 'microphones' : 'audioDevices';
        const text = speakersAvailable ? props.strings.microphoneMenuTitle : props.strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'MoreDrawerMicrophones' : 'MoreDrawerSpeakers';
        const selectedIconName = speakersAvailable ? 'MoreDrawerSelectedMicrophone' : 'MoreDrawerSelectedSpeaker';
        drawerMenuItems.push({
            itemKey: itemKey,
            disabled: props.disableButtonsForHoldScreen,
            text: text,
            iconProps: {
                iconName: iconName
            },
            subMenuProps: props.microphones.map(mic => ({
                itemKey: mic.id,
                iconProps: {
                    iconName: isDeviceSelected(mic, props.selectedMicrophone) ? selectedIconName : iconName
                },
                text: mic.name,
                onItemClick: onMicrophoneItemClick,
                secondaryIconProps: isDeviceSelected(mic, props.selectedMicrophone) ? {
                    iconName: 'Accept'
                } : undefined,
                disabled: drawerSelectionOptions !== false ? isDisabled$2(drawerSelectionOptions.microphoneButton) : undefined
            })),
            secondaryText: (_b = props.selectedMicrophone) === null || _b === void 0 ? void 0 : _b.name
        });
    }
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.peopleButton)) {
        drawerMenuItems.push({
            itemKey: 'people',
            id: 'call-composite-drawer-people-button',
            text: props.strings.peopleButtonLabel,
            iconProps: {
                iconName: 'MoreDrawerPeople'
            },
            onItemClick: props.onPeopleButtonClicked,
            disabled: isDisabled$2(drawerSelectionOptions.peopleButton) || props.disableButtonsForHoldScreen
        });
    }
    return React__default['default'].createElement(_DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss });
};
const isDeviceSelected = (speaker, selectedSpeaker) => !!selectedSpeaker && speaker.id === selectedSpeaker.id;
const isEnabled = (option) => option !== false;

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const moreDrawerSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        microphones: deviceManager.microphones,
        speakers: deviceManager.speakers,
        selectedMicrophone: deviceManager.selectedMicrophone,
        selectedSpeaker: deviceManager.selectedSpeaker
    };
});

// Copyright (c) Microsoft Corporation.
/** @private */
const PreparedMoreDrawer = (props) => {
    const strings = useCallWithChatCompositeStrings();
    const moreDrawerStrings = React.useMemo(() => ({
        peopleButtonLabel: strings.peopleButtonLabel,
        audioDeviceMenuTitle: strings.moreDrawerAudioDeviceMenuTitle,
        microphoneMenuTitle: strings.moreDrawerMicrophoneMenuTitle,
        speakerMenuTitle: strings.moreDrawerSpeakerMenuTitle
    }), [strings]);
    const deviceProps = useSelector$1(moreDrawerSelector);
    const callHandlers = useHandlers();
    return React__default['default'].createElement(MoreDrawer, Object.assign({}, props, deviceProps, callHandlers, { strings: moreDrawerStrings }));
};

// Copyright (c) Microsoft Corporation.
const DEFAULT_Z_INDEX = 1;
const mainScreenContainerStyle = {
    height: '100%',
    width: '100%'
};
/**
 * @private
 */
const mainScreenContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '30rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '22rem' // max height of min-height of composite pages (Configuration page)
 }));
/**
 * @private
 */
const mainScreenContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, mainScreenContainerStyle), { minWidth: '17.5rem', 
    // max of min-width of composite pages (Call page)
    minHeight: '13rem' // max height of min-height of composite pages (Configuration page & Call page)
 }));
/**
 * @private
 * Drawer styles to be used to house the _DrawerComponent on top of other content on the screen.
 * @param zIndex: this defaults to DEFAULT_Z_INDEX if unset
 */
const drawerContainerStyles = (zIndex = DEFAULT_Z_INDEX) => ({
    root: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        // Any zIndex > 0 will work because this is the only absolutely
        // positioned element in the container.
        zIndex: zIndex
    }
});
/**
 * @private
 * Page container style for leaving page
 */
const leavingPageStyle = (palette) => ({
    background: palette.neutralLighterAlt
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mobilePaneStyle = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
react.concatStyleSets(mobilePaneStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const mobilePaneControlBarStyle = {
    root: {
        height: '3rem'
    }
};
/**
 * @private
 */
const mobilePaneBackButtonStyles = {
    root: {
        border: 'none',
        minWidth: '2.5rem',
        height: '100%',
        background: 'none',
        padding: '0 1rem'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    }
};
/**
 * @private
 */
const mobilePaneHiddenIconStyles = react.concatStyleSets(mobilePaneBackButtonStyles, {
    root: {
        visibility: 'hidden'
    }
});
/**
 * @private
 */
const mobilePaneButtonStyles = {
    root: {
        border: 'none',
        borderBottom: '0.125rem solid transparent',
        width: '8rem',
        height: '100%',
        background: 'none',
        padding: '0'
    },
    rootChecked: {
        background: 'none'
    },
    rootCheckedHovered: {
        background: 'none'
    },
    flexContainer: {
        flexFlow: 'column',
        display: 'contents'
    },
    label: {
        fontSize: '1rem',
        fontWeight: 100,
        lineHeight: '2rem',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
    },
    labelChecked: {
        fontWeight: 600
    }
};
/**
 * @private
 */
const hiddenStyles = {
    root: {
        display: 'none'
    }
};
/**
 * @private
 */
const sidePaneStyles = {
    root: {
        height: 'auto',
        width: '100%',
        padding: '0.5rem 0.25rem',
        maxWidth: '21.5rem'
    }
};
/**
 * @private
 */
const availableSpaceStyles = {
    root: {
        width: '100%',
        height: '100%'
    }
};
/**
 * @private
 */
const sidePaneTokens = {
    childrenGap: '0.5rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Context for side pane interaction
 *
 * @private
 */
const SidePaneContext = React.createContext({});
/**
 * Provider to provide localized strings for this library's composites.
 *
 * @private
 */
const SidePaneProvider = (props) => {
    return React__default['default'].createElement(SidePaneContext.Provider, { value: props }, props.children);
};
/** @private */
const useSidePaneContext = () => React.useContext(SidePaneContext);
/** @private */
const useIsSidePaneOpen = () => {
    const { sidePaneRenderer, overrideSidePane } = useSidePaneContext();
    return !!(sidePaneRenderer || (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive));
};
/** @private */
const useIsParticularSidePaneOpen = (sidePaneId) => {
    const isSidePaneOpen = useIsSidePaneOpen();
    const { sidePaneRenderer } = useSidePaneContext();
    return isSidePaneOpen && (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === sidePaneId;
};

// Copyright (c) Microsoft Corporation.
/**
 * Legacy header to be removed when we make a breaking change.
 * @private
 */
const PeopleAndChatHeader = (props) => {
    const { onClose, onChatButtonClicked, onPeopleButtonClicked, activeTab } = props;
    const theme = useTheme();
    const strings = localeTrampoline$1(useLocale());
    const haveMultipleTabs = onChatButtonClicked && onPeopleButtonClicked;
    const mobilePaneButtonStylesThemed = React.useMemo(() => {
        return react.concatStyleSets(mobilePaneButtonStyles, {
            root: {
                width: '100%'
            },
            label: {
                fontSize: theme.fonts.medium.fontSize,
                fontWeight: theme.fonts.medium.fontWeight
            }
        }, haveMultipleTabs ? {
            rootChecked: {
                borderBottom: `0.125rem solid ${theme.palette.themePrimary}`
            }
        } : {});
    }, [theme, haveMultipleTabs]);
    return React__default['default'].createElement(react.Stack, { horizontal: true, grow: true, styles: mobilePaneControlBarStyle },
        React__default['default'].createElement(react.DefaultButton, { ariaLabel: strings.returnToCallButtonAriaLabel, ariaDescription: strings.returnToCallButtonAriaDescription, onClick: onClose, styles: mobilePaneBackButtonStyles, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }), autoFocus: true }),
        React__default['default'].createElement(react.Stack.Item, { grow: true }, onChatButtonClicked && React__default['default'].createElement(react.DefaultButton, { onClick: onChatButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'chat', role: 'tab', disabled: props.disableChatButton }, strings.chatButtonLabel)),
        React__default['default'].createElement(react.Stack.Item, { grow: true }, onPeopleButtonClicked && React__default['default'].createElement(react.DefaultButton, { onClick: onPeopleButtonClicked, styles: mobilePaneButtonStylesThemed, checked: activeTab === 'people', role: 'tab', disabled: props.disablePeopleButton }, strings.peopleButtonLabel)),
        React__default['default'].createElement(react.DefaultButton, { styles: mobilePaneHiddenIconStyles, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }) }));
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const localeTrampoline$1 = (locale) => {
    return locale.strings.callWithChat;
};

// Copyright (c) Microsoft Corporation.
/** @private */
const SidePane = (props) => {
    var _a;
    const { sidePaneRenderer, overrideSidePane } = useSidePaneContext();
    const renderingHiddenOverrideContent = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.renderer.contentRenderer) && overrideSidePane.persistRenderingWhenClosed && !overrideSidePane.isActive;
    const renderingOnlyHiddenContent = renderingHiddenOverrideContent && !sidePaneRenderer;
    const paneStyles = renderingOnlyHiddenContent ? hiddenStyles : props.mobileView ? availableSpaceStyles : sidePaneStyles;
    let Header = (_a = ((overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? overrideSidePane.renderer.headerRenderer : sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.headerRenderer)) !== null && _a !== void 0 ? _a : EmptyElement;
    /**
     * Legacy code to support old behavior of showing chat and people tab headers on mobile side pane.
     * To be removed in breaking change.
     */
    const overrideSidePaneId = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? overrideSidePane.renderer.id : undefined;
    const { updateSidePaneRenderer } = props;
    const closePane = React.useCallback(() => {
        updateSidePaneRenderer(undefined);
    }, [updateSidePaneRenderer]);
    if (props.mobileView && (overrideSidePaneId === 'chat' || (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people')) {
        // use legacy header
        Header = () => {
            var _a;
            return React__default['default'].createElement(PeopleAndChatHeader, { onClose: overrideSidePaneId === 'chat' ? (_a = props.onChatButtonClicked) !== null && _a !== void 0 ? _a : noop : closePane, activeTab: (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people' ? 'people' : 'chat', 
                // legacy arguments to be removed in breaking change:
                disablePeopleButton: props.disablePeopleButton, disableChatButton: props.disableChatButton, onPeopleButtonClicked: (sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id) === 'people' ? noop : props.onPeopleButtonClicked, onChatButtonClicked: overrideSidePaneId === 'chat' ? noop : props.onChatButtonClicked });
        };
    }
    const ContentRender = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) ? undefined : sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.contentRenderer;
    const OverrideContentRender = (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) || (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.persistRenderingWhenClosed) ? overrideSidePane.renderer.contentRenderer : undefined;
    if (!ContentRender && !OverrideContentRender) {
        return React__default['default'].createElement(EmptyElement, null);
    }
    return React__default['default'].createElement(react.Stack, { verticalFill: true, grow: true, styles: paneStyles, "data-ui-id": "SidePane", tokens: props.mobileView ? {} : sidePaneTokens },
        React__default['default'].createElement(Header, null),
        React__default['default'].createElement(react.Stack.Item, { verticalFill: true, grow: true, styles: paneBodyContainer },
            React__default['default'].createElement(react.Stack, { verticalFill: true, styles: scrollableContainer },
                ContentRender && React__default['default'].createElement(react.Stack.Item, { verticalFill: true, styles: scrollableContainerContents },
                    React__default['default'].createElement(react.Stack, { styles: containerContextStyles },
                        React__default['default'].createElement(ContentRender, null))),
                OverrideContentRender && React__default['default'].createElement(react.Stack.Item, { verticalFill: true, styles: !(overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive) && (overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.persistRenderingWhenClosed) ? hiddenStyles : scrollableContainerContents },
                    React__default['default'].createElement(react.Stack, { styles: containerContextStyles },
                        React__default['default'].createElement(OverrideContentRender, null))))));
};
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const EmptyElement = () => React__default['default'].createElement(React__default['default'].Fragment, null);

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const SidePaneHeader = (props) => {
    const theme = useTheme();
    const sidePaneCloseButtonStyles = React.useMemo(() => ({
        root: {
            minWidth: '1.5rem',
            padding: 0,
            backgroundColor: theme.semanticColors.bodyBackground
        },
        icon: {
            color: theme.palette.neutralSecondary
        },
        iconHovered: {
            color: theme.palette.neutralSecondary
        },
        iconPressed: {
            color: theme.palette.neutralSecondary
        }
    }), [theme.palette.neutralSecondary, theme.semanticColors.bodyBackground]);
    if (props.mobileView) {
        return React__default['default'].createElement(SidePaneMobileHeader, Object.assign({}, props));
    }
    return React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", styles: sidePaneHeaderContainerStyles },
        React__default['default'].createElement(react.Stack.Item, { styles: sidePaneHeaderStyles }, props.headingText),
        React__default['default'].createElement(react.CommandBarButton, { ariaLabel: props.dismissSidePaneButtonAriaLabel, styles: sidePaneCloseButtonStyles, iconProps: {
                iconName: 'cancel'
            }, onClick: props.onClose }));
};
const SidePaneMobileHeader = (props) => {
    const { headingText, dismissSidePaneButtonAriaLabel, dismissSidePaneButtonAriaDescription, onClose } = props;
    const theme = useTheme();
    const mobilePaneButtonStylesThemed = React.useMemo(() => {
        return react.concatStyleSets(mobilePaneButtonStyles, {
            root: {
                width: '100%'
            },
            label: {
                fontSize: theme.fonts.medium.fontSize,
                fontWeight: theme.fonts.medium.fontWeight
            }
        });
    }, [theme]);
    return React__default['default'].createElement(react.Stack, { horizontal: true, grow: true, styles: mobilePaneControlBarStyle },
        React__default['default'].createElement(react.DefaultButton, { ariaLabel: dismissSidePaneButtonAriaLabel, ariaDescription: dismissSidePaneButtonAriaDescription, onClick: onClose, styles: mobilePaneBackButtonStyles, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }), autoFocus: true }),
        React__default['default'].createElement(react.Stack.Item, { grow: true },
            React__default['default'].createElement(react.DefaultButton, { checked: true, styles: mobilePaneButtonStylesThemed }, headingText)),
        React__default['default'].createElement(react.DefaultButton, { styles: mobilePaneHiddenIconStyles, ariaHidden: true, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "ChevronLeft" }) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ParticipantListWithHeading = (props) => {
    const { onFetchAvatarPersonaData, onFetchParticipantMenuItems, title, participantListProps } = props;
    const theme = react.useTheme();
    const subheadingStyleThemed = React.useMemo(() => ({
        root: {
            color: theme.palette.neutralSecondary,
            margin: props.isMobile ? '0.5rem 1rem' : '0.5rem',
            fontSize: theme.fonts.smallPlus.fontSize
        }
    }), [theme.palette.neutralSecondary, theme.fonts.smallPlus.fontSize, props.isMobile]);
    return React__default['default'].createElement(react.Stack, { className: participantListStack },
        React__default['default'].createElement(react.Stack.Item, { styles: subheadingStyleThemed, "aria-label": title }, title),
        React__default['default'].createElement(react.FocusZone, { className: participantListContainerStyle, shouldFocusOnMount: true },
            React__default['default'].createElement(ParticipantList, Object.assign({}, participantListProps, { styles: props.isMobile ? participantListMobileStyle : participantListStyle, onRenderAvatar: (userId, options) => React__default['default'].createElement(React__default['default'].Fragment, null,
                    React__default['default'].createElement(AvatarPersona, Object.assign({ "data-ui-id": "chat-composite-participant-custom-avatar", userId: userId }, options, {
                        hidePersonaDetails: !!(options === null || options === void 0 ? void 0 : options.text)
                    }, { dataProvider: onFetchAvatarPersonaData })),
                    (options === null || options === void 0 ? void 0 : options.text) && React__default['default'].createElement(react.Text, { nowrap: true, styles: displayNameStyles }, options === null || options === void 0 ? void 0 : options.text)), onFetchParticipantMenuItems: onFetchParticipantMenuItems, showParticipantOverflowTooltip: !props.isMobile }))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const peoplePaneContainerStyle = {
    root: {
        position: 'relative',
        maxHeight: '100%',
        overflow: 'hidden'
    }
};
/**
 * @private
 */
const participantListContainerStyles = {
    root: {
        overflowY: 'scroll'
    }
};
/**
 * @private
 */
const copyLinkButtonContainerStyles = {
    root: {
        width: '100%',
        padding: '0.5rem 1rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStackStyles = {
    root: {
        marginLeft: '0.5rem',
        marginRight: '0.5rem'
    }
};
/**
 * @private
 */
const copyLinkButtonStyles = {
    root: {
        height: '2.5rem',
        width: '100%'
    },
    textContainer: {
        display: 'contents'
    }
};
/**
 * @private
 */
const linkIconStyles = {
    marginRight: '0.5rem'
};
/**
 * @private
 */
const themedCopyLinkButtonStyles = (mobileView, theme) => ({
    root: {
        minHeight: mobileView ? '3rem' : '2.5rem',
        borderRadius: mobileView ? theme.effects.roundedCorner6 : theme.effects.roundedCorner4
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Convert IContextualMenuItem to _DrawerMenuItemProps
 * @param contextualMenu - IContextualMenuItem to convert
 * @param onDrawerMenuItemClick - callback to call when converted DrawerMenuItem is clicked
 * @returns DrawerMenuItem
 * @private
 */
const convertContextualMenuItemToDrawerMenuItem = (contextualMenu, onDrawerMenuItemClick) => {
    return {
        itemKey: contextualMenu.key,
        onItemClick: () => {
            var _a;
            (_a = contextualMenu.onClick) === null || _a === void 0 ? void 0 : _a.call(contextualMenu);
            onDrawerMenuItemClick();
        },
        iconProps: contextualMenu.iconProps,
        text: contextualMenu.text,
        disabled: contextualMenu.disabled
    };
};

// Copyright (c) Microsoft Corporation.
/** @private */
const AddPeopleButton = (props) => {
    const { inviteLink, mobileView, strings, participantList } = props;
    const theme = react.useTheme();
    const [copyInviteLinkAnnouncerStrings, setCopyInviteLinkAnnouncerStrings] = React.useState('');
    const copyLinkButtonStylesThemed = React.useMemo(() => react.concatStyleSets(copyLinkButtonStyles, themedCopyLinkButtonStyles(mobileView, theme)), [mobileView, theme]);
    /**
     * sets the announcement string for when the link is copied.
     */
    const toggleAnnouncerString = React.useCallback(() => {
        setCopyInviteLinkAnnouncerStrings(strings.copyInviteLinkActionedAriaLabel);
        /**
         * Clears the announcer string after the user clicks the
         * copyInviteLink button allowing it to be re-announced.
         */
        setTimeout(() => {
            setCopyInviteLinkAnnouncerStrings('');
        }, 3000);
    }, [strings.copyInviteLinkActionedAriaLabel]);
    if (mobileView) {
        return React__default['default'].createElement(react.Stack, null, inviteLink && React__default['default'].createElement(react.Stack.Item, { styles: copyLinkButtonContainerStyles },
            React__default['default'].createElement(Announcer$1, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
            React__default['default'].createElement(react.PrimaryButton, { onClick: () => {
                    copy__default['default'](inviteLink !== null && inviteLink !== void 0 ? inviteLink : '');
                    toggleAnnouncerString();
                }, styles: copyLinkButtonStylesThemed, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), text: strings.copyInviteLinkButtonLabel })));
    }
    else {
        return React__default['default'].createElement(react.Stack, { tokens: peoplePaneContainerTokens, "data-ui-id": "people-pane-content" },
            inviteLink && React__default['default'].createElement(react.Stack, { styles: copyLinkButtonStackStyles },
                React__default['default'].createElement(Announcer$1, { announcementString: copyInviteLinkAnnouncerStrings, ariaLive: 'polite' }),
                React__default['default'].createElement(react.DefaultButton, { text: strings.copyInviteLinkButtonLabel, onRenderIcon: () => React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: "Link", style: linkIconStyles }), onClick: () => {
                        copy__default['default'](inviteLink !== null && inviteLink !== void 0 ? inviteLink : '');
                        toggleAnnouncerString();
                    }, styles: copyLinkButtonStylesThemed })),
            participantList);
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$8 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const PeoplePaneContent = (props) => {
    const { inviteLink, onFetchParticipantMenuItems, setDrawerMenuItems } = props;
    const adapter = useAdapter();
    const localeStrings = useLocale();
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const getStrings = () => {
        return localeStrings.strings.callWithChat;
    };
    const strings = getStrings();
    const removeParticipantFromCall = React.useCallback((participantId) => __awaiter$8(void 0, void 0, void 0, function* () {
        yield adapter.removeParticipant(participantId);
    }), [adapter]);
    const participantListDefaultProps = usePropsFor$1(ParticipantList);
    const removeButtonAllowed = hasRemoveParticipantsPermissionTrampoline();
    const setDrawerMenuItemsForParticipant = React.useMemo(() => {
        return (participant) => {
            if (participant) {
                let contextualMenuItems = createDefaultContextualMenuItems(participant, strings, participant.isRemovable ? participantListDefaultProps.onRemoveParticipant : undefined, participantListDefaultProps.myUserId);
                if (onFetchParticipantMenuItems) {
                    contextualMenuItems = onFetchParticipantMenuItems(participant.userId, participantListDefaultProps.myUserId, contextualMenuItems);
                }
                const drawerMenuItems = contextualMenuItems.map((contextualMenu) => convertContextualMenuItemToDrawerMenuItem(contextualMenu, () => setDrawerMenuItems([])));
                setDrawerMenuItems(drawerMenuItems);
            }
        };
    }, [strings, participantListDefaultProps.onRemoveParticipant, participantListDefaultProps.myUserId, removeButtonAllowed, onFetchParticipantMenuItems, setDrawerMenuItems]);
    const participantListProps = React.useMemo(() => {
        const onRemoveAParticipant = (participantId) => __awaiter$8(void 0, void 0, void 0, function* () { return removeParticipantFromCall(participantId); });
        return Object.assign(Object.assign({}, participantListDefaultProps), { 
            // Passing undefined callback for mobile to avoid context menus for participants in ParticipantList are clicked
            onRemoveParticipant: props.mobileView ? undefined : onRemoveAParticipant, 
            // We want the drawer menu items to appear when participants in ParticipantList are clicked
            onParticipantClick: props.mobileView ? setDrawerMenuItemsForParticipant : undefined });
    }, [participantListDefaultProps, props.mobileView, setDrawerMenuItemsForParticipant, removeParticipantFromCall]);
    const participantList = React__default['default'].createElement(ParticipantListWithHeading, { isMobile: props.mobileView, participantListProps: participantListProps, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.mobileView ? undefined : props.onFetchParticipantMenuItems, title: strings.peoplePaneSubTitle });
    if (props.mobileView) {
        return React__default['default'].createElement(react.Stack, { verticalFill: true, styles: peoplePaneContainerStyle, tokens: peoplePaneContainerTokens, "data-ui-id": "people-pane-content" },
            React__default['default'].createElement(react.Stack.Item, { grow: true, styles: participantListContainerStyles }, participantList),
            React__default['default'].createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings }));
    }
    return React__default['default'].createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings });
};
/**
 * Create default contextual menu items for particant
 * @param participant - participant to create contextual menu items for
 * @param strings - localized strings for menu item text
 * @param onRemoveParticipant - callback to remove participant
 * @param localParticipantUserId - Local participant user id
 * @returns - IContextualMenuItem[]
 */
const createDefaultContextualMenuItems = (participant, strings, onRemoveParticipant, localParticipantUserId) => {
    const menuItems = [];
    if (onRemoveParticipant && (participant === null || participant === void 0 ? void 0 : participant.userId) !== localParticipantUserId) {
        menuItems.push({
            key: 'remove',
            text: strings.removeMenuLabel,
            onClick: () => {
                if (participant === null || participant === void 0 ? void 0 : participant.userId) {
                    onRemoveParticipant === null || onRemoveParticipant === void 0 ? void 0 : onRemoveParticipant(participant === null || participant === void 0 ? void 0 : participant.userId);
                }
            },
            iconProps: {
                iconName: 'UserRemove'
            }
        });
    }
    return menuItems;
};
/**
 * @private
 */
const hasRemoveParticipantsPermissionTrampoline = () => {
    // Return true if stable.
    return true;
};

// Copyright (c) Microsoft Corporation.
const PEOPLE_SIDE_PANE_ID = 'people';
/** @private */
const usePeoplePane = (props) => {
    const { updateSidePaneRenderer, inviteLink, onFetchAvatarPersonaData, onFetchParticipantMenuItems, setDrawerMenuItems, mobileView } = props;
    const closePane = React.useCallback(() => {
        updateSidePaneRenderer(undefined);
    }, [updateSidePaneRenderer]);
    const localeStrings = localeTrampoline(useLocale());
    const onRenderHeader = React.useCallback(() => React__default['default'].createElement(SidePaneHeader, { onClose: closePane, headingText: localeStrings.peoplePaneTitle, dismissSidePaneButtonAriaLabel: localeStrings.dismissSidePaneButtonLabel, mobileView: mobileView !== null && mobileView !== void 0 ? mobileView : false }), [mobileView, closePane, localeStrings]);
    const onRenderContent = React.useCallback(() => {
        return React__default['default'].createElement(PeoplePaneContent, { inviteLink: inviteLink, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, setDrawerMenuItems: setDrawerMenuItems, mobileView: mobileView });
    }, [inviteLink, mobileView, onFetchAvatarPersonaData, onFetchParticipantMenuItems, setDrawerMenuItems]);
    const sidePaneRenderer = React.useMemo(() => ({
        headerRenderer: onRenderHeader,
        contentRenderer: onRenderContent,
        id: PEOPLE_SIDE_PANE_ID
    }), [onRenderContent, onRenderHeader]);
    const openPane = React.useCallback(() => {
        updateSidePaneRenderer(sidePaneRenderer);
    }, [sidePaneRenderer, updateSidePaneRenderer]);
    const isOpen = useIsParticularSidePaneOpen(PEOPLE_SIDE_PANE_ID);
    // Update pane renderer if it is open and the openPane dep changes
    React.useEffect(() => {
        if (isOpen) {
            openPane();
        }
    }, [isOpen, openPane]);
    return {
        openPeoplePane: openPane,
        closePeoplePane: closePane,
        isPeoplePaneOpen: isOpen
    };
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const localeTrampoline = (locale) => {
    return locale.strings.callWithChat;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LocalAndRemotePIP = (props) => {
    var _a, _b;
    const { localParticipant, dominantRemoteParticipant, onCreateLocalStreamView, onDisposeLocalStreamView, onCreateRemoteStreamView, onDisposeRemoteStreamView } = props;
    const localVideoTileProps = React.useMemo(() => {
        var _a, _b;
        return ({
            onCreateLocalStreamView,
            onDisposeLocalStreamView,
            localVideoViewOptions: localVideoViewOptions$3,
            displayName: localParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            showCameraSwitcherInLocalPreview: false,
            isAvailable: (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            renderElement: (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement
        });
    }, [localParticipant.displayName, (_a = localParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable, (_b = localParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.renderElement, onCreateLocalStreamView, onDisposeLocalStreamView]);
    const remoteVideoTileProps = React.useMemo(() => {
        var _a, _b, _c;
        return !dominantRemoteParticipant ? undefined : {
            remoteParticipant: dominantRemoteParticipant,
            onCreateRemoteStreamView,
            onDisposeRemoteStreamView,
            remoteVideoViewOptions: remoteVideoViewOptions$1,
            displayName: dominantRemoteParticipant === null || dominantRemoteParticipant === void 0 ? void 0 : dominantRemoteParticipant.displayName,
            showLabel: false,
            showMuteIndicator: false,
            isAvailable: (_a = dominantRemoteParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable,
            isReceiving: (_b = dominantRemoteParticipant.videoStream) === null || _b === void 0 ? void 0 : _b.isReceiving,
            renderElement: (_c = dominantRemoteParticipant.videoStream) === null || _c === void 0 ? void 0 : _c.renderElement,
            userId: dominantRemoteParticipant.userId,
            key: dominantRemoteParticipant.userId
        };
    }, [dominantRemoteParticipant, onCreateRemoteStreamView, onDisposeRemoteStreamView]);
    const locale = useLocale();
    const ariaLabel = locale.strings.callWithChat.pictureInPictureTileAriaLabel;
    const strings = React.useMemo(() => ({
        rootAriaLabel: ariaLabel
    }), [ariaLabel]);
    // If there are no remote participants, show the local participant as the primary tile
    const primaryTileProps = React.useMemo(() => ({
        children: remoteVideoTileProps ? React__default['default'].createElement(_RemoteVideoTile, Object.assign({}, remoteVideoTileProps)) : React__default['default'].createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps)),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    }), [localVideoTileProps, remoteVideoTileProps]);
    // If we are showing the local participant as the primary tile, show nothing for the secondary tile
    const secondaryTileProps = React.useMemo(() => remoteVideoTileProps ? {
        children: React__default['default'].createElement(_LocalVideoTile, Object.assign({}, localVideoTileProps, { personaMinSize: 20 })),
        // TODO: when the calling SDK provides height/width stream information - update this to reflect the stream orientation.
        orientation: 'portrait'
    } : undefined, [localVideoTileProps, remoteVideoTileProps]);
    return React__default['default'].createElement(_PictureInPictureInPicture, { onClick: props.onClick, strings: strings, primaryTile: primaryTileProps, secondaryTile: secondaryTileProps });
};
const localVideoViewOptions$3 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: false
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const localVideoSelector = reselect__namespace.createSelector([callStatusSelector, getDeviceManager, getLocalVideoStreams], (callStatus, deviceManager, localVideoStreams) => {
    var _a, _b;
    let localVideoStream;
    if (_isInCall(callStatus.callStatus)) {
        localVideoStream = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(i => i.mediaStreamType === 'Video');
    }
    else if (_isPreviewOn(deviceManager)) {
        // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
        // handle cases where 'Preview' view is in progress and not necessary completed.
        localVideoStream = deviceManager.unparentedViews[0];
    }
    return {
        isAvailable: !!localVideoStream,
        isMirrored: (_a = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _a === void 0 ? void 0 : _a.isMirrored,
        renderElement: (_b = localVideoStream === null || localVideoStream === void 0 ? void 0 : localVideoStream.view) === null || _b === void 0 ? void 0 : _b.target
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Get the most dominant remote participant, if no dominant speaker IDs exist, this uses
 * one of the remote participants with no bias towards which one.
 *
 * @private
 */
const dominantRemoteParticipantSelector = reselect__namespace.createSelector([getRemoteParticipants, getDominantSpeakerInfo], (remoteParticipants, dominantSpeakerInfo) => {
    const dominantSpeakers = _dominantSpeakersWithFlatId(dominantSpeakerInfo);
    const dominantRemoteParticipant = remoteParticipants && Object.keys(remoteParticipants).length > 0 ? findDominantRemoteParticipant(remoteParticipants, dominantSpeakers !== null && dominantSpeakers !== void 0 ? dominantSpeakers : []) : undefined;
    return dominantRemoteParticipant ? _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline(Object.values(dominantRemoteParticipant)))[0] : undefined;
});
const findDominantRemoteParticipant = (remoteParticipants, dominantSpeakerIds) => {
    let dominantRemoteParticipantId = dominantSpeakerIds[0];
    // Fallback to using the first remote participant if there are no dominant speaker IDs
    // or if the dominant speaker is no longer available in the list of remoteParticipantIds
    const remoteParticipantIds = Object.keys(remoteParticipants);
    if (!dominantRemoteParticipantId || !remoteParticipantIds.includes(dominantRemoteParticipantId)) {
        dominantRemoteParticipantId = remoteParticipantIds[0];
    }
    return {
        dominantRemoteParticipantId: remoteParticipants[dominantRemoteParticipantId]
    };
};
const updateUserDisplayNamesTrampoline = (remoteParticipants) => {
    return remoteParticipants;
};

// Copyright (c) Microsoft Corporation.
/**
 * Picture in picture in picture needs to display the most-dominant remote speaker, as well as the local participant video.
 * @private
 */
const localAndRemotePIPSelector = reselect__namespace.createSelector([getDisplayName, dominantRemoteParticipantSelector, localVideoSelector], (displayName, dominantRemoteParticipant, localVideoStreamInfo) => {
    return {
        localParticipant: {
            displayName,
            videoStream: localVideoStreamInfo
        },
        dominantRemoteParticipant
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * Default Modal PIP related pixel measurements used for ModalLocalAndremotePIP and common/utils.
 *
 * @private
 */
const MODAL_PIP_DEFAULT_PX = {
    rightPositionPx: 16,
    topPositionPx: 52,
    widthPx: 88,
    heightPx: 128
};
/**
 * @private
 */
const getPipStyles = (theme) => ({
    modal: {
        main: Object.assign(Object.assign({ borderRadius: theme.effects.roundedCorner4, boxShadow: theme.effects.elevation8, 
            // Above the message thread / people pane.
            zIndex: 2 }, (theme.rtl ? {
            left: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        } : {
            right: _pxToRem(MODAL_PIP_DEFAULT_PX.rightPositionPx)
        })), { top: _pxToRem(MODAL_PIP_DEFAULT_PX.topPositionPx) })
    }
});
/**
 * @private
 */
const PIPContainerStyle = {
    root: {
        position: 'absolute',
        width: '100%',
        height: '100%',
        pointerEvents: 'none'
    }
};
/**
 * @private
 */
const hiddenStyle = react.concatStyleSets(PIPContainerStyle, {
    root: {
        display: 'none'
    }
});
/**
 * @private
 */
const modalStyle = {
    main: {
        minWidth: 'min-content',
        minHeight: 'min-content',
        position: 'absolute',
        overflow: 'hidden',
        // pointer events for root Modal div set to auto to make LocalAndRemotePIP interactive
        pointerEvents: 'auto',
        touchAction: 'none'
    },
    root: {
        width: '100%',
        height: '100%',
        // pointer events for root Modal div set to none to make descendants interactive
        pointerEvents: 'none'
    }
};
/**
 * Styles for layer host to bound the modal wrapping PiPiP in the mobile pane.
 * @private
 */
const modalLayerHostStyle = {
    display: 'flex',
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    zIndex: '100000',
    // pointer events for layerHost set to none to make descendants interactive
    pointerEvents: 'none'
};

// Copyright (c) Microsoft Corporation.
/**
 * Drag options for Modal in {@link ModalLocalAndRemotePIP} component
 */
const DRAG_OPTIONS = {
    moveMenuItemText: 'Move',
    closeMenuItemText: 'Close',
    menu: react.ContextualMenu,
    keepInBounds: true
};
/**
 * A wrapping component with a draggable {@link LocalAndRemotePIP} component that is bound to a LayerHost component with id
 * specified by `modalLayerHostId` prop
 * @private
 */
const ModalLocalAndRemotePIP = (props) => {
    var _a;
    const rootStyles = props.hidden ? hiddenStyle : PIPContainerStyle;
    const pictureInPictureProps = useSelector$1(localAndRemotePIPSelector);
    const pictureInPictureHandlers = useHandlers();
    const localAndRemotePIP = React.useMemo(() => {
        return React__default['default'].createElement(LocalAndRemotePIP, Object.assign({}, pictureInPictureProps, pictureInPictureHandlers));
    }, [pictureInPictureProps, pictureInPictureHandlers]);
    const modalStylesThemed = react.concatStyleSets(modalStyle, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.modal);
    return React__default['default'].createElement(react.Stack, { styles: rootStyles },
        React__default['default'].createElement(_ModalClone, { isOpen: true, isModeless: true, dragOptions: DRAG_OPTIONS, styles: modalStylesThemed, layerProps: {
                hostId: props.modalLayerHostId
            }, minDragPosition: props.minDragPosition, maxDragPosition: props.maxDragPosition }, 
        // Only render LocalAndRemotePIP when this component is NOT hidden because VideoGallery needs to have
        // possession of the dominant remote participant video stream
        !props.hidden && localAndRemotePIP));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
// Use document.getElementById until Fluent's Stack supports componentRef property: https://github.com/microsoft/fluentui/issues/20410
const useMinMaxDragPosition = (modalLayerHostId, rtl) => {
    const modalHostRef = React.useRef(document.getElementById(modalLayerHostId));
    const modalHostWidth = _useContainerWidth(modalHostRef);
    const modalHostHeight = _useContainerHeight(modalHostRef);
    const minDragPosition = React.useMemo(() => modalHostWidth === undefined ? undefined : {
        x: rtl ? -1 * MODAL_PIP_DEFAULT_PX.rightPositionPx : MODAL_PIP_DEFAULT_PX.rightPositionPx - modalHostWidth + MODAL_PIP_DEFAULT_PX.widthPx,
        y: -1 * MODAL_PIP_DEFAULT_PX.topPositionPx
    }, [modalHostWidth, rtl]);
    const maxDragPosition = React.useMemo(() => modalHostWidth === undefined || modalHostHeight === undefined ? undefined : {
        x: rtl ? modalHostWidth - MODAL_PIP_DEFAULT_PX.rightPositionPx - MODAL_PIP_DEFAULT_PX.widthPx : MODAL_PIP_DEFAULT_PX.rightPositionPx,
        y: modalHostHeight - MODAL_PIP_DEFAULT_PX.topPositionPx - MODAL_PIP_DEFAULT_PX.heightPx
    }, [modalHostHeight, modalHostWidth, rtl]);
    return {
        minDragPosition: minDragPosition,
        maxDragPosition: maxDragPosition
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallArrangement = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const containerClassName = React.useMemo(() => {
        return props.mobileView ? containerStyleMobile : containerStyleDesktop;
    }, [props.mobileView]);
    const theme = useTheme();
    const callGalleryStyles = React.useMemo(() => galleryParentContainerStyles(theme.palette.neutralLighterAlt), [theme.palette.neutralLighterAlt]);
    const containerRef = React.useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    const isInLobby = _isInLobbyOrConnecting(useSelector$1(callStatusSelector).callStatus);
    const { updateSidePaneRenderer } = props;
    const adapter = useAdapter();
    const [drawerMenuItems, setDrawerMenuItems] = React.useState([]);
    const peoplePaneProps = React.useMemo(() => {
        var _a;
        return ({
            updateSidePaneRenderer,
            setDrawerMenuItems,
            inviteLink: props.callControlProps.callInvitationURL,
            onFetchParticipantMenuItems: (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems,
            mobileView: props.mobileView
        });
    }, [updateSidePaneRenderer, props.callControlProps.callInvitationURL, (_a = props.callControlProps) === null || _a === void 0 ? void 0 : _a.onFetchParticipantMenuItems, props.mobileView]);
    const { isPeoplePaneOpen, openPeoplePane, closePeoplePane } = usePeoplePane(peoplePaneProps);
    const togglePeoplePane = React.useCallback(() => {
        if (isPeoplePaneOpen) {
            closePeoplePane();
        }
        else {
            openPeoplePane();
        }
    }, [closePeoplePane, isPeoplePaneOpen, openPeoplePane]);
    const isSidePaneOpen = useIsSidePaneOpen();
    const isMobileWithActivePane = props.mobileView && isSidePaneOpen;
    const callCompositeContainerCSS = React.useMemo(() => {
        return {
            display: isMobileWithActivePane ? 'none' : 'flex',
            minWidth: props.mobileView ? 'unset' : `${compositeMinWidthRem}rem`,
            width: '100%',
            height: '100%',
            position: 'relative'
        };
    }, [isMobileWithActivePane, props.mobileView]);
    const [showDrawer, setShowDrawer] = React.useState(false);
    const onMoreButtonClicked = React.useCallback(() => {
        setShowDrawer(true);
    }, []);
    const closeDrawer = React.useCallback(() => {
        setShowDrawer(false);
    }, []);
    const onMoreDrawerPeopleClicked = React.useCallback(() => {
        setShowDrawer(false);
        togglePeoplePane();
    }, [togglePeoplePane]);
    const drawerContainerStylesValue = React.useMemo(() => drawerContainerStyles(DRAWER_Z_INDEX), []);
    let errorBarProps = props.errorBarProps;
    const minMaxDragPosition = useMinMaxDragPosition(props.modalLayerHostId);
    const pipStyles = React.useMemo(() => getPipStyles(theme), [theme]);
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles), id: props.id },
        React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "stretch", className: containerClassName, "data-ui-id": props.dataUiId },
            React__default['default'].createElement(react.Stack, { grow: true, styles: callArrangementContainerStyles },
                ((_b = props.callControlProps) === null || _b === void 0 ? void 0 : _b.options) !== false && !isMobileWithActivePane && React__default['default'].createElement(react.Stack.Item, { className: react.mergeStyles({
                        zIndex: CONTROL_BAR_Z_INDEX
                    }) }, isLegacyCallControlEnabled((_c = props.callControlProps) === null || _c === void 0 ? void 0 : _c.options) ? React__default['default'].createElement(CallControls, Object.assign({}, props.callControlProps, { containerWidth: containerWidth, containerHeight: containerHeight, isMobile: props.mobileView })) : React__default['default'].createElement(CommonCallControlBar, Object.assign({}, props.callControlProps, { callControls: props.callControlProps.options, callAdapter: adapter, mobileView: props.mobileView, disableButtonsForLobbyPage: isInLobby, peopleButtonChecked: isPeoplePaneOpen, onPeopleButtonClicked: togglePeoplePane, onMoreButtonClicked: onMoreButtonClicked }))),
                ((_d = props.callControlProps) === null || _d === void 0 ? void 0 : _d.options) !== false && showDrawer && React__default['default'].createElement(react.Stack, { styles: drawerContainerStylesValue },
                    React__default['default'].createElement(PreparedMoreDrawer, { callControls: props.callControlProps.options, onLightDismiss: closeDrawer, onPeopleButtonClicked: onMoreDrawerPeopleClicked })),
                React__default['default'].createElement(react.Stack, { horizontal: true, grow: true },
                    React__default['default'].createElement(react.Stack.Item, { style: callCompositeContainerCSS },
                        React__default['default'].createElement(react.Stack.Item, { styles: callGalleryStyles, grow: true },
                            React__default['default'].createElement(react.Stack, { verticalFill: true, styles: mediaGalleryContainerStyles$1 },
                                React__default['default'].createElement(react.Stack.Item, { styles: notificationsContainerStyles },
                                    React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
                                        React__default['default'].createElement(_ComplianceBanner, Object.assign({}, props.complianceBannerProps))),
                                    errorBarProps !== false && React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
                                        React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps))),
                                    !!props.mutedNotificationProps && React__default['default'].createElement(MutedNotification, Object.assign({}, props.mutedNotificationProps))),
                                props.onRenderGalleryContent && props.onRenderGalleryContent()))),
                    React__default['default'].createElement(SidePane, { mobileView: props.mobileView, updateSidePaneRenderer: props.updateSidePaneRenderer, onPeopleButtonClicked: props.mobileView && !shouldShowPeopleTabHeaderButton(props.callControlProps.options) ? undefined : togglePeoplePane, disablePeopleButton: typeof props.callControlProps.options !== 'boolean' && isDisabled$2((_e = props.callControlProps.options) === null || _e === void 0 ? void 0 : _e.participantsButton), onChatButtonClicked: (_f = props.mobileChatTabHeader) === null || _f === void 0 ? void 0 : _f.onClick, disableChatButton: (_g = props.mobileChatTabHeader) === null || _g === void 0 ? void 0 : _g.disabled }),
                    props.mobileView && React__default['default'].createElement(ModalLocalAndRemotePIP, { modalLayerHostId: props.modalLayerHostId, hidden: !isSidePaneOpen, styles: pipStyles, minDragPosition: minMaxDragPosition.minDragPosition, maxDragPosition: minMaxDragPosition.maxDragPosition }),
                    drawerMenuItems.length > 0 && React__default['default'].createElement(react.Stack, { styles: drawerContainerStyles() },
                        React__default['default'].createElement(_DrawerMenu, { onLightDismiss: () => setDrawerMenuItems([]), items: drawerMenuItems }))))));
};
const isLegacyCallControlEnabled = (options) => {
    var _a;
    // In stable builds, we default to legacy until new-call-control-bar feature is stablized.
    return options === undefined || options === true || ((_a = options) === null || _a === void 0 ? void 0 : _a.legacyControlBarExperience) !== false;
};
const shouldShowPeopleTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.participantsButton !== false && callControls.peopleButton !== false;
};

// Copyright (c) Microsoft Corporation.
/**
 * Provides data attributes to {@link LocalVideoCameraCycleButton} component.
 * @public
 */
const localVideoCameraCycleButtonSelector = reselect.createSelector([getDeviceManager], deviceManager => {
    return {
        cameras: deviceManager.cameras,
        selectedCamera: deviceManager.selectedCamera
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mediaGallerySelector = reselect__namespace.createSelector([getLocalVideoStreams], localVideoStreams => {
    var _a, _b;
    return {
        isVideoStreamOn: !!((_b = (_a = localVideoStreams === null || localVideoStreams === void 0 ? void 0 : localVideoStreams.find(stream => stream.mediaStreamType === 'Video')) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.target)
    };
});
/**
 * Custom selector for this hook to retrieve all the participants that are currently
 * connected to the call.
 */
const getRemoteParticipantsConnectedSelector = reselect__namespace.createSelector([getRemoteParticipants], remoteParticipants => {
    const participants = Object.values(remoteParticipants !== null && remoteParticipants !== void 0 ? remoteParticipants : {});
    return participants.filter(p => p.state === 'Connected');
});

// Copyright (c) Microsoft Corporation.
/**
 * sets the announcement string whenever a Participant comes or goes from a call to be
 * used by the system narrator.
 *
 * @returns string to be used by the narrator and Announcer component
 *
 * @internal
 */
const useParticipantChangedAnnouncement = () => {
    const locale = useLocale().strings.call;
    const strings = React.useMemo(() => {
        return {
            participantJoinedNoticeString: locale.participantJoinedNoticeString,
            twoParticipantJoinedNoticeString: locale.twoParticipantJoinedNoticeString,
            threeParticipantJoinedNoticeString: locale.threeParticipantJoinedNoticeString,
            participantLeftNoticeString: locale.participantLeftNoticeString,
            twoParticipantLeftNoticeString: locale.twoParticipantLeftNoticeString,
            threeParticipantLeftNoticeString: locale.threeParticipantLeftNoticeString,
            unnamedParticipantString: locale.unnamedParticipantString,
            manyParticipantsJoined: locale.manyParticipantsJoined,
            manyParticipantsLeft: locale.manyParticipantsLeft,
            manyUnnamedParticipantsJoined: locale.manyUnnamedParticipantsJoined,
            manyUnnamedParticipantsLeft: locale.manyUnnamedParticipantsLeft
        };
    }, [locale]);
    const [announcerString, setAnnouncerString] = React.useState('');
    const currentParticipants = useSelector$1(getRemoteParticipantsConnectedSelector);
    /**
     * We want to use a useRef here since we want to not fire this hook based on the previous participants
     * this allows this value to be used in the hook without being in the dependency array.
     *
     * Note: By definition if this hook is used in another component it is not pure anymore.
     */
    const previousParticipants = React.useRef(currentParticipants);
    const resetAnnoucement = (string) => {
        setAnnouncerString(string);
    };
    React.useMemo(() => {
        const currentIds = currentParticipants.map(p => toFlatCommunicationIdentifier(p.identifier));
        const previousIds = previousParticipants.current.map(p => toFlatCommunicationIdentifier(p.identifier));
        const whoJoined = currentParticipants.filter(p => !previousIds.includes(toFlatCommunicationIdentifier(p.identifier)));
        const whoLeft = previousParticipants.current.filter(p => !currentIds.includes(toFlatCommunicationIdentifier(p.identifier)));
        if (whoJoined.length > 0) {
            resetAnnoucement(createAnnouncementString('joined', whoJoined, strings));
        }
        if (whoLeft.length > 0) {
            resetAnnoucement(createAnnouncementString('left', whoLeft, strings));
        }
        // Update cached value at the end.
        previousParticipants.current = currentParticipants;
    }, [currentParticipants, strings]);
    return announcerString;
};
/**
 * Generates the announcement string for when a participant joins or leaves a call.
 */
const createAnnouncementString = (direction, participants, strings) => {
    var _a, _b, _c;
    /**
     * If there are no participants return empty string.
     */
    if (participants.length === 0) {
        return '';
    }
    /**
     * Filter participants into two arrays to put all the unnamed participants at the back of the
     * names being announced.
     */
    const unnamedParticipants = participants.filter(p => !p.displayName);
    const namedParicipants = participants.filter(p => p.displayName);
    const sortedParticipants = namedParicipants.concat(unnamedParticipants);
    /**
     * if there are only unnamed participants present in the array announce a special unnamed participants
     * only string.
     */
    if (sortedParticipants.filter(p => p.displayName).length === 0 && sortedParticipants.length > 1) {
        return _formatString(direction === 'joined' ? strings.manyUnnamedParticipantsJoined : strings.manyUnnamedParticipantsLeft, {
            numOfParticipants: (sortedParticipants.length - 1).toString()
        });
    }
    const participantNames = sortedParticipants.map(p => { var _a; return (_a = p.displayName) !== null && _a !== void 0 ? _a : strings.unnamedParticipantString; });
    switch (sortedParticipants.length) {
        case 1:
            return _formatString(direction === 'joined' ? strings.participantJoinedNoticeString : strings.participantLeftNoticeString, {
                displayName: participantNames[0]
            });
        case 2:
            return _formatString(direction === 'joined' ? strings.twoParticipantJoinedNoticeString : strings.twoParticipantLeftNoticeString, {
                displayName1: participantNames[0],
                displayName2: participantNames[1]
            });
        case 3:
            return _formatString(direction === 'joined' ? strings.threeParticipantJoinedNoticeString : strings.threeParticipantLeftNoticeString, {
                displayName1: participantNames[0],
                displayName2: participantNames[1],
                displayName3: participantNames[2]
            });
    }
    /**
     * If we have more than 3 participants joining we need to do something more to announce them
     * appropriately.
     *
     * We don't want to announce every name when more than 3 participants join at once so
     * we parse out the first 3 names we have and announce those with the number of others.
     */
    const numberOfExtraParticipants = sortedParticipants.length - 3;
    return _formatString(direction === 'joined' ? strings.manyParticipantsJoined : strings.manyParticipantsLeft, {
        displayName1: (_a = sortedParticipants[0].displayName) !== null && _a !== void 0 ? _a : strings.unnamedParticipantString,
        displayName2: (_b = sortedParticipants[1].displayName) !== null && _b !== void 0 ? _b : strings.unnamedParticipantString,
        displayName3: (_c = sortedParticipants[2].displayName) !== null && _c !== void 0 ? _c : strings.unnamedParticipantString,
        numOfParticipants: numberOfExtraParticipants.toString()
    });
};

// Copyright (c) Microsoft Corporation.
const VideoGalleryStyles = {
    root: {
        height: '100%',
        minHeight: '10rem',
        // space affordance to ensure media gallery is never collapsed
        minWidth: '6rem'
    }
};
const localVideoViewOptions$2 = {
    scalingMode: 'Crop',
    isMirrored: true
};
const remoteVideoViewOptions = {
    scalingMode: 'Crop'
};
/**
 * @private
 */
const MediaGallery = (props) => {
    const videoGalleryProps = usePropsFor$1(VideoGallery);
    const cameraSwitcherCameras = useSelector$1(localVideoCameraCycleButtonSelector);
    const cameraSwitcherCallback = useHandlers();
    const announcerString = useParticipantChangedAnnouncement();
    const layoutBasedOnTilePosition = localVideoTileLayoutTrampoline();
    const cameraSwitcherProps = React.useMemo(() => {
        return Object.assign(Object.assign({}, cameraSwitcherCallback), cameraSwitcherCameras);
    }, [cameraSwitcherCallback, cameraSwitcherCameras]);
    const onRenderAvatar = React.useCallback((userId, options) => {
        return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
                position: 'absolute',
                height: '100%',
                width: '100%'
            }) },
            React__default['default'].createElement(react.Stack, { styles: {
                    root: {
                        margin: 'auto',
                        maxHeight: '100%'
                    }
                } }, (options === null || options === void 0 ? void 0 : options.coinSize) && React__default['default'].createElement(AvatarPersona, Object.assign({ userId: userId }, options, { dataProvider: props.onFetchAvatarPersonaData }))));
    }, [props.onFetchAvatarPersonaData]);
    useLocalVideoStartTrigger(!!props.isVideoStreamOn);
    const VideoGalleryMemoized = React.useMemo(() => {
        var _a;
        return React__default['default'].createElement(VideoGallery, Object.assign({}, videoGalleryProps, { localVideoViewOptions: localVideoViewOptions$2, remoteVideoViewOptions: remoteVideoViewOptions, styles: VideoGalleryStyles, layout: layoutBasedOnTilePosition, showCameraSwitcherInLocalPreview: props.isMobile, localVideoCameraCycleButtonProps: cameraSwitcherProps, onRenderAvatar: (_a = props.onRenderAvatar) !== null && _a !== void 0 ? _a : onRenderAvatar }));
    }, [videoGalleryProps, props.isMobile, props.onRenderAvatar, onRenderAvatar, cameraSwitcherProps, layoutBasedOnTilePosition]);
    return React__default['default'].createElement("div", { style: mediaGalleryContainerStyles },
        React__default['default'].createElement(Announcer$1, { announcementString: announcerString, ariaLive: 'polite' }),
        VideoGalleryMemoized);
};
/**
 * @private
 *
 * `shouldTransition` is an extra predicate that controls whether this hooks actually transitions the call.
 * The rule of hooks disallows calling the hook conditionally, so this predicate can be used to make the decision.
 */
const useLocalVideoStartTrigger = (isLocalVideoAvailable, shouldTransition) => {
    // Once a call is joined, we need to transition the local preview camera setting into the call.
    // This logic is needed on any screen that we might join a call from:
    // - The Media gallery
    // - The lobby page
    // - The networkReconnect interstitial that may show at the start of a call.
    //
    // @TODO: Can we simply have the callHandlers handle this transition logic.
    const [isButtonStatusSynced, setIsButtonStatusSynced] = React.useState(false);
    const isPreviewCameraOn = useSelector$1(getIsPreviewCameraOn);
    const mediaGalleryHandlers = useHandlers();
    React.useEffect(() => {
        if (shouldTransition !== false) {
            if (isPreviewCameraOn && !isLocalVideoAvailable && !isButtonStatusSynced) {
                mediaGalleryHandlers.onStartLocalVideo();
            }
            setIsButtonStatusSynced(true);
        }
    }, [shouldTransition, isButtonStatusSynced, isPreviewCameraOn, isLocalVideoAvailable, mediaGalleryHandlers]);
};
const mediaGalleryContainerStyles = {
    width: '100%',
    height: '100%'
};
const localVideoTileLayoutTrampoline = (localTileOptions) => {
    return 'floatingLocalVideo';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// By default, absolute positioned elements are overlayed over static ones.
// So we need to explicitly layer the background and contents.
const OVERLAY_BACKGROUND_ZINDEX = 0;
const OVERLAY_CONTENT_ZINDEX = OVERLAY_BACKGROUND_ZINDEX + 1;
/**
 * @private
 */
const containerStyles = {
    root: {
        height: '100%',
        width: '100%',
        position: 'relative'
    }
};
/**
 * @private
 */
const overlayBackgroundStyles = (palette, isVideoReady) => {
    return {
        position: 'absolute',
        height: '100%',
        width: '100%',
        background: isVideoReady ? 'black' : palette.neutralLighterAlt,
        opacity: isVideoReady ? 0.6 : 1,
        zIndex: OVERLAY_BACKGROUND_ZINDEX
    };
};
/**
 * @private
 */
const overlayContentStyles = {
    height: '100%',
    width: '100%',
    zIndex: OVERLAY_CONTENT_ZINDEX
};
/**
 * @private
 */
const videoTileStyles = {
    root: {
        height: '100%',
        width: '100%'
    }
};

// Copyright (c) Microsoft Corporation.
const onRenderEmptyPlaceholder = () => React__default['default'].createElement(React__default['default'].Fragment, null);
const localVideoViewOptions$1 = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const ExpandedLocalVideoTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const renderElement = videoStream === null || videoStream === void 0 ? void 0 : videoStream.renderElement;
    const palette = useTheme().palette;
    React.useEffect(() => {
        if (videoStream && isVideoReady) {
            props.onCreateLocalStreamView && props.onCreateLocalStreamView(localVideoViewOptions$1).catch(err => console.log('Can not render video', err));
        }
    }, [isVideoReady, videoStream, props, renderElement]);
    return React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", styles: containerStyles, grow: true },
        React__default['default'].createElement(VideoTile, { styles: videoTileStyles, renderElement: renderElement ? React__default['default'].createElement(StreamMedia, { videoStreamElement: renderElement }) : undefined, onRenderPlaceholder: onRenderEmptyPlaceholder }, props.overlayContent && React__default['default'].createElement(React__default['default'].Fragment, null,
            React__default['default'].createElement(react.Stack, { className: react.mergeStyles(overlayBackgroundStyles(palette, isVideoReady)) }),
            React__default['default'].createElement(react.Stack, { horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContentStyles) }, props.overlayContent))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const containerStyle$1 = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem',
    gap: `1.5rem`
};
/**
 * @private
 */
const titleContainerStyle = {
    gap: `1rem`
};
/**
 * @private
 */
const titleStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1.25rem',
    fontWeight: react.FontWeights.semibold,
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});
/**
 * @private
 */
const moreDetailsStyle$1 = (palette, isVideoReady) => ({
    fontSize: '1rem',
    color: isVideoReady ? 'white' : palette.neutralPrimary,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const NetworkReconnectTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const strings = useLocale().strings.call;
    const handlers = useHandlers();
    // This tile may be shown at the beginning of a call.
    // So we need to transition local video to the call.
    useLocalVideoStartTrigger(!!props.localParticipantVideoStream.isAvailable);
    return React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(containerStyle$1), "aria-atomic": true },
            React__default['default'].createElement(react.Stack, { horizontal: true, className: react.mergeStyles(titleContainerStyle) },
                React__default['default'].createElement(CallCompositeIcon, { iconName: "NetworkReconnectIcon", className: react.mergeStyles(titleStyle$1(palette, isVideoReady)) }),
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectTitle)),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle$1(palette, isVideoReady)), "aria-live": 'assertive' }, strings.networkReconnectMoreDetails)) }, handlers));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const complianceBannerSelector = reselect__namespace.createSelector([getIsTranscriptionActive, getIsRecordingActive], (isTranscriptionActive, isRecordingActive) => {
    return {
        callTranscribeState: isTranscriptionActive,
        callRecordState: isRecordingActive
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mutedNotificationSelector = reselect__namespace.createSelector([getUserFacingDiagnostics], diagnostics => {
    var _a;
    return {
        speakingWhileMuted: !!((_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.media.latest.speakingWhileMicrophoneIsMuted) === null || _a === void 0 ? void 0 : _a.value)
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const lobbySelector = reselect__namespace.createSelector([localVideoSelector], localVideoStreamInfo => {
    return {
        localParticipantVideoStream: localVideoStreamInfo
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const networkReconnectTileSelector = reselect__namespace.createSelector([getUserFacingDiagnostics, lobbySelector], (diagnostics, lobbyProps) => {
    var _a;
    return {
        networkReconnectValue: (_a = diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.network.latest.networkReconnect) === null || _a === void 0 ? void 0 : _a.value,
        localParticipantVideoStream: lobbyProps.localParticipantVideoStream
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const CallPage = (props) => {
    const { callInvitationURL, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, mobileView } = props;
    // To use useProps to get these states, we need to create another file wrapping Call,
    // It seems unnecessary in this case, so we get the updated states using this approach.
    const { callStatus } = useSelector$1(callStatusSelector);
    const mediaGalleryProps = useSelector$1(mediaGallerySelector);
    const mediaGalleryHandlers = useHandlers();
    const complianceBannerProps = useSelector$1(complianceBannerSelector);
    const errorBarProps = usePropsFor$1(ErrorBar);
    const mutedNotificationProps = useSelector$1(mutedNotificationSelector);
    const networkReconnectTileProps = useSelector$1(networkReconnectTileSelector);
    const strings = useLocale().strings.call;
    // Reduce the controls shown when mobile view is enabled.
    const callControlOptions = mobileView ? reduceCallControlsForMobile(options === null || options === void 0 ? void 0 : options.callControls) : options === null || options === void 0 ? void 0 : options.callControls;
    const drawerMenuHostId = reactHooks.useId('drawerMenuHost');
    return React__default['default'].createElement(CallArrangement, { id: drawerMenuHostId, complianceBannerProps: Object.assign(Object.assign({}, complianceBannerProps), { strings }), 
        // Ignore errors from before current call. This avoids old errors from showing up when a user re-joins a call.
        errorBarProps: (options === null || options === void 0 ? void 0 : options.errorBar) !== false && Object.assign(Object.assign({}, errorBarProps), { ignorePremountErrors: true }), mutedNotificationProps: mutedNotificationProps, callControlProps: {
            callInvitationURL: callInvitationURL,
            onFetchParticipantMenuItems: onFetchParticipantMenuItems,
            options: callControlOptions,
            increaseFlyoutItemSize: mobileView
        }, mobileView: mobileView, modalLayerHostId: props.modalLayerHostId, onRenderGalleryContent: () => _isInCall(callStatus) ? isNetworkHealthy(networkReconnectTileProps.networkReconnectValue) ? React__default['default'].createElement(MediaGallery, Object.assign({ isMobile: mobileView }, mediaGalleryProps, mediaGalleryHandlers, { onRenderAvatar: onRenderAvatar, onFetchAvatarPersonaData: onFetchAvatarPersonaData, drawerMenuHostId: drawerMenuHostId })) : React__default['default'].createElement(NetworkReconnectTile, Object.assign({}, networkReconnectTileProps)) : React__default['default'].createElement(React__default['default'].Fragment, null), updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader, dataUiId: 'call-page' });
};
/**
 * @private
 */
const isNetworkHealthy = (value) => {
    // We know that the value is actually of type DiagnosticQuality for this diagnostic.
    // We ignore any boolen values, considering the network to still be healthy.
    // Thus, only DiagnosticQuality.Poor or .Bad indicate network problems.
    return value === true || value === false || value === undefined || value === communicationCalling.DiagnosticQuality.Good;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const mainStackTokens = {
    childrenGap: '1rem'
};
/**
 * @private
 */
const dropDownStyles = (theme) => ({
    caretDownWrapper: {
        height: '2.5rem',
        lineHeight: '2.5rem'
    },
    dropdownItem: {
        fontSize: '0.875rem',
        height: '2.5rem',
        background: theme.palette.neutralQuaternaryAlt
    },
    dropdown: {
        height: '2.5rem',
        width: '100%',
        svg: {
            verticalAlign: 'top'
        }
    },
    title: {
        fontSize: '0.875rem',
        height: '2.5rem',
        lineHeight: '2.3125rem'
    },
    label: {
        fontWeight: 600,
        fontSize: '0.875rem'
    },
    errorMessage: {
        fontSize: '0.875rem'
    }
});
/**
 * @private
 */
const dropDownTitleIconStyles = react.mergeStyles({
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    minWidth: '0',
    maxWidth: '100%',
    overflowWrap: 'break-word',
    margin: '.063rem'
});
/**
 * @private
 */
const optionIconStyles = react.mergeStyles({
    marginRight: '8px',
    verticalAlign: 'text-top'
});

/**
 * @private
 */
const ConfigurationPageCameraDropdown = (props) => {
    return props.cameraGrantedDropdown;
};

/**
 * @private
 */
const ConfigurationPageMicDropdown = (props) => {
    return props.micGrantedDropdown;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const configurationStackTokensDesktop = {
    childrenGap: '2rem'
};
/**
 * @private
 */
const configurationStackTokensMobile = {
    childrenGap: '1rem'
};
const configurationContainerStyle = {
    height: '100%',
    width: '100%',
    padding: '0.5rem'
};
/**
 * @private
 */
const configurationContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '25rem', 
    // sum of min-width from children + ChildrenGap * (nb of children - 1) + padding * 2 = (11 + 11) + (2 * 1) + 0.5 * 2
    minHeight: '22rem' // max height of SelectionContainer + padding * 2 = 21 + 0.5 * 2
 }));
/**
 * @private
 */
const configurationContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, configurationContainerStyle), { minWidth: '16rem', 
    // from LocalPreview: ControlBar width + 0.5 * 2 for spacing + padding * 2 = 14 + 0.5 * 2 + 0.5 * 2
    minHeight: '13rem' }));
/**
 * @private
 */
const selectionContainerStyle = react.mergeStyles({
    width: '50%',
    minWidth: '11rem',
    maxWidth: '18.75rem',
    padding: '0.5rem'
});
/**
 * @private
 */
const titleContainerStyleDesktop = react.mergeStyles({
    fontSize: '1.25rem',
    lineHeight: '1.75rem',
    fontWeight: 600
});
/**
 * @private
 */
const titleContainerStyleMobile = react.mergeStyles({
    fontSize: '1.0625rem',
    lineHeight: '1.375rem',
    fontWeight: 600,
    textAlign: 'center'
});
/**
 * @private
 */
const callDetailsContainerStylesDesktop = {
    root: {
        marginBottom: '1.563rem'
    }
};
const callDetailsStyle = {
    fontSize: '0.9375',
    lineHeight: '1.25rem',
    marginTop: '0.25rem'
};
/**
 * @private
 */
const callDetailsStyleDesktop = react.mergeStyles(Object.assign({}, callDetailsStyle));
/**
 * @private
 */
const callDetailsStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, callDetailsStyle), { textAlign: 'center' }));
/**
 * @private
 */
const startCallButtonContainerStyleDesktop = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const startCallButtonContainerStyleMobile = {
    root: {
        textAlign: 'center'
    }
};
/**
 * @private
 */
const startCallButtonStyleMobile = react.mergeStyles({
    width: '100%',
    maxWidth: 'unset'
});
/** @private */
const cameraAndVideoEffectsContainerStyleDesktop = {
    root: {
        alignItems: 'center'
    }
};
/** @private */
const fillWidth = react.mergeStyles({
    width: '100%'
});
/** @private */
const panelStyles = {
    content: {
        display: 'flex',
        flexBasis: '100%'
    },
    scrollableContent: {
        display: 'flex',
        flexDirection: 'column',
        height: '100%'
    }
};
/** @private */
const panelFocusProps = {
    forceFocusInsideTrap: false
};

// Copyright (c) Microsoft Corporation.
const getDropDownList = (list) => {
    // Remove duplicates
    const noDuplicates = new Map();
    for (const item of list) {
        noDuplicates.set(item.id, item);
    }
    const dropdownList = [];
    for (const item of noDuplicates.values()) {
        dropdownList.push({
            key: item.id,
            text: item.name === '' ? item.deviceType : item.name
        });
    }
    return dropdownList;
};
const getOptionIcon = (type) => {
    if (type === 'Camera') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsCamera", className: optionIconStyles });
    }
    else if (type === 'Microphone') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsMic", className: optionIconStyles });
    }
    else if (type === 'Speaker') {
        return React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalDeviceSettingsSpeaker", className: optionIconStyles });
    }
    else {
        return undefined;
    }
};
const onRenderTitle = (iconType, props) => {
    const icon = props && getOptionIcon(iconType);
    return props ? React__default['default'].createElement("div", { className: dropDownTitleIconStyles },
        icon,
        React__default['default'].createElement("span", null, props[0].text)) : React__default['default'].createElement(React__default['default'].Fragment, null);
};
const localVideoViewOptions = {
    scalingMode: 'Crop',
    isMirrored: true
};
/**
 * @private
 */
const LocalDeviceSettings = (props) => {
    var _a;
    const theme = useTheme();
    const locale = useLocale();
    const defaultPlaceHolder = locale.strings.call.defaultPlaceHolder;
    const cameraLabel = locale.strings.call.cameraLabel;
    const soundLabel = locale.strings.call.soundLabel;
    const noSpeakersLabel = locale.strings.call.noSpeakersLabel;
    const noCameraLabel = locale.strings.call.noCamerasLabel;
    const noMicLabel = locale.strings.call.noMicrophonesLabel;
    const cameraPermissionGranted = props.cameraPermissionGranted;
    const micPermissionGranted = props.microphonePermissionGranted;
    // actually granting access to query both microphone and speaker. However the browser popup asks you explicity for
    // 'microphone'. This needs investigation on how we want to handle this and maybe needs follow up with SDK team.
    const hasCameras = props.cameras.length > 0;
    const hasMicrophones = props.microphones.length > 0;
    const hasSpeakers = props.speakers.length > 0;
    const cameraGrantedDropdown = React__default['default'].createElement(react.Dropdown, { "data-ui-id": "call-composite-local-camera-settings", "aria-labelledby": 'call-composite-local-camera-settings-label', placeholder: hasCameras ? defaultPlaceHolder : noCameraLabel, options: cameraPermissionGranted ? getDropDownList(props.cameras) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], styles: dropDownStyles(theme), disabled: !cameraPermissionGranted || !hasCameras, errorMessage: props.cameraPermissionGranted === undefined || props.cameraPermissionGranted ? undefined : locale.strings.call.cameraPermissionDenied, defaultSelectedKey: micPermissionGranted ? props.selectedCamera ? props.selectedCamera.id : props.cameras ? (_a = props.cameras[0]) === null || _a === void 0 ? void 0 : _a.id : '' : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectCamera(props.cameras[index !== null && index !== void 0 ? index : 0], localVideoViewOptions);
        }, onRenderTitle: (props) => onRenderTitle('Camera', props) });
    const micGrantedDropdown = React__default['default'].createElement(React__default['default'].Fragment, null, React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: hasMicrophones ? defaultPlaceHolder : noMicLabel, styles: dropDownStyles(theme), disabled: !micPermissionGranted || !hasMicrophones, errorMessage: props.microphonePermissionGranted === undefined || props.microphonePermissionGranted ? undefined : locale.strings.call.microphonePermissionDenied, options: micPermissionGranted ? getDropDownList(props.microphones) : [{
                key: 'deniedOrUnknown',
                text: ''
            }], defaultSelectedKey: micPermissionGranted ? props.selectedMicrophone ? props.selectedMicrophone.id : defaultDeviceId(props.microphones) : 'deniedOrUnknown', onChange: (event, option, index) => {
            props.onSelectMicrophone(props.microphones[index !== null && index !== void 0 ? index : 0]);
        }, onRenderTitle: (props) => onRenderTitle('Microphone', props) }));
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-device-settings", tokens: mainStackTokens },
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Stack, { horizontal: true, horizontalAlign: "space-between", styles: cameraAndVideoEffectsContainerStyleDesktop },
                React__default['default'].createElement(react.Label, { id: 'call-composite-local-camera-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !cameraPermissionGranted }, cameraLabel)),
            React__default['default'].createElement(ConfigurationPageCameraDropdown, { cameraGrantedDropdown: cameraGrantedDropdown, cameraPermissionGranted: cameraPermissionGranted !== null && cameraPermissionGranted !== void 0 ? cameraPermissionGranted : false })),
        React__default['default'].createElement(react.Stack, null,
            React__default['default'].createElement(react.Label, { id: 'call-composite-local-sound-settings-label', className: react.mergeStyles(dropDownStyles(theme).label), disabled: !micPermissionGranted }, soundLabel),
            React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-sound-settings", tokens: mainStackTokens },
                React__default['default'].createElement(ConfigurationPageMicDropdown, { micGrantedDropdown: micGrantedDropdown, micPermissionGranted: micPermissionGranted !== null && micPermissionGranted !== void 0 ? micPermissionGranted : false }),
                React__default['default'].createElement(react.Dropdown, { "aria-labelledby": 'call-composite-local-sound-settings-label', placeholder: hasSpeakers ? defaultPlaceHolder : noSpeakersLabel, styles: dropDownStyles(theme), disabled: props.speakers.length === 0, options: getDropDownList(props.speakers), defaultSelectedKey: props.selectedSpeaker ? props.selectedSpeaker.id : defaultDeviceId(props.speakers), onChange: (event, option, index) => {
                        props.onSelectSpeaker(props.speakers[index !== null && index !== void 0 ? index : 0]);
                    }, onRenderTitle: (props) => onRenderTitle('Speaker', props) }))));
};
const defaultDeviceId = (devices) => {
    if (devices.length === 0) {
        return '';
    }
    const defaultDevice = devices.find(device => device.isSystemDefault);
    if (defaultDevice) {
        return defaultDevice.id;
    }
    return devices[0].id;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const videoCameraIconStyle = react.mergeStyles({
    marginRight: '0.375rem',
    fontSize: '1.375rem'
});
/**
 * @private
 */
const buttonStyle = react.mergeStyles({
    fontWeight: 600,
    fontSize: '0.875rem',
    // 14px
    height: '2.75rem',
    width: '100%'
});
/**
 * @private
 */
const buttonWithIconStyles = {
    textContainer: {
        display: 'contents'
    }
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const StartCallButton = (props) => {
    const { rejoinCall } = props;
    const locale = useLocale();
    return React__default['default'].createElement(react.PrimaryButton, Object.assign({}, props, { "data-ui-id": "call-composite-start-call-button", className: react.mergeStyles(buttonStyle, props.className), styles: buttonWithIconStyles, text: rejoinCall ? locale.strings.call.rejoinCallButtonLabel : locale.strings.call.startCallButtonLabel, onRenderIcon: () => React__default['default'].createElement(reactIcons.Video20Filled, { className: videoCameraIconStyle }) }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const devicePermissionSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    return {
        video: deviceManager.deviceAccess ? deviceManager.deviceAccess.video : undefined,
        audio: deviceManager.deviceAccess ? deviceManager.deviceAccess.audio : undefined
    };
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const localPreviewSelector = reselect__namespace.createSelector([getDeviceManager], deviceManager => {
    // TODO: we should take in a LocalVideoStream that developer wants to use as their 'Preview' view. We should also
    // handle cases where 'Preview' view is in progress and not necessary completed.
    const view = deviceManager.cameras.length > 0 &&
        // This ensures that the video stream is reset if camera devices are removed.
        deviceManager.unparentedViews.length > 0 && deviceManager.unparentedViews[0].view;
    return {
        videoStreamElement: view ? view.target : null
    };
});

// Copyright (c) Microsoft Corporation.
const localPreviewContainerStyle = {
    borderRadius: '.25rem'
};
/**
 * @private
 */
const localPreviewContainerStyleDesktop = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '50%', minWidth: '11rem', maxWidth: '25rem', height: '18.75rem', padding: '0.5rem' }));
/**
 * @private
 */
const localPreviewContainerStyleMobile = react.mergeStyles(Object.assign(Object.assign({}, localPreviewContainerStyle), { width: '100%', height: '100%' }));
/**
 * @private
 */
const cameraOffLabelStyle = react.mergeStyles({
    fontSize: '0.75rem' // 12px
});
/**
 * @private
 */
const localPreviewTileStyle = {
    root: {
        borderRadius: '.25rem',
        '@media (forced-colors: active)': {
            borderColor: '#FFFFFF',
            border: '1px solid'
        }
    }
};
/**
 * @private
 */
const localPreviewButtonStyle = {
    root: {
        '@media (forced-colors: active)': {
            ':focus': {
                border: '1px solid !important' // we need bang important to override fluents colours
            },
            ':focus::after': {
                border: 'unset !important',
                // we need bang important to override fluents colours
                outline: 'unset !important'
            }
        }
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$7 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const LocalPreview = (props) => {
    const locale = useLocale();
    const cameraButtonProps = usePropsFor$1(CameraButton);
    const localPreviewProps = useSelector$1(localPreviewSelector);
    const devicesButtonProps = usePropsFor$1(DevicesButton);
    const { audio: microphonePermissionGranted, video: cameraPermissionGranted } = useSelector$1(devicePermissionSelector);
    const isLocalMicrophoneEnabled = useSelector$1(getLocalMicrophoneEnabled);
    const adapter = useAdapter();
    const onToggleMic = React.useCallback(() => __awaiter$7(void 0, void 0, void 0, function* () {
        isLocalMicrophoneEnabled ? adapter.mute() : adapter.unmute();
    }), [adapter, isLocalMicrophoneEnabled]);
    const hasNoDevices = devicesButtonProps.cameras.length === 0 && devicesButtonProps.microphones.length === 0 && devicesButtonProps.speakers.length === 0;
    const hasCameras = devicesButtonProps.cameras.length > 0;
    const hasMicrophones = devicesButtonProps.microphones.length > 0;
    const theme = useTheme();
    const onRenderPlaceholder = React.useCallback(() => {
        return React__default['default'].createElement(react.Stack, { className: react.mergeStyles({
                width: '100%',
                height: '100%'
            }), verticalAlign: "center", tokens: {
                childrenGap: '0.25rem'
            } },
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(CallCompositeIcon, { iconName: "LocalPreviewPlaceholder", className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralTertiary
                    }) })),
            React__default['default'].createElement(react.Stack.Item, { align: "center" },
                React__default['default'].createElement(react.Text, { className: react.mergeStyles(cameraOffLabelStyle, {
                        color: theme.palette.neutralSecondary
                    }) }, locale.strings.call.cameraTurnedOff)));
    }, [theme, locale.strings.call.cameraTurnedOff]);
    const devicesButtonStyles = props.mobileView ? {
        menuStyles: {
            menuItemStyles: buttonFlyoutIncreasedSizeStyles
        }
    } : undefined;
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-composite-local-preview", className: props.mobileView ? localPreviewContainerStyleMobile : localPreviewContainerStyleDesktop },
        React__default['default'].createElement(VideoTile, { styles: localPreviewTileStyle, renderElement: (localPreviewProps === null || localPreviewProps === void 0 ? void 0 : localPreviewProps.videoStreamElement) ? React__default['default'].createElement(StreamMedia, { videoStreamElement: localPreviewProps.videoStreamElement }) : undefined, onRenderPlaceholder: onRenderPlaceholder },
            React__default['default'].createElement(ControlBar, { layout: "floatingBottom" },
                React__default['default'].createElement(MicrophoneButton, { "data-ui-id": "call-composite-local-device-settings-microphone-button", checked: isLocalMicrophoneEnabled, onToggleMicrophone: onToggleMic, disabled: !microphonePermissionGranted || !hasMicrophones, showLabel: true, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipOnContent: '',
                        tooltipOffContent: '',
                        tooltipDisabledContent: ''
                    } : {}, styles: localPreviewButtonStyle }),
                React__default['default'].createElement(CameraButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-camera-button" }, cameraButtonProps, { showLabel: true, disabled: !cameraPermissionGranted || !hasCameras, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipOnContent: '',
                        tooltipOffContent: '',
                        tooltipDisabledContent: '',
                        tooltipVideoLoadingContent: ''
                    } : {}, styles: localPreviewButtonStyle })),
                props.showDevicesButton && React__default['default'].createElement(DevicesButton, Object.assign({ "data-ui-id": "call-composite-local-device-settings-options-button" }, devicesButtonProps, { 
                    // disable button whilst all other buttons are disabled
                    disabled: !microphonePermissionGranted || !cameraPermissionGranted || hasNoDevices, showLabel: true, 
                    // disable tooltip as it obscures list of devices on mobile
                    strings: props.mobileView ? {
                        tooltipContent: ''
                    } : {}, styles: devicesButtonStyles })))));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ConfigurationPageErrorBar = (props) => {
    const { errorBarProps } = props;
    return React__default['default'].createElement(ErrorBar, Object.assign({}, errorBarProps));
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$6 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const ConfigurationPage = (props) => {
    var _a;
    const { startCallHandler, mobileView, modalLayerHostId } = props;
    const options = useAdaptedSelector(getSelector$1(DevicesButton));
    const localDeviceSettingsHandlers = useHandlers();
    const { video: cameraPermissionGranted, audio: microphonePermissionGranted } = useSelector$1(devicePermissionSelector);
    let errorBarProps = usePropsFor$1(ErrorBar);
    const adapter = useAdapter();
    const deviceState = adapter.getState().devices;
    let disableStartCallButton = !microphonePermissionGranted || ((_a = deviceState.microphones) === null || _a === void 0 ? void 0 : _a.length) === 0;
    const locale = useLocale();
    const title = React__default['default'].createElement(react.Stack.Item, { className: mobileView ? titleContainerStyleMobile : titleContainerStyleDesktop, role: "heading", "aria-level": 1 }, locale.strings.call.configurationPageTitle);
    const callDescription = locale.strings.call.configurationPageCallDetails && React__default['default'].createElement(react.Stack.Item, { className: mobileView ? callDetailsStyleMobile : callDetailsStyleDesktop }, locale.strings.call.configurationPageCallDetails);
    let mobileWithPreview = mobileView; // When permission API is not available, we want to show screen saying checking for access (disappears on its own)
    // then based on permission setting, we show permission denied or nothing
    const startCall = React.useCallback(() => __awaiter$6(void 0, void 0, void 0, function* () {
        startCallHandler();
    }), [startCallHandler]);
    const panelLayerProps = React.useMemo(() => ({
        hostId: modalLayerHostId
    }), [modalLayerHostId]);
    return React__default['default'].createElement(react.Stack, { className: mobileView ? configurationContainerStyleMobile : configurationContainerStyleDesktop },
        React__default['default'].createElement(react.Stack, { styles: bannerNotificationStyles },
            React__default['default'].createElement(ConfigurationPageErrorBar, { errorBarProps: errorBarProps })),
        React__default['default'].createElement(react.Stack, { verticalFill: true, grow: true, horizontal: true, className: fillWidth },
            React__default['default'].createElement(react.Stack, { className: fillWidth, horizontal: !mobileWithPreview, horizontalAlign: mobileWithPreview ? 'stretch' : 'center', verticalAlign: "center", tokens: mobileWithPreview ? configurationStackTokensMobile : configurationStackTokensDesktop },
                mobileWithPreview && React__default['default'].createElement(react.Stack.Item, null,
                    title,
                    callDescription),
                localPreviewTrampoline(mobileWithPreview),
                React__default['default'].createElement(react.Stack, { className: mobileView ? undefined : selectionContainerStyle },
                    !mobileWithPreview && React__default['default'].createElement(React__default['default'].Fragment, null,
                        React__default['default'].createElement(react.Stack.Item, { styles: callDetailsContainerStylesDesktop },
                            title,
                            callDescription),
                        React__default['default'].createElement(LocalDeviceSettings, Object.assign({}, options, localDeviceSettingsHandlers, { cameraPermissionGranted: cameraPermissionGrantedTrampoline(cameraPermissionGranted), microphonePermissionGranted: micPermissionGrantedTrampoline(microphonePermissionGranted) }))),
                    React__default['default'].createElement(react.Stack, { styles: mobileWithPreview ? startCallButtonContainerStyleMobile : startCallButtonContainerStyleDesktop },
                        React__default['default'].createElement(StartCallButton, { className: mobileWithPreview ? startCallButtonStyleMobile : undefined, onClick: startCall, disabled: disableStartCallButton })))),
            React__default['default'].createElement(react.Panel, { hasCloseButton: false, isBlocking: false, isHiddenOnDismiss: false, styles: panelStyles, focusTrapZoneProps: panelFocusProps, layerProps: panelLayerProps },
                React__default['default'].createElement(SidePane, { mobileView: props.mobileView, updateSidePaneRenderer: props.updateSidePaneRenderer }))));
};
const localPreviewTrampoline = (mobileView, doNotShow) => {
    return React__default['default'].createElement(LocalPreview, { mobileView: mobileView, showDevicesButton: mobileView });
};
const cameraPermissionGrantedTrampoline = (cameraPermissionGranted, videoState) => {
    return cameraPermissionGranted;
};
const micPermissionGrantedTrampoline = (microphonePermissionGranted, audioState) => {
    return microphonePermissionGranted;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const containerStyle = {
    maxWidth: '22.5rem',
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const containerItemGap = {
    childrenGap: '0.5rem'
};
/**
 * @private
 */
const rejoinCallButtonContainerStyles = {
    root: {
        paddingTop: '1.125rem'
    }
};
/**
 * @private
 */
const titleStyles = {
    fontSize: '1.25rem',
    fontWeight: 600
};
/**
 * @private
 */
const moreDetailsStyles = {
    fontSize: '1rem'
};

// Copyright (c) Microsoft Corporation.
/**
 * Generic page with a title and more details text for serving up a notice to the user.
 *
 * @private
 */
function NoticePage(props) {
    const adapter = useAdapter();
    return React__default['default'].createElement(react.Stack, { className: react.mergeStyles(props.pageStyle), verticalFill: true, verticalAlign: "center", horizontalAlign: "center", "data-ui-id": props.dataUiId, "aria-atomic": true },
        React__default['default'].createElement(react.Stack, { className: react.mergeStyles(containerStyle), tokens: containerItemGap },
            props.iconName && React__default['default'].createElement(CallCompositeIcon, { iconName: props.iconName }),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyles), "aria-live": "assertive" }, props.title),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyles), "aria-live": "assertive" }, props.moreDetails),
            !props.disableStartCallButton && React__default['default'].createElement(react.Stack, { styles: rejoinCallButtonContainerStyles },
                React__default['default'].createElement(StartCallButton, { onClick: () => adapter.joinCall(), disabled: false, rejoinCall: true, autoFocus: true }))));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const overlayContainerStyle = {
    // Ensure some space around the text on a narrow viewport.
    margin: '1rem'
};
/**
 * @private
 */
const titleStyle = (palette, isVideoReady) => {
    return {
        fontSize: '1rem',
        color: isVideoReady ? 'white' : palette.blue,
        textAlign: 'center'
    };
};
/**
 * @private
 */
const moreDetailsStyle = (palette, isVideoReady) => ({
    fontSize: '0.75rem',
    color: isVideoReady ? 'white' : palette.blue,
    textAlign: 'center'
});

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyTile = (props) => {
    var _a;
    const videoStream = props.localParticipantVideoStream;
    const isVideoReady = (_a = videoStream === null || videoStream === void 0 ? void 0 : videoStream.isAvailable) !== null && _a !== void 0 ? _a : false;
    const palette = useTheme().palette;
    const handlers = useHandlers();
    return React__default['default'].createElement(ExpandedLocalVideoTile, Object.assign({ localParticipantVideoStream: props.localParticipantVideoStream, overlayContent: props.overlayProps ? React__default['default'].createElement(react.Stack, { verticalFill: true, horizontalAlign: "center", verticalAlign: "center", className: react.mergeStyles(overlayContainerStyle), "aria-atomic": true },
            React__default['default'].createElement(react.Stack.Item, { className: react.mergeStyles(titleStyle(palette, isVideoReady)) }, props.overlayProps.overlayIcon),
            React__default['default'].createElement(react.Text, { className: react.mergeStyles(titleStyle(palette, isVideoReady)), "aria-live": "assertive", "data-ui-id": "lobbyScreenTitle" }, props.overlayProps.title),
            props.overlayProps.moreDetails && React__default['default'].createElement(react.Text, { className: react.mergeStyles(moreDetailsStyle(palette, isVideoReady)), "aria-live": "assertive" }, props.overlayProps.moreDetails)) : undefined }, handlers));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const LobbyPage = (props) => {
    var _a, _b, _c, _d;
    const errorBarProps = usePropsFor$1(ErrorBar);
    const lobbyProps = useSelector$1(lobbySelector);
    const strings = useLocale().strings.call;
    const callState = useSelector$1(getCallStatus);
    const inLobby = callState === 'InLobby';
    const participants = (_a = useSelector$1(getRemoteParticipants)) !== null && _a !== void 0 ? _a : {};
    useLocalVideoStartTrigger(lobbyProps.localParticipantVideoStream.isAvailable, inLobby);
    // Reduce the controls shown when mobile view is enabled.
    let callControlOptions = props.mobileView ? reduceCallControlsForMobile((_b = props.options) === null || _b === void 0 ? void 0 : _b.callControls) : (_c = props.options) === null || _c === void 0 ? void 0 : _c.callControls;
    callControlOptions = disableCallControls(callControlOptions, ['screenShareButton', 'participantsButton']);
    return React__default['default'].createElement(CallArrangement, { complianceBannerProps: {
            strings
        }, 
        // Ignore errors from before current call. This avoids old errors from showing up when a user re-joins a call.
        errorBarProps: ((_d = props.options) === null || _d === void 0 ? void 0 : _d.errorBar) !== false && Object.assign(Object.assign({}, errorBarProps), { ignorePremountErrors: true }), callControlProps: {
            options: callControlOptions,
            increaseFlyoutItemSize: props.mobileView
        }, mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, onRenderGalleryContent: () => React__default['default'].createElement(LobbyTile, Object.assign({}, lobbyProps, { overlayProps: overlayProps(strings, inLobby, Object.values(participants)) })), dataUiId: 'lobby-page', updateSidePaneRenderer: props.updateSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader });
};
const overlayProps = (strings, inLobby, remoteParticipants) => {
    /**
     * Only grab the first participant because there will only be one in this situation.
     * when starting a call with multiple people the call goes to the connected state and composite goes directly to
     * videoGallery.
     *
     * We also need to check the participant state since in a group call the remote participants array will populate just before
     * the user joins. In this situation we also check the participant states. in a groupCall the state of the participants
     * will be 'Idle'.
     */
    const outboundCallParticipant = remoteParticipants[0] && ['Ringing', 'Connecting'].includes(remoteParticipants[0].state) && remoteParticipants.length === 1 ? remoteParticipants[0] : undefined;
    return inLobby ? overlayPropsWaitingToBeAdmitted(strings) : outboundCallParticipant ? overlayPropsOutboundCall(strings, outboundCallParticipant) : overlayPropsConnectingToCall(strings);
};
const overlayPropsConnectingToCall = (strings) => ({
    title: strings.lobbyScreenConnectingToCallTitle,
    moreDetails: strings.lobbyScreenConnectingToCallMoreDetails,
    overlayIcon: React__default['default'].createElement(CallCompositeIcon, { iconName: "LobbyScreenConnectingToCall" })
});
const overlayPropsWaitingToBeAdmitted = (strings) => ({
    title: strings.lobbyScreenWaitingToBeAdmittedTitle,
    moreDetails: strings.lobbyScreenWaitingToBeAdmittedMoreDetails,
    overlayIcon: React__default['default'].createElement(CallCompositeIcon, { iconName: "LobbyScreenWaitingToBeAdmitted" })
});
const overlayPropsOutboundCall = (strings, participant) => {
    if (communicationCommon.isPhoneNumberIdentifier(participant.identifier)) {
        return {
            title: participant.identifier.phoneNumber,
            moreDetails: outboundCallStringsTrampoline()
        };
    }
    else {
        return {
            title: outboundCallStringsTrampoline()
        };
    }
};
const outboundCallStringsTrampoline = (strings) => {
    return '';
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$5 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isShowing = (overrideSidePane) => {
    return !!(overrideSidePane === null || overrideSidePane === void 0 ? void 0 : overrideSidePane.isActive);
};
const MainScreen = (props) => {
    var _a;
    const { callInvitationUrl, onRenderAvatar, onFetchAvatarPersonaData, onFetchParticipantMenuItems } = props;
    const page = useSelector$1(getPage);
    const [sidePaneRenderer, setSidePaneRenderer] = React__default['default'].useState();
    const [injectedSidePaneProps, setInjectedSidePaneProps] = React__default['default'].useState();
    const overridePropsRef = React.useRef(props.overrideSidePane);
    React.useEffect(() => {
        setInjectedSidePaneProps(props.overrideSidePane);
        // When the injected side pane is opened, clear the previous side pane active state.
        // this ensures when the injected side pane is "closed", the previous side pane is not "re-opened".
        if (!isShowing(overridePropsRef.current) && isShowing(props.overrideSidePane)) {
            setSidePaneRenderer(undefined);
        }
        overridePropsRef.current = props.overrideSidePane;
    }, [props.overrideSidePane]);
    const onSidePaneIdChange = props.onSidePaneIdChange;
    React.useEffect(() => {
        onSidePaneIdChange === null || onSidePaneIdChange === void 0 ? void 0 : onSidePaneIdChange(sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id);
    }, [sidePaneRenderer === null || sidePaneRenderer === void 0 ? void 0 : sidePaneRenderer.id, onSidePaneIdChange]);
    const adapter = useAdapter();
    const locale = useLocale();
    const palette = useTheme().palette;
    const leavePageStyle = React.useMemo(() => leavingPageStyle(palette), [palette]);
    let pageElement;
    switch (page) {
        case 'configuration':
            pageElement = React__default['default'].createElement(ConfigurationPage, { mobileView: props.mobileView, startCallHandler: () => {
                    adapter.joinCall();
                }, updateSidePaneRenderer: setSidePaneRenderer, modalLayerHostId: props.modalLayerHostId });
            break;
        case 'accessDeniedTeamsMeeting':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageAccessDeniedTeamsMeeting", title: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedTitle, moreDetails: locale.strings.call.failedToJoinTeamsMeetingReasonAccessDeniedMoreDetails, dataUiId: 'access-denied-teams-meeting-page' });
            break;
        case 'removedFromCall':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageRemovedFromCall", title: locale.strings.call.removedFromCallTitle, moreDetails: locale.strings.call.removedFromCallMoreDetails, dataUiId: 'removed-from-call-page' });
            break;
        case 'joinCallFailedDueToNoNetwork':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageJoinCallFailedDueToNoNetwork", title: locale.strings.call.failedToJoinCallDueToNoNetworkTitle, moreDetails: locale.strings.call.failedToJoinCallDueToNoNetworkMoreDetails, dataUiId: 'join-call-failed-due-to-no-network-page' });
            break;
        case 'leaving':
            pageElement = React__default['default'].createElement(NoticePage, { title: (_a = locale.strings.call.leavingCallTitle) !== null && _a !== void 0 ? _a : 'Leaving...', dataUiId: 'leaving-page', pageStyle: leavePageStyle, disableStartCallButton: true });
            break;
        case 'leftCall':
            pageElement = React__default['default'].createElement(NoticePage, { iconName: "NoticePageLeftCall", title: locale.strings.call.leftCallTitle, moreDetails: locale.strings.call.leftCallMoreDetails, dataUiId: 'left-call-page' });
            break;
        case 'lobby':
            pageElement = React__default['default'].createElement(LobbyPage, { mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: setSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader });
            break;
        case 'call':
            pageElement = React__default['default'].createElement(CallPage, { onRenderAvatar: onRenderAvatar, callInvitationURL: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: props.mobileView, modalLayerHostId: props.modalLayerHostId, options: props.options, updateSidePaneRenderer: setSidePaneRenderer, mobileChatTabHeader: props.mobileChatTabHeader });
            break;
    }
    if (!pageElement) {
        throw new Error('Invalid call composite page');
    }
    // default retElement for stable version
    let retElement = pageElement;
    return React__default['default'].createElement(SidePaneProvider, { sidePaneRenderer: sidePaneRenderer, overrideSidePane: injectedSidePaneProps }, retElement);
};
/**
 * A customizable UI composite for calling experience.
 *
 * @remarks Call composite min width/height are as follow:
 * - mobile: 17.5rem x 21rem (280px x 336px, with default rem at 16px)
 * - desktop: 30rem x 22rem (480px x 352px, with default rem at 16px)
 *
 * @public
 */
const CallComposite = (props) => React__default['default'].createElement(CallCompositeInner, Object.assign({}, props));
/** @private */
const CallCompositeInner = (props) => {
    const { adapter, callInvitationUrl, onFetchAvatarPersonaData, onFetchParticipantMenuItems, options, formFactor = 'desktop' } = props;
    React.useEffect(() => {
        (() => __awaiter$5(void 0, void 0, void 0, function* () {
            const constrain = getQueryOptions();
            yield adapter.askDevicePermission(constrain);
            adapter.queryCameras();
            adapter.queryMicrophones();
            adapter.querySpeakers();
        }))();
    }, [adapter]);
    const mobileView = formFactor === 'mobile';
    const modalLayerHostId = reactHooks.useId('modalLayerhost');
    const mainScreenContainerClassName = React.useMemo(() => {
        return mobileView ? mainScreenContainerStyleMobile : mainScreenContainerStyleDesktop;
    }, [mobileView]);
    return React__default['default'].createElement("div", { className: mainScreenContainerClassName },
        React__default['default'].createElement(BaseProvider, Object.assign({}, props),
            React__default['default'].createElement(CallAdapterProvider, { adapter: adapter },
                React__default['default'].createElement(MainScreen, { callInvitationUrl: callInvitationUrl, onFetchAvatarPersonaData: onFetchAvatarPersonaData, onFetchParticipantMenuItems: onFetchParticipantMenuItems, mobileView: mobileView, modalLayerHostId: modalLayerHostId, options: options, onSidePaneIdChange: props.onSidePaneIdChange, overrideSidePane: props.overrideSidePane, mobileChatTabHeader: props.mobileChatTabHeader }),
                // This layer host is for ModalLocalAndRemotePIP in SidePane. This LayerHost cannot be inside the SidePane
                // because when the SidePane is hidden, ie. style property display is 'none', it takes up no space. This causes problems when dragging
                // the Modal because the draggable bounds thinks it has no space and will always return to its initial position after dragging.
                // Additionally, this layer host cannot be in the Call Arrangement as it needs to be rendered before useMinMaxDragPosition() in
                // common/utils useRef is called.
                // Warning: this is fragile and works because the call arrangement page is only rendered after the call has connected and thus this
                // LayerHost will be guaranteed to have rendered (and subsequently mounted in the DOM). This ensures the DOM element will be available
                // before the call to `document.getElementById(modalLayerHostId)` is made.
                React__default['default'].createElement(react.LayerHost, { id: modalLayerHostId, className: react.mergeStyles(modalLayerHostStyle) }))));
};
const getQueryOptions = (options) => {
    return {
        video: true,
        audio: true
    };
};

/**
 * @private
 */
class ParticipantSubscriber {
    constructor(participant, emitter) {
        this.isMutedChangedHandler = () => {
            this.emitter.emit('isMutedChanged', {
                participantId: this.participant.identifier,
                isMuted: this.participant.isMuted
            });
        };
        this.displayNameChangedHandler = () => {
            this.emitter.emit('displayNameChanged', {
                participantId: this.participant.identifier,
                displayName: this.participant.displayName
            });
        };
        this.isSpeakingChangedHandler = () => {
            this.emitter.emit('isSpeakingChanged', {
                participantId: this.participant.identifier,
                isSpeaking: this.participant.isSpeaking
            });
        };
        this.videoStreamsUpdatedHandler = (event) => {
            this.emitter.emit('videoStreamsUpdated', event);
        };
        this.participant = participant;
        this.emitter = emitter;
        this.subscribeParticipantEvents();
    }
    subscribeParticipantEvents() {
        this.participant.on('isMutedChanged', this.isMutedChangedHandler);
        this.participant.on('displayNameChanged', this.displayNameChangedHandler);
        this.participant.on('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.on('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
    unsubscribeAll() {
        this.participant.off('isMutedChanged', this.isMutedChangedHandler);
        this.participant.off('displayNameChanged', this.displayNameChangedHandler);
        this.participant.off('isSpeakingChanged', this.isSpeakingChangedHandler);
        this.participant.off('videoStreamsUpdated', this.videoStreamsUpdatedHandler);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
class DiagnosticsForwarder {
    constructor(emitter, call) {
        this.unsubscribe = () => {
            this._diagnostics.network.off('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
            this._diagnostics.media.off('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
        };
        this._diagnostics = call.feature(communicationCalling.Features.UserFacingDiagnostics);
        this._emitter = emitter;
        this.subscribe();
    }
    subscribe() {
        this._diagnostics.network.on('diagnosticChanged', this.networkDiagnosticsChanged.bind(this));
        this._diagnostics.media.on('diagnosticChanged', this.mediaDiagnosticsChanged.bind(this));
    }
    networkDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'network' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
    mediaDiagnosticsChanged(args) {
        const event = Object.assign({ type: 'media' }, args);
        this._emitter.emit('diagnosticChanged', event);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 *
 * This is used to create correct handler for generic agent type
 */
const createHandlers = (callClient, callAgent, deviceManager, call) => {
    // Call can be either undefined or ACS Call
    if ((!call || call && _isACSCall())) {
        return createDefaultCallingHandlers(callClient, callAgent, deviceManager, call);
    }
    throw new Error('Unhandled agent type');
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$4 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @private
 */
const createProfileStateModifier = (onFetchProfile, notifyUpdate) => {
    const cachedDisplayName = {};
    return (state) => {
        var _a;
        const originalParticipants = (_a = state.call) === null || _a === void 0 ? void 0 : _a.remoteParticipants;
        (() => __awaiter$4(void 0, void 0, void 0, function* () {
            let shouldNotifyUpdates = false;
            for (const key in originalParticipants) {
                if (cachedDisplayName[key]) {
                    continue;
                }
                const profile = yield onFetchProfile(key, {
                    displayName: originalParticipants[key].displayName
                });
                if ((profile === null || profile === void 0 ? void 0 : profile.displayName) && originalParticipants[key].displayName !== (profile === null || profile === void 0 ? void 0 : profile.displayName)) {
                    cachedDisplayName[key] = profile === null || profile === void 0 ? void 0 : profile.displayName;
                }
                shouldNotifyUpdates = true;
            }
            // notify update only when there is a change, which most likely will trigger modifier and setState again
            shouldNotifyUpdates && notifyUpdate();
        }))();
        const participantsModifier = createParticipantModifier((id, participant) => {
            if (cachedDisplayName[id]) {
                return Object.assign(Object.assign({}, participant), { displayName: cachedDisplayName[id] });
            }
            return undefined;
        });
        return participantsModifier(state);
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$3 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of call, which is a centralized context for all state updates */
class CallContext {
    constructor(clientState, isTeamsCall, options) {
        var _a, _b;
        this.emitter = new EventEmitter.EventEmitter();
        this.state = {
            isLocalPreviewMicrophoneEnabled: false,
            userId: clientState.userId,
            displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName,
            devices: clientState.deviceManager,
            call: undefined,
            page: 'configuration',
            latestErrors: clientState.latestErrors,
            isTeamsCall,
            cameraStatus: undefined
        };
        this.emitter.setMaxListeners((_b = options === null || options === void 0 ? void 0 : options.maxListeners) !== null && _b !== void 0 ? _b : 50);
        this.bindPublicMethods();
        this.displayNameModifier = (options === null || options === void 0 ? void 0 : options.onFetchProfile) ? createProfileStateModifier(options.onFetchProfile, () => {
            this.setState(this.getState());
        }) : undefined;
    }
    bindPublicMethods() { }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = this.displayNameModifier ? this.displayNameModifier(state) : state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    setIsLocalMicrophoneEnabled(isLocalPreviewMicrophoneEnabled) {
        this.setState(Object.assign(Object.assign({}, this.state), { isLocalPreviewMicrophoneEnabled }));
    }
    // This is the key to find current call object in client state
    setCurrentCallId(callId) {
        this.callId = callId;
    }
    onCallEnded(handler) {
        this.emitter.on('callEnded', handler);
    }
    offCallEnded(handler) {
        this.emitter.off('callEnded', handler);
    }
    updateClientState(clientState) {
        var _a;
        let call = this.callId ? clientState.calls[this.callId] : undefined;
        const latestEndedCall = clientState.callsEnded ? findLatestEndedCall(clientState.callsEnded) : undefined;
        // As the state is transitioning to a new state, trigger appropriate callback events.
        const oldPage = this.state.page;
        const newPage = getCallCompositePage(call, latestEndedCall);
        if (!IsCallEndedPage(oldPage) && IsCallEndedPage(newPage)) {
            this.emitter.emit('callEnded', {
                callId: this.callId
            });
            // Reset the callId to undefined as the call has ended.
            this.setCurrentCallId(undefined);
            // Make sure that the call is set to undefined in the state.
            call = undefined;
        }
        if (this.state.page) {
            this.setState(Object.assign(Object.assign({}, this.state), { userId: clientState.userId, displayName: (_a = clientState.callAgent) === null || _a === void 0 ? void 0 : _a.displayName, call, page: newPage, endedCall: latestEndedCall, devices: clientState.deviceManager, latestErrors: clientState.latestErrors, cameraStatus: (call === null || call === void 0 ? void 0 : call.localVideoStreams.find(s => s.mediaStreamType === 'Video')) || clientState.deviceManager.unparentedViews.find(s => s.mediaStreamType === 'Video') ? 'On' : 'Off' }));
        }
    }
}
const findLatestEndedCall = (calls) => {
    var _a, _b, _c, _d;
    const callStates = Object.values(calls);
    if (callStates.length === 0) {
        return undefined;
    }
    let latestCall = callStates[0];
    for (const call of callStates.slice(1)) {
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) > ((_d = (_c = latestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            latestCall = call;
        }
    }
    return latestCall;
};
/**
 * @private
 */
class AzureCommunicationCallAdapter {
    constructor(callClient, locator, callAgent, deviceManager, options) {
        this.participantSubscribers = new Map();
        this.emitter = new EventEmitter.EventEmitter();
        this.isMyMutedChanged = () => {
            var _a;
            this.emitter.emit('isMutedChanged', {
                participantId: this.getState().userId,
                isMuted: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isMuted
            });
        };
        this.bindPublicMethods();
        this.callClient = callClient;
        this.callAgent = callAgent;
        this.locator = locator;
        this.deviceManager = deviceManager;
        const isTeamsMeeting = ('meetingLink' in this.locator);
        this.context = new CallContext(callClient.getState(), isTeamsMeeting, options);
        this.context.onCallEnded(endCallData => this.emitter.emit('callEnded', endCallData));
        const onStateChange = (clientState) => {
            var _a;
            // unsubscribe when the instance gets disposed
            if (!this) {
                callClient.offStateChange(onStateChange);
                return;
            }
            // `updateClientState` searches for the current call from all the calls in the state using a cached `call.id`
            // from the call object. `call.id` can change during a call. We must update the cached `call.id` before
            // calling `updateClientState` so that we find the correct state object for the call even when `call.id`
            // has changed.
            // https://github.com/Azure/communication-ui-library/pull/1820
            if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) {
                this.context.setCurrentCallId(this.call.id);
            }
            this.context.updateClientState(clientState);
        };
        this.handlers = createHandlers(callClient, callAgent, deviceManager, undefined);
        this.onClientStateChange = onStateChange;
        this.subscribeDeviceManagerEvents();
        this.callClient.onStateChange(onStateChange);
    }
    get call() {
        return this._call;
    }
    set call(newCall) {
        this.resetDiagnosticsForwarder(newCall);
        this._call = newCall;
    }
    // TODO: update this to include the 'selectedCameraChanged' when calling adds it to the device manager
    subscribeDeviceManagerEvents() {
        this.deviceManager.on('selectedMicrophoneChanged', () => {
            this.emitter.emit('selectedMicrophoneChanged');
        });
        this.deviceManager.on('selectedSpeakerChanged', () => {
            this.emitter.emit('selectedSpeakerChanged');
        });
    }
    bindPublicMethods() {
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startCall.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.on.bind(this);
        this.off.bind(this);
        this.processNewCall.bind(this);
    }
    dispose() {
        this.resetDiagnosticsForwarder();
        this.callClient.offStateChange(this.onClientStateChange);
        this.callAgent.dispose();
    }
    queryCameras() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                return this.deviceManager.getCameras();
            }));
        });
    }
    queryMicrophones() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                return this.deviceManager.getMicrophones();
            }));
        });
    }
    querySpeakers() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                return this.deviceManager.isSpeakerSelectionAvailable ? this.deviceManager.getSpeakers() : [];
            }));
        });
    }
    askDevicePermission(constrain) {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                yield this.deviceManager.askDevicePermission(constrain);
            }));
        });
    }
    joinCall(microphoneOn) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call!');
        }
        return this.teeErrorToEventEmitter(() => {
            const audioOptions = {
                muted: !(microphoneOn !== null && microphoneOn !== void 0 ? microphoneOn : this.getState().isLocalPreviewMicrophoneEnabled)
            };
            // TODO: find a way to expose stream to here
            const videoOptions = {
                localVideoStreams: this.localStream ? [this.localStream] : undefined
            };
            const call = this._joinCall(audioOptions, videoOptions);
            this.processNewCall(call);
            return call;
        });
    }
    _joinCall(audioOptions, videoOptions) {
        const isTeamsMeeting = ('meetingLink' in this.locator);
        if (isTeamsMeeting) {
            return this.callAgent.join(this.locator, {
                audioOptions,
                videoOptions
            });
        }
        return this.callAgent.join(this.locator, {
            audioOptions,
            videoOptions
        });
    }
    createStreamView(remoteUserId, options) {
        return __awaiter$3(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                return yield this.handlers.onCreateLocalStreamView(options);
            }
            else {
                return yield this.handlers.onCreateRemoteStreamView(remoteUserId, options);
            }
        });
    }
    disposeStreamView(remoteUserId) {
        return __awaiter$3(this, void 0, void 0, function* () {
            if (remoteUserId === undefined) {
                yield this.handlers.onDisposeLocalStreamView();
            }
            else {
                yield this.handlers.onDisposeRemoteStreamView(remoteUserId);
            }
        });
    }
    leaveCall(forEveryone) {
        return __awaiter$3(this, void 0, void 0, function* () {
            yield this.handlers.onHangUp(forEveryone);
            this.unsubscribeCallEvents();
            this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, undefined);
            // We set the adapter.call object to undefined immediately when a call is ended.
            // We do not set the context.callId to undefined because it is a part of the immutable data flow loop.
            this.call = undefined;
            this.stopCamera();
            this.mute();
        });
    }
    setCamera(device, options) {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                yield this.handlers.onSelectCamera(device, options);
            }));
        });
    }
    setMicrophone(device) {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                yield this.handlers.onSelectMicrophone(device);
            }));
        });
    }
    setSpeaker(device) {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                yield this.handlers.onSelectSpeaker(device);
            }));
        });
    }
    startCamera(options) {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                if (!isCameraOn(this.getState())) {
                    // First kick off the effect on the local device before starting the camera in the call.
                    // This prevents the effect not being applied for a brief moment when the camera is started.
                    yield this.handlers.onToggleCamera(options);
                }
            }));
        });
    }
    stopCamera() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                if (isCameraOn(this.getState())) {
                    yield this.handlers.onToggleCamera();
                }
            }));
        });
    }
    mute() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(false);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && !((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    unmute() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                var _a, _b;
                this.context.setIsLocalMicrophoneEnabled(true);
                if (_isInCall((_a = this.call) === null || _a === void 0 ? void 0 : _a.state) && ((_b = this.call) === null || _b === void 0 ? void 0 : _b.isMuted)) {
                    yield this.handlers.onToggleMicrophone();
                }
            }));
        });
    }
    startScreenShare() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                var _a;
                if (!((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn)) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    stopScreenShare() {
        return __awaiter$3(this, void 0, void 0, function* () {
            return yield this.asyncTeeErrorToEventEmitter(() => __awaiter$3(this, void 0, void 0, function* () {
                var _a;
                if ((_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn) {
                    yield this.handlers.onToggleScreenShare();
                }
            }));
        });
    }
    startCall(participants, options) {
        var _a, _b;
        if (_isInCall((_b = (_a = this.getState().call) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : 'None')) {
            throw new Error('You are already in the call.');
        }
        const idsToAdd = participants.map(participant => {
            // FIXME: `onStartCall` does not allow a Teams user.
            // Need some way to return an error if a Teams user is provided.
            const backendId = _toCommunicationIdentifier(participant);
            if (communicationCommon.isPhoneNumberIdentifier(backendId)) {
                if ((options === null || options === void 0 ? void 0 : options.alternateCallerId) === undefined) {
                    throw new Error('Unable to start call, PSTN user present with no alternateCallerId.');
                }
                return backendId;
            }
            else if (communicationCommon.isCommunicationUserIdentifier(backendId)) {
                return backendId;
            }
            return backendId;
        });
        const call = this.handlers.onStartCall(idsToAdd, options);
        if (!call) {
            throw new Error('Unable to start call.');
        }
        this.processNewCall(call);
        return call;
    }
    processNewCall(call) {
        this.call = call;
        this.context.setCurrentCallId(call.id);
        // Resync state after callId is set
        this.context.updateClientState(this.callClient.getState());
        this.handlers = createHandlers(this.callClient, this.callAgent, this.deviceManager, this.call);
        this.subscribeCallEvents();
    }
    removeParticipant(userId) {
        return __awaiter$3(this, void 0, void 0, function* () {
            let participant = userId;
            this.handlers.onRemoveParticipant(participant);
        });
    }
    getState() {
        return this.context.getState();
    }
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    subscribeCallEvents() {
        var _a, _b, _c, _d;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.on('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.on('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.on('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.on('idChanged', this.callIdChanged.bind(this));
    }
    unsubscribeCallEvents() {
        var _a, _b, _c, _d;
        for (const subscriber of this.participantSubscribers.values()) {
            subscriber.unsubscribeAll();
        }
        this.participantSubscribers.clear();
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.off('remoteParticipantsUpdated', this.onRemoteParticipantsUpdated.bind(this));
        (_b = this.call) === null || _b === void 0 ? void 0 : _b.off('isMutedChanged', this.isMyMutedChanged.bind(this));
        (_c = this.call) === null || _c === void 0 ? void 0 : _c.off('isScreenSharingOnChanged', this.isScreenSharingOnChanged.bind(this));
        (_d = this.call) === null || _d === void 0 ? void 0 : _d.off('idChanged', this.callIdChanged.bind(this));
    }
    onRemoteParticipantsUpdated({ added, removed }) {
        if (added && added.length > 0) {
            this.emitter.emit('participantsJoined', {
                joined: added
            });
        }
        if (removed && removed.length > 0) {
            this.emitter.emit('participantsLeft', {
                removed: removed
            });
        }
        added.forEach(participant => {
            this.participantSubscribers.set(toFlatCommunicationIdentifier(participant.identifier), new ParticipantSubscriber(participant, this.emitter));
        });
        removed.forEach(participant => {
            const subscriber = this.participantSubscribers.get(toFlatCommunicationIdentifier(participant.identifier));
            subscriber && subscriber.unsubscribeAll();
            this.participantSubscribers.delete(toFlatCommunicationIdentifier(participant.identifier));
        });
    }
    isScreenSharingOnChanged() {
        var _a;
        this.emitter.emit('isLocalScreenSharingActiveChanged', {
            isScreenSharingOn: (_a = this.call) === null || _a === void 0 ? void 0 : _a.isScreenSharingOn
        });
    }
    callIdChanged() {
        var _a;
        ((_a = this.call) === null || _a === void 0 ? void 0 : _a.id) && this.emitter.emit('callIdChanged', {
            callId: this.call.id
        });
    }
    resetDiagnosticsForwarder(newCall) {
        if (this.diagnosticsForwarder) {
            this.diagnosticsForwarder.unsubscribe();
        }
        if (newCall) {
            this.diagnosticsForwarder = new DiagnosticsForwarder(this.emitter, newCall);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        this.emitter.off(event, listener);
    }
    asyncTeeErrorToEventEmitter(f) {
        return __awaiter$3(this, void 0, void 0, function* () {
            try {
                return yield f();
            }
            catch (error) {
                if (isCallError(error)) {
                    this.emitter.emit('error', error);
                }
                throw error;
            }
        });
    }
    teeErrorToEventEmitter(f) {
        try {
            return f();
        }
        catch (error) {
            if (isCallError(error)) {
                this.emitter.emit('error', error);
            }
            throw error;
        }
    }
}
/**
 * Create a {@link CallAdapter} backed by Azure Communication Services.
 *
 * This is the default implementation of {@link CallAdapter} provided by this library.
 *
 * Note: `displayName` can be a maximum of 256 characters.
 *
 * @public
 */
const createAzureCommunicationCallAdapter = ({ userId, displayName, credential, locator }) => __awaiter$3(void 0, void 0, void 0, function* () {
    if (!_isValidIdentifier(userId)) {
        throw new Error('Invalid identifier. Please provide valid identifier object.');
    }
    const callClient = createStatefulCallClient({
        userId
    });
    const callAgent = yield callClient.createCallAgent(credential, {
        displayName
    });
    const adapter = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, locator);
    return adapter;
});
/**
 * @private
 */
const useAzureCommunicationCallAdapterGeneric = (args, afterCreate, beforeDispose, adapterKind = 'AzureCommunication') => {
    const { credential, locator, userId } = args;
    const displayName = 'displayName' in args ? args.displayName : undefined;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const creatingAdapterRef = React.useRef(false);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !locator || !userId) {
            return;
        }
        if (adapterKind === 'AzureCommunication' && !displayName) {
            return;
        }
        (() => __awaiter$3(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = undefined;
            if (adapterKind === 'AzureCommunication') {
                // This is just the type check to ensure that displayName is defined.
                if (!displayName) {
                    throw new Error('Unreachable code, displayName already checked above.');
                }
                // This is just the type check to ensure that roleHint is defined.
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, please see storybook for more information: https://azure.github.io/communication-ui-library/?path=/story/troubleshooting--page');
                    return;
                }
                creatingAdapterRef.current = true;
                newAdapter = (yield createAzureCommunicationCallAdapter({
                    credential,
                    displayName: displayName,
                    locator,
                    userId: userId
                }));
            }
            else if (adapterKind === 'Teams') {
                if (creatingAdapterRef.current) {
                    console.warn('Adapter is already being created, skipping creation.');
                    return;
                }
                creatingAdapterRef.current = true;
            }
            else {
                throw new Error('Unreachable code, unknown adapterKind');
            }
            if (!newAdapter) {
                throw Error('Unreachable code! Get undefined adapter');
            }
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            creatingAdapterRef.current = false;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, adapterKind, credential, locator, userId, displayName]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter$3(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * A custom React hook to simplify the creation of {@link CallAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallAdapter = (args, afterCreate, beforeDispose) => {
    return useAzureCommunicationCallAdapterGeneric(args, afterCreate, beforeDispose, 'AzureCommunication');
};
/**
 * Create a {@link CallAdapter} using the provided {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallAdapterFromClient = (callClient, callAgent, locator, options) => __awaiter$3(void 0, void 0, void 0, function* () {
    const deviceManager = yield callClient.getDeviceManager();
    return new AzureCommunicationCallAdapter(callClient, locator, callAgent, deviceManager);
});
const isCallError = (e) => {
    return e['target'] !== undefined && e['innerError'] !== undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const compositeOuterContainerStyles = {
    root: {
        width: '100%',
        // Create a new stacking context so that DrawerMenu can be positioned absolutely.
        position: 'relative'
    }
};
/** @private */
const callCompositeContainerStyles = (isMobile) => ({
    root: {
        // Start a new stacking context so that any `position:absolute` elements
        // inside the call composite do not compete with its siblings.
        position: 'relative',
        width: '100%',
        minWidth: isMobile ? 'unset' : `${compositeMinWidthRem}rem`
    }
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$2 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/**
 * Facade around the CallWithChatAdapter to satisfy the call adapter interface.
 *
 * @private
 */
class CallWithChatBackedCallAdapter {
    constructor(callWithChatAdapter) {
        // For onStateChange we must convert CallWithChat state to chat state. This involves creating a new handler to be passed into the onStateChange.
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.on('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.on('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('callError', listener);
                case 'participantsJoined':
                    return this.callWithChatAdapter.off('callParticipantsJoined', listener);
                case 'participantsLeft':
                    return this.callWithChatAdapter.off('callParticipantsLeft', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(callAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => callAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.joinCall = (microphoneOn) => {
            return this.callWithChatAdapter.joinCall(microphoneOn);
        };
        this.leaveCall = (forEveryone) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.leaveCall(forEveryone); });
        this.startCall = (participants, options) => {
            let communicationParticipants = participants;
            return this.callWithChatAdapter.startCall(communicationParticipants, options);
        };
        this.setCamera = (sourceId, options) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setCamera(sourceId, options); });
        this.setMicrophone = (sourceId) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setMicrophone(sourceId); });
        this.setSpeaker = (sourceId) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.setSpeaker(sourceId); });
        this.askDevicePermission = (constraints) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.askDevicePermission(constraints); });
        this.queryCameras = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryCameras(); });
        this.queryMicrophones = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.queryMicrophones(); });
        this.querySpeakers = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.querySpeakers(); });
        this.startCamera = (options) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startCamera(options); });
        this.stopCamera = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopCamera(); });
        this.mute = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.mute(); });
        this.unmute = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.unmute(); });
        this.startScreenShare = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.startScreenShare(); });
        this.stopScreenShare = () => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.stopScreenShare(); });
        this.removeParticipant = (userId) => __awaiter$2(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callWithChatAdapter.removeParticipant(participant);
        });
        this.createStreamView = (remoteUserId, options) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.createStreamView(remoteUserId, options); });
        this.disposeStreamView = (remoteUserId, options) => __awaiter$2(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.disposeStreamView(remoteUserId, options); });
        this.callWithChatAdapter = callWithChatAdapter;
    }
}
function callAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    return {
        isLocalPreviewMicrophoneEnabled: callWithChatAdapterState.isLocalPreviewMicrophoneEnabled,
        page: callWithChatAdapterState.page,
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName,
        call: callWithChatAdapterState.call,
        devices: callWithChatAdapterState.devices,
        isTeamsCall: callWithChatAdapterState.isTeamsCall,
        latestErrors: callWithChatAdapterState.latestCallErrors
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Facade around the CallWithChatAdapter to satisfy the chat adapter interface.
 *
 * @private
 */
class CallWithChatBackedChatAdapter {
    constructor(callWithChatAdapter) {
        // For onStateChange we must convert CallWithChat state to chat state. This involves creating a new handler to be passed into the onStateChange.
        // In order to unsubscribe the handler when offStateChange is called we must have a mapping of the original handler to the newly created handler.
        this.eventStore = new Map();
        this.fetchInitialData = () => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.fetchInitialData(); });
        this.sendMessage = (content) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendMessage(content); });
        this.sendReadReceipt = (chatMessageId) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendReadReceipt(chatMessageId); });
        this.sendTypingIndicator = () => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.sendTypingIndicator(); });
        this.removeParticipant = (userId) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.removeParticipant(userId); });
        this.loadPreviousChatMessages = (messagesToLoad) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.loadPreviousChatMessages(messagesToLoad); });
        this.dispose = () => this.callWithChatAdapter.dispose();
        this.onStateChange = (handler) => {
            const convertedHandler = (state) => {
                handler(chatAdapterStateFromCallWithChatAdapterState(state));
            };
            this.callWithChatAdapter.onStateChange(convertedHandler);
            this.eventStore.set(handler, convertedHandler);
        };
        this.offStateChange = (handler) => {
            const convertedHandler = this.eventStore.get(handler);
            convertedHandler && this.callWithChatAdapter.offStateChange(convertedHandler);
        };
        this.getState = () => chatAdapterStateFromCallWithChatAdapterState(this.callWithChatAdapter.getState());
        /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
        this.on = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.on('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.on('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.on('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.on(event, listener);
            }
        };
        this.off = (event, listener) => {
            switch (event) {
                case 'error':
                    return this.callWithChatAdapter.off('chatError', listener);
                case 'participantsAdded':
                    return this.callWithChatAdapter.off('chatParticipantsAdded', listener);
                case 'participantsRemoved':
                    return this.callWithChatAdapter.off('chatParticipantsRemoved', listener);
                default:
                    return this.callWithChatAdapter.off(event, listener);
            }
        };
        this.updateMessage = (messageId, content, metadata) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.updateMessage(messageId, content, metadata); });
        this.deleteMessage = (messageId) => __awaiter$1(this, void 0, void 0, function* () { return yield this.callWithChatAdapter.deleteMessage(messageId); });
        this.clearErrors = (errorTypes) => {
            throw new Error(`Method not supported in CallWithChatComposite.`);
        };
        this.setTopic = (topicName) => __awaiter$1(this, void 0, void 0, function* () {
            throw new Error(`Chat Topics are not supported in CallWithChatComposite.`);
        });
        this.callWithChatAdapter = callWithChatAdapter;
    }
}
function chatAdapterStateFromCallWithChatAdapterState(callWithChatAdapterState) {
    if (!callWithChatAdapterState.chat) {
        throw new Error('Chat thread state id undefined.');
    }
    return {
        userId: callWithChatAdapterState.userId,
        displayName: callWithChatAdapterState.displayName || '',
        thread: callWithChatAdapterState.chat,
        latestErrors: callWithChatAdapterState.latestChatErrors
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const ChatButton = (props) => {
    const strings = Object.assign({ label: props.label }, props.strings);
    const theme = useTheme();
    const styles = React.useMemo(() => {
        var _a;
        return react.concatStyleSets({
            rootChecked: {
                background: theme.palette.neutralLight
            }
        }, (_a = props.styles) !== null && _a !== void 0 ? _a : {});
    }, [props.styles, theme.palette.neutralLight]);
    return React__default['default'].createElement(ControlBarButton, Object.assign({}, props, { labelKey: 'chatButtonLabelKey', strings: strings, onClick: props.onClick, styles: styles }));
};

// Copyright (c) Microsoft Corporation.
/**
 * @private
 */
const NotificationIcon = (props) => {
    const { chatMessagesCount, label } = props;
    const theme = react.useTheme();
    const renderNumber = (numberOfMessages) => {
        if (numberOfMessages < 1) {
            return React__default['default'].createElement(React__default['default'].Fragment, null);
        }
        else {
            const textNumberOfMessages = numberOfMessages < 9 ? numberOfMessages : '9+';
            return React__default['default'].createElement(react.Text, { role: 'status', "aria-label": textNumberOfMessages + label, styles: notificationTextStyles(theme) }, textNumberOfMessages);
        }
    };
    return React__default['default'].createElement(react.Stack, { "data-ui-id": "call-with-chat-composite-chat-button-unread-icon", horizontalAlign: "center", verticalAlign: "center", styles: notificationIconContainerStyles(theme) },
        React__default['default'].createElement(react.Stack, null, renderNumber(chatMessagesCount)));
};
const notificationIconPaddingREM = 0.225;
const notificationSizeREM = 1;
const notificationIconContainerStyles = react.memoizeFunction((theme) => ({
    root: {
        borderRadius: `${notificationSizeREM}rem`,
        // Create a css circle. This should match the height.
        height: `${notificationSizeREM}rem`,
        minWidth: `${notificationSizeREM}rem`,
        // use min-width over width as we want to extend the width of the notification icon when contents is more than one character (e.g. 9+)
        background: theme.palette.themePrimary,
        border: `0.0625rem solid white`,
        // border should always be white
        padding: `${notificationIconPaddingREM}rem`,
        // positioning to place the badge within the button appropriately.
        position: 'absolute',
        top: `-${0.5 - notificationIconPaddingREM / 2}rem`,
        left: `${0.5 + notificationIconPaddingREM / 2}rem`
    }
}));
const notificationTextStyles = react.memoizeFunction((theme) => ({
    root: {
        color: 'white',
        fontSize: theme.fonts.xSmall.fontSize
    }
}));

// Copyright (c) Microsoft Corporation.
/**
 * Helper function to determine if the message in the event is a valid one from a user.
 * Display name is used since system messages will not have one.
 */
const validNewChatMessage = (message) => !!message.senderDisplayName && (message.type === 'text' || message.type === 'html');
const filledIcon = React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonActive' });
const regularIcon = React__default['default'].createElement(CallWithChatCompositeIcon, { iconName: 'ControlBarChatButtonInactive' });
/**
 * @private
 */
const ChatButtonWithUnreadMessagesBadge = (props) => {
    var _a, _b, _c, _d;
    const { chatAdapter, isChatPaneVisible, newMessageLabel } = props;
    const [unreadChatMessagesCount, setUnreadChatMessagesCount] = React.useState(0);
    const baseIcon = props.showLabel ? regularIcon : filledIcon;
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const numberOfMsgToolTip = ((_a = props.strings) === null || _a === void 0 ? void 0 : _a.tooltipOffContent) && unreadChatMessagesCount > 0 ? _formatString(callWithChatStrings.chatButtonTooltipClosedWithMessageCount, {
        unreadMessagesCount: `${unreadChatMessagesCount}`
    }) : undefined;
    const chatStrings = React.useMemo(() => {
        var _a, _b, _c;
        return ({
            label: (_a = props.strings) === null || _a === void 0 ? void 0 : _a.label,
            tooltipOffContent: numberOfMsgToolTip ? numberOfMsgToolTip : (_b = props.strings) === null || _b === void 0 ? void 0 : _b.tooltipOffContent,
            tooltipOnContent: (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOnContent
        });
    }, [numberOfMsgToolTip, (_b = props.strings) === null || _b === void 0 ? void 0 : _b.label, (_c = props.strings) === null || _c === void 0 ? void 0 : _c.tooltipOffContent, (_d = props.strings) === null || _d === void 0 ? void 0 : _d.tooltipOnContent]);
    const onRenderOnIcon = React.useCallback(() => baseIcon, [baseIcon]);
    const notificationOnIcon = React.useCallback(() => {
        return React__default['default'].createElement(react.Stack, { styles: chatNotificationContainerStyles },
            unreadChatMessagesCount > 0 && React__default['default'].createElement(NotificationIcon, { chatMessagesCount: unreadChatMessagesCount, label: newMessageLabel }),
            baseIcon);
    }, [unreadChatMessagesCount, newMessageLabel, baseIcon]);
    React.useEffect(() => {
        if (isChatPaneVisible) {
            setUnreadChatMessagesCount(0);
            return;
        }
        const incrementUnreadChatMessagesCount = (event) => {
            if (!isChatPaneVisible && validNewChatMessage(event.message)) {
                setUnreadChatMessagesCount(unreadChatMessagesCount + 1);
            }
        };
        chatAdapter.on('messageReceived', incrementUnreadChatMessagesCount);
        return () => {
            chatAdapter.off('messageReceived', incrementUnreadChatMessagesCount);
        };
    }, [chatAdapter, setUnreadChatMessagesCount, isChatPaneVisible, unreadChatMessagesCount]);
    return React__default['default'].createElement(ChatButton, Object.assign({}, props, { "data-ui-id": "call-with-chat-composite-chat-button", onRenderOffIcon: notificationOnIcon, onRenderOnIcon: onRenderOnIcon, strings: chatStrings }));
};
const chatNotificationContainerStyles = {
    root: {
        display: 'inline',
        position: 'relative'
    }
};

// Copyright (c) Microsoft Corporation.
const CallWithChatScreen = (props) => {
    const { callWithChatAdapter, fluentTheme, formFactor = 'desktop' } = props;
    const mobileView = formFactor === 'mobile';
    if (!callWithChatAdapter) {
        throw new Error('CallWithChatAdapter is undefined');
    }
    const callAdapter = React.useMemo(() => new CallWithChatBackedCallAdapter(callWithChatAdapter), [callWithChatAdapter]);
    const [currentCallState, setCurrentCallState] = React.useState();
    const [currentPage, setCurrentPage] = React.useState();
    const [isChatOpen, setIsChatOpen] = React.useState(false);
    const containerRef = React.useRef(null);
    React.useEffect(() => {
        const updateCallWithChatPage = (newState) => {
            var _a;
            setCurrentPage(newState.page);
            setCurrentCallState((_a = newState.call) === null || _a === void 0 ? void 0 : _a.state);
        };
        updateCallWithChatPage(callWithChatAdapter.getState());
        callWithChatAdapter.onStateChange(updateCallWithChatPage);
        return () => {
            callWithChatAdapter.offStateChange(updateCallWithChatPage);
        };
    }, [callWithChatAdapter]);
    const chatProps = React.useMemo(() => {
        return {
            adapter: new CallWithChatBackedChatAdapter(callWithChatAdapter)
        };
    }, [callWithChatAdapter]);
    /** Constant setting of id for the parent stack of the composite */
    const compositeParentDivId = reactHooks.useId('callWithChatCompositeParentDiv-internal');
    const closeChat = React.useCallback(() => {
        setIsChatOpen(false);
    }, []);
    const openChat = React.useCallback(() => {
        setIsChatOpen(true);
        // timeout is required to give the window time to render the sendbox so we have something to send focus to.
        // TODO: Selecting elements in the DOM via attributes is not stable. We should expose an API from ChatComposite to be able to focus on the sendbox.
        const chatFocusTimeout = setInterval(() => {
            const callWithChatCompositeRootDiv = document.querySelector(`[id="${compositeParentDivId}"]`);
            const sendbox = callWithChatCompositeRootDiv === null || callWithChatCompositeRootDiv === void 0 ? void 0 : callWithChatCompositeRootDiv.querySelector(`[id="sendbox"]`);
            if (sendbox !== null) {
                sendbox.focus();
                clearInterval(chatFocusTimeout);
            }
        }, 3);
        setTimeout(() => {
            clearInterval(chatFocusTimeout);
        }, 300);
    }, [compositeParentDivId]);
    const isOnHold = isOnHoldTrampoline();
    React.useEffect(() => {
    }, [closeChat, isOnHold]);
    const hasJoinedCall = !!(currentPage && hasJoinedCallFn(currentPage, currentCallState !== null && currentCallState !== void 0 ? currentCallState : 'None'));
    const toggleChat = React.useCallback(() => {
        isChatOpen || !hasJoinedCall ? closeChat() : openChat();
    }, [closeChat, hasJoinedCall, isChatOpen, openChat]);
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const chatButtonStrings = React.useMemo(() => ({
        label: callWithChatStrings.chatButtonLabel,
        tooltipOffContent: callWithChatStrings.chatButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.chatButtonTooltipClose
    }), [callWithChatStrings]);
    const theme = useTheme();
    const commonButtonStyles = React.useMemo(() => !mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [mobileView, theme]);
    const showChatButton = checkShowChatButton(props.callControls);
    const chatButtonDisabled = showChatButton && (checkChatButtonIsDisabled(props.callControls) || !hasJoinedCall || isOnHold);
    const chatTabHeaderProps = React.useMemo(() => mobileView && showChatButton ? {
        onClick: toggleChat,
        disabled: chatButtonDisabled
    } : undefined, [chatButtonDisabled, mobileView, toggleChat, showChatButton]);
    const customChatButton = React.useCallback((args) => ({
        placement: mobileView ? 'primary' : 'secondary',
        onRenderButton: () => React__default['default'].createElement(ChatButtonWithUnreadMessagesBadge, { chatAdapter: chatProps.adapter, isChatPaneVisible: isChatOpen, checked: isChatOpen, showLabel: args.displayType !== 'compact', onClick: toggleChat, disabled: chatButtonDisabled, strings: chatButtonStrings, styles: commonButtonStyles, newMessageLabel: callWithChatStrings.chatButtonNewMessageNotificationLabel })
    }), [callWithChatStrings.chatButtonNewMessageNotificationLabel, chatButtonStrings, chatProps.adapter, commonButtonStyles, isChatOpen, chatButtonDisabled, mobileView, toggleChat]);
    const callControlOptionsFromProps = React.useMemo(() => (Object.assign({}, (typeof props.callControls === 'object' ? props.callControls : {}))), [props.callControls]);
    const injectedCustomButtonsFromProps = React.useMemo(() => {
        return [];
    }, [callControlOptionsFromProps]);
    const callCompositeOptions = React.useMemo(() => ({
        callControls: props.callControls === false ? false : Object.assign(Object.assign({}, callControlOptionsFromProps), { onFetchCustomButtonProps: [...(showChatButton ? [customChatButton] : []),
                ...injectedCustomButtonsFromProps], legacyControlBarExperience: false })
    }), [props.callControls, callControlOptionsFromProps, showChatButton, customChatButton, injectedCustomButtonsFromProps]);
    const onRenderChatContent = React.useCallback(() => React__default['default'].createElement(ChatComposite, Object.assign({}, chatProps, { fluentTheme: theme, options: {
            topic: false
        }, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData })), [chatProps, props.onFetchAvatarPersonaData, theme]);
    const sidePaneHeaderRenderer = React.useCallback(() => { var _a; return React__default['default'].createElement(SidePaneHeader, { headingText: callWithChatStrings.chatPaneTitle, onClose: closeChat, dismissSidePaneButtonAriaLabel: (_a = callWithChatStrings.dismissSidePaneButtonLabel) !== null && _a !== void 0 ? _a : '', mobileView: mobileView }); }, [callWithChatStrings.chatPaneTitle, callWithChatStrings.dismissSidePaneButtonLabel, closeChat, mobileView]);
    const sidePaneContentRenderer = React.useMemo(() => hasJoinedCall ? onRenderChatContent : undefined, [hasJoinedCall, onRenderChatContent]);
    const sidePaneRenderer = React.useMemo(() => ({
        contentRenderer: sidePaneContentRenderer,
        headerRenderer: sidePaneHeaderRenderer,
        id: 'chat'
    }), [sidePaneContentRenderer, sidePaneHeaderRenderer]);
    const overrideSidePaneProps = React.useMemo(() => ({
        renderer: sidePaneRenderer,
        isActive: isChatOpen,
        persistRenderingWhenClosed: true
    }), [isChatOpen, sidePaneRenderer]);
    const onSidePaneIdChange = React.useCallback(sidePaneId => {
        // If the pane is switched to something other than chat, removing rendering chat.
        if (sidePaneId && sidePaneId !== 'chat') {
            closeChat();
        }
    }, [closeChat]);
    return React__default['default'].createElement("div", { ref: containerRef, className: react.mergeStyles(containerDivStyles) },
        React__default['default'].createElement(react.Stack, { verticalFill: true, grow: true, styles: compositeOuterContainerStyles, id: compositeParentDivId },
            React__default['default'].createElement(react.Stack, { horizontal: true, grow: true },
                React__default['default'].createElement(react.Stack.Item, { grow: true, styles: callCompositeContainerStyles(mobileView) },
                    React__default['default'].createElement(CallCompositeInner, Object.assign({}, props, { formFactor: formFactor, options: callCompositeOptions, adapter: callAdapter, fluentTheme: fluentTheme, callInvitationUrl: props.joinInvitationURL, overrideSidePane: overrideSidePaneProps, onSidePaneIdChange: onSidePaneIdChange, mobileChatTabHeader: chatTabHeaderProps }))))));
};
/**
 * CallWithChatComposite brings together key components to provide a full call with chat experience out of the box.
 *
 * @public
 */
const CallWithChatComposite = (props) => {
    const { adapter, fluentTheme, rtl, formFactor, joinInvitationURL, options } = props;
    return React__default['default'].createElement(BaseProvider, { fluentTheme: fluentTheme, rtl: rtl, locale: props.locale, icons: props.icons },
        React__default['default'].createElement(CallWithChatScreen, Object.assign({}, props, { callWithChatAdapter: adapter, formFactor: formFactor, callControls: options === null || options === void 0 ? void 0 : options.callControls, joinInvitationURL: joinInvitationURL, fluentTheme: fluentTheme })));
};
const hasJoinedCallFn = (page, callStatus) => {
    return page === 'call' && (callStatus === 'Connected' || callStatus === 'Disconnecting');
};
const checkShowChatButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.chatButton !== false;
};
const checkChatButtonIsDisabled = (callControls) => {
    return typeof callControls === 'object' && isDisabled$2(callControls === null || callControls === void 0 ? void 0 : callControls.chatButton);
};
const isOnHoldTrampoline = (page) => {
    return false;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
function callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter) {
    const callAdapterState = callAdapter.getState();
    const chatAdapterState = chatAdapter.getState();
    return {
        call: callAdapterState.call,
        chat: chatAdapterState.thread,
        userId: callAdapterState.userId,
        page: callAdapterState.page,
        displayName: callAdapterState.displayName,
        devices: callAdapterState.devices,
        isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled,
        isTeamsCall: callAdapterState.isTeamsCall,
        latestCallErrors: callAdapterState.latestErrors,
        latestChatErrors: chatAdapterState.latestErrors
    };
}
/**
 * @private
 */
function mergeChatAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, chatAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { chat: chatAdapterState.thread, latestChatErrors: chatAdapterState.latestErrors });
}
/**
 * @private
 */
function mergeCallAdapterStateIntoCallWithChatAdapterState(existingCallWithChatAdapterState, callAdapterState) {
    return Object.assign(Object.assign({}, existingCallWithChatAdapterState), { userId: callAdapterState.userId, page: callAdapterState.page, displayName: callAdapterState.displayName, devices: callAdapterState.devices, call: callAdapterState.call, isLocalPreviewMicrophoneEnabled: callAdapterState.isLocalPreviewMicrophoneEnabled, isTeamsCall: callAdapterState.isTeamsCall, latestCallErrors: callAdapterState.latestErrors });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @private
 */
const UNSUPPORTED_CHAT_THREAD_TYPE = ['@thread.tacv2', '@thread.skype'];
/**
 * @private
 */
const TEAMS_LIMITATION_LEARN_MORE = 'https://learn.microsoft.com/en-us/azure/communication-services/concepts/join-teams-meeting#limitations-and-known-issues';

// Copyright (c) Microsoft Corporation.
/**
 * Get chat thread from a teams url.
 * As per documented on the Chat SDK: https://docs.microsoft.com/en-us/azure/communication-services/quickstarts/chat/meeting-interop?pivots=platform-web#get-a-teams-meeting-chat-thread-for-a-communication-services-user
 *
 * @private
 */
const getChatThreadFromTeamsLink = (teamsMeetingLink) => {
    // Get the threadId from the url - this also contains the call locator ID that will be removed in the threadId.split
    let threadId = teamsMeetingLink.replace('https://teams.microsoft.com/l/meetup-join/', '');
    // Unescape characters that applications like Outlook encode when creating joinable links
    threadId = decodeURIComponent(threadId);
    // Extract just the chat guid from the link, stripping away the call locator ID
    threadId = threadId.split(/^(.*?@thread\.v2)/gm)[1];
    if (!threadId || threadId.length === 0) {
        if (UNSUPPORTED_CHAT_THREAD_TYPE.some(t => teamsMeetingLink.includes(t))) {
            throw new Error(`Teams Channel Meetings are not currently supported, read more ${TEAMS_LIMITATION_LEARN_MORE}`);
        }
        throw new Error('Could not get chat thread from teams link');
    }
    return threadId;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** Context of Call with Chat, which is a centralized context for all state updates */
class CallWithChatContext {
    constructor(clientState, maxListeners = 50) {
        this.emitter = new EventEmitter.EventEmitter();
        this.state = clientState;
        this.emitter.setMaxListeners(maxListeners);
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    updateClientState(clientState) {
        this.setState(clientState);
    }
    updateClientStateWithChatState(chatAdapterState) {
        this.updateClientState(mergeChatAdapterStateIntoCallWithChatAdapterState(this.state, chatAdapterState));
    }
    updateClientStateWithCallState(callAdapterState) {
        this.updateClientState(mergeCallAdapterStateIntoCallWithChatAdapterState(this.state, callAdapterState));
    }
}
/**
 * CallWithChat adapter backed by Azure Communication Services.
 * Created for easy use with the {@link CallWithChatComposite}.
 */
class AzureCommunicationCallWithChatAdapter {
    constructor(callAdapter, chatAdapter) {
        this.bindPublicMethods();
        this.callAdapter = callAdapter;
        this.chatAdapter = chatAdapter;
        this.context = new CallWithChatContext(callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter));
        const onChatStateChange = (newChatAdapterState) => {
            this.context.updateClientStateWithChatState(newChatAdapterState);
        };
        this.chatAdapter.onStateChange(onChatStateChange);
        this.onChatStateChange = onChatStateChange;
        const onCallStateChange = (newCallAdapterState) => {
            this.context.updateClientStateWithCallState(newCallAdapterState);
        };
        this.callAdapter.onStateChange(onCallStateChange);
        this.onCallStateChange = onCallStateChange;
    }
    bindPublicMethods() {
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.startCall.bind(this);
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.fetchInitialData.bind(this);
        this.sendMessage.bind(this);
        this.sendReadReceipt.bind(this);
        this.sendTypingIndicator.bind(this);
        this.loadPreviousChatMessages.bind(this);
        this.updateMessage.bind(this);
        this.deleteMessage.bind(this);
        this.on.bind(this);
        this.off.bind(this);
    }
    /** Join existing Call. */
    joinCall(microphoneOn) {
        return this.callAdapter.joinCall(microphoneOn);
    }
    /** Leave current Call. */
    leaveCall(forEveryone) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only remove self from the GroupCall. Contoso must manage access to Chat.
            yield this.callAdapter.leaveCall(forEveryone);
        });
    }
    /** Start a new Call. */
    startCall(participants, options) {
        let communicationParticipants = participants;
        return this.callAdapter.startCall(communicationParticipants, options);
    }
    /**
     * Subscribe to state change events.
     * @param handler - handler to be called when the state changes. This is passed the new state.
     */
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    /**
     * Unsubscribe to state change events.
     * @param handler - handler to be no longer called when state changes.
     */
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    /** Get current Call and Chat state. */
    getState() {
        return this.context.getState();
    }
    /** Dispose of the current CallWithChatAdapter. */
    dispose() {
        this.chatAdapter.offStateChange(this.onChatStateChange);
        this.callAdapter.offStateChange(this.onCallStateChange);
        this.chatAdapter.dispose();
        this.callAdapter.dispose();
    }
    /** Remove a participant from the Call only. */
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callAdapter.removeParticipant(participant);
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setCamera(device, options);
        });
    }
    /** Set the microphone to be used in the Call. */
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setMicrophone(device);
        });
    }
    /** Set the speaker to be used in the Call. */
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setSpeaker(device);
        });
    }
    askDevicePermission(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.askDevicePermission(constraints);
        });
    }
    /** Query for available cameras. */
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryCameras();
        });
    }
    /** Query for available microphones. */
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryMicrophones();
        });
    }
    /** Query for available speakers. */
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.querySpeakers();
        });
    }
    /** Start the camera for the user in the Call. */
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startCamera(options);
        });
    }
    /** Stop the camera for the user in the Call. */
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopCamera();
        });
    }
    /** Mute the user in the Call. */
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.mute();
        });
    }
    /** Unmute the user in the Call. */
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.unmute();
        });
    }
    /** Trigger the user to start screen share. */
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startScreenShare();
        });
    }
    /** Stop the current active screen share. */
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopScreenShare();
        });
    }
    /** Create a stream view for a remote participants video feed. */
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.createStreamView(remoteUserId, options);
        });
    }
    /** Dispose of a created stream view of a remote participants video feed. */
    disposeStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeStreamView(remoteUserId, options);
        });
    }
    /** Fetch initial Call and Chat data such as chat messages. */
    fetchInitialData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.fetchInitialData();
        });
    }
    /** Send a chat message. */
    sendMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendMessage(content);
        });
    }
    /** Send a chat read receipt. */
    sendReadReceipt(chatMessageId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendReadReceipt(chatMessageId);
        });
    }
    /** Send an isTyping indicator. */
    sendTypingIndicator() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendTypingIndicator();
        });
    }
    /** Load previous Chat messages. */
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.loadPreviousChatMessages(messagesToLoad);
        });
    }
    /** Update an existing message. */
    updateMessage(messageId, content, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.updateMessage(messageId, content, metadata);
        });
    }
    /** Delete an existing message. */
    deleteMessage(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.deleteMessage(messageId);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.on('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.on('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.on('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.on('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.on('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.on('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.on('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.on('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.on('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.on('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.on('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.on('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.on('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.on('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.on('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.on('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.on('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.off('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.off('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.off('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.off('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.off('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.off('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.off('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.off('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.off('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.off('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.off('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.off('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.off('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.off('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.off('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.off('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.off('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
}
/**
 * Create a CallWithChatAdapter backed by Azure Communication services
 * to plug into the {@link CallWithChatComposite}.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapter = ({ userId, displayName, credential, endpoint, locator }) => __awaiter(void 0, void 0, void 0, function* () {
    const callAdapterLocator = isTeamsMeetingLinkLocator(locator) ? locator : locator.callLocator;
    const createCallAdapterPromise = createAzureCommunicationCallAdapter({
        userId,
        displayName,
        credential,
        locator: callAdapterLocator
    });
    const threadId = isTeamsMeetingLinkLocator(locator) ? getChatThreadFromTeamsLink(locator.meetingLink) : locator.chatThreadId;
    const createChatAdapterPromise = createAzureCommunicationChatAdapter({
        endpoint,
        userId,
        displayName,
        credential,
        threadId
    });
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
/**
 * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
const useAzureCommunicationCallWithChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, locator, userId } = args;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = React.useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = React.useRef(undefined);
    const afterCreateRef = React.useRef(undefined);
    const beforeDisposeRef = React.useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    React.useEffect(() => {
        if (!credential || !displayName || !endpoint || !locator || !userId) {
            return;
        }
        (() => __awaiter(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationCallWithChatAdapter({
                credential,
                displayName,
                endpoint,
                locator,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, locator, userId]);
    // Dispose any existing adapter when the component unmounts.
    React.useEffect(() => {
        return () => {
            (() => __awaiter(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.
 *
 * @public
 */
const createAzureCommunicationCallWithChatAdapterFromClients = ({ callClient, callAgent, callLocator, chatClient, chatThreadClient }) => __awaiter(void 0, void 0, void 0, function* () {
    const createCallAdapterPromise = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, callLocator);
    const createChatAdapterPromise = createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
const isTeamsMeetingLinkLocator = (locator) => {
    return 'meetingLink' in locator;
};

// Copyright (c) Microsoft Corporation.
/**
 * Hook to obtain a selector for a specified component.
 *
 * Useful when implementing a custom component that utilizes the providers
 * exported from this library.
 *
 * @public
 */
const useSelector = (selector, selectorProps, type) => {
    // Because of react hooks rules, hooks can't be conditionally called
    // We call both call and chat hooks and detect current context
    // Return undefined and skip execution when not in that context
    const callingMode = !type || type === 'calling';
    const chatMode = !type || type === 'chat';
    const callProps = useSelector$3(callingMode ? selector : undefined, selectorProps);
    const chatProps = useSelector$2(chatMode ? selector : undefined, selectorProps);
    return callProps !== null && callProps !== void 0 ? callProps : chatProps;
};
/**
 * Primary hook to get all hooks necessary for a React Component from this library.
 *
 * To call this hook, the component requires to be wrapped under these providers:
 *
 * 1. For chat components: {@link ChatClientProvider} and {@link ChatThreadClientProvider}.
 *
 * 2. For calling components: {@link CallClientProvider}, {@link CallAgentProvider} and {@link CallAgentProvider}.
 *
 * Most straightforward usage of a components looks like:
 *
 * @example
 * ```
 *     import { ParticipantList, usePropsFor } from '@azure/communication-react';
 *
 *     const App = (): JSX.Element => {
 *         // ... code to setup Providers ...
 *
 *         return <ParticipantList {...usePropsFor(ParticipantList)}/>
 *     }
 * ```
 *
 * @public
 */
const usePropsFor = (component, type) => {
    const callingSelector = type === 'calling' || !type ? getSelector$1(component) : undefined;
    const chatSelector = type === 'chat' || !type ? getSelector(component) : undefined;
    const callProps = useSelector$3(callingSelector);
    const chatProps = useSelector$2(chatSelector);
    const callingHandlers = useHandlers$3();
    const chatHandlers = useHandlers$2();
    if (chatProps) {
        if (!chatHandlers) {
            throw 'Please initialize chatClient and chatThreadClient first!';
        }
        return Object.assign(Object.assign({}, chatProps), chatHandlers);
    }
    if (callProps) {
        if (!callingHandlers) {
            throw 'Please initialize callClient first!';
        }
        return Object.assign(Object.assign({}, callProps), callingHandlers);
    }
    if (!chatSelector && !callingSelector) {
        throw "Can't find corresponding selector for this component. Please check the supported components from Azure Communication UI Feature Component List.";
    }
    else {
        throw 'Could not find props for this component, ensure the component is wrapped by appropriate providers.';
    }
};

exports.COMPONENT_LOCALE_AR_SA = COMPONENT_LOCALE_AR_SA;
exports.COMPONENT_LOCALE_DE_DE = COMPONENT_LOCALE_DE_DE;
exports.COMPONENT_LOCALE_EN_GB = COMPONENT_LOCALE_EN_GB;
exports.COMPONENT_LOCALE_EN_US = COMPONENT_LOCALE_EN_US;
exports.COMPONENT_LOCALE_ES_ES = COMPONENT_LOCALE_ES_ES;
exports.COMPONENT_LOCALE_FI_FI = COMPONENT_LOCALE_FI_FI;
exports.COMPONENT_LOCALE_FR_FR = COMPONENT_LOCALE_FR_FR;
exports.COMPONENT_LOCALE_HE_IL = COMPONENT_LOCALE_HE_IL;
exports.COMPONENT_LOCALE_IT_IT = COMPONENT_LOCALE_IT_IT;
exports.COMPONENT_LOCALE_JA_JP = COMPONENT_LOCALE_JA_JP;
exports.COMPONENT_LOCALE_KO_KR = COMPONENT_LOCALE_KO_KR;
exports.COMPONENT_LOCALE_NB_NO = COMPONENT_LOCALE_NB_NO;
exports.COMPONENT_LOCALE_NL_NL = COMPONENT_LOCALE_NL_NL;
exports.COMPONENT_LOCALE_PL_PL = COMPONENT_LOCALE_PL_PL;
exports.COMPONENT_LOCALE_PT_BR = COMPONENT_LOCALE_PT_BR;
exports.COMPONENT_LOCALE_RU_RU = COMPONENT_LOCALE_RU_RU;
exports.COMPONENT_LOCALE_SV_SE = COMPONENT_LOCALE_SV_SE;
exports.COMPONENT_LOCALE_TR_TR = COMPONENT_LOCALE_TR_TR;
exports.COMPONENT_LOCALE_ZH_CN = COMPONENT_LOCALE_ZH_CN;
exports.COMPONENT_LOCALE_ZH_TW = COMPONENT_LOCALE_ZH_TW;
exports.COMPOSITE_LOCALE_AR_SA = COMPOSITE_LOCALE_AR_SA;
exports.COMPOSITE_LOCALE_DE_DE = COMPOSITE_LOCALE_DE_DE;
exports.COMPOSITE_LOCALE_EN_GB = COMPOSITE_LOCALE_EN_GB;
exports.COMPOSITE_LOCALE_EN_US = COMPOSITE_LOCALE_EN_US;
exports.COMPOSITE_LOCALE_ES_ES = COMPOSITE_LOCALE_ES_ES;
exports.COMPOSITE_LOCALE_FI_FI = COMPOSITE_LOCALE_FI_FI;
exports.COMPOSITE_LOCALE_FR_FR = COMPOSITE_LOCALE_FR_FR;
exports.COMPOSITE_LOCALE_HE_IL = COMPOSITE_LOCALE_HE_IL;
exports.COMPOSITE_LOCALE_IT_IT = COMPOSITE_LOCALE_IT_IT;
exports.COMPOSITE_LOCALE_JA_JP = COMPOSITE_LOCALE_JA_JP;
exports.COMPOSITE_LOCALE_KO_KR = COMPOSITE_LOCALE_KO_KR;
exports.COMPOSITE_LOCALE_NB_NO = COMPOSITE_LOCALE_NB_NO;
exports.COMPOSITE_LOCALE_NL_NL = COMPOSITE_LOCALE_NL_NL;
exports.COMPOSITE_LOCALE_PL_PL = COMPOSITE_LOCALE_PL_PL;
exports.COMPOSITE_LOCALE_PT_BR = COMPOSITE_LOCALE_PT_BR;
exports.COMPOSITE_LOCALE_RU_RU = COMPOSITE_LOCALE_RU_RU;
exports.COMPOSITE_LOCALE_SV_SE = COMPOSITE_LOCALE_SV_SE;
exports.COMPOSITE_LOCALE_TR_TR = COMPOSITE_LOCALE_TR_TR;
exports.COMPOSITE_LOCALE_ZH_CN = COMPOSITE_LOCALE_ZH_CN;
exports.COMPOSITE_LOCALE_ZH_TW = COMPOSITE_LOCALE_ZH_TW;
exports.COMPOSITE_ONLY_ICONS = COMPOSITE_ONLY_ICONS;
exports.CallAgentProvider = CallAgentProvider;
exports.CallClientProvider = CallClientProvider;
exports.CallComposite = CallComposite;
exports.CallProvider = CallProvider;
exports.CallWithChatComposite = CallWithChatComposite;
exports.CameraButton = CameraButton;
exports.ChatClientProvider = ChatClientProvider;
exports.ChatComposite = ChatComposite;
exports.ChatThreadClientProvider = ChatThreadClientProvider;
exports.ControlBar = ControlBar;
exports.ControlBarButton = ControlBarButton;
exports.DEFAULT_COMPONENT_ICONS = DEFAULT_COMPONENT_ICONS;
exports.DEFAULT_COMPOSITE_ICONS = DEFAULT_COMPOSITE_ICONS;
exports.DevicesButton = DevicesButton;
exports.EndCallButton = EndCallButton;
exports.ErrorBar = ErrorBar;
exports.FluentThemeProvider = FluentThemeProvider;
exports.GridLayout = GridLayout;
exports.LocalizationProvider = LocalizationProvider$1;
exports.MessageStatusIndicator = MessageStatusIndicator;
exports.MessageThread = MessageThread;
exports.MicrophoneButton = MicrophoneButton;
exports.ParticipantItem = ParticipantItem;
exports.ParticipantList = ParticipantList;
exports.ParticipantsButton = ParticipantsButton;
exports.ScreenShareButton = ScreenShareButton;
exports.SendBox = SendBox;
exports.StreamMedia = StreamMedia;
exports.TypingIndicator = TypingIndicator;
exports.VideoGallery = VideoGallery;
exports.VideoTile = VideoTile;
exports._IdentifierProvider = _IdentifierProvider;
exports.createAzureCommunicationCallAdapter = createAzureCommunicationCallAdapter;
exports.createAzureCommunicationCallAdapterFromClient = createAzureCommunicationCallAdapterFromClient;
exports.createAzureCommunicationCallWithChatAdapter = createAzureCommunicationCallWithChatAdapter;
exports.createAzureCommunicationCallWithChatAdapterFromClients = createAzureCommunicationCallWithChatAdapterFromClients;
exports.createAzureCommunicationChatAdapter = createAzureCommunicationChatAdapter;
exports.createAzureCommunicationChatAdapterFromClient = createAzureCommunicationChatAdapterFromClient;
exports.createDefaultCallingHandlers = createDefaultCallingHandlers;
exports.createDefaultChatHandlers = createDefaultChatHandlers;
exports.createStatefulCallClient = createStatefulCallClient;
exports.createStatefulChatClient = createStatefulChatClient;
exports.darkTheme = darkTheme;
exports.fromFlatCommunicationIdentifier = fromFlatCommunicationIdentifier;
exports.getCallingSelector = getSelector$1;
exports.getChatSelector = getSelector;
exports.lightTheme = lightTheme;
exports.toFlatCommunicationIdentifier = toFlatCommunicationIdentifier;
exports.useAzureCommunicationCallAdapter = useAzureCommunicationCallAdapter;
exports.useAzureCommunicationCallWithChatAdapter = useAzureCommunicationCallWithChatAdapter;
exports.useAzureCommunicationChatAdapter = useAzureCommunicationChatAdapter;
exports.useCall = useCall;
exports.useCallAgent = useCallAgent;
exports.useCallClient = useCallClient;
exports.useChatClient = useChatClient;
exports.useChatThreadClient = useChatThreadClient;
exports.useDeviceManager = useDeviceManager;
exports.usePropsFor = usePropsFor;
exports.useSelector = useSelector;
exports.useTheme = useTheme;
//# sourceMappingURL=index.js.map
