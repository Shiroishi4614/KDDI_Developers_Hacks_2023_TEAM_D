// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { useCallback, useRef } from 'react';
import { smartDominantSpeakerParticipants } from '../../../gallery';
const DEFAULT_MAX_REMOTE_VIDEOSTREAMS = 4;
const DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS = 6;
const _useOrganizedParticipants = (props) => {
    const visibleGridParticipants = useRef([]);
    const visibleOverflowGalleryParticipants = useRef([]);
    const { remoteParticipants = [], dominantSpeakers = [], maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEOSTREAMS, maxOverflowGalleryDominantSpeakers = DEFAULT_MAX_OVERFLOW_GALLERY_DOMINANT_SPEAKERS, isScreenShareActive = false, pinnedParticipantUserIds = [] } = props;
    const videoParticipants = remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; });
    visibleGridParticipants.current = pinnedParticipantUserIds.length > 0 || isScreenShareActive ? [] : smartDominantSpeakerParticipants({
        participants: videoParticipants,
        dominantSpeakers,
        lastVisibleParticipants: visibleGridParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    const visibleGridParticipantsSet = new Set(visibleGridParticipants.current.map(p => p.userId));
    const remoteParticipantsOrdered = putVideoParticipantsFirst(remoteParticipants);
    visibleOverflowGalleryParticipants.current = smartDominantSpeakerParticipants({
        participants: remoteParticipantsOrdered.filter(p => !visibleGridParticipantsSet.has(p.userId)),
        dominantSpeakers: dominantSpeakers,
        lastVisibleParticipants: visibleOverflowGalleryParticipants.current,
        maxDominantSpeakers: maxOverflowGalleryDominantSpeakers
    });
    const getGridParticipants = useCallback(() => {
        if (isScreenShareActive) {
            return [];
        }
        return visibleGridParticipants.current.length > 0 ? visibleGridParticipants.current : visibleOverflowGalleryParticipants.current;
    }, [isScreenShareActive]);
    const gridParticipants = getGridParticipants();
    const getOverflowGalleryRemoteParticipants = useCallback(() => {
        if (isScreenShareActive) {
            // If screen sharing is active, assign video and audio participants as overflow gallery participants
            return visibleGridParticipants.current.concat(visibleOverflowGalleryParticipants.current);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            return visibleGridParticipants.current.length > 0 ? visibleOverflowGalleryParticipants.current : [];
        }
    }, [isScreenShareActive]);
    const overflowGalleryParticipants = getOverflowGalleryRemoteParticipants();
    return {
        gridParticipants,
        overflowGalleryParticipants: overflowGalleryParticipants
    };
};
const putVideoParticipantsFirst = (remoteParticipants) => {
    const videoParticipants = [];
    const audioParticipants = [];
    remoteParticipants.forEach(p => {
        var _a;
        if ((_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) {
            videoParticipants.push(p);
        }
        else {
            audioParticipants.push(p);
        }
    });
    const remoteParticipantSortedByVideo = videoParticipants.concat(audioParticipants);
    return remoteParticipantSortedByVideo;
};
/**
 * Hook to determine which participants should be in grid and overflow gallery and their order respectively
 * @private
 */
export const useOrganizedParticipants = (args) => {
    return _useOrganizedParticipants(args);
};
//# sourceMappingURL=videoGalleryLayoutUtils.js.map