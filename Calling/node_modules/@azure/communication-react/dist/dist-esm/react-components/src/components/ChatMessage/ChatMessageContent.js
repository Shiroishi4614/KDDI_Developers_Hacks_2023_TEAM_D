// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React from 'react';
import { _formatString } from "../../../../acs-ui-common/src";
import { Parser, ProcessNodeDefinitions, IsValidNodeDefinitions } from 'html-to-react';
import Linkify from 'react-linkify';
import { Link } from '@fluentui/react';
import LiveMessage from '../Announcer/LiveMessage';
import DOMPurify from 'dompurify';
/** @private */
export const ChatMessageContent = (props) => {
    switch (props.message.contentType) {
        case 'text':
            return MessageContentAsText(props);
        case 'html':
            return MessageContentAsRichTextHTML(props);
        case 'richtext/html':
            return MessageContentAsRichTextHTML(props);
        default:
            console.warn('unknown message content type');
            return React.createElement(React.Fragment, null);
    }
};
const MessageContentWithLiveAria = (props) => {
    return React.createElement("div", { "data-ui-status": props.message.status, role: "text", "aria-label": props.ariaLabel },
        React.createElement(LiveMessage, { message: props.liveMessage, ariaLive: "polite" }),
        props.content);
};
const MessageContentAsRichTextHTML = (props) => {
    return React.createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: processHtmlToReact(props) });
};
const MessageContentAsText = (props) => {
    return React.createElement(MessageContentWithLiveAria, { message: props.message, liveMessage: generateLiveMessage(props), ariaLabel: messageContentAriaText(props), content: React.createElement(Linkify, { componentDecorator: (decoratedHref, decoratedText, key) => {
                return React.createElement(Link, { target: "_blank", href: decoratedHref, key: key }, decoratedText);
            } }, props.message.content) });
};
// https://stackoverflow.com/questions/28899298/extract-the-text-out-of-html-string-using-javascript
const extractContent = (s) => {
    const span = document.createElement('span');
    span.innerHTML = s;
    return span.textContent || span.innerText;
};
const generateLiveMessage = (props) => {
    const liveAuthor = _formatString(props.strings.liveAuthorIntro, {
        author: `${props.message.senderDisplayName}`
    });
    return `${props.message.editedOn ? props.strings.editedTag : ''} ${props.message.mine ? '' : liveAuthor} ${extractContent(props.message.content || '')} `;
};
const messageContentAriaText = (props) => {
    // Strip all html tags from the content for aria.
    return props.message.content ? props.message.mine ? _formatString(props.strings.messageContentMineAriaText, {
        message: DOMPurify.sanitize(props.message.content, {
            ALLOWED_TAGS: []
        })
    }) : _formatString(props.strings.messageContentAriaText, {
        author: `${props.message.senderDisplayName}`,
        message: DOMPurify.sanitize(props.message.content, {
            ALLOWED_TAGS: []
        })
    }) : undefined;
};
const processNodeDefinitions = ProcessNodeDefinitions();
const htmlToReactParser = Parser();
const processHtmlToReact = (props) => {
    var _a;
    const steps = [{
            // Process everything else in the default way
            shouldProcessNode: IsValidNodeDefinitions.alwaysValid,
            processNode: processNodeDefinitions.processDefaultNode
        }];
    return htmlToReactParser.parseWithInstructions((_a = props.message.content) !== null && _a !== void 0 ? _a : '', IsValidNodeDefinitions.alwaysValid, steps);
};
//# sourceMappingURL=ChatMessageContent.js.map